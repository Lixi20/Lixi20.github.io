<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="李喜">
<title>C03课堂随笔</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white; color: rgba(0, 0, 0, 0.8); padding: 0; margin: 0; font-family: "Noto Serif", "DejaVu Serif", serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: #7a2518; font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #2156a5; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Open Sans", "DejaVu Sans", sans-serif; font-weight: 300; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.0125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddddd8; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; font-weight: normal; color: rgba(0, 0, 0, 0.9); }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }

blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #f7f8f7; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }

body { tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; word-spacing: -0.05em; }
h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong { font-weight: 400; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; background-color: #f7f7f8; -webkit-border-radius: 4px; border-radius: 4px; line-height: 1.45; text-rendering: optimizeSpeed; border: 1px dashed #2f6fab;}

pre {border: 1px dashed gray;}

pre, pre > code { line-height: 1.45; color: rgba(0, 0, 0, 0.9); font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace; font-weight: normal; text-rendering: optimizeSpeed;}

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: rgba(0, 0, 0, 0.8); }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: rgba(0, 0, 0, 0.9); }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddddd8; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddddd8; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddddd8; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #ddddd8; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #efefed; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #7a2518; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #efefed; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #efefed; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: rgba(0, 0, 0, 0.8); padding: 1.25em; }

#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #efefed; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1rem; font-style: italic; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: rgba(0, 0, 0, 0.85); }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddddd8; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; text-align: center; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.listingblock pre:not(.highlight) {color: white; background: #002b36; }

.literalblock pre, .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #f7f7f8; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 1em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #f7f7f8; background-color: rgba(0, 0, 0, 0.9); }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock pre.prettyprint { border-width: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.45; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddddd8; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #7a2518; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid rgba(0, 0, 0, 0.6); }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: rgba(0, 0, 0, 0.6); }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.6; background: #f7f8f7; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 1.25em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.05em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

dt, th.tableblock, td.content, div.footnote { text-rendering: optimizeLegibility; }

h1, h2, p, td.content, span.alt { letter-spacing: -0.01em; }

p strong, td.content strong, div.footnote strong { letter-spacing: -0.005em; }

p, blockquote, dt, td.content, span.alt { font-size: 1.0625rem; }

p { margin-bottom: 1.25rem; }

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }

.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }

.print-only { display: none !important; }

@media print { @page { margin: 1.25cm 0.75cm; }
  * { -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
  a { color: inherit !important; text-decoration: underline !important; }
  a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
  a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  pre, blockquote, tr, img, object, svg { page-break-inside: avoid; }
  thead { display: table-header-group; }
  svg { max-width: 100%; }
  p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
  #toc { border-bottom: 1px solid #ddddd8 !important; padding-bottom: 0 !important; }
  .sect1 { padding-bottom: 0 !important; }
  .sect1 + .sect1 { border: 0 !important; }
  #header > h1:first-child { margin-top: 1.25rem; }
  body.book #header { text-align: center; }
  body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
  body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
  body.book #header .details span:first-child { margin-left: 0 !important; }
  body.book #header .details br { display: block; }
  body.book #header .details br + span:before { content: none !important; }
  body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
  body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
  .listingblock code[data-lang]:before { display: block; }
  #footer { background: none !important; padding: 0 0.9375em; }
  #footer-text { color: rgba(0, 0, 0, 0.6) !important; font-size: 0.9em; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }

</style>
<link rel="stylesheet" href="css/font-awesome.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>C03课堂随笔</h1>
<div class="details">
<span id="author" class="author">李喜</span><br>
<span id="email" class="email"><a href="mailto:lixi0506cd@gmail.com">lixi0506cd@gmail.com</a></span><br>
<span id="revdate">何文松 &lt;conscience0915@gmail.com&gt;</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_前言">前言</a>
<ul class="sectlevel2">
<li><a href="#_贡献名单">贡献名单</a></li>
</ul>
</li>
<li><a href="#_BCTS1_chapter">1. 编程通识(一)</a>
<ul class="sectlevel2">
<li><a href="#_板书">1.1. 板书</a></li>
<li><a href="#_三个公式">1.2. 三个公式</a></li>
<li><a href="#_产品软件商业模式">1.3. 产品=软件+商业模式</a>
<ul class="sectlevel3">
<li><a href="#_软件是什么">1.3.1. 软件是什么？</a></li>
<li><a href="#_商业模式是什么">1.3.2. 商业模式是什么？</a></li>
</ul>
</li>
<li><a href="#_软件程序使用场景">1.4. 软件=程序+使用场景</a>
<ul class="sectlevel3">
<li><a href="#_程序">1.4.1. 程序</a></li>
<li><a href="#_使用场景">1.4.2. 使用场景</a></li>
</ul>
</li>
<li><a href="#_程序算法数据结构">1.5. 程序=算法+数据结构</a>
<ul class="sectlevel3">
<li><a href="#_程序是什么">1.5.1. 程序是什么</a></li>
<li><a href="#_算法是什么">1.5.2. 算法是什么</a></li>
<li><a href="#_数据结构是什么">1.5.3. 数据结构是什么</a></li>
</ul>
</li>
<li><a href="#_编程要培养编程直觉">1.6. 编程要培养编程直觉</a></li>
</ul>
</li>
<li><a href="#_BCTS2_chapter">2. 编程通识(二)</a>
<ul class="sectlevel2">
<li><a href="#_板书_2">2.1. 板书</a></li>
<li><a href="#_前言_2">2.2. 前言</a></li>
<li><a href="#_什么是网络">2.3. 什么是网络</a>
<ul class="sectlevel3">
<li><a href="#_互联网与万维网">2.3.1. 互联网与万维网</a></li>
</ul>
</li>
<li><a href="#_补充学习编程到底在学习什么">2.4. 补充：学习编程到底在学习什么？</a>
<ul class="sectlevel3">
<li><a href="#_数学">2.4.1. 数学</a></li>
<li><a href="#_编程">2.4.2. 编程</a></li>
</ul>
</li>
<li><a href="#_什么是协议">2.5. 什么是协议</a>
<ul class="sectlevel3">
<li><a href="#_举个例子">2.5.1. 举个例子</a></li>
</ul>
</li>
<li><a href="#_什么是网络协议">2.6. 什么是网络协议</a>
<ul class="sectlevel3">
<li><a href="#_协议">2.6.1. 协议：</a></li>
<li><a href="#_tcp子集_httpftpudptcpsmtppop3imap">2.6.2. TCP子集 （HTTP、FTP、UDP、TCP、SMTP、POP3、IMAP）</a>
<ul class="sectlevel4">
<li><a href="#_pop3_smtp_imap的区别在哪里">POP3, SMTP, IMAP的区别在哪里？</a></li>
</ul>
</li>
<li><a href="#_ip子集icmparp">2.6.3. IP子集(ICMP\ARP)</a></li>
<li><a href="#_要理解计算机世界是怎么运行的非常重要">2.6.4. 要理解计算机世界是怎么运行的非常重要！！！</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_XMSZ1_chapter">3. 项目实战(一)</a>
<ul class="sectlevel2">
<li><a href="#_板书_3">3.1. 板书</a></li>
<li><a href="#_前言_3">3.2. 前言</a></li>
<li><a href="#_项目背景">3.3. 项目背景</a>
<ul class="sectlevel3">
<li><a href="#_常用监控软件">3.3.1. 常用监控软件</a></li>
<li><a href="#_它们存在的问题">3.3.2. 它们存在的问题</a></li>
<li><a href="#_项目背景_2">3.3.3. 项目背景</a></li>
<li><a href="#_还有哪些领域在用linux">3.3.4. 还有哪些领域在用Linux？</a></li>
<li><a href="#_什么叫头部">3.3.5. 什么叫头部？</a></li>
<li><a href="#_linux存在的问题">3.3.6. Linux存在的问题</a></li>
<li><a href="#_起步阶段">3.3.7. 起步阶段</a></li>
<li><a href="#_补充为什么程序员的工资比传统行业高">3.3.8. 补充：为什么程序员的工资比传统行业高</a></li>
<li><a href="#_起步阶段的会遇见的问题">3.3.9. 起步阶段的会遇见的问题</a></li>
<li><a href="#_项目后期会遇见的问题">3.3.10. 项目后期会遇见的问题</a></li>
</ul>
</li>
<li><a href="#_提出问题技术">3.4. 提出问题(技术)</a>
<ul class="sectlevel3">
<li><a href="#_怎样了解模块间的调用关系">3.4.1. 怎样了解模块间的调用关系？</a></li>
<li><a href="#_模块内的工作状态是怎样的">3.4.2. 模块内的工作状态是怎样的？</a></li>
</ul>
</li>
<li><a href="#_解决问题设计">3.5. 解决问题(设计)</a>
<ul class="sectlevel3">
<li><a href="#_管控模块间的交互">3.5.1. 管控模块间的交互</a></li>
<li><a href="#_模块内的工作时长输入参数输出结果数量等等">3.5.2. 模块内的工作时长（输入参数，输出结果数量等等）</a></li>
</ul>
</li>
<li><a href="#_整体数据逻辑设计">3.6. 整体数据逻辑设计</a>
<ul class="sectlevel3">
<li><a href="#_架构图">3.6.1. 架构图</a></li>
<li><a href="#_怎样收集数据应该收集哪些数据">3.6.2. 怎样收集数据？应该收集哪些数据？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_XMSZ2_chapter">4. 项目实战(二)</a>
<ul class="sectlevel2">
<li><a href="#_板书_4">4.1. 板书</a></li>
<li><a href="#_前言_4">4.2. 前言</a></li>
<li><a href="#_客户端的问题">4.3. 客户端的问题</a></li>
<li><a href="#_扩展性">4.4. 扩展性</a></li>
<li><a href="#_主程序怎么运行的">4.5. 主程序怎么运行的？</a></li>
<li><a href="#_扩充">4.6. 扩充</a></li>
<li><a href="#_新的问题">4.7. 新的问题</a></li>
</ul>
</li>
<li><a href="#_HTTP_chapter">5. HTTP协议</a>
<ul class="sectlevel2">
<li><a href="#_板书_5">5.1. 板书</a></li>
<li><a href="#_什么是http">5.2. 什么是HTTP？</a>
<ul class="sectlevel3">
<li><a href="#_协议_2">5.2.1. 协议</a></li>
<li><a href="#_文本">5.2.2. 文本</a></li>
</ul>
</li>
<li><a href="#_为什么用http">5.3. 为什么用HTTP？</a></li>
<li><a href="#_怎么使用http">5.4. 怎么使用HTTP？</a></li>
</ul>
</li>
<li><a href="#_Linux-systemsprogramming1_chapter">6. Linux系统编程(一、二)</a>
<ul class="sectlevel2">
<li><a href="#_板书_6">6.1. 板书</a></li>
<li><a href="#_linux系统编程是什么">6.2. Linux系统编程是什么？</a></li>
<li><a href="#_what">6.3. What?</a></li>
<li><a href="#_做什么">6.4. 做什么？</a></li>
<li><a href="#_how">6.5. How？</a></li>
<li><a href="#_实战">6.6. 实战</a></li>
</ul>
</li>
<li><a href="#_Linux-systemsprogramming2_chapter">7. Linux系统编程(三、四、五)</a>
<ul class="sectlevel2">
<li><a href="#_板书_7">7.1. 板书</a></li>
<li><a href="#_挂载信息">7.2. 挂载信息</a></li>
<li><a href="#_伪代码">7.3. 伪代码</a></li>
<li><a href="#_约定">7.4. 约定</a></li>
<li><a href="#_拓扑">7.5. 拓扑</a></li>
<li><a href="#_调用配置文件">7.6. 调用配置文件</a></li>
<li><a href="#_agentd设计第一阶段">7.7. Agentd设计（第一阶段）</a></li>
<li><a href="#_server第一阶段">7.8. Server（第一阶段）</a></li>
</ul>
</li>
<li><a href="#_linux系统编程六七">8. Linux系统编程(六、七)</a>
<ul class="sectlevel2">
<li><a href="#_板书_8">8.1. 板书</a></li>
<li><a href="#_前言_5">8.2. 前言</a></li>
<li><a href="#_zabbix的优缺点">8.3. Zabbix的优缺点</a></li>
<li><a href="#_我们需要什么">8.4. 我们需要什么？</a></li>
<li><a href="#_我们为什么要自己造一套">8.5. 我们为什么要自己造一套？</a>
<ul class="sectlevel3">
<li><a href="#_更小的颗粒度">8.5.1. 更小的颗粒度</a></li>
<li><a href="#_更现代更好的生态">8.5.2. 更现代，更好的生态</a></li>
<li><a href="#_视角">8.5.3. 视角</a></li>
</ul>
</li>
<li><a href="#_取名字的作用">8.6. 取名字的作用</a></li>
<li><a href="#_球眼系统qiuyan服务端设计">8.7. 球眼系统（QiuYan）服务端设计</a>
<ul class="sectlevel3">
<li><a href="#_postgresql">8.7.1. PostgreSQL</a></li>
<li><a href="#_springboot">8.7.2. Springboot</a></li>
<li><a href="#_react">8.7.3. React</a></li>
<li><a href="#_only_pc">8.7.4. Only pc</a></li>
<li><a href="#_时间通知回调http">8.7.5. 时间通知，回调（HTTP）</a></li>
<li><a href="#_大致过程">8.7.6. 大致过程</a></li>
<li><a href="#_怎么使用">8.7.7. 怎么使用</a></li>
<li><a href="#_界面概念图">8.7.8. 界面概念图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_QiuYang_chapter">9. 球眼系统设计(八)</a>
<ul class="sectlevel2">
<li><a href="#_板书_9">9.1. 板书</a></li>
<li><a href="#_控制策略">9.2. 控制策略</a>
<ul class="sectlevel3">
<li><a href="#_when">9.2.1. When？</a></li>
</ul>
</li>
<li><a href="#_交互过程">9.3. 交互过程</a>
<ul class="sectlevel3">
<li><a href="#_简单的梳理逻辑">9.3.1. 简单的梳理逻辑</a></li>
<li><a href="#_合理性">9.3.2. 合理性</a></li>
<li><a href="#_怎么同步客户端和服务端的清单">9.3.3. 怎么同步客户端和服务端的清单？</a></li>
</ul>
</li>
<li><a href="#_分发系统">9.4. 分发系统</a></li>
</ul>
</li>
<li><a href="#_QiuYangAPI_chapter">10. 球眼系统设计(API系统)</a>
<ul class="sectlevel2">
<li><a href="#_板书_10">10.1. 板书</a></li>
<li><a href="#_什么是api">10.2. 什么是API</a>
<ul class="sectlevel3">
<li><a href="#_参数校验">10.2.1. 参数校验</a></li>
<li><a href="#_身份认证令牌">10.2.2. 身份认证（令牌）</a></li>
<li><a href="#_整体设计思路">10.2.3. 整体设计思路</a></li>
</ul>
</li>
<li><a href="#_api的特点">10.3. API的特点</a></li>
<li><a href="#_api的标准">10.4. API的标准</a>
<ul class="sectlevel3">
<li><a href="#_参数校验_2">10.4.1. 参数校验</a></li>
<li><a href="#_身份标识token">10.4.2. 身份标识(Token)</a></li>
</ul>
</li>
<li><a href="#_api_逻辑链业务">10.5. API 逻辑链（业务）</a></li>
<li><a href="#_api命名规范">10.6. API命名规范</a></li>
</ul>
</li>
<li><a href="#_DaimaTongshi_chapter">11. 代码设计（通识）</a>
<ul class="sectlevel2">
<li><a href="#_本源">11.1. 本源</a></li>
<li><a href="#_编程的本源">11.2. 编程的本源</a></li>
<li><a href="#_工具的作用">11.3. 工具的作用</a>
<ul class="sectlevel3">
<li><a href="#_程序是怎样提高效率的">11.3.1. 程序是怎样提高效率的？</a></li>
</ul>
</li>
<li><a href="#_怎样设计程序无限贴近工具的特质">11.4. 怎样设计程序无限贴近工具的特质？</a></li>
</ul>
</li>
<li><a href="#_JPA_chapter">12. Spring JPA</a>
<ul class="sectlevel2">
<li><a href="#_板书_11">12.1. 板书</a></li>
<li><a href="#_jpa是什么">12.2. JPA是什么？</a></li>
<li><a href="#_jdbc和jpa">12.3. JDBC和JPA</a></li>
<li><a href="#_jpa为什么方便">12.4. JPA为什么方便？</a>
<ul class="sectlevel3">
<li><a href="#_jdbc是怎么用的">12.4.1. JDBC是怎么用的？</a></li>
<li><a href="#_jpa怎么做的">12.4.2. JPA怎么做的?</a></li>
</ul>
</li>
<li><a href="#_补充list">12.5. 补充：List</a></li>
</ul>
</li>
<li><a href="#_SJKTS_chapter">13. 数据库通识</a>
<ul class="sectlevel2">
<li><a href="#_板书_12">13.1. 板书</a></li>
<li><a href="#_什么是数据库">13.2. 什么是数据库</a>
<ul class="sectlevel3">
<li><a href="#_关键词">13.2.1. 关键词</a></li>
<li><a href="#_网络读写">13.2.2. 网络读写</a></li>
<li><a href="#_总结">13.2.3. 总结</a></li>
</ul>
</li>
<li><a href="#_使用场景_2">13.3. 使用场景？</a></li>
<li><a href="#_怎么用how">13.4. 怎么用？(How)</a></li>
</ul>
</li>
<li><a href="#_HTTPYY_chapter">14. HTTP协议(应用)</a>
<ul class="sectlevel2">
<li><a href="#_板书_13">14.1. 板书</a></li>
<li><a href="#_http是什么">14.2. HTTP是什么？</a></li>
<li><a href="#_http的使用场景">14.3. HTTP的使用场景</a>
<ul class="sectlevel3">
<li><a href="#_浏览器">14.3.1. 浏览器</a></li>
<li><a href="#_web服务器">14.3.2. Web服务器</a></li>
<li><a href="#_客户端与服务端之间的传输媒介">14.3.3. 客户端与服务端之间的传输媒介</a></li>
</ul>
</li>
<li><a href="#_http1_1_vs_http2_0">14.4. HTTP/1.1 VS HTTP/2.0</a></li>
</ul>
</li>
<li><a href="#_HTTP1.1VS2.0_chapter">15. HTTP 1.1 VS 2.0</a>
<ul class="sectlevel2">
<li><a href="#_板书_14">15.1. 板书</a></li>
<li><a href="#_http1_1第二个慢是慢在哪">15.2. HTTP1.1第二个慢是慢在哪？</a></li>
<li><a href="#_为什么有http2_0">15.3. 为什么有HTTP/2.0?</a></li>
<li><a href="#_http2_0是怎么解决以上问题的">15.4. HTTP/2.0是怎么解决以上问题的？</a>
<ul class="sectlevel3">
<li><a href="#_三次握手">15.4.1. 三次握手</a></li>
</ul>
</li>
<li><a href="#_减少http头部的传输量">15.5. 减少HTTP头部的传输量</a>
<ul class="sectlevel3">
<li><a href="#_http头压缩">15.5.1. HTTP头压缩</a></li>
</ul>
</li>
<li><a href="#_延伸">15.6. 延伸</a>
<ul class="sectlevel3">
<li><a href="#_http的body是不是可以压缩">15.6.1. HTTP的Body是不是可以压缩？</a></li>
<li><a href="#_http3_0">15.6.2. HTTP/3.0</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYANMOJO_chapter">16. 智眼设计（采集模块）</a>
<ul class="sectlevel2">
<li><a href="#_板书_15">16.1. 板书</a></li>
<li><a href="#_网络拓扑">16.2. 网络拓扑</a></li>
<li><a href="#_解决问题">16.3. 解决问题</a>
<ul class="sectlevel3">
<li><a href="#_补充为什么要着重程序设计">16.3.1. 补充：为什么要着重程序设计？</a></li>
<li><a href="#_agent获取用户配置逻辑">16.3.2. Agent获取用户配置逻辑</a></li>
</ul>
</li>
<li><a href="#_接口安全">16.4. 接口安全</a>
<ul class="sectlevel3">
<li><a href="#_身份认证">16.4.1. 身份认证</a></li>
<li><a href="#_参数校验_3">16.4.2. 参数校验</a></li>
<li><a href="#_接口的时效性校验">16.4.3. 接口的时效性校验</a></li>
<li><a href="#_校验过程">16.4.4. 校验过程</a></li>
<li><a href="#_回调">16.4.5. 回调</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_apisys_chapter">17. API System</a>
<ul class="sectlevel2">
<li><a href="#_板书_16">17.1. 板书</a></li>
<li><a href="#_what_is_api系统">17.2. What is API系统？</a></li>
<li><a href="#_what_is_系统system">17.3. What is 系统(System)?</a>
<ul class="sectlevel3">
<li><a href="#_软件">17.3.1. 软件</a></li>
<li><a href="#_复杂">17.3.2. 复杂</a></li>
<li><a href="#_体量较大">17.3.3. 体量较大</a></li>
<li><a href="#_功能完善">17.3.4. 功能完善</a></li>
<li><a href="#_总结_2">17.3.5. 总结</a></li>
</ul>
</li>
<li><a href="#_what_is_apiapplication_interface">17.4. What is API(Application Interface)？</a></li>
<li><a href="#_什么是api系统">17.5. 什么是API系统</a></li>
<li><a href="#_使用场景_3">17.6. 使用场景</a></li>
</ul>
</li>
<li><a href="#_SJKYL1_chapter">18. 数据库原理（一）</a>
<ul class="sectlevel2">
<li><a href="#_板书_17">18.1. 板书</a></li>
<li><a href="#_数据库是什么">18.2. 数据库是什么</a></li>
<li><a href="#_使用场景_4">18.3. 使用场景</a></li>
<li><a href="#_怎么保存数据的工作原理">18.4. 怎么保存数据的（工作原理）</a></li>
</ul>
</li>
<li><a href="#_bianchengjiqiao_chapter">19. 编程技巧</a>
<ul class="sectlevel2">
<li><a href="#_板书_18">19.1. 板书</a></li>
<li><a href="#_什么是编程技巧what">19.2. 什么是编程技巧？(What)</a></li>
<li><a href="#_使用场景_where">19.3. 使用场景 (Where)</a></li>
<li><a href="#_怎么用how_2">19.4. 怎么用？(How)</a>
<ul class="sectlevel3">
<li><a href="#_引申">19.4.1. 引申</a></li>
</ul>
</li>
<li><a href="#_使用场景一">19.5. 使用场景一</a>
<ul class="sectlevel3">
<li><a href="#_接收参数">19.5.1. 接收参数</a></li>
<li><a href="#_划分阶段">19.5.2. 划分阶段</a></li>
</ul>
</li>
<li><a href="#_使用场景二">19.6. 使用场景二</a>
<ul class="sectlevel3">
<li><a href="#_补充c语言中的枚举">19.6.1. 补充：C语言中的枚举</a></li>
<li><a href="#_代码逻辑">19.6.2. 代码逻辑</a></li>
</ul>
</li>
<li><a href="#_拒载同意">19.7. 拒载？同意？</a>
<ul class="sectlevel3">
<li><a href="#_bus">19.7.1. BUS</a></li>
<li><a href="#_track">19.7.2. Track</a></li>
</ul>
</li>
<li><a href="#_代码实现">19.8. 代码实现</a></li>
<li><a href="#_设计校验步骤">19.9. 设计校验步骤</a>
<ul class="sectlevel3">
<li><a href="#_accesskeyid">19.9.1. AccessKeyId</a></li>
<li><a href="#_signmethod">19.9.2. SignMethod</a></li>
<li><a href="#_signnoce">19.9.3. SignNoce</a></li>
<li><a href="#_timestep">19.9.4. Timestep</a></li>
<li><a href="#_signtrue">19.9.5. Signtrue</a></li>
<li><a href="#_什么叫逻辑统一">19.9.6. 什么叫逻辑统一？</a></li>
<li><a href="#_总结_3">19.9.7. 总结</a></li>
</ul>
</li>
<li><a href="#_逻辑校验">19.10. 逻辑校验</a>
<ul class="sectlevel3">
<li><a href="#_数据库查询类">19.10.1. 数据库查询类</a></li>
<li><a href="#_有效时间校验">19.10.2. 有效时间校验</a></li>
<li><a href="#_综合判断">19.10.3. 综合判断</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_SJKYL2_chapter">20. 数据库原理（二）</a>
<ul class="sectlevel2">
<li><a href="#_板书_19">20.1. 板书</a></li>
<li><a href="#_数据库原理二">20.2. 数据库原理（二）</a></li>
<li><a href="#_什么是存储引擎">20.3. 什么是存储引擎</a>
<ul class="sectlevel3">
<li><a href="#_视频播放器">20.3.1. 视频播放器</a></li>
<li><a href="#_存储引擎">20.3.2. 存储引擎</a></li>
<li><a href="#_格式">20.3.3. 格式</a></li>
</ul>
</li>
<li><a href="#_存储格式">20.4. 存储格式</a></li>
</ul>
</li>
<li><a href="#_ORM_chapter">21. ORM原理</a>
<ul class="sectlevel2">
<li><a href="#_板书_20">21.1. 板书</a></li>
<li><a href="#_什么是orm框架">21.2. 什么是ORM框架？</a></li>
<li><a href="#_orm工作原理">21.3. ORM工作原理</a>
<ul class="sectlevel3">
<li><a href="#_java和jpa是什么关系">21.3.1. Java和JPA是什么关系？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_前言">前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一本关于软件开发、应用前端、系统运维、产品运营、思维、思考的全能手册。</p>
</div>
<div class="sect2">
<h3 id="_贡献名单">贡献名单</h3>
<div class="paragraph">
<p><strong>不按时间先后</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>李喜</p>
</li>
<li>
<p>何文松</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_BCTS1_chapter">1. 编程通识(一)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书">1.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/1.1编程通识(一)板书.jpg" alt="1.1编程通识(一)板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_三个公式">1.2. 三个公式</h3>
<div class="paragraph">
<p>程序一般有很多种理解，比如我们在Linux命令行里经常输入的命令,它其实就是一个程序，再比如我们常用的微信，它也是一个程序,那么程序到底指的是什么？
讲程序之前我们先了解3个公式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>产品=软件+商务模式

软件=程序+使用场景

程序=算法＋数据结构</pre>
</div>
</div>
<div class="paragraph">
<p>很明显它们 <code>相互关联</code> ，可以说它们能够构成一个 <code>链</code> ，从左到右，逐渐的就开始无限扩大，我们也会发现越到后面越虚，为了更好的理解，从上往下我们一步一步的来</p>
</div>
</div>
<div class="sect2">
<h3 id="_产品软件商业模式">1.3. 产品=软件+商业模式</h3>
<div class="paragraph">
<p>将日常中使用的微信带入到这个公式中，然后 <code>产品=软件+商务模式</code> 将微信带入这个公式就变为了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>微信 = 微信 + 商业模式</pre>
</div>
</div>
<div class="paragraph">
<p>这个公式成立吗?</p>
</div>
<div class="paragraph">
<p>很虚，说不通，所以换一种说法，那这个公式正确写法应该是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>产品 (微信) = 程序(微信) + 商业模式(微信)</pre>
</div>
</div>
<div class="sect3">
<h4 id="_软件是什么">1.3.1. 软件是什么？</h4>
<div class="paragraph">
<p>简单来说软件就代表的是这个产品的App</p>
</div>
</div>
<div class="sect3">
<h4 id="_商业模式是什么">1.3.2. 商业模式是什么？</h4>
<div class="paragraph">
<p>我们先举个例子来说明微信的上商业模式是怎样的，这样就能理解商业模式指的是什么概念。</p>
</div>
<hr>
<div class="paragraph">
<p>在智能手机普及之前，不管动感地带、电信、联通等等运营商，购买了它们的包月套餐，假如当时你在谈恋爱，那个套餐里的短信数量，一个月肯定是不够用的，然后就会想方设法的去免费的发消息，但有个问题，当时并不是所有的手机都是智能机，那么在那个时代充斥着一堆诺基亚或者是一堆老年机的时代里，是没有任何好用并且免费的沟通工具。</p>
</div>
<hr>
<div class="paragraph">
<p>那么在智能手机开始普及后的初期，当时安卓和IOS这两个平台上都没有一个好用的、免费的沟通工具。QQ当时出现了，当时QQ的重心并不是移动端，不过当时QQ也适配了移动端(3G QQ)，可是进去过后各种东西，普通人根本不适用，更适用于懂网络的人，微信和QQ的注册方式也不同，微信只需要用手机号发送一个短信就能注册账号了，这样就更适用于普通用户，而QQ则需要登录网页，可能还要申请邮箱而且有很繁琐的步骤，那么微信的商业模式也可以说解决的问题就是普罗大众利用移动的智能手机，免费的相互发送消息。</p>
</div>
<hr>
<div class="paragraph">
<p>为什么特别强调免费呢，因为在这个之前，有一个叫飞书的那个软件，一天有十条的免费短信，飞书这个软件其实也解决了问题。他就像发短信一样的操作，但是超过十条要另外收费。最开始是不收费的，但后面变成了收费，所以自从他想收费的那一天开始，他就已经和成功远离了。
而这类软件的盈利点是随着你的用户量越多，从而产生其他的盈利点，而不是在发消息本身。假设现在的微信发十条消息过后要收钱一分钱一条，那他就和以前搞那个超级女声投票一样，每投一次一块钱一条没有本质的区别。
那现在微信可不是这么玩了，微信说你要开发小程序，对不起，你要交钱，你的服务器要在我这，然后我还要流量提成，你要和我合作，所以收费的渠道很多，盈利点都是在后期。</p>
</div>
<div class="paragraph">
<p>从上面这个例子来看，微信这个产品就等于微信这个App加上他商业模式，而他的 <code>商业模式</code> 就是免费的移动端，消息互发，交友，解决了移动端通信打电话要钱、发短信要钱的问题，你只需要装个App就可以了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_软件程序使用场景">1.4. 软件=程序+使用场景</h3>
<div class="sect3">
<h4 id="_程序">1.4.1. 程序</h4>
<div class="paragraph">
<p>我们顺着上面的微信来讲，之前讲的软件指的就是App，但是它的定义很笼统，它包含了 <code>所有平台</code> 的App，如： <code>安卓</code> ， <code>IOS</code> ， <code>PC</code> 等等 ,在软件这个公式里，App就具体指的众多平台中其中一个，就比如说安卓的App、IOS的App等等。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用场景">1.4.2. 使用场景</h4>
<div class="paragraph">
<p>刚刚商业模式指的是发送消息这种很笼统的概念，而使用场景是说
<code>你拿出了手机，打开了安卓的App，然后在输入框里面打字</code>
相比于商业模式分化的更加细致。</p>
</div>
<div class="paragraph">
<p>举一些例子</p>
</div>
<hr>
<div class="paragraph">
<p>以前的甲骨文，可以用来传递的消息。甚至甲骨文之前你还可以用藤条打几个结记事情，还有就是图像，比如像型文字，甲骨文那种像型文字都是为了传递信息。那么在文字出现之前呢？像型文字出现之前，可以用声音，在一万年前通信基本靠吼，一个人站在那个山头，另一个人站在这个山头，我们俩就对吼，这也是传递消息的一种方式。</p>
</div>
<hr>
<div class="paragraph">
<p>那在指环王里，刚铎被围攻，甘道夫就对洛翰国的国王说你应该去帮助刚铎，然后国王说“刚铎国王都没有点起烽火，我去干嘛？这样我很没面子。”，不过之后就有一个夏尔人爬到那个烽火上面，故意把油打倒然后点燃了烽火。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>烽火是啥？
烽火，又称烽燧、狼烟、狼燧，是一种用于示警的讯号，通常会在险要处或交通要道上建筑用于传递这种讯号的高台，后方看见讯号便知有战事发生，出兵相助。</pre>
</div>
</div>
<div class="paragraph">
<p>那么这个烽火就是在传递消息，所以视觉也可以传递消息，但是这种传递消息是属于双方提前约好的，就比如说两个人，并没有提前交代生火的意思，对于他们来说，就只是单纯地认为着火了，但是当他们提前告知对方生火所蕴含的意义时，就会认为，一方按规矩生火了，那另一方也要生火，按规则运行，那么他们就是在有效的传递消息。</p>
</div>
<hr>
<div class="paragraph">
<p>再比如说，在大街上看到消防车后，我们就知道肯定某个地方着火了，不过这个消息是没有意义的，因为你并不知道是哪个地方着火了，着火的是不是你家？你需不去救火？但消防员知道，他知道XXX小区X楼着火了，可能因为是烤腊肉或者电灯毯着火的，所以消防员的目的，就是我知道着火了，我要去救火，对于他来说，着火了，他的使命就是救火，而对于我们来说，可能是手足无措看热闹，看热闹的时候你挤进去了，那么你就知道到底发生什么事了。</p>
</div>
<hr>
<div class="paragraph">
<p>综上所述，视觉可以传递消息，通信靠吼也可以传递消息，文字也可以传递信息，手打出的文字，画的画都可以传递消息。
那么使用场景，如果从微信上来说的话，就应该是打字的输入框，还有就是点那个语音然后录音，这两种就是使用场景，
但是这个地方并不涉及到一对一还是一对多，他们的输入方式都是一样的，都是在那个框框里面打字或者使用语音呢。</p>
</div>
<div class="paragraph">
<p>上面举得例子都是为了传递信息，但是都是在不同的场景下使用不同的方式实现的，所以 <code>使用场景</code> 指的就是处于不同的场景下实现不同的功能，回到微信的例子，文字的使用场景就应该是打字的输入框，还有语音的使用场景就是点那个语音按钮过后录音，这些也就是微信的使用场景。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_程序算法数据结构">1.5. 程序=算法+数据结构</h3>
<div class="sect3">
<h4 id="_程序是什么">1.5.1. 程序是什么</h4>
<div class="paragraph">
<p>例：安卓的app</p>
</div>
</div>
<div class="sect3">
<h4 id="_算法是什么">1.5.2. 算法是什么</h4>
<div class="paragraph">
<p>逻辑就是算法</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>输入一个参数要 <code>怎么</code> 去处理、 输入文字要 <code>怎么</code> 发送给对方、我是 <code>怎么</code> 让对方收到我发的消息或者我发的信息，包括语音，包括文字，图片我可以认为他是一种视觉的，是一种文件或者怎么样的，但这些都不是很重要，因为就算我不发图片我光靠打文字我也能讲清楚大部分事情，但是在威信诞生之初，大家是没有想过发图片这么一回事儿，你发短信都没有图片，你搞个微信发图片不是必要的，他只是起到一个丰富的作用，所以怎么让对方收到你的信息。你怎么让他收到，所以`这个怎么就是算法`。</p>
</div>
<div class="paragraph">
<p>内在核心：</p>
</div>
<div class="paragraph">
<p>How to ？      Answer——&gt;处理逻辑</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>函数、代码块、代码设计（关系）——&gt;设计模式</p>
</div>
<div class="paragraph">
<p>我们之前写的课程表的算法就是怎么排课。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数据结构是什么">1.5.3. 数据结构是什么</h4>
<div class="paragraph">
<p>你写函数的作用就是调用它，你调用他过后就产生一系列的行为和动作，那么最终你传输的过程当中你一定会携带某种存储结构，所以这个地方的数据结构指的是：</p>
</div>
<div class="paragraph">
<p>1、存储结构</p>
</div>
<div class="paragraph">
<p>2、怎么展示</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/微信界面.png" alt="微信界面">
</div>
</div>
<div class="paragraph">
<p>比如这是微信的对话框。然后下面这个地方是语音的那个符号啊，这个地方你打了文字。我打个比方，你最开始，你发了一个文字信息X给他。那么是你发的你在左边，然后左边这个是你发的文字，然后他又回了一个文字给你，比如这是y，这个地方数据结构包含两大类，第一类是他在网络上怎么去传输，就是你要配合算法去组合它，存储的一种结构，叫存储结构。存储数据结构，全称就叫这个，但这最前面一定省略了某个东西嘛，他一定是数据结构里面细分的东西嘛，所以他那里面有一种叫存储，就是说你文字怎么让他收到。在你看不见的领域，对吧？在网线上，或者在你的wifi上面流淌着那些数据流，这也有数据结构嘛，然后第二种就是说他收到过后，他怎么把那个信息展示出来让他的用户看见，他是在两大类，所以这个时候他要把用存储结构又转换成一种显示结构，然后最后就显示了屏幕上了，但是你在网线传的时候有可能携带了其他的杂七杂八的东西对吧。</p>
</div>
<div class="paragraph">
<p>内在核心：</p>
</div>
<div class="paragraph">
<p>what is？       Answer——&gt;数据关系（描述物体）</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>结构体、类成员、数据表、List/Map、变量（这一类是做存储的，是程序内可见的）、Json/Xml/Html/Jpg(这一类是做传输的，是人类肉眼可见的)他们都是在描述数据怎么去展示的问题，都是在描述物体是什么。（描述物体本身或物体间的关系）。就比如你的姓名和年龄两个分开没啥问题。合在一起他也没问题，那你为什么合在一起啊？对啊，这个东西是你的。为什么我看到这个表单我就知道这是某某某。又比如说我们就只有一个字段，那个字段叫身份证号码，我就问你那身份证号码是不是能表示你啊。但是我说个性别男，他能表示你某一部分。他是在描述物体，为什么在描述物体，而不是描述事物？什么什么事情。比如说我吃饭这个事情你怎么了。去理解他的关系啊，你很难理解为什么他掺杂了很多东西，你用什么吃？对吧，你送嘴吃还是用。我也不知道用啥吃，对吧。你是用筷子还是用勺子，你用大碗还是小碗，你在哪儿吃？所以这个事情啊就是很麻烦。所以像这种数据结构啊，他通常描述的是客观世界里面具体某个东西，东西和东西之间的关系。</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>微信的数据结构</p>
</div>
<div class="paragraph">
<p>这个地方就是聊回微信这个话题啊，那么刚刚讲了微信的发文字信息和发语音是微信的使用场景，算法就是 <code>怎么</code> 去发送消息？数据结构就是发送 <code>什么</code>（Json、List、Xml、数据表）消息？（具体到某个物件比如说螺丝钉）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_编程要培养编程直觉">1.6. 编程要培养编程直觉</h3>
<div class="paragraph">
<p>同样是写代码，为什么你写的代码就是设计不好？就是因为你对这些理解不好，你对这些理解不好就导致你这个人是没有思维的。就好比在几岁的时候，特别是小孩子身上，特别明显，就是他们的逻辑思维非常好。为什么，他天天会问为什么，他一直在问这个问题。小孩子逻辑这样的，如果我哭就会有东西，我就一直哭，如果我哭不挨打，我就有东西吃，如果我哭又被挨打又没东西吃，然后If爸爸举手了，然后就不哭了。小孩子嘛，你看他们，他逻辑思维非常非常的强，为什么？你可以理解为他就是个状态机，就是看人下菜，看动作下菜，看眼神下菜，所以小孩子特别会看眼神。你长大了就不一样了我就不我偏不我就不干。那叫耍性子，你就已经没有逻辑思维了，要感情用事了。小孩子哪来感情呢？你就是天天喂他东西吃，你当宠物养，那是种食物关系，但是小孩子才出生的时候他一天到晚为什么嘛？对吧，他一天在干这个事情我怎么能拿到吃的。比如说那个医院，我举个例子的，那个孩子都哭的，都饿的呀，都一嘴哇哇大哭。然后奶奶抱起来，哄两下，他走到里面，走到里面走两个小时，饿晕了，当然就不哭啦。对吧，小孩子很简单的。怎么简单，哭了，要么是屎糊的屁股上屁股长红疹了。要么是肚子饿了，要么是哪儿扎着痛了，要么被蚊子咬了，对吧？做梦，他连魔鬼是啥都没见过。他做啥梦啊？对不对？他不可能出生就梦到魔鬼对吧？梦到观音菩萨下凡还是啥的吧，不会吧，对不对，所以你看到没有小孩子的概念真的很简单，他就是一个完全的生物有机体。他在按他的本能在去做这种反馈。比如小孩子被扎了，对吧？穿个衣服不舒服你一直动。关键是他才三个月或者才七天，他身都翻不了，你知道吗？就在那里啊啊啊的哭。然后呢，然后妈妈就说，再哭再哭给你两巴掌。相比真的说的话被扇了一巴掌挺痛的，那哭得更凶了，你放心，他会一直哭的，你打他，他会一直哭的。除非你把他打晕，那就不哭了。所以你看到没有？其实小孩子哈很小，他们他逐渐长长大，其实他逻辑思维是非常非常完整的，他也完整的逻辑念路。他有if else一堆。但随着你长大了过后你不会的。然后你身上我有吃的，我得先挣钱，而挣钱的话我先是卖屁股然后完蛋了。所以你就会把这个事情越想越复杂，其实很简单，没吃的嘛。你跑到商店面抢出来就有吃的了噻。你就被这个社会约定俗成的东西给框住了你的生物本能，你的人类本能就已经被限制住了。因为你有法律，或者有社会的道德约束。所以这个时候已经和他相隔十万八千里了，为什么？因为程序是没有道德的。他没有道德去约束他。他也没有爸爸妈妈，也没有感情，所以他就是个冰冷的机器，那一个冰冷的机器，你要怎么样成为个冰冷机器啊？就回到你还是个小娃娃小婴儿的时候。那个时候你就是冰冷的一个吃饭机器，天天要奶粉喝，你干饭机器就是那种这么养成的嘛。所以如果你要逻辑的话，小朋友的逻辑是更完整的。他更符合程序的直觉，所以你可以理解为你这个东西，最终你产这个东西叫程序直觉啊。程序直觉就是我刚刚举的这种，小朋友这种就是直接反应。没有过多的运算，凡是那种经过大脑社会道德，我该不该做这种运算已经和他不符了，所以你要培养的是程序直接这个东西。所以我刚讲的就是说，一旦你知道这些逻辑过后我打个比方，我以前我去学怎么编程的时候，我考虑的问题是。我点的那个按钮过后面发生了什么？我永远会去想根据那个按钮点了过后往后走，查查查查查。怎么通信的。我就一条链路就拉通了，但是这个需要大量的去写代码，大量的去试验。所以只要不删代码，啥都好办。所以像这个东西的话，就是你要靠去练。</p>
</div>
<div class="paragraph">
<p>但是这个地方你要经过大量的代码去练的话不现实，所以你一开始应该有浅显的认知。浅层次就可以了，你大概知道有那么回事。然后剩下就是你，当有这种直觉过后，你就开始去研究这种直觉。具体对应到现实世界或者你的软件哪一部分你去训练它。你去思考，你思考完了过后，那么你就会去补充你这边的这些理论。然后补充的越来越多，越来越完善，比如说最开始你学会的列表，最开始你学会的变量，A=1嘛，然后第二次，你又看到某个软件可以用，或者某个代码可以调某个demo，你可以研究一下，你研究完了就得到什么就得到list。像不像你某天打游戏的时候研究某个部件，然后他升华了，就变成一个战衣爆装备了。对吧，所以他也是这样一个过程啊，所以程序直觉，其实编程这个事情不是那么非常非常感性的编程它是有迹可循的。但是有迹可循它不是摆在明面上的，它是有一套训练方法，而60年代，70年代应该是linux ，unix，c语言发明出来，那发明除了到现在怎么去开发个软件，在业界都没有个统一的认知。你用a方法可以，你用b方法可以，甚至你不用方法也是可以的，就证明条条大路通罗马，就看你所学的哪一条，所以你培养程序直觉是怎么样？这个直觉的意思就是说，你从一个点到另外一个点，你清楚你的目标，所以第一个重点就是你清楚你的目标，我打个比方，我从成都到北京啊。我想从成都到北京，那是我的目标。我怎么去，所以说这涉及到方式的问题，开飞机还是坐火车还是走路？所以你的程序直接是这样的。你最开始训练出一种a方法，你可以达到这个目的，我觉得有个游戏嘛，就造桥嘛。那个桥你用的那个材料越少越牛逼，最开始你用1000个木头造出了桥，然后这个时候，你的效率就随着这个a方案，然后最后a+吧？然后就变成了a，然后效率更高，你的程序直觉是训练这个方法，而从a到a+这个过程，那么就是你的直觉训练。就直觉训练的过程，你训练完了，那么得到这个方法本身就得这个工具又爆了个装备嘛，那你说明掌握了一种技巧，所以你要不断的训练，反复，你可能这个方法不是最优的，你还要想办法去得到更优的。当然，具体写代码来说的话，你肯定就没有那么简单，你可能为了实现这个方法，你跟他学很多东西，那你清楚你的目标和方式。所以你训练的越多，那么你这个方法工具越多。比如说对于我来说，我的武器库里面就有各种核弹，各种常规战术导弹，各种狙击的子弹我流弹炮牌机炮都有，对于你来说你可能就小米加步枪，所以说你要让你的武器库里面越来越多。你武器库越多，那么你的威力越大，那这样的话你中你要想炸的那个房子是用核弹炸还是榴弹炸随便你挑？比如说我明天写一个javaweb程序，没关系，你用c也是可以写的。反正写个三个月嘛，就像用核弹去做了这个事情一样。然后你用springboot的去写，就像用榴弹炮去写嘛对吧。是不是然后有一天出现那个叫轻量级迷你springboot这就是迫击炮了撒，所以你的直接训练会决定你这个你的武器的多少，最终会达到某种目的，所以说你训练的越好。怎么样你的那个整个技巧，技能，技术栈就越靠近你的目标这个中轴线，你能最终你形成了这个线路啊，如果能够直捣黄龙就是最优解。</p>
</div>
<div class="paragraph">
<p>1、要清楚自己的目标。</p>
</div>
<div class="paragraph">
<p>2、要清楚自己的学习方式。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_BCTS2_chapter">2. 编程通识(二)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_2">2.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/编程通识(二)板书1.jpg" alt="编程通识(二)板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程通识(二)板书2.jpg" alt="编程通识(二)板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_2">2.2. 前言</h3>
<div class="paragraph">
<p>网络协议,如果要了解 <code>网络协议</code> ，首先得知道什么是 <code>网络</code> ，知道什么是网络过后，<code>协议</code> 自然而然就通了，最奇怪的是，还有第三个问题，就是什么是 <code>网络协议</code> 。</p>
</div>
<div class="paragraph">
<p>所以我们有3个问题</p>
</div>
<div class="listingblock">
<div class="content">
<pre> 什么是网络

 什么是协议

 什么是网络协议</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是网络">2.3. 什么是网络</h3>
<div class="paragraph">
<p>90年代有一本叫《TCP/IP网络协议》那本书，上面写的：</p>
</div>
<div class="paragraph">
<p><code>“现在有高达几百万台电脑连接在了一起。”</code></p>
</div>
<div class="paragraph">
<p>最开始计算机两两相连，但是两两相连毕竟是很原始的状态，只能单向通信，而不能让两台计算机相互通信，现在发明出了计算机，但是很早之前并没有交换机的概念，就说白了先有网线才有了交换机，不可能发明一个交换机，发现没有东西连接，然后才发明网线，这么看来就觉得很怪。</p>
</div>
<div class="paragraph">
<p>举个例子</p>
</div>
<hr>
<div class="paragraph">
<p>如果没有电视机，就没有现在的安卓电视，如果说先发明安卓，才有安卓电视，这不可能吧。
所以说不用去查，肯定是先有了网线，才发明了交换机，因为为网线更简单，不过还是只能单向通信，但如果两个计算机想要互联怎么办呢？那这种网络拓扑就不够成熟了，所以我们在聊网络的时候，肯定讲的是 <code>互联网</code> 。</p>
</div>
<div class="paragraph">
<p>讲到了互联网，它的起源是美国国航部，当时美国国航部赞助了一个叫网络网际连接的项目，通过引入一个交换机，大家都连到这个交换机上去，那这样的话就形成了 <code>网络</code> 。美国人把网络取名为 <code>“NetWork”</code> ，那么这个Net就是网的意思。</p>
</div>
<div class="paragraph">
<p>网络，英文是：Network，上面说的互联网是美国国防部发明的，从广义上来讲，网络就是美国人发明的，取名叫Network，其中Net的意思就是网络，蜘蛛网不就是Nat。</p>
</div>
<div class="paragraph">
<p>从纯小白的视角可以这样来理解这个单词，就是一个网，可以理解每台电脑都是walker，那么网上就有很多worker，然后他们最终组成一张网， 最后统称就叫NetWork。</p>
</div>
<div class="paragraph">
<p>以此类推，每台计算机都是矿机,很多台矿机最后组成了矿网，</p>
</div>
<div class="sect3">
<h4 id="_互联网与万维网">2.3.1. 互联网与万维网</h4>
<div class="paragraph">
<p>万维网和是互联网区别在哪，万维网能称为万维网，万维网就只作用于浏览器输入网址或者和网页产生关系的地方，只要和浏览器扯上关系的都是万维网的一部分，但是国防部最开始发明的可不是万维网。最开始发明的是Network，所以万维网属于NetWork的一部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_补充学习编程到底在学习什么">2.4. 补充：学习编程到底在学习什么？</h3>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="listingblock">
<div class="content">
<pre>变量a=1
变量b=3
变量c=a+b
那么C的值是多少</pre>
</div>
</div>
<div class="paragraph">
<p>这道题是一道编程题也是一道数学题，它们没有本质的区别，所以可以说编程和数学是紧密联系在一起的，不过它们有对与世界着不同的理解。</p>
</div>
<div class="sect3">
<h4 id="_数学">2.4.1. 数学</h4>
<div class="paragraph">
<p>举个例子嘛
小时候学的加减法，在生活中可以用来买菜，乘法或者除法也是可以的，到了六年级，就开始学代数，到了初一初二就开始学几何，到了高中，等差数列，还有很多更高级东西，其实它们都是来源于生活。数学家，一代一代传承然后经过几百年的发展，他把自己看的某种现象给总结出来了。甚至前几年，浙江大学有篇论文叫博弈论，这个博弈论就研究石头剪刀布的事儿,还花了国家的钱去研究，但是普遍人都认为：“这个东西都要研究？简直不可思议。”但是研究人员就真的通过总结一系列规律后,总结出石头剪刀布的时候怎样才能提高你的胜率,当某天你和别人石头你看论文过后，你能够达到目的。</p>
</div>
<div class="paragraph">
<p>再比如说， <code>万有引力</code> ，如果苹果有砸到头上，普通人肯定不会想到万有引力，可是牛顿就想到了。</p>
</div>
<div class="paragraph">
<p>现在的数学家甚至黑洞都能计算。</p>
</div>
<div class="paragraph">
<p>从上面的例子就可以看出，数学更多的是总结规律，那么数学就是 <code>对客观世界的规律或者事物的一系列的总结</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_编程">2.4.2. 编程</h4>
<div class="paragraph">
<p>那么编程呢？
编程其实就是我们经常讲到编程编程是某某件事情，并不是指代某个东西。
那么 <code>编程为动词，数学为名词</code> ，和数学对等的叫做程序。</p>
</div>
<div class="paragraph">
<p>上面数学是总结世界的运行规律，程序呢？先偷换个概念，我们先给程序这个东西进行归类，每当我们看新东西，不知道他是啥 ，就会去对他进行归类。那程序，首先他应该是某种工具。 那人类用工具是干啥的呀？
远古时期，原始人第一次发现可以用锋利的石头，给自己做一件大衣，貂皮大衣；用火烤的肉更香，除了肉更香以外，吃了还不会拉肚子，还可以长寿，估计最开始有人吃生的，有人吃熟的，结果发现，吃熟的人到活到了30岁40岁，而不吃熟的拉肚子死掉了 。所以说工具的是和效率挂钩的人类发明工具或者是找到某种工具或者制作工具，一定是为了自己服务的 。那程序也是工具，所以说程序也是用来提高人类的工作效率的，那么，它是怎么提高工作效率的呢？
程序首先是代替人类完成工作的，程序的速度很快，这里的速度就有两层意思，那么第一层更快说是指的 <code>计算速度快</code> ，那第二层意思更快，意思说，下一次程序要做同样的事情的时候，就只是把程序拿出来跑一遍，就像洗碗一样，第二次拿个洗碗的刷子，就指的 <code>重复使用</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是协议">2.5. 什么是协议</h3>
<div class="paragraph">
<p>我们先把上面讲网络的概念放下来，就是很多计算机中间一个交换机的例子，我们将这个例子里面的计算机代换成一个个小人,假设那是atm机里面小人，那里面的小人在干啥？他在里面工作，那么每一台atm机之间或者人之间，他们都有相互联系，这样就组成了一个 <code>人际关系网</code> ，他们之间相互联系，但是我们没有交换机，就把空气当做交换机，人与人之间交流也是靠空气来传播的，那么空气就是人与人“连接”的一条线,连接的主要作用就是传递信息，那要怎么才能把信息传递出去呢？在人与人之间传递信息主要依靠的是语言，所以语言就是传递信息的主要方式，语言之下也有不同的实现方式，比如语音，字等等，但是语言还是要就借助“连接”，连接可以理解为更大层次，它就是一个 <code>工具</code> 的载体，那连接这类 <code>工具</code> ，你要要用说话的方式，要用一种语言的方式让他生效，</p>
</div>
<div class="sect3">
<h4 id="_举个例子">2.5.1. 举个例子</h4>
<div class="paragraph">
<p>一个婴儿在咦呀哇的乱叫的时候，你是听不懂的，你不知道他在叫什么，为什么？因为你不是婴儿，你的语言系统已经成熟了，不知道他的婴语究竟代表什么东西。在07、08年的时候，有个视频超级火，两个光头的外国人小男孩，才学会走路，也就就一岁多一点，两个人穿的小baby的衣服走来走去的，当他们走到厨房的角落，其中一个婴儿把袜子脱下来，闻了一下，就开始哇哇哇哇的叫。而且最关键是视频长达67分钟。叫完过后，其中一个小男孩走过来把冰箱打开，接着就开始咦呀哇的，然后另外小男孩就走过来了，这样证明他们之间是有沟通的，但是你听不懂。 所以这个时候他们之间的婴语，对于他们来说，是生效的，对于我们来就没有办法理解一致，那么这个时候他们的语言对你来说是无效的，所以上面我们在人际网络里面就需要使用共同的语言来通信。</p>
</div>
<div class="paragraph">
<p>语言其实就是 <code>工具</code> ，那么 <code>连接</code> 要承载信息嘛，还要信息要流转，那就是协议咯
在网络上面都有计算机，有计算机过后，就会产生数据，但网络上肯定不止一台计算机，现在假设有两台计算机，就会产生数据A(Data A)和数据B(Data B)两个数据，产生了这两个数据过后，因为数据产生就会传递给对方那么就有起点和终点 ，那么他们之间相互连接的网线就是数据的 <code>载体</code> ，但这时载体发送数据它并不能听懂，所以还差一个东西，就是 <code>协议</code> ,平时也叫通信协议。
那这时候在网络就有几类大的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>计算机、数据空间、协议、网线</pre>
</div>
</div>
<div class="paragraph">
<p>网线就是通信协议流淌的载体，是通信的基础条件，是硬件，计算机也是硬件，而协议则是软件，在下图</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/网线里有什么.png" alt="网线里有什么">
</div>
</div>
<div class="paragraph">
<p>Computer A要向Computer B发送数据，上图就是根网线，网线就相当于高速公路，外面的皮是网线皮，这皮里头有同心线，这个时候呢里面肯定还流淌着协议(网络语言),里面充斥着Data A一直流，发送到Computer B后返回的数据就是Data B，严格意义上来讲的话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>网线就是一条高速公路，上面有两个方向，高速公路你开过去的时候，产生Data A，到达Computer B后产生Data B返回回来，这个时候Data是指数据0101，但是如果要让双方都能听懂，就必须带语言格式(协议)</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是网络协议">2.6. 什么是网络协议</h3>
<div class="paragraph">
<p>网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</p>
</div>
<div class="paragraph">
<p>这里的网络就是指流淌在操作系统内部的东西（OS内）</p>
</div>
<div class="sect3">
<h4 id="_协议">2.6.1. 协议：</h4>
<div class="paragraph">
<p>协议其实跟语言一样，语言有中文、英语、西班牙语等。</p>
</div>
<div class="paragraph">
<p>TCP/IP协议：TCP（传输控制协议）和IP（网际协议）</p>
</div>
<div class="paragraph">
<p>TCP/IP提供了点对点链接的机制，将资料应该如何封装、寻址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，分别归属到这四个层次结构之中[7][8]，常视为是简化的‘七层OSI模型’。</p>
</div>
<div class="paragraph">
<p>七层OSI模型：</p>
</div>
<div class="paragraph">
<p>第7层 应用层
主条目：应用层
应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p>
</div>
<div class="paragraph">
<p>第6层 表示层
主条目：表示层
表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
</div>
<div class="paragraph">
<p>第5层 会话层
主条目：会话层
会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p>
</div>
<div class="paragraph">
<p>第4层 传输层
主条目：传输层
传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>
</div>
<div class="paragraph">
<p>第3层 网络层
主条目：网络层
网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p>
</div>
<div class="paragraph">
<p>第2层 数据链路层
主条目：数据链路层
数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
</div>
<div class="paragraph">
<p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p>
</div>
<div class="paragraph">
<p>第1层 物理层
主条目：物理层
物理层（Physical Layer）在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p>
</div>
</div>
<div class="sect3">
<h4 id="_tcp子集_httpftpudptcpsmtppop3imap">2.6.2. TCP子集 （HTTP、FTP、UDP、TCP、SMTP、POP3、IMAP）</h4>
<div class="paragraph">
<p>HTTP：超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的。</p>
</div>
<div class="paragraph">
<p><a href="http://XXX.com" class="bare">http://XXX.com</a></p>
</div>
<div class="paragraph">
<p>ssh://XXX.com</p>
</div>
<div class="paragraph">
<p>比如说一个连接有两个点:</p>
</div>
<div class="paragraph">
<p>server————————client</p>
</div>
<div class="paragraph">
<p>连接是由client发起的，就有了客户端跟服务端的概念，客户端上用的通信是HTTP协议，里面又包裹了HTML。</p>
</div>
<div class="paragraph">
<p>FTP：文件传输协议（英语：File Transfer Protocol，缩写：FTP）是一个用于在计算机网络上在客户端和服务器之间进行文件传输的应用层协议。文件传送（file transfer）和文件访问（file access）之间的区别在于：前者由FTP提供，后者由如NFS等应用系统提供。</p>
</div>
<div class="paragraph">
<p>UDP：用户数据报协议（英语：User Datagram Protocol，缩写：UDP；又称用户数据包协议）是一个简单的面向数据报的通信协议，位于OSI模型的传输层。在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。UDP适用于不需要或在程序中执行错误检查和纠正的应用，它避免了协议栈中此类处理的开销。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取</p>
</div>
<div class="paragraph">
<p>TCP：传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。用户数据报协议（UDP）是同一层内另一个重要的传输协议。TCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。操作系统将TCP连接抽象为套接字表示的本地端点（local end-point），作为编程接口给程序使用。在TCP连接的生命期内，本地端点要经历一系列的状态改变。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/SMTP,%20POP3,%20IMAP.png" alt="SMTP, POP3, IMAP">
</div>
</div>
<div class="paragraph">
<p>SMTP：简单邮件传输协议（英语：Simple Mail Transfer Protocol，缩写：SMTP）是一个在互联网上传输电子邮件的标准。SMTP是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过telnet程序来测试一个SMTP服务器。SMTP使用TCP端口25。要为一个给定的域名决定一个SMTP服务器，需要使用DNS的MX记录。在八十年代早期SMTP开始被广泛地使用。当时，它只是作为UUCP的补充，UUCP更适合于处理在间歇连接的机器间传送邮件。相反，SMTP在发送和接收的机器在持续连线的网络情况下工作得最好。</p>
</div>
<div class="paragraph">
<p>POP3：邮局协议（英语：Post Office Protocol，缩写：POP）是TCP/IP协议族中的一员，由1996年5月发行之RFC1939 首次定义。此协议主要用于支持使用客户端远程管理在服务器上的电子邮件。最新版本为POP3，全名“Post Office Protocol - Version 3”，而提供了SSL加密的POP3协议被称为POP3S。POP支持离线邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或Mac。一旦邮件下载到PC机或Mac上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。</p>
</div>
<div class="paragraph">
<p>IMAP：因特网信息访问协议（英语：Internet Message Access Protocol，缩写：IMAP；以前称作交互邮件访问协议）是一个应用层协议，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。</p>
</div>
<div class="sect4">
<h5 id="_pop3_smtp_imap的区别在哪里">POP3, SMTP, IMAP的区别在哪里？</h5>
<div class="paragraph">
<p>简单地说，SMTP管‘发’， POP3/IMAP管‘收’。</p>
</div>
<div class="paragraph">
<p>举个例子，你坐在电脑边用mail client写完邮件，点击‘发送’。这时你的mail client会发消息给邮件服务器上的SMTP service。这时有两种情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果邮件的收信人也是处于同一个domain，比如从http://163.com发送给163的邮箱，SMTP service只需要转给local的POP3 Service即可</p>
</li>
<li>
<p>如果邮件收信人是另外的domain，比如http://163.com发送给http://sina.com， SMTP service需要通过询问DNS, 找到属于sina的SMTP service的host。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SMTP service收到邮件后转给负责接收邮件的POP3 service</p>
</div>
<div class="paragraph">
<p>POP3 service和IMAP的区别主要是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POP3是比较老的protocol，主要为了解决本地机器和远程邮件服务器链接的问题，每次邮件会download到本地机器，然后从远程邮件服务器上删掉（当然特殊config除外），然后进行本地编辑。这样的问题是如果从多个终端链接服务器，只有第一个下载的能看到，现在pop4正在讨论中</p>
</li>
<li>
<p>IMAP是比较新的（好吧，好像也是80年代的产物）protocol，可以将邮件分文件夹整理，然后这些信息也存在远程的邮件服务器上，读取邮件后，服务器上不删除。原理上IMAP应该是相当于oneline编辑，但现在的mail client基本都有在本地存copy的功能。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ip子集icmparp">2.6.3. IP子集(ICMP\ARP)</h4>
<div class="paragraph">
<p>ICMP：互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。ICMP [1]依靠IP来完成它的任务，它是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了 ping 和 traceroute 这两个特别的例子。 IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6。</p>
</div>
<div class="paragraph">
<p>ARP：地址解析协议（英语：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。ARP也可能指是在多数操作系统中管理其相关地址的一个进程。ARP是通过网络地址来定位MAC地址。</p>
</div>
<div class="paragraph">
<p>VPN（企业内部协议）:虚拟私人网络（英语：virtual private network，缩写：VPN）是常用于连接中、大型企业或团体间私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到发送端认证、消息保密与准确性等功能.</p>
</div>
<div class="paragraph">
<p>例：一个员工出差想访问公司的局域网，他就要进行拨号，打开软件才行，VPN 就会帮你虚拟一张网卡出来，一旦拨号了之后就会有一个IP地址，如果没拨就是没有IP地址的，没有IP地址就不能上网，就不能上公司的局域网。</p>
</div>
<div class="paragraph">
<p>网络协议就是指的这上面的东西。</p>
</div>
</div>
<div class="sect3">
<h4 id="_要理解计算机世界是怎么运行的非常重要">2.6.4. 要理解计算机世界是怎么运行的非常重要！！！</h4>
<div class="paragraph">
<p>一旦你理解了这个过后，你去学很多其他的东西就ok了，比如说有一天，你遇到企业内部的软件出问题了。你没有见过他，难道你就不知道他是怎么回事吗？</p>
</div>
<div class="paragraph">
<p>举个例子：</p>
</div>
<div class="paragraph">
<p>某一天，公司里面的的出纳小姐姐找到我说帅哥能帮我看看吗？她说电子税务的那个软件打不开。当然我帮他解决打不开这个问题，解决了五花八门，最简单的就是经过我一顿骚操作，我就蹲下去插了下网线好了，结果是因为那个下面线太多，小姐姐踢到了，网线就踢松了，他那个网口不牢就踢松了。但是没有开机这种事情我就不讲了，那他自己能解决。我遇到了我跟他解决过很多次这种他那个软件打不开的问题，为什么因为在她的概念里面，电子税务软件出问题了，问题很严重。对吧，但在我的理解里面，这个计算机出什么问题了？然后才是软件，我要先排除计算机有没有问题？对吧。你连windos网络都不通，一上来。Alt+R 输入 cmd，一个黑色窗口，ping一个qq.com然后回车，网络不通，插一下网线好了。</p>
</div>
<div class="paragraph">
<p>你会发现我其实我不懂那个电子记账系统，我也不清楚，但是别人为了为什么遇到问题老去找我为什么，因为我很清楚计算机出什么问题了？我不会被错误迷失了双眼。所以要理解计算机是怎么工作的，他是怎么运行的，非常非常重要。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_XMSZ1_chapter">3. 项目实战(一)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_3">3.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/项目实战（一）板书1.jpg" alt="项目实战（一）板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/项目实战（一）板书2.jpg" alt="项目实战（一）板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_3">3.2. 前言</h3>
<div class="paragraph">
<p>这篇随笔会穿插很多项目，因为讲太多，不动手的话手会生。</p>
</div>
<div class="paragraph">
<p>C01讲的是 <code>Radis</code> ，是一个很复杂的系统，因为当时所有成员都已经有编程经验了，所以就上了一个看起来高大上的一套框架和组织架构。</p>
</div>
<div class="paragraph">
<p>C02的话做了 <code>GeeShow</code> ，属于一种中型项目，有简单的地方，也有技术挑战，然后他也有就是很复杂的理念，至少在市面上见不到第二个，</p>
</div>
<div class="paragraph">
<p>那这次C03的话，就是做一个Linux监控系统。</p>
</div>
</div>
<div class="sect2">
<h3 id="_项目背景">3.3. 项目背景</h3>
<div class="sect3">
<h4 id="_常用监控软件">3.3.1. 常用监控软件</h4>
<div class="paragraph">
<p>监控系统其实在Linux平台或者服务器里并不少见</p>
</div>
<div class="paragraph">
<p>比如说现在已经有:</p>
</div>
<hr>
<div class="paragraph">
<p><code>Zabbix</code></p>
</div>
<div class="paragraph">
<p>由Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。</p>
</div>
<hr>
<div class="paragraph">
<p><code>Cacti</code></p>
</div>
<div class="paragraph">
<p>一种基于Web的开源网络监视和绘图工具，设计为开源的，行业标准的数据记录工具RRDtool的前端应用程序。</p>
</div>
<hr>
<div class="paragraph">
<p><code>Nagios</code></p>
</div>
<div class="paragraph">
<p>电脑系统和网络监控程序，用于检测主机和服务，当异常发生和解除时能提醒用户；是基于GPLv2开发的开源软件，可免费获得及使用。</p>
</div>
<div class="paragraph">
<p>这些都是比较常见的监控软件，这些软件主要就是把服务器的CPU带宽、硬盘、内存、进程数还有很多其他东西通过统计分析的方式，画成图表展示出来，既然这些软件能生成图表，就意味有数据库，如果没有数据库就无法生成图表。</p>
</div>
<div class="paragraph">
<p>至于数据库，用常见的 <code>关系型数据库</code> 或者存储到文件里面的 <code>纯XML</code> 都没有关系，因为最终都能读出来。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_它们存在的问题">3.3.2. 它们存在的问题</h4>
<div class="paragraph">
<p>上面的软件都集中解决的是一个问题，第一个问题就是它的覆盖面是比较通用领域，那么它们是用来解决通用领域，既然是解决通用领域的问题，那就意味着他们就是 <code>同质化</code>，但同质化解决问题就相对的比较之后。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>同质化：指同一大类中不同品牌的商品在性能、外观甚至营销手段上相互模仿，以至逐渐趋同的现象</pre>
</div>
</div>
<div class="paragraph">
<p><code>举个例子</code></p>
</div>
<div class="paragraph">
<p>公司的服务器老死机，然后工作人员查死机的原因，当他查不出来具体的原因，他就通过监控软件，监控软件可能显示CPU有异常，但是并不清楚具体是哪个地方出了问题，比如说看到CPU占用100%，然后监控软件给你提供一个线索，所以说用这种监控，他可以帮你解决问题，但是从强哥的从业经验来说，我解决这种疑难杂症问题，从来不依赖他们，为什么？因为他们都一样，你比如说像宋波峰，我没有让他搭过监控软件，我也没有让黄臣玉去搭监控软件，我也没有让卢宇去搭，我也没有让李喜去搭，为什么？因为这种东西装着玩儿就可以了，这个东西本来它就不重要，因为他只是给你提供一个 <code>线索</code>，那既然你能提供线索，那么在CPU超温或者僵死的时候，系统日志里面已经提示你cpu冻住、卡住了，那么系统日志里面已经提供了线索，就不需要跑到监控的软件上去看它生成的图形，然后有人就说：“图形很好看，日志不好看。”那既然都去解决问题了，肯定也不在乎友不友好，因为你有那个能力去查日志，日志才是追根溯源最好的东西，相反图形这些东西，他只是起个辅助作用，所以他不是决定性的，是通用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_项目背景_2">3.3.3. 项目背景</h4>
<div class="paragraph">
<p>现在Linux可是 <code>巨量的</code>（都不是说大量的）在使用，他是 <code>服务器领域的事实标准</code>，尽管我们会讨论说CentOS好还是Ubantu好，但是从来没有讨论过Windows和Linux该选谁？</p>
</div>
<div class="paragraph">
<p>在我才开始学习Linux那一段时间还充斥着一种说法：“Unix更稳定，Linux不稳定。”但是我从来没有在任何一台服务器上面去装过Unix，因为最开始我在自己的PC上装Unix，发现要装上它是个艺术活，为什么？因为它里面不带驱动，驱动都要你自己弄，最关键基本市场上的驱动都适配的Linux，Unix由于版本还有各种东西都很老，当然也有新的，不过大部分情况下厂商并没有进行适配，这个时候，你要去解决各种各样非常奇怪的问题，那既然我用操作系统目的就是因为我不能写底层的东西，那现在你都让我介入到你的内核里的驱动层面去了，这样不就和我自己写驱动没有什么本质的区别，所以对于系统优先选择就应该是一个成熟标准的系统，那么Unix和Linux相比，那肯定是Linux，这是其一，其二就是Linux和Windows根本就没可比性。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_还有哪些领域在用linux">3.3.4. 还有哪些领域在用Linux？</h4>
<div class="paragraph">
<p>上面说到“Linux已经成为服务器领域事实上的标准了”</p>
</div>
<div class="paragraph">
<p><code>打个比方</code></p>
</div>
<div class="paragraph">
<p>在手机上随便打开一个软件，哪怕是微软的Office365，他的服务器肯定是跑在 `Nginx`下面的，既然都跑在 `Nginx`下面，那么搭建在Linux上就很香，微软有个语音叫Azure，Azure的平台，最开始只卖微软的云，那就只用于微软的Windows，结果过了几年都没起色，直到微软换了一个印度的CEO，这个人推从开源，上一届是鲍威尔和比尔盖茨他们两个在主事，然后他们两退了，他们退了后那就是印度的CEO在主事，那个CEO是一个财务和市场营销出身的，他就只关心钱，他并不关心技术或者生态层面的东西，所以在很长一段时间里微软在开源领域说Linux是毒瘤，就因为Linux抢占了Windows市场份额了，可以想象微软当时是敌对的态度，之后印度的那个CEO上台了，叫萨提亚·纳德拉，他上台就开始推行政策，让微软全面拥抱开源生态，首当其冲的成为了Linux核心基金会的成员，其实要成为Linux核心基金会会员很简单，拿钱买就行了，告诉他我要做这个事，他就会让你进，当然，微软后面夹带私活要想在内核里面加入他的exFAT文件系统，然后Linux大声说Get out，为什么？因为那个东西和你Linux没有半点关系，都是微软的私货，我给Inte说我的CPU有漏洞，我要为了几个漏洞加第二个补丁，不过这个补丁也是一个漏洞、后门，求求Linux让他加进去，然后你Linu也对他说Get Out。所以想加入Linux生态，给钱就可以了，但是你真正想参与其中，你必须要做对社区和生态有益的事情。那之前说的Azure这个云平台，他后面也支持Linux了，自从发现支持Linux后生意大大的好，微软甚至自己的东西都架在了Linux上面。包括他的官方网站，还有IIS、webserver，结果他自己都不用，他用Nginx做前端负载，后端IIS，这也无所谓。这就证明一个问题啊，在负债均衡和反代领域，Nginx才是绝对的王，绝对的流量入口。那看到Nginx也是跑在Linux下面的，你不可能跑个Windows下面，在Windows下面性能贼差，为什么？Nginx官方说在windows上是实验性的，支持很差的，那就是个玩具，谁用谁知道，那这是一个，那微软后面还做了Open JDK，他也开始支持自己的发行版了。</p>
</div>
<div class="paragraph">
<p>微软的发行版名字贼怪，表面上看起来Windows应该是绝对数量的，但实际上在 <code>重要的领域</code> 和 <code>头部</code>，Linux更占数量。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_什么叫头部">3.3.5. 什么叫头部？</h4>
<div class="paragraph">
<p>在服务器用的最多的那些厂商里头100%的都是Linux，不否认说尾巴后面有时候中小企业，小微企业，他们没有能力去用Linux，就会用windows，比如说像那个万科这种房地产的，没有任何技术含量，跨界他需要有一些服务器来做它内部的云或者软件，那他肯定会装windows，所以Windows是肯定有的，而且数量还不少，但是头部才是决定你找工作的或者是从业人员选择的一个重要因素，尾巴上那些顺带会一下就可以了，在这个行业里面，Linux绝对是服务器领域的事实标准，只是大家都在用发行版吵架，但是不妨碍他是Linux。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_linux存在的问题">3.3.6. Linux存在的问题</h4>
<div class="paragraph">
<p>Linux用的多了后就存在 <code>管理问题</code>，操作系统都是需要维护的，比如说：</p>
</div>
<div class="paragraph">
<p><code>安全补丁</code></p>
</div>
<div class="paragraph">
<p><code>版本升级</code></p>
</div>
<div class="paragraph">
<p><code>发布新版软件去迭代</code></p>
</div>
<div class="paragraph">
<p><code>流量大了过后还要去做各种调整或者策略</code>、</p>
</div>
<div class="paragraph">
<p><code>通过Debug找哪个地方慢</code></p>
</div>
<div class="paragraph">
<p>比如说在中小企业里，他们写的程序很慢，但是慢的问题都是有本质共通性的原因，具体原因也不知道，反正就是各种各样的问题，每个操作系统上都有这种需求，那么Linux也不例外，数量越多，存在管理的问题就越多，比如说华为或者富士康，郑州、东莞的富士康工厂一个就有几十万人，这么多人，就存在各种各样的宿舍管理问题，时不时就跳个楼啥的，就算里拉上了蜘蛛网，你一跳跳到网上能接住几个是几个，没接住就都死翘翘了，至少还有赔偿金，所以这就成为了管理问题，人多了过后要管理人，那么软件多也要管理软件，那操作系统也是软件也需要管理，这种问题一旦出现，无法解决，那么这个时候就提出了管理的要求，那么管理的需求是存在的，那之前在最开始讲过的哪些已经有的监控软件，它们都有一种通用性，并不能解决企业当中的问题，为什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

企业的老板，他已经知道了这个服务器已经死过3次机了，那他现在要解决问题，什么问题？ “服务器为什么会宕机？”这是一种场景，但是如果你连用户都没有，死啥机呀。</pre>
</div>
</div>
<div class="paragraph">
<p>所以在死机之前，还有一个阶段，</p>
</div>
</div>
<div class="sect3">
<h4 id="_起步阶段">3.3.7. 起步阶段</h4>
<div class="paragraph">
<p>这一阶段就是企业从零开始做，企业老板需要了解他的用户数据，而系统管理是一个消耗性岗位或者消耗的事情需要去做的，但这种消耗对于企业的就是投资方或者老板，他并不关心，他最关心的是他能 `收入`多少。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你告诉一个老板说：全中国政府，他们都有各种招标，我写了一个爬虫，我把所有的招标消息通过爬虫爬到了我的平台里，每个月花500块钱订阅我的邮件，我会自动把全国的招标信息发邮件推给你。这样只要去找到你的客户，他绝对会买，因为相比于人情事故、打电话还要请吃饭维护关系来说。你这样的话至少能给他更多的机会，他都不知道，那个地方要招标，那个标就和他没关系。他一订阅了你的平台，他就知道那个地方有标了，比如说：政府强制规定，招标必须向外公布，那比如说你是市长啊。其实那个网站上已经发了，但假设我作为一个土豪，我就会直接问“市长，最近有什么生意可以做呀？”然后市长说“我们最近有个招标”</pre>
</div>
</div>
<div class="paragraph">
<p>那么这种是靠人际关系才知道招标的消息，但是搞技术的人就应该看网站。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

我的老家要拆迁，其实拆迁的消息我早几年前就知道了，但是那个时候我非常清楚他处于规划阶段，为什么？因为当地规划局网站上明确的写着规划是多久到多久，甚至某个地方修机场，我比新闻还提前知道，三天两头去看那个规划网站，因为国家规划局只要定版了就开始是进入后续阶段，要是规划都没做，就不用考虑了。</pre>
</div>
</div>
<div class="paragraph">
<p>我们搞技术的，就要用技术的方法去解决问题，而这个市场上的需求方或者老板，他们只关心收入，他不会关心你帮他节约了多少块钱，他觉得只要挣500块我就不关心那节约的500块，因为挣500块属于流动资金，而节约500那不叫流动资金，和支出是不一样的，流动资金能从一个人的钱包流到另一个人的钱包，那你们两个都有500块钱收入，你们两个加起来收入1000块钱，但是如果这种问题一旦出现，少给一个人发了500块钱，那就叫节约开源截流，看起来，大家都不高兴，为什么？因为一个人少收费500块钱。</p>
</div>
<div class="paragraph">
<p>所以这种暴露出的问题啊有几类，第一个那么当用户在项目的初始阶段或者起步阶段，最重要的是了解自己的发展状态、运营状态，这个地方范围会很大，具体来说我的运营状态里面包括我向市场投了广告，那广告的点击量是多少？我投了电梯广告或者是那个电视广告哈，我的完播率或者是观看量是多少？还有每天客户打进来的电话数量是多少？那么有了数量过后有成交率，就是打了电话里面的人有多少人买了我的东西，这就叫成交率，那我得了解我的成交率是多少？成交率有了过后还有退货率，最近鸿星尔克电话都被打爆了，火了之后销量是直接往上涨，最后自己的工厂实在顶不住那么大的订单量，那么就只能退款一些，所以这些老板都很清楚，这些都是人类社会存在几千年的规则了，不需要你去加工，专业的人比你还专业，但是现在已经步入信息化社会，那就意味着这个过程中肯定会用很多软件，这些软件里面订单量，他可以从后台看到的，所以也不需要你操心，反正那个收钱和你没关系，但是有个问题，你那么多订单量到了你的服务器上面，你服务器什么状态啊？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

如果你是京东的老板，你想知道每天多少人浏览你的网站，怎么解决？</pre>
</div>
</div>
<div class="paragraph">
<p>现在做法就是挂一个百度的JS文件在网页的最下头，每当有人访问你的网页的时候也会访问百度那个JS，那么服务器上就会产生一条Web日志，百度就用那个日志来做分析，不过这个已经技术很成熟了，一二十年了，不过还有个问题，这个只是解决了运营里面比较前端的事情，就是眼睛能看得见的那一部分，而眼睛看不见的那部分是从用户发起请求到服务器上后到底发生多少事情？前端肉眼能看得见的那一部分你都很了解，各种各的地方都可以让你看，但你并不了解服务器上的东西，你非常清楚用户从哪来到哪去，甚至用户的性别，电话号码都有，但你就是不清楚你自己的系统，以及整个运营过程的状态，所以这是个很严重的问题，这个问题在十年前就存在了，十年后的今天还没解决好。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

比如说你买了阿里云，阿里云上面有个东西叫监控面板，成功的代替了这个玩意儿，但是出问题死机还是得死，最离谱的就是在阿里云的服务器里你啥都没干，安安静静的放着，结果某天三更半夜CPU突然跑上去然后服务器死掉了，第二天找到客服沟通，沟通了半天，客服给你回复说“亲，我给你换台服务器好了。”刚换没几天，那个服务器的用户又塞满了结果又死掉了，你又得联系客服换服务器，最后你去投诉了三次，阿里云直接把你迁移到一台稳定的服务器上面，终于不出问题了。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个问题就在于自己对自己所拥有的资产不清楚，到现在为止，大家都没有意识到这个严重的问题，这可不是说CPU跑了多少，那可是用户访问你网页访了多少？他产生了多少个查询？你都不清楚。</p>
</div>
</div>
<div class="sect3">
<h4 id="_补充为什么程序员的工资比传统行业高">3.3.8. 补充：为什么程序员的工资比传统行业高</h4>
<div class="paragraph">
<p>那我们现在要做个东西他并不是一个完整的监控系统，我打个比方，为什么程序员的工资比传统行业高吗？</p>
</div>
<div class="paragraph">
<p>设想一下工人在工地上扎钢筋，每天扎多少个灌水泥的小笼子，还有一根一根的钢筋，一根多少钱？但是老板是不是大概知道一个人一天能扎多少多少根吧，所以他请个小工，给他五块钱，计件，你在服装厂上班，在店富士康上班，也是计件，那么计件就意味着工资低，为什么吗？计件意味着你的工作和你的价值是可以量化的，当一个人的价值可以量化过后，那么资本家可以资本家可以剥削任何人，但是当你的劳动价值是明码标价，那就会被砍价。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

老板就知道行情价五块钱一根，但老板可能出四块五但还是有人做，所以他是可以砍价的，但是找个程序员帮你做个软件，你也不知道他的标价是多少，你就问他，你们一般做这个多少钱的？程序员心想：“正常来说我要花三个月，但是我不能报低了给他砍价，所以他心里面想的是4万但是给老板说的8万，然后老板心想，我得还价，但是老板发现还了价后对方就不理他了，第二次老板学乖了，他就不还价了，他就会说：“你这开发要多久啊”。那么如果老板砍价成功，那么将面临个第二个致命问题，老板砍价是砍爽了但是要求的功能，程序员也砍的可爽了,这就叫“上有政策，下有对策，我看需求”如果老板不砍需求还要原价，程序员就想“老板的给5万又不能砍需求怎么办？”缩水呀！任何异常都不管，</pre>
</div>
</div>
<div class="paragraph">
<p>所以说在计算机领域是生产力说了算，可不是甲方说了算，但凡甲方说了算的计算机项目，他已经被明码标价，已经被定价了。这个钱摆在那你这爱要不要，就比如说政府的项目，但是除了这种甲方强势的项目以外，你到自由市场上，你找个程序员给你开发500块钱的系统，对方骂你是傻子，就是因为不能被定价，所以程序员工资高，创新能力是一方面，它有科技含含量，最重要的原因就是不能定价，一旦程序员的工作能够被定价过后，就能批量的从学校培养，直接进企业上班写代码，对日外包就是怎么回事，但是那种模式有严重的问题，什么问题？创新能力严重低下，他不符合这个行业的价值观和驱动能力，为什么这个行业是一直在创新的？而这种定价和计件的方式，他只能解决已有的问题，但是这个行业已经经过了20年的发展已经有了翻天覆地的变化，日本的那一套已经被严重的抛弃了，理论也过时了，那么这个时候，还要用这种方式去打通其他的方式来做定价这种？也要考虑一个问题：“他多久能够过会过时？”那么 <code>程序员的工资高，很很大一部分是因为它的生产力不能被定价.</code></p>
</div>
<div class="paragraph">
<p>而现在老板面临手的问题就是：“虽然我不不需要定程序员的价格，但是老板要知道程序员做出来的系统到底产生了多少的交货、查询、带宽或者是花费的时间，因为这样就意味着老板可以对系统的算力量进行定价和标定。”</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

服务器上的是一个1Ghz的CPU，那么按我之前监控的数据来看的话，在1Ghz的CPU上，我的系统去跑最高的话大概能够同时跑到100个人，这样的话，他就能大概预估，那么如果我把CPU加到2Ghz ，那现在我的系统至少能够跑100-150个人，具体多少可以去测试，可以再观察一段时间，然后就发现，1Ghz的时候是100个人，2Ghz是120人，4Ghz的时候是150人，</pre>
</div>
</div>
<div class="paragraph">
<p>所以他是能够通过观察得到一个数据，但是这个玩意并不能用数学算，因为太复杂了，里面包括的变量太多了，数学里要做的事情是可控变量，</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子：如果a+b=c，a和b的变量一直在变，请问怎么知道c的值，所以数学里面最重要的一点就是控制变量，要先把其中一个变量控制下来，所以数学里经常看见“假定a=1，那么b=偶数。请问c有多少种可能性？”</pre>
</div>
</div>
<div class="paragraph">
<p>看到没数学它在控制变量，但是在服务器领域或软件领域里，最大的问题就是它不能控制变量，虽然他是不能用数学算的，他太复杂了，可变因素太多了，所以要经过测试。但是有多少人访问，这个是肉眼就可以看出来的，所以在运营里面最大的一个问题就是不能对系统算力进行标定啊。</p>
</div>
<div class="paragraph">
<p>那么还有问题，第一个问题，企业不知道自己究竟可以承担多少访问量，</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方
老板现在知道在50个并发量的时候会出问题，那么要怎样全靠程序员去自觉排查代码，按行话来说，叫走代码，走代码的意思就是打开你的IDEA，然后从程序员个人觉得，举个例子，访问A的登录API时候出了问题，你就会打开IDEA，然后找到Spring Boot的Controller找到登录接口，从登录接口那个代码一直往下看。然后猜哪里出问题了，这个是全凭经验的，比如说你这地方的查询是不是太太慢了？然后你去测试，测试完后，发布个新版，然后你同事在管这个服务器，你就对他说：“发了个新版，我Jar包发给你了，你重新测一下”结果他弄了半天还是对你说：“哎，还是不行。”这样一来一回来个十次，你两个疯了，为什么？效率太低，而且老板这时候直接冒出来说：“什么时候能解决呀？”</pre>
</div>
</div>
<div class="paragraph">
<p>比如说最经典的就是发生在我小伙伴身上的事情，他在一个外企工作，大概是5:30交给他个任务，然后六点就问：“做完没有啊？”这种情况我们一般用智障的眼神看着的leader，刚刚我们才讨论完需求，那么快啊。然后Leader就说：“那辛苦一下你们，今天晚上加个班做完好不好？”然后你心里骂娘都有了，但是一想哎呀，我靠。还是钱香，所以这个时候你就被逼的去996了啊。</p>
</div>
</div>
<div class="sect3">
<h4 id="_起步阶段的会遇见的问题">3.3.9. 起步阶段的会遇见的问题</h4>
<div class="literalblock">
<div class="content">
<pre> `1.程序可以支撑多少并发量的认知`
这种认知是需要时间的教育的，没有时间去真正的承受这种访问，你是不知道的，所以在运营状态里头第一个问题就缺少偏后置的一些阶段，但病发量它是一个很大的概念。</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方：

在京东上买东西需要多少个步骤啊？

1.你首先得打开京东

2.浏览网页浏览商品

3.找到一个想要的商品点的购物车

4.下订单

5.选地址

6.选择送货时间

7.选择支付方式，

8.提交订单

9.去支付。</pre>
</div>
</div>
<div class="paragraph">
<p>可以看到有这么多的过程，那么并发发生在哪一个地方？
下单有下单的并发，访问有访问的并发,这样就存在一个问题，因素太多(软件因素/流通节点)。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`2.流通节点太多`</pre>
</div>
</div>
<div class="paragraph">
<p>流通节点太多就有个致命的问题： <code>知之甚少</code>。</p>
</div>
<div class="paragraph">
<p>如果纯网页浏览的话，Nginx会产生日志，那现在你要想知道 <code>Mybatis到底查了几个东西？</code>  <code>Mybatis哪个地方卡了呀？</code> 你说我在Mysql上打开慢查询就知道了，这样是没问题，但关键是本身就已经是后置了，访问入口在最前面，Mysql在最后面，然后你在最后面那个软件装了个监控器，那中间呢怎么办，当然这样是能解决输入输出的问题，但是后面的数据库不是你能上你就能上的，数据库是一个企业最核心的资产，它不会让随便让你上去弄，一不小心删库怎么办。</p>
</div>
<div class="paragraph">
<p>前段时间抖音一个实习生把那个训练模型给删了，最关键是那个模型还不是试验的还是生产的，更早一点，网易的程序员也不靠谱，把数据库密码传到了网上，而且那个他那个账号密码也是是生产的，不是测试的。</p>
</div>
<div class="paragraph">
<p>所以让不可靠的人进入生产系统过后，会发生一系列安全隐患，根本不可能让不靠谱的人去排查Mysql的慢查询。</p>
</div>
<div class="paragraph">
<p>如果真的让不靠谱的了去排查Mysql，然后他看到Mysql超CPU8%，看起来是Mysql有问题，那他直接先重启下Mysql，结果一重启十个子系统全部宕机，本身就两个子系统宕机，结果一重启Mysql全部系统全宕机，然后在重启期间所有的新发生的请求又一直涌向Mysql卡在那，结果刚刚起来的Mysql还没热身呢，又挂了，CPU堵车的时候是真堵车，不是慢慢堵车，会发生一系列很可怕的事情。</p>
</div>
<div class="paragraph">
<p>起步阶段会存在很多数据流通节点，一旦软件数据流通节点太多，就存在管理问题，这就是起步阶段会遇到的问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_项目后期会遇见的问题">3.3.10. 项目后期会遇见的问题</h4>
<div class="paragraph">
<p>到了后期，主要是对软件进行优化，怎么优化？ <code>提升并发</code>,但是企业并不会主动去提升并发的，因为没有出问题，企业就认为不出问题的机器就是好机器，他也就不会管，所以这个时候企业不主动优化，那就意味的所有优化暴露出来的问题都是Bug，就是 <code>性能方面的Bug</code>,一旦出现性能方面的Bug,一般企业是没有能力解决的，不要说现在云技术那么发达，人才那么多，你放心，他连人都找不到。</p>
</div>
<div class="paragraph">
<p>曾经我有一个同事的一个下属，他们公司以前的项目就是因为性能太差，被政府给踢出来了，他们开发了一个林业的管理系统， 就是森林防火的那种系统，结果三天两头系统打不开，为什么打不开，因为访问的人有点多，有多少呢，大概十个，搞了一年多，搞不定然后甲方终止合作，公司就垮了，后面又花了一天时间，成功支持11个了，老板欢心鼓舞，但关键是到第十个时候还是死机。</p>
</div>
<div class="paragraph">
<p>所以在项目后期还存在个问题：优化性能Bug，这个问题可以很快很好的解决，不过要花很大的代价，比如说程序员告诉老板：“这个2万的服务器不行，我们要买20万的服务器。”那确实优化好了，钱不是问题就能很好的解决，但是我们作为一个高薪行业，要有自己的职业素养，能花2万解决的问题最多花3万，花20万就离谱了，当然不说老板不老板的问题，光从社会效益上来说，程序员是尽量少花钱，大家心里都有一个认知的，就是 <code>在有限的场景下面去解决问题</code>，这样程序员是非常有成就感的，但是并不妨碍这个行业里还是有落后者，那落后者就说：“我只要够富裕，加钱就可以了。”加钱能解决的问题还要你，淘宝如果花510亿能买，你买一个淘宝多好啊，你能买到淘宝吗？你买不到，关键出性能Bug的时候，你可能买了新的服务器可还是一样的慢，这是最离谱的，所以说钱不一定能解决问题，因为你根本就不清楚问题出在哪，可能问题就是电信机房给你现在十兆带宽，你带宽跑满了，有这种可能对吧，所以存在诸多的问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_提出问题技术">3.4. 提出问题(技术)</h3>
<div class="sect3">
<h4 id="_怎样了解模块间的调用关系">3.4.1. 怎样了解模块间的调用关系？</h4>
<div class="paragraph">
<p>并发量是对软件系统整体效率的度量标准。（结果，颗粒度更细）</p>
</div>
<div class="paragraph">
<p>软件数据流通节点太多，管理存在问题。</p>
</div>
<div class="paragraph">
<p>如：用户登录，在登录界面上，用户输入用户名和密码，再点击登录（这个时候都是在人机交互界面发生关系），点完登录过后服务器去查询你的用户名是否存在，用户名如果存在会去判断这个用户预设的密码和你填写的密码是不是相等的，如果相等，提示，返回，返回一个ture，提示登录成功，如果不相等，提示返回密码错误，那就有以下几个节点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>点登录发送了一个POST请求，POST请求到了服务器上面。</p>
</li>
<li>
<p>你的Java代码收到了之后要做协议的解包，解码，然后协议就把用户的帐号跟密码拿出来，拿出来过后要通过数据库去查询这个用户名对应的密码。</p>
</li>
<li>
<p>查询完了之后要进行对比。</p>
</li>
<li>
<p>对比完了之后要输出结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就一个登录放到数据流通节点那里就会发生很多次这种事情，但是最重要的几个点就是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户发送请求。</p>
</li>
<li>
<p>发起请求到最后密码对比结果结束，对比结束之后的结果ture或者false。</p>
</li>
<li>
<p>查询语句</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>发起请求跟结果对比是同一个层次的，查询语句是一个层次，都很重要。</p>
</div>
<div class="paragraph">
<p>（模块间交互）
项目后期优化（被动），性能Bug。</p>
</div>
</div>
<div class="sect3">
<h4 id="_模块内的工作状态是怎样的">3.4.2. 模块内的工作状态是怎样的？</h4>
<div class="paragraph">
<p>如：查Mysql，正常来说，在本机上查询只需要1毫秒，但是上了生产过后一开始是1毫秒然后是5毫秒最后变成4秒，这个秒就需要管控，这是第一个问题，第二个问题：查询这个东西很细，有可能是有很多个查询组合的最终你要想客户端反映一个登录结果，你点了登录，卡了五分钟，那就要对请求响应时间做管控，要记录响应时间，记录响应时间是基于一个点来记录的，要么那个响应时间在nginx内部，你监控nginx日志，他请求和响应是有个日志可以打出来的，还有个方式就是在Controller进来的时候getting start，那么出去的时候end，这个时候就可以有个计时器记录时间，在你代码的开始入口和出口之间写个计时器去监控他，所以可以对响应时间做控制，更精细一点，你可以查每一个查询的返回时间。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解决问题设计">3.5. 解决问题(设计)</h3>
<div class="sect3">
<h4 id="_管控模块间的交互">3.5.1. 管控模块间的交互</h4>

</div>
<div class="sect3">
<h4 id="_模块内的工作时长输入参数输出结果数量等等">3.5.2. 模块内的工作时长（输入参数，输出结果数量等等）</h4>
<div class="paragraph">
<p>如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SQL查询时间</p>
</li>
<li>
<p>HTTP的响应时间</p>
</li>
<li>
<p>调用地图API的时间</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用户：程序员，System admin（系统管理员）</p>
</div>
<div class="paragraph">
<p>使用：通过 yaml包或者pacman装一个软件，先把我们这个软件跑起来，装完了会有一个Web界面，比如说zabbix,这个东西装完了过后会有个网页，网页有CTO的使用率，有内存，还有网络和其他的东西，但是这个解决不了模块间交互的关系，还有一个东西Istio就是Googel给k8s开发的，这个东西是用在k8s领域的，k8s里面有很多模块，那模块内怎么通信，怎么死掉的或者状态怎么样是通过一些监控去监控k8s死没死掉，如果死掉了他会有一个记录，然后你可以自定义一下策略，当他死掉之后做拉起或者重新新建一个镜像让他启动起来，这个样子之后当你的app服务器死掉之后经过几秒钟检测之后再给你启动一个，就又活了，除了这个他还有一些收集信息的能力，还有一类就是定制，给自己开发一个，一般写的时候是根自己有关系，在英文里面，在linux领域我们一般吧调优这种东西叫profile，这个东西很多时候会在代码里面镶嵌很多东西，镶嵌完了过后会把你的调用堆栈，就比如说你调用了有一个进程，进程有依赖了什么东西，他把那个函数的调用关系全部打印出来了，最后就点那个加号减号就行了（点了加号就会把下面都展开，它可能就会有很多调用），这一类就是linux上面有现成的命令，在你运行这个命令的前面先运行profile，运行完了就会生成一个分析文件，那个分析文件里面就会有函数的调用关系，每个函数花了多少时间，我们优化c或者c + + 程序就是这么干的，这种优化已经是从操作系统的调用层面叫System call，这个叫系统调用，就是通过系统内核和你产生交互，然后把你的规则跟数据收集出来，最终你就能看到某个函数在那里转圈圈，一直在调用，每一次占0.1秒，运行了一万次，你是能看出来的，但是有个问题，如果按这种方式首先你的程序必须是c或者c + + 写的，java就不要想了，因为你去看java的话就只能看到jvm的东西，看不到 user层的，因为jvm和系统发生关系，而你和java发生关系，中间隔了一层，所以只有纯静态语言才能调这个，比如说Rust。
这是三种我认知里面的方式，那么第一种zabbix就是通用领域里面收集系统信息， 而且收集信息是很有限的，当然你可以写插件去监控某些特殊的东西。然后第二类Istio他是集中在k8s这个生态里面的，这个非常非常有限，因为我可以完全不用k8s,虽然k8s对你来说这几年有用，但是你咋知道五年过k8s他不过时呢。第三类profile就是太底层了，1w个程序员里面顶多一个人在用这个，我都是高估了这个，所以在成都市，在对面那么多栋大楼里面找到一个都是不大可能的事情，凤毛麟角的，这个也不是因为它没用，而是因为它太底层了,太底层就意味着现在的程序员大多叫Web程序员，他们是搞不清次这个东西的，但是按常理来说，你如果是一个计算机工程师，我认为这种程序调优是必备的技能，但是你如果只是为了吃饭，只是为了生存你肯定不会在意这些东西，虽然我不知道怎么去设计，但是我知道市面上有这么几种东西，我个人觉得我们做的东西可能和第二类Istio差不多， 和第三类profile相比起来，如果你要通过编码去控制他的交互，我个人觉得那样对代码的侵入太大了，我打个比方：</p>
</div>
<div class="paragraph">
<p>某个公司用java开发了一套东西。然后后面发现老宕机，你告诉他你也用我这个东西，在你代码里面加入某些东西就可以怎么样了。但是用户他就不愿意动，为什么？我代码通过了安全审计，好不容易甲方认可上线呢？你这么一改，我要用要跑的用户去发版本，还要经过代码审计一系列复杂的事情，侵入太大了。那这种轻松的话万一你是个病毒呢？万一你又坏心思了，所以这种侵入性太大了，当然他的运行方式是在命令前面加一个东西，但是java，这种你是没有办法通过这种纯调用，所以你必须=侵入代码里面去统计它的函数使用对吧？那就很麻烦了，你这样侵入代码里面统计你为啥不开发个jvm的统计工具，直接统计都完了完事对吧。层次太低了，就和profile一样的，你统计到jvm里面去有几个人搞得懂啊。就是我们有一个广度，就是你的适应性要广，而且侵入还要小，所以看起来纯profile这种方式不行的。所以看起来的话首先总结特点:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>普遍性（适应性）：我们这东西不是很特殊，不能只能用了某一个细分的领域。我们用到应该是感受和程序相关的，至少都能有一些作用。（普遍性第一个是指的人，第二个指的是物）</p>
</li>
<li>
<p>无侵入性：这个无就是少的意思嘛，最好是无，就是更可能少的侵入性。</p>
</li>
<li>
<p>更灵活、扩展性：要适应变化，要能写插件，应该是一个平台，一个数据容器。</p>
</li>
<li>
<p>覆盖关键路径：在关键领域把握要点。</p>
</li>
<li>
<p>性能热点：性能热点就比如一个系统一共花了5秒钟去响应用户的某个动作，在这个动作5秒里面有个查询占了3秒就是性能热点。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上五点是最重要的！</p>
</div>
<div class="paragraph">
<p>因为你的程序卡顿，不管你是走代码还是你去测试也好，你就不能一眼看出问题在那里，就术语盲人摸象，然后这个时候程序员需要一个东西去辅助他解这种问题，不是还有一个大的嘛，就是企业里面，你应该对你系统的运行状态去了解，他应该是先有状态的本身的收集。收集完了过后在某些地方他看到有异常的数据，他应该是这样就发现的，所以最终程序员装了我们的的东西过后，把数据收集上来过后能看到异常，现在就有两个问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>怎么把数据收集上来？</p>
</li>
<li>
<p>收集什么样的数据？</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_整体数据逻辑设计">3.6. 整体数据逻辑设计</h3>
<div class="sect3">
<h4 id="_架构图">3.6.1. 架构图</h4>
<div class="imageblock">
<div class="content">
<img src="images/项目设计.jpg" alt="项目设计">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_怎样收集数据应该收集哪些数据">3.6.2. 怎样收集数据？应该收集哪些数据？</h4>
<div class="paragraph">
<p>在不侵入的情况下哪些数据应该是收集的？我们就先写出数据特征，一项项列出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>传统的东西比如：

CPU

内存

硬盘

UpTime（系统运行时间）</pre>
</div>
</div>
<div class="paragraph">
<p>除了这些以外，还有最重要的一点：网络，网络是很笼统的概念，那就得区分，那网络区分那就有：  <code>HTTP的请求,MySQL、Redis、Kafaka</code>，还有文件IO，但他不属于网络，本来他应该属于常见的硬盘里面，但是那里的硬盘是负责硬盘的大小，所以这个地方应该还有 <code>FileSystem(文件系统)</code>，那么FileSystem里应该有 <code>R/W IO</code>，IOPS应该是属于上面硬盘的，因为IOPS是硬盘里面的，而R/W IO是涉及到 <code>文件读写`的，文件读写和机械是不一样的， `IOPS是机械的限制，R/W IO则是软件层面的限制</code>，因为FileSystem这个地方涉及到NTFS和ext4。</p>
</div>
<div class="paragraph">
<p>那现在假设个场景，假设查询慢，那么有几种方法能够采集到MySQL查询？写一个Mybetis PlusPlus，然后在里面加一个代码，那个代码就是我写的Class，凡是用我的框架，就能自动把那个数据采集上来，那这就是意味着我对代码具有侵入性了，用户必须用我的代码，用户不把我的软件包的代码引入到项目里面，就采集不了MySQL，还有Redis，你也写一个Jdis PlusPlus，那工作量就可大了，然后Kafaka，他是通过用Zookeper请求的。</p>
</div>
<div class="paragraph">
<p>再假设一个场景，用户他不懂任何Linux的操作，那他只需要根据我们的软件，去看每一个SQL的执行效率，然后我们按SQL的响应时长排序，时间越长的排的越靠前，那用户是不是能很快就能查出问题，还有连接池，这样的话用户就能看到同时有多少个连接。</p>
</div>
<div class="paragraph">
<p>那像 `文件读写`呢,Linux内核提供的接口，是可以去读写的，就是监控某个指定的目录，Linux就是这么高级，Windows其实也有，但是是靠技巧去做的，但是在Linux内核就自带了，你可以用info这个命令,带上参数 -w指定Watch模式，加上目录，就能监听目录的读写、删除、修改，比如说木马，他是要创建文件的，我有段时间那个服务器老是被改文件，但是我又不知道什么时候上来的，日志太多，然后就把那个网站目录做成监听模式，只要Create文件，I Know，所以说就去把木马立项到日志文件里面，第二天只要看到有那个文件就翻日志，就可以看到是什么时候创建的，而且还能看到是什么时间访问的。</p>
</div>
<div class="paragraph">
<p>除了这些以外，内存的分配不需要考虑，因为内存一般指大小就可以了，cpu通用时长也不重要，那么一般出问题就是NetWork那一块，因为一般取数据、文件IO一般都是和应用直接挂钩的，那么现在他是延伸一下，提出一个问题：HTTPS怎么办？</p>
</div>
<div class="paragraph">
<p>首先，假设要加密的数据，如果要让我监控的话，就应该在平台上面把MySQL或者Radies配的证书给我，你把你配的证书给我过后我对的，或者我们最开始就不考虑那些问题？要知道我们的软件是有延展性的</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

用户发起了一个高德地图的请求，那在NetWokr这个地方除了常见的以外，可能还要针对TCP连接单独去处理，因为加密的不都是TCP连接，那你就知道项目里是谁发起的连接，哪个连接耗时多久，又等于说这些就是PCB下面应用层，等于说TCP应该是大的层次，而左边一般都是小的，所以整个连接中，你应该是一个连接管理的地方，连接耗时了多久？应该把它列出来，然后HTTPS加密的话，可以把证书配给我，证书配给我的话，你通信过程当中。我就可以解，MySQL也是配证书，Readish好像也是，他们基本上都是差不多的，只要解了一个，剩下都可以，说白了：

“你加了密的我就监控不了吗？”</pre>
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre>再打个比方

用户让我监听某个端口的TCP通信，那肯定得告诉我端口，不可能把所有网卡全部监听一遍，那数量得多大呀？所以这个时候比如用户的8080都出问题了，你应该让我看8080那个没有加密的，不应该让我看Nginx之外的，只要在Nginx后面的就不存在加密的问题，而且大多数MySQL大家都不会用加密的，你本地都要调用，所以很少有人去加密，所以加密问题应该不是最优先的，因为总可以看不加密的，然后还有TCP那个，可以看它连接的时长，你能统计出来的，就是一个连接过来直到连接断开？从端口开始到结束一共花了多长时间你给记下来，然后写个MySQL协议解析器，Redis也要写，HTTP好弄,现成的有很多，然后MySQL也有，所以就看我们把他们怎么结合在一起，但是MySQL个有个问题：不同的版本，协议形式不一样。所以我们可能支持常用的5.7,8.0,那么这就是版本支持问题，那个最老的5.5，你可能想都不想支持，Redis相对比较简单，因为它的协议就简单，然后Kafaka的话，也不难，所以说白了，你做完这些过后，你比那个Kafaka官方的人还了解Kafaka。</pre>
</div>
</div>
<div class="paragraph">
<p>所以我们的工作量应该主要在NetWork那一块，难度和工作量在那块非常集中。所以这个地方很明显就是插件，肯定优先支持HTTP，然后就是文件IO，文件IO有现成的内核模块，直接用，因为这个东西肯定和性能有关系，肯定不会用Python来做，那文件IO这块是调用内核模块，内核模块里面有各种标志。可以用C/C++，如果rust可以的话，尽量用Rust，因为我希望这个项目有后来者参加，用C的话可能没有人维护，所以我们大概清楚要怎么做了。</p>
</div>
<div class="paragraph">
<p>那么这样做的话，首先：</p>
</div>
<div class="paragraph">
<p>1.对人的要求就很低，只需要在网页上配置一下。</p>
</div>
<div class="paragraph">
<p>2.普遍性：都已经做成这个样子了，已经关心网络还有底层的基础设施，那么物体肯定也是适配的。</p>
</div>
<div class="paragraph">
<p>3.无侵入性：我们做的就相当于把你网络流量Copy了一份，这样看起来像把罗番那个科来公司的事情全部重新干了一遍。</p>
</div>
<div class="paragraph">
<p>4.灵活和扩展性：我们因为扩展的是协议嘛，这就是一个模块嘛，一个Mojo，那么就相当于是一个个做扩展。</p>
</div>
<div class="paragraph">
<p>5.关键路径：网卡，性能热点可以通过观察它的时长。</p>
</div>
<div class="paragraph">
<p>当然，如果一个应用，全部东西写在一起，没有前后端分离，你只存在查数据库这种，那你就只和外界查数据库有交互，那这种我们就帮不上了，为什么？因为你所有东西耦合在一起，你都没有模块，我想一下那种我们能覆盖到哪种范围，首先查数据库或者Redis都是可以的，还有我们的客户应该是现代的，不会出现前后端耦合，都是前后端分离，至少分成模块了，还有微服务，差不多覆盖住这一个就行了。</p>
</div>
<div class="paragraph">
<p>那现在回过头来想这个项目有没有意义。</p>
</div>
<div class="paragraph">
<p>因为我们最开始肯定先考虑的项目背景、可行性，虽然之前简单聊了一下，那现在我们要确定一个事情： `“这个事情做下来到底能不能解决客户的问题，或者他的问题值不值得解决？”`如果客户的系统不出问题的时候，通过我们的软件能不能让更有意义一些，比如说用户没有问题的时候用这个东西，他可以看到，每一次SQL要花多长时间，如果时间过长的话就可以针对他进行一个优化，还有比如说软件测试的同事啊，他要去做测试。他虽然看不懂代码，但他可以看有没有发起请求，这是一个对于软件测试的，对程序员来说的话就是刚刚说的MySQL开发、请求，比如说可以排查哪哪会不会出问题，对系统管理员来说呢？那这个地方能不能解决客户要知道有多少并发的问题？那也是可以的，就直接看流量入口进来的数量，然后对于运维，我们可以做插件的话，类似于刚才说百度？？的统计页面，比如说是哪个IP来的、用的什么浏览器、哪个端口、哪个URL，对老板来说，老板肯定是让下面的人去做；对项目经理来说，他从代码层面来说，他是不懂这个项目的，但他看了这个我们的页面之后，他知道哪里可能花的时间很久，从Team leader来说的话，他就可以让程序员的工作量化了，对运营来说，就和老板差不多，运营关心的是指标，他就看那个承载量，这些看起来都是ok的，目的达到了。</p>
</div>
<div class="paragraph">
<p>那现在是采集的类别收集到了。那现在考虑个问题，我采集过后看起来这个地方应该运行个程序，那么这个程序我们一般叫Agent，你可以翻译成代理(客户端代理)，他就运行在每一个用户的操作系统上面的，比如阿里云，他就是在他的机器上装的这个玩意儿，不然他怎么控制你重启的,他可以断电重启，但是用户说我要温柔的重启，他就必须通过Agent控制你的系统,那上面讲的就是Agent，那么肯定这些数据有需要一个接收的服务器。</p>
</div>
<div class="paragraph">
<p>那从Agent到Server肯定是基于tcp的，但是为了让软件更具扩展性，我们应该知道TCP下面有哪种协议？假如我们自己造了套协议在TCP上面，现在要考虑个问题：为什么？要通过协议去造一个通信协议。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

造了个通信协议，让别人去维护，那他肯定不会。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个肯定更加倾向于HTTP+JSON，它们更通用更快，说白了界面酷炫。然后Agent里的东西都看起来现代，所以就有人会去用，哪怕是为了装酷，那我们就会用基于HTTP+JSON的方式来传输数据，但是地方有个问题：传输的速度可能会非常快，想一下嘛，Agent一定会要把协议分析一下，把数据分析出来，再传出去的，运计算量肯定不会放到服务端去计算的，所以你肯定是在每台机器上做边缘计算，所以这个地方肯定丢的是SQL本身，还有他的响应时间，看起来通信协议是靠HTTP+JSON，传输平次就是Agent只要有变化就会去推，比如说Agent里HTTP的包很多，那就会一直产生单独的HTTP的包往外面推，性能不是现在要考虑的问题，这个地方实际上是对性能不敏感，因为服务器你大不了一边100E 次嘛。这也是100E次,实在不行的话，你可以把Agent缓存一会再打包丢吗，你是可以通过策略降频的，你不一定来一个就推一个，可以一分钟推一下嘛，但是要存到内存里面，那么Server既然是接收服务器，它是HTTP的，那这样看起来要接收HTTP，而且要和Agent配合，先讲下一个和数据库发生关系的模块，我们这些数据，它首先量不大等于说存储这边我们用Post，还需要统计就是ELK，用来做简单的统计分析，他启动起来，其实你数据越多也大吧，但是我们Agent已经统计完了，相对来说，它是数量是固定的；所以说暂时就是一个纯持久化存储的，然后一个用ELK，为什么用PSQL？因为它有很多非常非常好的特性，比如说，可以做实时数据，MySQL都不行，因为那个MySQL是学院派开发的，就是那些典型的大学开发的。至于是用对象关系性存储，还是用持续存储，这个看需求，到时大不了把特性打开就可以了，然后ES主要是用来做复杂的分析，判断，排序，那差不多就这些，然后Server接收啊，Store存储，那应该还有个WebServer，那么Web的话肯定就用Spring Boot，前端的话我建议用react，你写。为什么用React？因为它复杂，Vue就是简单，那简单的东西，我们都会，就要玩一会复杂的，因为Vue和React他们在里面都差不多，你会React了，看Vue就一天的时间。</p>
</div>
<div class="paragraph">
<p>从Web—Store—Server—Agent都有各种控制策略，所以分开是可以的。先确定建设设计方案，首先Agent，肯定不能用Java，因为性能太差了，而且内存消耗贼多，我们希望控制住内存，为什么？因为用户的的客户机可能内存只有几百兆，比如说，你要求用户内存至少512MB以上，然后自己就占了人家一半的内存，所以这个地方偏向于Rust或者是C++都可以，这是没问题的。然后Agent和Server之间，是用HTTP出来的，出来过后到Server有些策略控制，那这种策略控制有哪些？</p>
</div>
<div class="paragraph">
<p>补充之前PSQL和ELK中还需要有消息队列RabbitMQ，那首先这个地方消息对列那这个地方的话。因为他是rust，总是为了内存，这个server和他是跑在一起的，那么Server和Web都可以使用Java。</p>
</div>
<div class="paragraph">
<p>现在我们就设计出了就是大致的逻辑，那我们再复述一遍。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>首先这个软件

1.要对人的要求要低，他最好用可视界面，能够做设置、查看，以及对监听目标的适应性更广，比如说只要Linux都可以。

2.无侵入性，我们是通过监听基础设施，然后就实现了无侵入性。

3.灵活扩展性，说白了，基础之外实现的功能都是加工的模块。

4.关键路径覆盖，主要因为都是基础设施，所以已经覆盖了。

5.性能热点，统计状态然后进行了排序，然后如果客户真的要找热点，可以让他去做个设置，就比如说设置个预值，SQL超过三秒就标红。</pre>
</div>
</div>
<div class="paragraph">
<p>现在看来通用领域的监控我们都得有，那么Agent你的NetWork块是有挑战难度的，比如说MySQL，要去写一个协议解析，官方有，但是官方他是有版本支持还要各种裁剪，所以有适配问题，他有各种各样的版本，那我们可能要最低支持5.7,8.0再说,然后Redis相对比较简单一些，然后Kafaka的报文也比较简单；然后文件IO这个地方是比较固定，是内核的东西，几百年都没有变过的。</p>
</div>
<div class="paragraph">
<p>那么技术难度主要就是MySQL，HTTP很多现成的，没什么大难度，把报文拿出来解析个报文，就算手写都把它写出来；那么Agent我们就采用rust或者C + ，要知道，做这个东西要有延展性，C+用户越来越少，越来越贵；Rust虽然也贵啊，但是他相对来说没有那么多糟心的事，也就语法严格，要在safe模式下面去工作。那这样的话如果有新人来维护的时候，那么肯定他维护的是这样的，新增了一个功能点，报上Server，Server内部应该不用大动，为什么？因为你新增功能点应该是加了Compent的结构，那么Server和Web都是Java，所以的话难度应该在Agent下的NetWork，所以对开发者的要求来说，难度会大一些。</p>
</div>
<div class="paragraph">
<p>现在在说大的这样做到底有没有意义？这样会不会是重复造轮子？
现在市场上没有这种东西，因为我们是针对企业的问题来提的，老板或者Leeder他们要的是一个完整的解决方案，他要的不是说我知道某个工具能解决。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_XMSZ2_chapter">4. 项目实战(二)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_4">4.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/项目实战(二)板书.jpg" alt="项目实战(二)板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_4">4.2. 前言</h3>
<div class="paragraph">
<p>上面我们讲到解决方案，我们当时涉及到说有Web界面，上报数据的服务器，Agent客户端，大概是三种，然后Agent客户端的话，当时心想的可能用Rust/C++/C/Python，就是还没有确定，那么Web端或者服务端，因为是Web程序，所以说用Java写是ok的。</p>
</div>
<div class="paragraph">
<p>那今天的话我们就先考虑一个问题：客户端的问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_客户端的问题">4.3. 客户端的问题</h3>
<div class="paragraph">
<p>客户端肯定是用来上报数据的，如果网络托普是这样的话：</p>
</div>
<div class="paragraph">
<p>客户端收集信息，收集完了后通过网络协议报给服务器。</p>
</div>
<div class="paragraph">
<p>那现在我们讨论客户端里面的东西，首先常见的客户端，像Zabbix、Cacti或者是Nagios，他们都有不同的方式，比如：阿里云，大家都用过，但可能没有注意，它客户机里面有个叫Aliyun.service，那个东西就是客户端。</p>
</div>
<div class="paragraph">
<p>那客户端他干了什么？</p>
</div>
<div class="paragraph">
<p>收集cpu、内存，执行重启、关机、睡眠等等操作，除了以外，他还要检测你系统上有没有安全隐患，像那天我尝试把Aliyun.service给删了，马上就在控制台上显示说的“有人试图删除我自己，”请你注意，后面我就奇为什么删不掉，然后我就花了接近半个多小时去分析他具体是怎么防删除的，后面发现它是supersuper管理员，然而你就是一个普通用户，那你就删不掉他的系统，也不能干掉它,这个就很国情，要是放在亚马逊上，你这么做会被别人吐口水淹死了，为什么？ `因为你侵犯了我的隐私。`在国外这一点最重要就是你产品可以不，就算你体验不、使用很难，但我可以学，你写个教程给我学，学完了过后我自己弄，但是请你不能干涉我的系统，而国内是这样的：哎呀，我害怕你出错，害怕你删掉了什么东西，就像防傻瓜一样防，这个应该在以前我讲过国情的问题，像国外的话，他们发明了互联网，所以所有的与计算机相关的，都是外国人发明的，就说英语那帮，那么他们的基础素养是很高的，为什么？因为他们素养低的都在那个大街上当流浪汉的，但是总体来说，只要办公室里面穿着得体的人，他们整个综合素质是非常高的，为什么？人少嘛，可以搞精英教育，如果让他变成14亿人，他来搞他还不指定搞成啥样呢，再加上那会儿从清朝抢走那么多白银黄金，那不发展的更，所以你得承认这个差距。</p>
</div>
<div class="paragraph">
<p>那么典型的客户端，肯定在机器上会有一个程序在运行，首先我们得有 <code>守护进程</code>，那么这个进程其实是从Agent过去的，所以说Agent是出口，那么现在有个问题，Agent是出口，我们采集cpu、内存等等应该怎么做？常见的做法是在这个Agent里面写代码，写一个cpu函数，写一个内存函数，然后再写个网络函数，那我问你个问题：做是可以做，但做完了过后系统扩展性在那？在我们的特性中，有一条非常非常关键的特性就是扩展性，因为你不可能把全世界所有用户的需求都囊括在里面，那么就要借助整个社区给你的反馈。</p>
</div>
<div class="paragraph">
<p>那这个时候你就应该留出编程接口让别人来帮你完善，那这时候你说：“强哥，Web界面他不可能帮你完善”，但是改这个东西并不影响Web，Web界面那边完全可以动态呀，那这样看起来Web一点都不重要，其实重要的是客户端，然后这个时候就涉及到一个问题：我可以用rush的一种语言完成所有的事情，但是为什么不选c呀？因为写c的话，内存管理很麻烦。那为什么用Python？</p>
</div>
<div class="paragraph">
<p>其实每一种语言有它的 <code>优劣势</code>，那这个时候就根据用户需求，他愿意怎么弄他就弄，但是你不要把他 `限制`死，比如说有一次我想去改RabbitMQ的这个东西，我觉得他那个整个机制没有解决我的问题，我不知道是我用错了，还是怎么样，那我就尝试去看Agent的代码，结果拉下来一堆C，想去改东西的话，还没文档，还要自己琢磨，然后就放弃了，之后我自己又花了一个月写了个ZSR，才解决我的问题。因为当时有台服务器老被黑，是用户的服务器，但是我也抓不到是谁，我就写了ZSR，把所有的东西都监控起来，每秒钟把整个系统快照一遍，产生的日志文件一天的话大概有两个G，但是他颗粒度非常细，每秒钟，如果想更快的话也可以，但是没有必要，所以我用编程的方式解决我自己最核心的问题，之后我写完了就放在那，不需要去管了，为什么？对于我来说经常是要用到什么我就写什么，但是这样会有个问题，就是说整个技术栈很散，知道的东西也很散，以后想解决更多的问题的时候，要把它们合在一起就很麻烦。</p>
</div>
<div class="paragraph">
<p>所以这个平台也是作为我个人技能的补充，就把我以前理念全部合在一起，做过的，没做过的都可以用上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩展性">4.4. 扩展性</h3>
<div class="paragraph">
<p>所以在Agent里，首要的是考虑扩展性，性能是才是第二位，为什么说性能是第二位？你连数据都采集不上来，你咋知道性能有问题。</p>
</div>
<div class="paragraph">
<p>举个例子</p>
</div>
<div class="paragraph">
<p>今天吃晚饭的时候还在和跟同事讨论那个南瓜尖，他说那个南瓜尖很吃，我说那个有毛刺，他说没有，很吃，我说是如果在你家里面，去掐的话，你会掐那个很短很嫩的那个芽，但是你咋知道菜市场的大妈，她掐的那么长的，然后买回来吵着碗里，你不咬一口你咋知道他很老？，这个很实际的例子。
所以我自己不喜欢吃是因为我不确定他老不老，就像我每次问我妈，我说：“那个鸡的屁股你洗干净了吗？”然后我妈说：“吸干净了，没得问题”然后一咬下去，呕，这辈子都都不会再碰那个东西，为什么？心理阴影，你不咬一下，你咋知道他洗干净没有？。</p>
</div>
<div class="paragraph">
<p>所以扩展性是第一位，那我东西都没有装上去，跑起来，就是说都没有见过猪跑，怎么去吃猪肉呢？要吃的明明白白？比如猪的后腿肯定吃，为什么？它天天都在的锻炼，所以扩展性尤为重要，因为你要让他先跑起来。</p>
</div>
<div class="paragraph">
<p>那什么是性能？就是你运行起来的时候不能耗太多的CPU、内存，那如果是客户自己写的，CPU和内存消耗的高，那就和我们没关系，但是我们写的对性能是有要求的，所以说如果你搞不定的话，可以让我们帮你定制。</p>
</div>
<div class="paragraph">
<p>那我们先讨论扩展性的问题，你想你要让客户甚至用JS来写，都能收集东西。你想之前说不限制语言嘛？他用任何语言都可以把这个数据报上去，但是扩展性里还有个隐藏条件，就是要简单，就是我们整个系统能够做的事情，你不能让用户去做，那要做的扩展性，先画个拓扑:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/扩展性拓扑.jpg" alt="扩展性拓扑">
</div>
</div>
<div class="paragraph">
<p>比如说这个是一个cpu的程序啊，这个cpu的程序是用Pyhone写的。还有有个负责内存的，用Shell写的，最后还有一个报文件IO的东西，用Java写的。那这三种他最终应该有统一的行为，那么他们一定会和某个模块发生关系。然后这个模块发生关系过后统一行为再抛出去，但这个时候都还没有脱离本机，还是在自己本机上面，还没有通过网线再出去，所以中间的模块他的职责是什么？Agentd职责又是什么？那Agentd肯定是整个系统的核心，为什么？因为他的任务很重要，为什么前面那么多东西过来过后对于他来说，他要整理、调度，然后再发出去，所以这个时候对于他来说有很多任务啊，但是中间的模块是什么？这个叫动态客户端模块支持，简称DAMS，这个灵感来源是来自内核里面一个概念，叫DKMS，他们两之间A和K他们两个的行为都差不多。那么DAMS的作用是什么？他提供统一的行为接口，这个是编程的编程关系哈，是在模块代码层面，模块之间的关系，并不是运行时的关系。</p>
</div>
</div>
<div class="sect2">
<h3 id="_主程序怎么运行的">4.5. 主程序怎么运行的？</h3>
<div class="paragraph">
<p>举个例子</p>
</div>
<div class="paragraph">
<p>假如有一个cpu模块，首先，你开机肯定要先跑Agentd，因为他是入口，那么在跑他的时候，他会去读配置文件，那么我就把那个运行的时候，整个启动的过程写下来。</p>
</div>
<div class="paragraph">
<p>1.启动Agentd</p>
</div>
<div class="paragraph">
<p>2.检查目录Conf.d下面的配置文件</p>
</div>
<div class="paragraph">
<p>比如说Conf.d下面很多个*.ini配置文件。那么他会去扫描所有的配置文件当他扫描过后，他会把配置文件加载进去。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`那么ini配置文件里应该有什么?`</pre>
</div>
</div>
<div class="paragraph">
<p>首先里面应该有模块的名字，然后他有一个exec可执行程序，这个地方你可以写成什么，比如说top命令，就应该是exec=/sbin/top，就是命令的路径，然后在下面写个type，那么type是什么？就等于每一次运行几次？比如说运行一次，就叫oneshot。那么这就是配置文件里面的东西。</p>
</div>
<div class="paragraph">
<p>3.dans -m cpu start</p>
</div>
<div class="paragraph">
<p>那么他读了配置文件过后，就要在内部就要dans -m cpu start ，因为它在加载的时候，要启动一个线程，启动线程过后，那么这个c我后面就用cpu代替这个模块那第四个。cpu这个模块，他在启动的时候，他要执行top下命令。</p>
</div>
<div class="paragraph">
<p>4.resect</p>
</div>
<div class="paragraph">
<p>就像像你调用mkdir一样，会返回结果，所以他在启动的时候，执行完了会把比如说那个东西叫result(结果)，</p>
</div>
<div class="paragraph">
<p>5.Agentd&#8212;&#8203;JSON A&#8212;&#8203;JSON B&#8212;&#8203;Server</p>
</div>
<div class="paragraph">
<p>然后会把这个结果通过HTTP/JSON上报给DAMS，比如说他的端口是8080，那报给他过后，这个地方是JSON A，那上报给Agentd后应该去做一些整理，那么他把那个JSON A转成JSON B发给Server。</p>
</div>
<hr>
<div class="paragraph">
<p>这个时候，因为我们有几个模块，这地方有三个例子，那么这个动作会发生几次？三次，等于说他就是个循环，那第三点就很重要，如果有几个模块的就应该起几个线层，每一个线程去运行每个模块的命令，比如说第一个运行的是CPU和top命令，第二个可以用free命令看内存，然后再用某个命令去IO，那么看完了都有返回结果，那返回结果经过程序，因为程序是给他自己处理的。</p>
</div>
<div class="paragraph">
<p>可以自己通过命令把比如说CPU的数据，就只要那个90%筛出来，我们先忽略掉一部分细节啊，逻辑的话就是，在你开机的时候，首先被拉起来的是你的agent这个主程序，主程序启动的时候，它就扫描某一个模块文件夹下面所有的模块配置文件，等于说模块不是写死的，不是代码里面写死的是什么？，所有的都是这么做的，比如说你用PHP加模块，也是这样加的。那这样的话就相当于是说比如说有三个模块，那这个第二步就应该起三个线程，每一个线程和线之间是没有关系的，但是线程和主程序之间是通过HTTP通信的，这就解决了资源的问题，编程的难度陡然降低，为什么？无非就是请求个网址，这个网址是自己的还是别人的，无所谓，启动主程序的时候启动个8080端口，然后程序报给8080过后8080再去请求他的网址，把最终结果丢给Server，但是如果难度太高，就导致了没有人愿意用，维护成本太高了，所以这个Agentd有个职责，他叫代理，叫Broker，你大家看英文的框架的时候，你经常遇到这个东西。比如消息队列里头，经常你看到，翻译成砖块，他其实和persis代理还是有本质的区别的吧，代理一般是指很复杂的东西。比如说你说Nginx就是个反带，他是一个完整的代理，但是这个地方，你不能把它叫代理，为什么？他既不是反向代理，也不是正向代理，他就是简单的把东西封装一下，朝外面丢，那为什么要这个东西，而不直接把数据丢给Server？因为，现在有几个连接呀？有三个连接，那都连到Server上去，那我一台机器上面就也不止三个模块吧，那么通过这种汇总的行为，来降低服务器的连接数，让总体性能更好一些。</p>
</div>
<div class="paragraph">
<p>因为你最终从DAMS出来的时候，是模块自己的信息。但Agentd，应该告诉他是哪台机器的，是那个IP地址的。</p>
</div>
<div class="paragraph">
<p>现在问题来了，如果你打的标准输出或者文件日志里的，请问你打的时候，你怎么能够及时的通知Agentd去处理？因为你如果用标准输出打到屏幕上或者日上都差不多的，文件IO你异步处理是有问题的，为什么?因为你写了过后，那服务器咋知道有新东西了，所以这样的话就必须两边同时打开，就相当于说Agentd要打开那个日志文件，就只读嘛。DAMS是又写又读嘛，然后两边就一直都有个关系了，那这就意味着两边状态要同步，如果我不小心把文件删了，Agent就要重新打开，这样你还要管理，很麻烦，所以你设计的时候考虑的问题就是用起来方便。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩充">4.6. 扩充</h3>
<div class="paragraph">
<p>然后现在开始做扩充，刚刚有些细节省掉了啊，从8080端口开始，那这个地方看起来是要启动Web server，webserver启动了过后，那么就应该运行在他的一个线程，当然你也可以运行在进程里头，但是我们是假设哈。不过进程太多也可以，比如说他一个子进程专门用来处理Web请求，处理完了过后顺手丢出去。假设有一个主进程和一个Web的进程，然后在启动的时候，拿个进程专门取Web端口，另外一个继续做下面的事情，因为下面的才是主流程，Web端口是有消息发上来才会被触发，叫事件驱动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>事件驱动：等着别人来请求我的时候，我才返给你，就比如说支付宝的服务器也没莫名其妙给我发余额呀，那么就证明他也是被动的，为什么？要有存款的行为才有余额的变动呀，如果某一天突然打钱进来了，一定是幻觉，就像某个银行账号，突然存款一个亿，你敢用吗？你不敢动啊，因为你如果今天用了1000万，第二天就被抓了贪污国家公款罪，为什么？钱也不是你打你就开始用了。</pre>
</div>
</div>
<div class="paragraph">
<p>所以整体来说，首先你要起个子进程，放在那，然后你的主进程就一直接往下走，就开始去扫描配置目录里面的那个模块配置，模块不止一个，所以你应该用一个命令去扫描那个目录下所有匹配规则的名字，然后用列表列出来，列出来了过后你就应该有个清单，然后挨个读，先读它的名字，读了名字过后，应该有个class或者列表把名字保存，然后就是对象的执行执行路径，还有一个是执行的类型，这三个凑成的一个子对象。然后再把对象放在对象列表里面就存下来了嘛。我们之前讲的程序等于算法加数据结构。这地方就在讲数据结构，还没涉及到算法的地方，为什么？那时候他还在加载，就像从MySQL读东西读完了，准备好了，必要的条件数据都有了，这样算法才能运行起来，为什么？算法是需要输入参数的，比如说人工智能的推荐算法，推荐算法是不是有输入嘛，再比如说用户说100块钱到200块钱以内，男性用品，然后这个时候算法有输入，算法才能运行，所以现在还在为算法准备东西 ，最后得到一个对象列表，过后你是不是该写个for循环，挨个把列表里面的对象读出来，怎么读啊？object取出来，object.name放到第3步的CPU那个位置上，至于是这样执行还是在函数里面直接调函数，无所谓，所以应该是这样的，简单一点，你应该调object.exec直接启动，那如果有三个模块的话就写三个，而且启动的时候你要先把他传给一个线程，让他在线程里面去跑，不管那个东西是执行一次还是一直执行不退出来，都用一样的逻辑处理，为什么不用进程？哇，你机器20个接口。你的20个进程，那就太拥堵了，因为进程的消耗很大，进程是要分配内存的，分配各种各样继承出来的内存，就很麻烦，而线程是操作系统调度的最小单位，在面试的时候，很可能有些人会问这个问题，但是你不用担心，一般人不会问你，为什么？因为他也不懂，所以进程是操作系统分配资源的最小单位，内存，cpu，怎么打开文件就是这种东西。</p>
</div>
<div class="paragraph">
<p>线程是依附于进程的，但是线程又可以跑东西，所以线程是跑东西的最小单位，没毛病。所以你用线程跑就是为了节约资源，就是为了省内存，把内存省掉的一点，能抠一点是一点，就这么抠出来的，不像那个微软，你的电脑一共才8G的内存，结果他一次性给你用完了6G，剩下两个g自由发挥,以前Windows Xp 512内存用的好好的，突然来个Vista要求1.5G的内存，装上开个机啥都不干他就自己卡死了，微软和Intel总会想方设法用各种Flash东西给你塞满，但是作为优秀的开发者来讲，我们不要去干那个事情，所以在设计的时候要考虑各种各样的细节，所以那这个地方肯定是用线程。至于线程，我是单纯用一个命令启动，还是用个模块，都一样的。</p>
</div>
<div class="paragraph">
<p>所以第三点是一个线程，那么他可能调函数或者命令，然后把线程跑起来，你现在不要关心他。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

这个线程运行的是top命令，那么运行的过后，他会马上返东西出来，那这个县城里头，那么肯定不仅是一个简单的线程，那线程里面应该包装了这模块里面的一些行为。刚刚波波说的嘛，有SaaS服务，但你不可能让用户去写，比如说CPU模块到DAMS是有行为的，打个比方，整个主程序执行完了的结果是一个屏幕上的整个东西，你要把这个东西塞在JSON里面然后丢给服务器吗？所以你在写cpu这个模块的时候，里面应该预备一些函数，把那个数据得到过后，用预备的一些函数，把它清理一遍，然后往Agent丢，但朝这丢的时候一定是标准接口，就是你清理完后的东西，通过标准的这个接口又出去，这个接口是我们自己预备的。用户只需要解决那个选数据的问题，所以这个程序不是一个简单的命令，第二步里应该是用户自己写的。
这个程序里头，他要负责处理获取数据的数据的清洗，清洗完了过后，把清洗完的东西打到标准输出上面，打到屏幕上面，然后线程把屏幕的东西捕获了，再通过标准的HTTP接口封装成JSON，接着丢出去，所以用户只需要处理配置文件的逻辑，但是有个前提，你打出来的标准输出或者你的这种格式，必须统一，为什么？因为我是统一的，所以我去拿东西的时候，一定也是统一的，所以这个地方是是统一的接口。用户的程序里面就应该去处理这些逻辑，这个地方虽然例子是一个拓扑，但是你要自己写一个Shell把拓扑给处理掉。</pre>
</div>
</div>
<div class="paragraph">
<p>所以等一会我们就把这个黑板上擦掉，重新去写个例子去完善它，这个里面有统一的逻辑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

比如说写个插件，那个ZSR我里面写用C写了个插件系统，就是插件或者是模块，你要注册，模块你要注册，你还要注销，就相当加载和卸载吗，除这个以外，模块输出至少有三个接口，首先你应该又有加载，慢慢加载完了过后你应该有获取，这个获取里面应该包括命令拓扑的结果，拿到结果过后再做一些简单的筛选，所以说数据的获取1就是输出的东西，应该是处理完的，然后处理完后，应该还有一个output的东西，为什么？他应该输出到屏幕上，应该告诉对高统一的格式告诉DAMS我是哪个模块，要把名称、采集时间、命令输出结果放上去，然后把这几个结果转成JSON，往上一报ok，所以DASM就是刚刚说的统一格式，Agentd就是他封装完的HTTP  JSON包，然后丢出去，这样的话，对于用户来说，如果有想开发自己的扩展的话，你只需要加一个配置文件，然后在配置文件中的exec下写一句Shell或者一个简单的程序，只要那个格式是我们统一的格式，我们就能处理。那这样的话基本常用的语言都可以实现，扩散性就ok了。然后性能的问题，客户自己写的程序的性能问题又和我们没有关系。</pre>
</div>
</div>
<div class="paragraph">
<p>整个设计里没有进程和线程的关系，他们只有一个启动就完了，那这样的话，就形成一个完整的闭环，而不用关心各种细节的问题，关系太多很容易把这个开发难度给提升提升，提升完就不友好了，所以应该把更多的精力放在优秀的设计上面。而不是放在技术的细节上，为什么？因为技术是挣不了钱的，比如说知乎上经常有个问题：大公司怎么保护他代码的。
是这样的，微软美国公司，他把他的Windows 10的原代码给了中国政府。那中国政府搞了个Windows 10出来吗？为什么？他要让中国政府相信他，Windows 10里面没有放木马，让政府办公可以信任他？所以这个是原代码，它不值钱，为什么？政府买他单给他单子，单子才值钱，原代码啥都不是，比如说华为交换机的原代码，欧盟有，英国有，美国也有，因为华为任正非早就给他们，让他们随便审核，找出问题算我输，然后美国说，不是这个样子的，我不是想看你代码，我是想加点进去，任正非又说不敢干，那不然美国怎么监控全世界嘛，这个话不能公开场合说白了，说白了就没意思了，只要智商正常都能看懂，所以整个主程序的设计逻辑，你要解决是什么？要解决是优秀的设计，优秀的框架，不要在意太多技术细节，因为技术细节处处都是陷阱，你想嘛？你到处都用Socket或者C，我没说这个东西不能写，但是他会让别人望而却步，就没有人愿意参与你的项目了，所以这个时候你要考虑的是什么，通过这种扩展性和优秀的设计解决生态问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方
今天你你能干，你拿到1万的薪水做这个事情，那明天比如说有个5000的小伙子，他敢不敢动？他不敢动，为什么？因为难度摆在那，但是他用Python是这样的，我一般让别人写Python，我才不提前一个星期了，你今天下午用拍上把这个写一下。有啥难度吗？没有难度，因为你只要是从事这个行业的，你多多少少都会写一点，除非你是文职，你凡是技术岗的都没有问题，甚至我之前讲过，上家公司的一个人，我让他用Python，他死活不用，后面我强行让他们用，三天给我写出了个花里胡哨的Python还写成了Java，反正我是没看懂，就真的写了三天，三天过后，他的代码我已经看不懂了，为什么？各种封装？Java有注解Python也有了，然后他那个函数，他说：打日志的时候不方便，用注解来打日志，然后把整个代码传给那个注解。注解里头123封装，反正一出问题一调试，结果到处乱跳，也不知道跳哪去了，用Python的目的是因为它简单快吗，结果里写成了Java，那为什么你直接用Java呢？</pre>
</div>
</div>
<div class="paragraph">
<p>顺着刚才讲，那么你写for循环，你循环完了过后起n个线程，线程把数据采集完了，过后，输出一个标准的123名称、采集时间、输出结果，然后把它弄在一起丢出去，就从模块丢到DASM，DASM是认识的，如果不认识那么就是你的格式不对，然后用HTTP封装一下包成JSON，往外面丢就ok了，至少数据传上去了。</p>
</div>
<div class="paragraph">
<p>现在还有个很复杂的问题：就是配置文件中的One Shot，这个命令现在显示的是执行一次，但是有的东西你是不能间断的，我打个比方，监听HTTP的包。总不能间隔采集，只要断一秒钟，下次来的时候，前面数据都丢掉了，所以像这种监听HTTP的或采集cpu的这两个东西很特别。因为采cpu，一旦你停下来你再采集的时候，每次采的第一次，他永远都是0。因为CPU的使用率是靠占用时间来算的，所以时间有个起点，那这样的话就面临的就是像cpu、HTT这种的采集程序，用HTTP举例，你不能停掉，得一直运行的。所以在配置文件里就有一个问题，你的输出会源源不断的往外面丢了，如果用刚才把数据都合并在一起的那种方式，是不是有问题？消息发不出来，因为他永远堵在那儿了，源源不断的就变成了那个阻塞，就像堵车一样，你前面的没有过红绿灯，后面的全部排在那排着队的。就导致了越发越多，越压越多，后面那个内存就爆炸了，所以这个地方你要考虑个问题：像HTTP那种，刚刚说模块和DAMS之间用打在屏幕上的方式，但屏幕是不能异步的，就算能异步，你也是用函数来实现的，但这样难度就太大了，所以真正在去做设计的时候。真正在去做设计的时候，各个模块和DAMS是一个整块，比如说cpu是cpu的、内存是内存的、IO是IO的。所以这这两个不是单独的两个模块，他们是一体的，是DAMS去调的，那么他要去调用那些东西该怎么掉？所以他应该有个自己的策略，比如说他发现这个地方如果是OneShot的，他就只调用一次，有东西过后，他就把那个程序stop了，当然你可以在配置文件里加个间隔多少秒再调用，那这样就比如监控内存，每一分钟采集一次，这样的话，你有几种实现方式？</p>
</div>
<div class="paragraph">
<p>第一种：到1分钟的时候，启动一下，采集完了，STOP。</p>
</div>
<div class="paragraph">
<p>第二种：启动过后永远不退出。</p>
</div>
<div class="paragraph">
<p>但是第二种就有个问题了，你等那一分钟，你要让用户自己去写空白，刚刚才推了东西，然后应该等59秒，空白空白空白空白空白。所以用户的程序应该不考虑这个问题。那么调度的事情啊，应该让DAMS来做，采数据，用户说了算。</p>
</div>
<div class="paragraph">
<p>那么刚刚说这个内存就应该是这样的：</p>
</div>
<div class="paragraph">
<p>启动第一次，运行一下，程序就会有输出，当你拿到想要的过后，计数器设为1，这个时候就退出，退出完了过后，他那个线程肯定是不会退出的，他就Sleep 60秒，那线程会一直放在那儿，所以这个地方，他相当于说Sleep 60秒，60秒后下次再来，但是线程是不会退出去的，因为什么？因为他OneShot下面还有一个配置，就是间隔时间60秒嘛，这是一种方式，还有一种方式，就像HTTP那种，不能间隔，你必须一直采，那一直采就一直朝外面报，那现在怎么解决输出的问题啊？当然你输出到DAMS那肯定是JSON，当然有点抽象哈，不懂我们就解释到懂为止。</p>
</div>
</div>
<div class="sect2">
<h3 id="_新的问题">4.7. 新的问题</h3>
<div class="paragraph">
<p>那么在配置文件中Type里HTTP这种东西怎么去采？采了过后，你又不能阻塞，因为只有一个线程，说白了你采完了报给谁？然后怎么怎么样，首先才肯定是用户自己写的程序采集，那要怎么解决gdp的问题、采集的问题。
首先分析一下采集HTTP的时候你要怎么用？</p>
</div>
<div class="paragraph">
<p>那个东西一定一直卡在那儿的，因为他不退出来，所以采集到的时候就一直卡在那，当然我们不讨论用户程序里头怎么写的，我不关心他。我们就只做什么，这边是用户的，这边是给我们的，我们就只知道他会每秒钟输出一条数据，然后这个数据你要怎么去搜？他每秒钟打一条，比如说你，你们两个，都不能断开，就等于说是这样的。你接收到一条数据，数据你收到过后马上处理，处理完了过后就应该到后面的逻辑，这个时候你处理完了，你应该又处于一个什么？他们之间数据给出来到这个地方，要怎么去处理？我不限制方式，头脑风暴，HTTP它每一秒钟那个程序每一秒钟就像will shock一样，每一秒钟朝指定的地方丢一条数据，我们不讨论之前的，你就相当于说你那个软件上头一直在新增东西对吧？新增一行一行一行，你说你每次处理的是新增的那一行，老的你肯定是不管的，那新的那一行怎么处理？</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_HTTP_chapter">5. HTTP协议</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_5">5.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/HTTP协议板书1.jpg" alt="HTTP协议板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP协议板书2.jpg" alt="HTTP协议板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是http">5.2. 什么是HTTP？</h3>
<div class="paragraph">
<p>HTTP：超文本传输协议</p>
</div>
<div class="paragraph">
<p>H：Hyper（超）</p>
</div>
<div class="paragraph">
<p>T：Text（文本）</p>
</div>
<div class="paragraph">
<p>T：Transfer （传输）</p>
</div>
<div class="paragraph">
<p>P：Protocol（协议）</p>
</div>
<div class="paragraph">
<p>之所以讲HTTP是因为所有人天天都会和他打交道，浏览器，app。甚至你的支付宝，他很多地方都用到这个东西。当然你刷抖音也很有可能为什么他的视频分段嘛， 像哔哩哔哩我之前上课的时候直播，我就把哔哩哔哩爬出来了，他出来发现他的URL都是什么HTTP打头的 ，而且他可能一个十分钟的视频，他分成了四段。</p>
</div>
<div class="sect3">
<h4 id="_协议_2">5.2.1. 协议</h4>
<div class="paragraph">
<p>网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</p>
</div>
</div>
<div class="sect3">
<h4 id="_文本">5.2.2. 文本</h4>
<div class="paragraph">
<p>很多文字组成在一起的就叫文本。</p>
</div>
<div class="paragraph">
<p>写一个超过文本的文本：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/文本.png" alt="文本">
</div>
</div>
<div class="paragraph">
<p>&lt;h1&gt;是经过渲染之后的文本</p>
</div>
<div class="paragraph">
<p>&lt;p&gt;就是文本哦</p>
</div>
<div class="paragraph">
<p>这个地方你可以看出区别，这个两个大小一样，他其实就是把一个文字打印到了屏幕和浏览器上面，没有做任何的改变，那这个地方我加了个h1过后就表示是标题1,就是你的word里头那个标题12345还有这个字体就越来越大，1最大嘛，2小3更小，然后正文是最小的。</p>
</div>
<div class="paragraph">
<p>所以这个地方指的超文本是靠这种东西这种东西来渲染的，用英文来讲的话叫tag,叫标记，英文来讲叫tag，那么tag翻译成中文就是标记，也经常有有人把这个东西叫什么标记语言，所以我们经常会把这个这种语法称作HTML ，HTML你就理解为这个协议里面的文字，HTTP是存在的协议嘛，你协议里面要有一种表现协议数据的形式。0101是计算机的表示，然后比如说我说话，说普通话，说汉字是我的表示，是我们两个能够理解普通话的，这个字典里面的表示 ，汉字是表示的 ，比如说你是英国人，你说英语，然后你写英文的文字，这个时候你的表现形式就是那个英文，那这个时候你既然说的是HTTP语言，那HTTP语言就应该有一个自己的文字和语言，那这样的话就是HTML。</p>
</div>
<div class="paragraph">
<p>HTTP=语言</p>
</div>
<div class="paragraph">
<p>HTML=HTTP的文字</p>
</div>
<div class="paragraph">
<p>H：Hyper（超）</p>
</div>
<div class="paragraph">
<p>T：Text （文本）</p>
</div>
<div class="paragraph">
<p>M：Markup （标记）</p>
</div>
<div class="paragraph">
<p>L：Language（语言）</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_为什么用http">5.3. 为什么用HTTP？</h3>
<div class="ulist">
<ul>
<li>
<p>简单好用：HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。</p>
</li>
<li>
<p>可扩展的：在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。</p>
</li>
<li>
<p>无状态，有会话的：HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p>
</div>
<div class="paragraph">
<p>使用场景：app、网页、物联网</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>摩拜单车要将他的位置报上服务器，就是用没有界面的HTTP；电梯里面的广告机在服务器上下发广告的时候也用的HTTP；投一块钱或者扫码拍照的，拍完数据传输也是HTTP。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么使用http">5.4. 怎么使用HTTP？</h3>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>你用一个裸的python，你怎么使用http协议传东西啊？你最开始应该是准备一个什么？你要写个库，那个库能够正常的封包解包http协议。有了这个作为基础，你才能在封装更上层的class。</p>
</div>
<div class="paragraph">
<p>java本身它和http是有关系的，java语言他自带了一套去访问网页的一套库啊或者一些基础功能，或者叫内置功能啊，它里面有servlet，这个东西是干了个啥？那么这个地方servlet，他是做了一个封包解包，他在构造请求和解析请求，解析什么请求，现在看要是手写一个报文:</p>
</div>
<div class="paragraph">
<p>请求报文：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/请求报文.png" alt="请求报文">
</div>
</div>
<div class="paragraph">
<p>响应报文：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/响应报文.png" alt="响应报文">
</div>
</div>
<div class="paragraph">
<p>这个报文很简单，servlet干了个什么事情啊？servlet他收到数据的时候，收到的是Accept，他判断这个里头那些东西，他把他单独的拎出来，他封装了一堆class，就叫HTTP Request，
HTTP Request它会产生这个对象哈。然后这个时候，因为你是程序员，你要控制他你要回答，你要回答的话，你又需要构造HTTP Response对象，所以我现在我就决定他的对象那个中间的，Body等于body，标题等于title，最后，他就会构造上面一堆，他构造这一堆过后就把它丢给访问者，就相当说你在浏览器里面敲qq.com，浏览器会生成这个报文，什么叫报文呢？就是上面这堆东西就是给也程序看的数据，在网络上流淌的数据可以叫报文，所以这个时候，针对网络请求，我们一般都会说叫报文，上面这两个东西都叫报文，第一个叫请求报文，第二个个叫响应报文，所以请求报文是什么？是浏览器帮你构造的，那这个地方是浏览器帮你构造的，他发给了java，java在调他的servlet，servlet收到这个报文过后，把它转换成request这个对象，小写就是对象的，那么这个上面是java帮你转的，然后这个地方是程序员转的。程序员自己收到这个东西过后他要做什么处理哈？我就写到伪代码：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/伪代码.png" alt="伪代码">
</div>
</div>
<div class="paragraph">
<p>我打个比方我有个函数，这个函数的返回值是一个Response的对象，然后函数名字比如说我就叫doGet（），函数名字叫doGet就调用get，意思就是说get的时候调这个函数吗？至于怎么跑到这来的，你就先不要去管他，然后这个地方我写一段代码，HTTP Request这个东西就是servlet处理好的，他已经帮你生成了，就是把那个报文转成了Request对象，然后现在你就调一下，我就假设那边传了参数进来的，比如说这个时候我假设有个参数叫名称，那就是我就假设有个叫getName的方法，有这个方法过后，那么这个时候我就怎么样啊？我就构造一个对象 ，比如说直接reture，我就直接传类，反正最终能够返回这个对象就可以了，HTTP Ｒesponse（name）就是返回值嘛，所以你看到没有这个request的是java帮你生成好的，但是response要你自己调，要你自己初始化，最后你初始化完了过后就会得到响应报文，浏览器就会收到响应报文，最终这个response会回到user这个的地方，就通过http。
通过http七协议最终传给chrome吗？ 然后库中最后中间看那个网页上所以这个地方他怎么发生关系的？哈这个东西叫解码器decoder，当然解码器的话就是decoder，然后这个东西叫encoder，编码器。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Linux-systemsprogramming1_chapter">6. Linux系统编程(一、二)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_6">6.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程板书1.jpg" alt="Linux系统编程板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linux系统编程是什么">6.2. Linux系统编程是什么？</h3>
<div class="paragraph">
<p>Linux系统编程。系统编程是什么？分词嘛，以前比如说你有Java的编程经验或者有前端的编程经验，那你是在哪编程的，你那叫Web编程，是在HTTP协议上面给浏览器写网页，所以那个经常叫Web程序员，那Web程序员做的事情就是Web编程，那系统程序员就是系统编程，所以这个地方要分开来讲，首先，什么是编程？我就肯定不讲了，那么系统编程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what">6.3. What?</h3>
<div class="paragraph">
<p>老规矩：首先是What？这个地方应该有两个概念，把系统编程拆开，拆开后得了两个东西，第一个是 <code>系统</code>，第二个是 <code>编程</code>，当然这个地方的系统指的就是Linux，那肯定首先如果从范围上来讲的话，编程范围最大，任何东西都可以编程，系统编程是在缩小他的范围，就局限在特定的系统，比如windows，Linux、Unix，那Linux系统肯定就是在限定系统编程的范围，在一步步缩小，那么</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`Linux&lt;系统&lt;编程`</pre>
</div>
</div>
<div class="paragraph">
<p>从范围上是这样的，那就很简单了，编程我们不讲，那系统就是Linux，所以这个地方实际上说的就是在Linux系统上面编程。比如说，以前一个人虽然写 浏览器，Web程序，也是在Linux上面编程，但是那问了一个非常非常简单的区别。你去写HTTP的GET、POST，查了各种数据库，请问一个问题：你关心你是在什么系统上面吗？你想一下你关心吗？你用java加spring boot加MySQL。那他在Windows之下可不可以跑？在Linux下面也是可以跑的，所以就算你是用c++写的，它的区别也是非常非常小，为什么？因为你的编程语言跟你的操作系统之间，你没有让他们之间发生交互。比如说JVM我肯定知道自己在Linux下头，但是和你没关系，你是编程语言的用户，你没有和操作系统发生关系，你没有让你的Java代码去干点啥，所以这个时候就算你写十年的Java，你也成不了系统开发工程师，因为系统开发工程师要求的是：对操作系统非常熟悉。要求的难度直线上升，比如现在市面上有些岗位叫算法工程师，其实啥都不是，就是打杂的，为什么？各种各样的逻辑嘛？他不就高效嘛，他去理逻辑嘛，就是涉及到各个方方面面，那么系统工程师是非常老派的叫法，但老派不意味着落后，这是非常典型的叫法，他是按使用场景来分的。比如Web开发工程师是开发Web相关的，那么系统开发工程是开发系统相关的，现在出现的算法工程师或者全栈，他的意思就是说你是样样通样样温，你说那个算法工程要求很高的，是，他只是对学历要求很高，那他造过自己的一个框架？他没有，他只有用他有限的数学知识，然后去怎么怎么样，但是他绝无可能从头自己搭一套东西，为什么？算法工程师不是干那个事的。算法工程师是在已经有的数据上面去做一些逻辑的处理，让这个逻辑处理更快，更简单，去简化企业里面产品的一些地方，这才是算法工程师应该去做的事情，比如说有个岗位叫数据推荐算法工程师，干啥的嘛？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方
你刚刚在外面说话的时候你说我要买个录音机，结果打开知乎推荐第一个就是录音机，他们就是干那个的。</pre>
</div>
</div>
<div class="paragraph">
<p>所以以前我们的程序员或者我们开发的东西是根据它的使用场景来定义的，但随着现在的岗位越来越多，除了传统的岗位以外，还有很多新兴的岗位，它就是混合概念的，那这个地方说的系统编程是非常非常基础的，你都不能成为一个系统开发工程师，你成为不了一个优秀的全栈，因为一个优秀的全栈离不开系统，所以说这个是基础当中的基础，只有你成为一个合格的系统工程师，你才有可能成为一个优秀的Web开发工程师，你觉得这个没有关系啊，以后你会慢慢理解到的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你写的Java那个Spring Boot出问题了，前后端跨域嘛，反正你说我配了的，照着CSDN上面配了的，配完了后，你要知道生没生效，然后打开浏览器测一下，就是因为浏览器打开有问题，我才问你生没生效，对不对？你看这个时候，你就忙着摸下，就全靠瞎猜，但是如果你是一个优秀的系统工程师，你会怎么样？你会首当其冲：抓包，抓包看报文，请求报文一看，跨域头发过来了，但是你反东西的时候不对，你的响应报文有问题，或者是说不抓包，我浏览器F12也是抓包嘛，也能看到报文。</pre>
</div>
</div>
<div class="paragraph">
<p>所以它很重要，它很基础，我讲过的警惕一件事情：用技术论高地，键盘大侠就是这么来的，就是你虽然可能主修Java？但这是现在主修Java，等两年你咋知道你主修啥？你根本不清楚，等两年你主修收钱那就更好了，所以不要用技术论高低，他只是你当前所处的阶段，这个东西和你的阶段匹配，仅此而已。比如说：给你6000块钱用C++，给你8000块钱用Java，给你2万的时候对不起了，除了Java，你还得干点其他的，这个时候你的重心已经开始偏移了，发生了变化。</p>
</div>
<div class="paragraph">
<p>刚刚主要讲的是系统编程啊，在Linux上面编程啊，笼统的讲就是在某种平台上编程，比如说在手机上编程，我叫安卓程序员，我在iphone上编程，我就叫IOS开发工程师，我在单片机就叫嵌入式开发工程师，？然后那个嵌入式里面又用的Linux，所以又叫Linux嵌入式开发工程师，在浏览器上面就是Web开发工程师，所以这些都是在某种场景下面去做编程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_做什么">6.4. 做什么？</h3>
<div class="paragraph">
<p>系统编程解决了什么样的问题？怎么解决的？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

常见的MySQL、Nginx、Redis他们都是什么软件？他们是典型的系统软件，就运行在操作系统系统上面做某种事情，为什么不写qq？因为qq是纯用户端的，和个人也有关系，而上面举例的都是提供服务的就是Server就你可以理解为Service，就是服务，这些都是提供服务的，它们都要和操作系统打交道，而且非常密切，也可以把他们叫服务端软件，这样更具体一些，所以操作系统编程，系统开发工程师要做什么事情？就是调用操作系统的各种API和各种资源去编程。</pre>
</div>
</div>
<div class="paragraph">
<p>API的英文：Application programming interface，AP指的是Application就是应用程序接口，那接口是啥？其实就是那个USB充电那个口，这个地方的接口就是说操作系统留了个USB给你，只要拿USB，按那个USB的规则比如说：那个电压是多少？接口的形状是什么样的？插进去对不对？你唯一要做的事情就是自己用Java写一个USB接口，所以这个地方是调用超出性的接口开发或资源开发程序，举个最简单的例子的：ls，天天用是不是，他也是个程序，他在操作系统API，这个就很典型，它会调命令，这会调操作系统的函数叫：dir( )打了个括号，就表示是函数，Linux内核里面有个函数叫dir，你只要调这个函数，他就会把目录的列表还给你，然后ls再把这个列表的结果处理一下，弄成各种格式发给你。</p>
</div>
<div class="paragraph">
<p>ls调了操作系统的函数。刚才你说强哥；“我调Java的时候，我也调了read和write，”他肯定和他这种打交道，我知道，但是调用操作系统那个东西不是你本意，但ls是，你必须要直接调查这种系统的接口，比如说如果在Window下，你可以写个windows程序，然后把那个注册表的目录数、节点全部遍历出来，Windows就提供了comm接口出来，但是难用，相比Linux编程贼爽，Windows编程脑壳大，各种历史包袱，导致丑陋无比，Linux是直接：对不起，函数没有了，Windows为了兼容，他付出很多的代价啊，所以对程序员来说有的时候有些人可能适应。</p>
</div>
<div class="paragraph">
<p>上面讲到ls是调了dir，而上面MySQL、Nginx、Redis肯定是调了网络接口的，因为他要监听端口，所以他们一定会调个Listen，还有except，Listen是监听端口，比如说你MySQL默认端口是3306，那他一定会调这个代码的，MySQL官方自己调的，说白了，如果你写的一个程序直接和操作系统打交道。就是像这个样子，调用它的内核里面的各种函数，各种代码，你就可以叫系统软件。当然，ERP系统就指的是企业服务，比如说物流ERP，那种就和企业服务打交道了，这个地方全称是操作系统软件，意思就是说他是所有上层软件的基础，比如说我把MySQL一炸，所有人就瘫痪了，MySQL只要有Bug基本上挂掉百分之七八十都是很正常的。所以操作系统软件非常的重要，它不能有bug，他不能比如说圣诞节一个彩蛋挑出来，不是哪个UI框架，圣诞节的时候在政府的微系统上跳了个彩蛋出来，好像是阿里的程序员干的，就贼奇怪，在全世界，吐口水都把你淹死，所以在这个领域哈，是绝对不允许出现这种情况的。</p>
</div>
<div class="paragraph">
<p>那ls他做了什么？</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`1.调用OS的函数（直接）`</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>`2.直接调用操作系统的资源（内核）`</pre>
</div>
</div>
<div class="paragraph">
<p>在Linux场景下面的话，一切皆文件，鼠标是文件，显示器是文件，刚才他的显卡有问题，他的显卡也是文件，你的显卡在/dev/video card下，你把那个文件一删你会发现电脑就出问题了，而且就算重启了他也可能会有问题，那是因为你在装显卡那个包或者驱动的时候，他创建那个文件，你删了过后重启它就没有了，你只能重新把那个安装程序安装一遍。但是Windows如果是这种情况的话必须重装系统，但Linux就简单，只要把那个显卡驱动重新弄来，在命令行下头直接重装一遍，它就会恢复正常了。
这就叫一切皆文件，什么叫文件？刚刚讲了你的键盘、内存、cpu都是文件啊，所以这个时候你直接朝那个文件里面写点啥就有可能出问题，要是你要想搞坏一个人的电脑，贼简单，随便打开个文件槽里面乱写点啥，如果你要想搞一个Windows电脑，很简单，把目录一删就好了，Linux至少可以修复，但windows你想多了啊，你可以把比如说的两台电脑都是CentOS8，其中一台出问题，直接把另外那台电脑上目录东西拷过来后十有八九就好了，都不用重装。</p>
</div>
<div class="paragraph">
<p>所以，做什么具体就是两大类方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_how">6.5. How？</h3>
<div class="paragraph">
<p>怎么做？很简单。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

要统计内存信息。就是那个free命令，这个地方API调动函数的话，就类似刚刚讲的dir，当然还有很多比如删除。是一个叫unlink函数，你调它就可以删的东西，比如说修改权限chmod，这个命令，对不起，恰巧刚好有一样的函数，直接调这个函数也可以改权限啊，那既然可以改文件权限，那用户组也可以chown，能举很多很多例子，而且你都听过，所以你会发现那些命令都传参数给内核函数，他根据你的参数调这个内核函数的，把参数拼成他想要的样子，然后最后丢给系统执行就完了，好简单，就是这么直接了当，这是一类，就是刚刚说这个，那文件怎么办？文件大部分都在/proc这个目录，这个目录下面有所有的进程信息，还有一个比如说你要想知道你有多少个硬盘，你扫描/dev下面sd开头的，当然现在有的硬盘现在已经不是SATA的了，M.2的，你会发现还要支持n开头的，但是这个下面有所有设备的硬件信息，显卡呀、硬盘啊、usb、各种串口、sd卡槽都在这个下面，然后分区多大、分了几个区、分区信息、分区的头、分区的尾全有，有一个文件很重要，很常见的，比如说要看那个发行版的信息，它就在/etc/os-release，所有的Linux都有这个文件，这个文件里头，如果你是ubant 12.04，把这个文件的内容打到屏幕上面，它里面就12.04，完整的发行版的信息都在里面，个别发行版，他可能不遵从这个约定，有可能是其他的，但是红帽是很标准的，他除了这个以外，他还有个东西叫redhead-release就表示红帽发行版信息，这个叫系统发行版信息，但是红帽这两个都是一样的，ubantu有细微的区别，所以你会发现他的发型版信息就在这里头，如果把这个文件删了，你会发现有些软件，工作会崩溃，他凡是读那个系统信息都会崩溃，但是Windows你要拿信息就很麻烦你得调查的函数，Windows把所有的东西都封装到了它的函数里面，这些导致个问题，万一哪天他的函数参数变了呢，而且要维护那么多版本，你调的函数他还会乱码，但这个乱码是你不会处理，因为你不知道他用的什么编码，我就想拿个信息而已，所以Linux真的很简单，因为它的行为非常的一致，进程信息在/proc，设备信息在/dev，操作系统在/etc/os-release。</pre>
</div>
</div>
<div class="paragraph">
<p>所以Linux简单，是因为它的哲学：一切皆文件，他的行为也非常的一致，不会有特殊的东西，所以Windows下面那个注册表就是个毒瘤，那个玩意儿吐槽一万次都吐槽不干净啊，完全没用，还是累赘，搞注册表之前，我都要先把注册表完整备付，也不知道会不会出问题，Linux很简单，文件就两个行为，就读和写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

打开一个文件

1.打开一个文件

打开的时候，指定它是只读、只写、可读可写，一般只读可以了，然后指定文件名。

2.close

比如说打开是写就可以往里面写东西，写完了过后就直接close。</pre>
</div>
</div>
<div class="paragraph">
<p>全世界甚至全宇宙所有读写问题都是这么干的，没有例外，就很简单，没有特例，都是这么干的。当然一般搞系统编程的，涉及到内核文件的时候，一般都是只读，写的情况非常非常少，除非真的有特殊的需求，当然，除了这些文件，你可能还会写自己的文件，比如说Linux下面经常看到/run/nginx.pid这个东西,各种各种pid,特别是管服务器的时候，那个MySQL的pid意外失败了，那个pid一直放在那，然后你第二次重启起不起来，因为那个pd已经存在了，他提示你把pid删了就好了，而那个pid打开，你就会发现这个数字，那个数字就是进程号，所以一个很重要的文件，他居然就是写了个数字放在里头。所以就不要随意去改这些文件，你改了过后，你就发现起不起来了，放心，那个报错你是不会看的，然后你就会直接网络上求助。昨天前天我在网上乱逛的时候，发现有一个人提了个问题，他用Spring Boot读P SQL报错，请问大家怎么处理啊？我打开了他那个问题，有截图，是个好习惯，打开第一眼我就看到了问题在哪，我就找了旁边的同事，我说：你信不信，你是个天才。他说，我不行。那来看一个图，这个正在读P SQL，我给手指指给你看，你看这报错是不是报的MySQL，看到没有他就是不了解，他不会看报错信息，但是但凡你的多看一眼，你也不至于犯这种错误，所以这个地方他就很简单，就是往里面写了个数字。</p>
</div>
<div class="paragraph">
<p>所以搞操作系统编程，Linux操作系统编程，只需要了解上面两个，剩下的就简单了，真的，甚至写的Linux内核也不是不可能，内核模块，也很简单，只是有个问题：如果你写内核模块，你的程序出问题了，整个机器直接当机，因为你把内核搞崩了，但是你写用户态的信息啊，叫userspace啊，你随便怎么死，反正不会有事，但是你写内核态的程序的时候，他就很重要，为什么？因为内核态的东西是没有保护的，你在里面加个Bug，就像你往核反应堆里吐口水都可能出事，不过可能你打开盖子那瞬间已经出事了，就像打开你的天灵盖一样啊，剩下的就全靠天了。所以用户态的程序啊，影响不大。如果你能写这个，你就能写内核态的东西，什么叫内核态？就是更原始，用户态是在操作系统层面，那内核都不叫操作系统了，为什么？那叫操作系统的内核在最下面，这个时候，你要去写程序，你就应该更严谨，但是整体一样的没有区别。像我们以前给那个四川网监写防火墙，当时我们在运营商级别是有关键字扫描的，比如说你要席叉叉，将叉叉这种，你在百度上乱搜，你会被我们屏蔽的，你放心，不会抓你的，就只是是打不开网页，你会发现你的网页莫名其妙打不开，而且你怎么查都查不出问题，你只要搜特定关键字你就打不开，为什么？因为我们在Linux内核里，因为你要发现网络请求，那我们就在网络请求连接的过程当中，我们在中间加了个钩子，一旦你的钩子检查到你搜的是关键字列表里头的，就直接把你的链接强行关掉，然后刚好那么巧Linux是整个运营商的网关，你所以的流量都会在我那过，等于说我们再监控里，所以那个程序你能写这个，我刚刚说那个程序你也是可以写的，那个程序加起来不到200行，一共写了三个月。</p>
</div>
</div>
<div class="sect2">
<h3 id="_实战">6.6. 实战</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程板书2.jpg" alt="Linux系统编程板书2">
</div>
</div>
<div class="paragraph">
<p>我们监控系统里面最基础的功能就是监控cpu，监控内存，监控硬盘 ，监控cpu，线程和进程数量 ，开机时间，负载。</p>
</div>
<div class="paragraph">
<p>讲个最简单的uptime，看这个名字就知道，就叫开机时间，linux下面有这个命令 ，你在linux敲下回车，他会告诉你当前本机已经已经登录有多少个用户，就是桌面用户，或者远程登上去的，他会告诉你我有多少个用户，然后我开机时间是多少，开机了几天几年几月几分几秒 。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Linux-systemsprogramming2_chapter">7. Linux系统编程(三、四、五)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_7">7.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(三、四、五)板书1.jpg" alt="Linux系统编程(三、四、五)板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(三、四、五)板书2.jpg" alt="Linux系统编程(三、四、五)板书2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(三、四、五)板书3.jpg" alt="Linux系统编程(三、四、五)板书3">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_挂载信息">7.2. 挂载信息</h3>
<div class="paragraph">
<p>上次讲实战就只是泛泛的提了一下，今天我们就写挂载磁盘的监控，比如说平时我们在Linux服务器上面会用df -h命令，那么你会看到下面几个东西：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/dfh.png" alt="dfh">
</div>
</div>
<div class="paragraph">
<p>上面就是df -h命令输出的东西，但是如果要去做监控系统的话，不可能去靠这个命令得到这些东西，为什么？因为会出现下面几种情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一个情况：命令可能会升级。

第二个情况：命令有可能执行的时候没权限。

第三个情况：命令有格式，他有格式意味着要去解析格式，这样就对格式产生了依赖，哪怕多一个空格都会影响最后的结果，无法保证他没有，那么就要考虑各种格式的问题。</pre>
</div>
</div>
<div class="paragraph">
<p>所以在获取信息的时候，对方最好给你接口，有接口就可以调函数，就不用去解析格式，比如说刚才有一个人说他要查微博的信息，如果微博SDK都给你输出了一个列表一个for循环就弄出来了，你不用去爬了呀，那是爬方便还是API方便，那肯定是API方便。</p>
</div>
<div class="paragraph">
<p>所以这种方式它是有缺点的，但是现在我们要实现一样的效果，要在我们的网页上面能看到一个表格，表格有这么多多列，然后这个时候，你肯定不会把这个直接输出过去，在Linux下面，是有函数的，但是Linux不是所有的东西都会提供函数给你，为什么？因为这东西太简单了，所以他有一个东西叫/etc/mtab,当然他在proc目录下面也有类似的东西，比如说就叫mont,这两个效果是一样的。但是在那个文件里头，他就不是上面图片上的样子了，在那个文件里面，他不是一个命令的输出，他就是个文件内容，那个东西内核只要不变，比如说Linux大神，他们在开发的时候，如果不去故意地改变他，你或许是ok的，但是这个命令结果你获取就有问题，所以一般我们是从源头拿，而不是用命令知道，为什么？因为你读它，你要靠命令去帮你读，这就意味着中间包了一层，包了一层是有风险的，所以现在你要去读源头文件，那这个文件里面是怎么写的？这个文件里面很简单了</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/procmounts.png" alt="procmounts">
</div>
</div>
<div class="paragraph">
<p>由图可见这个地方和上面用命令出来的东西是不一样的，有多余的东西是列不出来的，就看你到底要不要那个多余的东西，所以这个时候就相当于是说用你的编程语言打开这个文件，文件有这些东西，然后挨个读。</p>
</div>
</div>
<div class="sect2">
<h3 id="_伪代码">7.3. 伪代码</h3>
<div class="paragraph">
<p>现在就写个伪代码：</p>
</div>
<div class="paragraph">
<p>首先应该就是打开文件，比如说打开/etc/mtab:</p>
</div>
<div class="paragraph">
<p><code>f = open(“/etc/mtab”,”r”)</code></p>
</div>
<div class="paragraph">
<p>这个时候是不需要去判断那个文件存不存在的，为什么？因为这个文件都不存在了，那你Linux都没启动起来，属于那种什么超级恢复模式，当然不能正常运行了，放心，就算是在那个模式，这个文件也是在的啊，除非到了崩溃模式，grub那个启动界面都进不去，所以哪怕是微内核的，甚至你的手机里面，都有这个东西，只是你看不见而已，所以这个地方就不需要判断文件在不在。</p>
</div>
<div class="paragraph">
<p>现在得到f了，那应该怎样一行一行的取呢？是不是所以我要调个Get一行，所以第二步是这样写的：</p>
</div>
<div class="paragraph">
<p><code>while (line = getline(f))</code></p>
</div>
<div class="paragraph">
<p>调了这个函数过后会得到这个变量，但是不理解为什么这个地方要合在一起写，那是因为偷懒的办法，如果这个地方，如果这个Line变量最终是一个空，是一个 <code>null</code> ，指向一个空地址，那这个while就会变成FALSE，一旦是空值他肯定就不会走下面了，所以这个地方那如果我得到的line有东西，那就得到的是第一行，那么第二行，第三行，第四行，然后如果在第四行过后，他又会转回来，又到了这个地方，直到第五行的时候是空的，那这个函数就会跳出去，其实写这个程序只需要几行，所以系统编程有好高级吗？你不懂的并不是这个地方，你不懂的是这个有什么用，然后他又怎么去呈现到用户那边去。</p>
</div>
<div class="paragraph">
<p>但是就算这个那么简单，到现在为止，100个人里面也没有一个人会写，为什么？因为基本上你可以忽略不计这种人，因为要对操作系统有了解，多少人装一个linux，装个Docker，把东西一拉一跑完事剩下的什么也不知道啊，然后我就拿K8S把它跑起来嘛，就解决你的宕机问题，这个用法没有问题，但是终归你会遇到，万一对方没有K8S，你就两眼一抹黑，而大多数公司出问题都是重启，在我这个地方可没有重启这个说法，为什么？只要你能连上去，就能够给解决，不要跟我讲重启这回事，为什么？因为重启是既不治标也不治本，为什么？你影响了业务啊。重启也是在影响业务，这边不就是本吗？所以最后两头都不站，只是解决了当前的死机的问题，但是你并没有解决他出问题，他为什么出问题？然后明天必定还会出问题，有可能是在你睡觉的时候，有可能是在你下班的路上，有可能是大家都睡觉了，用户在用的时候，这个时候你只能通宵值班，你看他啥时候出问题吗？</p>
</div>
<div class="paragraph">
<p>那这个地方我得到第一行，我得到第一行过后，我下一步是不是要做这个分割？所以我要得到第一列，第二列，第三列，第四列，第五列，那现在我要分裂，要把它分开，所以假设有个函数叫分割函数，比如说我有这个函数，那把这个行传进来，告诉他用空格分割，但是我的结果没有保存，那是不是该用个列表把它存下来，那么我有一个列表等于它，然后剩下就好办了，我列表等于他，而这个列表的总列数一定是固定的,为什么?他不可能说这个地方有5列，然后下面就只有4列吧，在操作系统领域不可能有这种行为的，就算没有，他都会给你放个none，会放一个标识符，表示站着位的，但是很多时候不会这么写的，他一定有某一个东西，所以它的总列数一定是固定的，就假设有五列：</p>
</div>
<div class="paragraph">
<p><code>if(line size()!=5)</code></p>
</div>
<div class="paragraph">
<p><code>break</code></p>
</div>
<div class="paragraph">
<p>只要循环不满足就立刻跳出嘛，所以说写程序嘛，你要处理异常，70%代码都是在做异常处理，因为我完全可以不写它，我直接会拿值，加起来不到五行，所以那判断等于五接下来就可以放心大胆的用了。</p>
</div>
<div class="paragraph">
<p>所以那这个地方得到第一列，那第一列，比如说，你要给他取个名字，这个地方叫分区，分区的英文怎么说的？Prtition：分区，然后第二列文件系统第三列是总大小，第四列是可用空间，第五个就是mount挂载点，我也讲过的：<code>程序等于算法加数据结构</code>，这个就是数据结构，这也就是算法，这也就是程序，完了，当然这个数据结构太简单了我可以给它拼成JSON，现在是叫数据结构噻，只是太简单了嘛。你不看这边，你就看上头的list的，它也是数据结构，只不过是放到数组里面的，放的变量就不是List？就不是数据结构了吗？它是有逻辑的，我现在是不是可以把它转成JSON？我是不是可以给它转成XML？还可以把他转成HTML，我可不可以存到数据库里面？所以你刚刚我说那些所有的东西就叫数据结构，而什么叫算法？得到那些数据结构的整个过程就叫算法，他的算法严格意义上说是这个While循环，在循环里面这一部分是不是，如果你要说整个程序的算法应该是这个包含While，严格意义上的话，那么整个While里面的list和if语句就叫算法，然后下面这部分就是数据结构，当然我这个地方数据结构很简单，那整个加起来呢？我这个地方可以把它拼成一个SQL，然后连接数据库、插入，然后你这个时候发现，其实按最精简的模式，连接数据库根本就不是程序核心的一部分，真正核心的部分只有你构造出等待插入到MySQL里面的那一部分，比如说insert、into、table那一句话里面屁股后面你有value吗？那个东西才是真正有价值的？为什么？万一某一天我不插MySQL，可能我要插P SQL，然后P SQL也不想用，我就想放到Redis里头，你会发Values里面那个东西啊，他始终是不会变的，就这一堆东西，变的是它前面的一部分语法，或者是你把这个值用到哪个地方去，等于说你构造了一个数据包，而这个包要怎么用？那是根据你的场景或者你需要的东西去演化、变化了，所以在这个过程当中，连接MySQL，然后检查连接是否成功、处理错误代码，这一堆东西，虽然它是程序的一部分，但是它严格意义上来说的话，它属于异常处理的代码，而不在这个公式里头，所以你在做技术调研的时候，你就做这两个，第一行都不重要，你一定会拿到那一行的，为什么？如果你用C写的话，你要去做那个切割的话，这个地方要用一个特殊的函数。sscnf去做列的切割。如果你用Python的话就更简单了，Python自动能够帮你分，你要用Java就麻烦一点，人生苦短我用Python，Java可能写个五行六行才能解决，Python一行就解决了，那么这都是根据你的语言不同。</p>
</div>
<div class="paragraph">
<p>所以我说这个东西叫伪代码，伪代码的意思就是说他和真正的编程语言没有关系，只表达你的意思就可以了，一般Python是最简洁的，所以你在做技术调研的时候，就是你要去验证你的思路是不是可行，或者是说，某种方案是不是可靠的时候，你就要做算法和数据结果的设计了，这件设计你能说通，你能说给你的同事或者能说服你自己，剩下事情就简单了。</p>
</div>
<div class="paragraph">
<p>第一个问题，你要在IDE里面去建一个工程，和他有关系吗？没关系，有没有问题？有问题，但问题不大，所以这个地方，你要自信一点，就是你只要把这个过程做了，剩下都简单了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_约定">7.4. 约定</h3>
<div class="paragraph">
<p>那么这个是一个挂载信息的获取，现在拿了这个东西，我剩下就只需要按照和对方的 <code>约定</code>，比如对方约定用JSON我就用JSON把它包一下，然后丢出去。如果对方说你打到屏幕上就可以了，格式是什么什么，照做就行了。如果对方要HTTP，就封个报文给他，至于我是用Spring Boot，还是用我自己写的，你管得着吗？只要按那个报文丢给你就可以了，就是说按我们两个约定，我们接口之间是要有约定的，为什么？因为你会调我给你的接口或者说我会调你准备好的借口，那这个时候我们两个是提前有约定的，叫规范(API规范)，JSON也是一种规范，为什么？因为我们两个提前会约定好，用花过号表示什么，用冒号表示什么，key叫什么名字的时候表示什么意思等等，那这个时候你们是提前有约定的，你说我们两个传JSON，他不叫约定，为什么传JSON传一对空的花括号，他也叫JSON，为什么？空JSON嘛，空JSON也是JSON啊，那所以这个时候你又要考虑清楚具体要怎么用它，但是这个一定不是在你调研的时候需要去考虑的，为什么？我如果打屏幕上print12345直接打，但是如果你Print打他就有问题了，为什么？因为你没有算法，但这个算法有可能有五行十行100行1000行，他都叫算法，所以程序多或者很大的时候，不要受干扰，程序里面70%的代码都是为了解决异常、平台兼容、错误处理、日志，只有20%到30%的代码才是真正的核心代码，而且可能比这个还低，有可能有的人你经常看到那个JS里面有人说，你见过最差的代码是什么样的？他能if 100层，到后面格式挺好看的，这种里面，我能用三行，把它的那个核心算法说白了，把它程序给写完，为什么？因为他无非就是一个查询表，查询表我在做可行性研究的时候，我那个表写一行。他也是有元素的，元素数量为一，然后顺利把唯一的那个元素拿出来，然后做一个加减乘除完了，你看就是不是大多数都是三行吗？对不对，所以说你跟别人去沟通，最开始做初步沟通的时候，你是跟别人沟通算法和数据结果的设计，但是你去写代码的时候一定要比他多，为什么？你要写各种错误处理：文件在不在？有没有权限？比如说这个地方f报错的时候，他一定有返回值，这个f就可能是空子针，然后这个空子针你要判断if f=空子针，就报什么什么错，然后这个时候本身原计划数据结构是这样的，然后结果报错的时候，你肯定还要对方约一个当出错的时候我们的数据结构是怎么样的？看到没有，无非就是这个链路走通了，你开始做完善了。就是那天我发到群里面的图一样。我发给你们过后我又改了2版，我发现：有的地方可以精简或者可以画的更好，我就开始做叠带了，有这个东西，你就可以做叠带，没有这个东西的时候你啥都不是，为什么？就停留在脑子里，脑子里面的东西是不值钱的，就像我脑子里面有很多东西一样，他一文不值，为什么？你又看不见，摸不着，也不能换钱啊。所以说这个时候，你要把它千方百计的落在你的纸面上，落在你的代码层面。</p>
</div>
<div class="paragraph">
<p>然后现在我们开始慢慢往上走了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拓扑">7.5. 拓扑</h3>
<div class="paragraph">
<p>接着上面的讲，先画个拓扑图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tuopu.jpg" alt="tuopu">
</div>
</div>
<div class="paragraph">
<p>一个机器上面可能有不同的监控程序负责收集数据，那么这些数据收集完了过后，他会通过假定现在是HTTP报给他Agentd，那么Agentd的守护进程收到过后，他又会把这些东西完整的收集一遍，然后统一报给他的上层，所以解释一下为什么要用HTTP，上次我们讲过，就是当前这个编程生态用HTTP是一种行业共识，因为它简单，而且很多框架的支持它，如果你自己要造一套TCP上的应用层协议，就有个问题：你的维护者可能看不懂，就会导致参与度很低，那么这个时候我们在没有遇到明显瓶颈的时候，就假设就用的就是HTTP，这个地方之所以让Agentd打包而不是直接发上去的原因是因为直接报上他，如果没有这一层Agentd直接往上报的话，那如果有50个模块，那就连接太多了，所以这个地方我们就假设他每秒钟，等于说每隔n秒他都会往上报一次，这个主要是为了解决服务端的压力的问题。</p>
</div>
<div class="paragraph">
<p>然后回到刚刚的这个程序这一边，那我们现在写的这个程序啊，就属于这个User的，那现在很明显用HTTP朝外面报，当时我们不是考虑了个问题嘛，就是说如果他是一个Shell怎么办？用Shell没有办法调别人的代码库，但是他完全可以用curl、pust往上报，可行性是有的？那这样的话，对于用户来说是，它可以用我们的编程，我们提供好的SDK。他也可以自己用HTTP往上报，这就像极了ES这种东西，你可以用它的JavaSDK，他帮你封装HTTP的请求，或者你觉得你自己要求简单，你也直接可以请求他的app往上面报就可以了，所以这样的话支持就非常广泛了，对我们的用户端程序就没有非常具体的要求，你都可以，当然Socket的好处就是他的性能很好，但现在是这个东西都没跑起来，求啥性能啊，我们又不是一个性能程序，如果真的要求性能程序，比如说我是一个监控MySQL查询的一个程序，所以这个时候对性能的要求应该是在User里头，就相当于是说我每监控一段时间，我就会朝外面报一下我的状态，我就像他这样的转圈圈，报出去，然后继续转圈圈再报出去，他上报的动作和他监控的动作其实是两个线程，这样的话就不影响了嘛，就非阻塞了。</p>
</div>
<div class="paragraph">
<p>所以网络托普就这样的，每一个人在写程序的时候，你肯定要画各种各样的图。算法和数据结构他解决的是单个点的问题，当然这种点可能有n个，但拓扑图一定你要有那么一张，因为它能让你的程序怎么运行，怎么用，一目了然，很明显吗？你都Agentd的这个程序了，好简单嘛。你系统上是不是装这个东西啊，看到没有，那运行怎么运行啊？是用c还是用Java就有很具体的要求了，我们之前讲过，这地方对内存很敏感，为什么？你运行这个东西跑个Java最低的要求一两百兆的内存，那别人一共在256内存，起都起不起来啊，就有一点过分，可能用户就很敏感，所以这个地方要么用rust要么用C，但是我们为了练手，就这个地方就是rust的，那这个地方用rush的，那么User，我仔细想了一下，你要调系统的函数，用rust调系统函数中间还是隔一层，所以用rush的地方一定是非常纯粹的，什么意思？他和别人不打交道，就是纯代码层面，别人不调他，他也不调别人，那我们就用rush的来写，但这个地方既要调操作系统，又要朝外面报东西，那操作系统都是C写的？windows是C吗？Linux可是纯C写的，Unix可也是纯C写的，所以这个地方监控cpu这种非常非常基础的，那就纯C，像那种要监控HTTP的你肯定首选C++或者rust了，为什么？因为这个时候他的分析量上来了，你要考虑你编写和维护的性价比的问题。所以这个是你要考虑，比如说像有些东西能够一个行就是弄出来了，还用啥编程语呀，一句Shell就搞定的事情，你要让你的程序快速的能够工作是一件非常非常好的事情，如果你写了一年你的程序，他跑不起来，我劝你早点放弃。</p>
</div>
<div class="paragraph">
<p>所以野生程序员就会经常犯一个错误，什么错误？</p>
</div>
<div class="paragraph">
<p><code>为了追求局部的先进性，忽略了总体设计的稳定性.</code></p>
</div>
<div class="paragraph">
<p>这句话是钱学森说的，讲的非常非常有道理，他是什么人？美国的喷气式实验室就是他和他的导师冯大牛一起搞的，钱学森是冯大神的学生，冯大神同时还搞了土星五全世界200吨推力的火箭，美国人的，当时和苏联竞争嘛？钱学森是美国空间实验室的缔造者，我们都先不说他是中国人，他为人类做了很大一部分事情，所以这个人非常非常厉害，你们要仔细去研究一下，也是可以的。</p>
</div>
<div class="paragraph">
<p>那现在我们通过简易的设计，然后让总体处于稳定状态就可以了，所以你不要为了追求先进性，搞得非常非常复杂，程序一定是越简单越好。</p>
</div>
<div class="paragraph">
<p>今天我跟我的同事在商量，我们有两套系统，这两套系统是通过网线或者wifi连在一起的，我就问他：“以前你们做这个这种需求的时候，你们是怎么去交换数据的？”就是说白了下面负责收集数据，上面负责接收数据，然后再丢出去，从这个层面就是这样的，这个是数据的收集者，这个是透传出去。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>我就问他一个问题：“以前你们是怎么把这个数据下面这个数据，发给上面做数据交换的？”

他说：“以前我们是直接用裸的TCP报文。”

对的，就是在TCP内层自己加一些简单的应用协议，就传个数据，对性能啥都没有要求你，他们居然要自己搞一个报文，自己造一套协议？

我说：“你们累不累啊？有没有什么可用的开源库？”

他说：“没有，啥的没有，一穷二白。”

然后我就推荐他，

我说：“你用HTTP绝对能解决。”

他说：“HTTP一传几百个字节，好麻烦。”

这时候我说：“什么？来我手写个报文给你看一下。”</pre>
</div>
</div>
<div class="paragraph">
<p>然后他看到，那么简单，对呀，就这么简单，为什么？我都能手写了，你程序员不能写啊，懂我意思了吗？我手写这个事情已经说明了HTTP很简单，然后他还有一些疑虑，怕掌握不够，我说，没关系，我花20分钟我跟你讲一下，20分钟我都觉得要不到，为什么？他以前也自己写过，但是我看了一下他们以前拼那个HTTP的报文可复杂了，拼JS，还加了很多没有用的头，那肯定复杂呀，我搞了那么久的研究，我觉得这个事情很简单，要用Python的话，五分钟的就解决了，你要用c的话，估计一天，为什么？真的很麻烦，各种各样的编译环境，很麻烦，但是相比他以前来说真的很简单，为什么？以前如果你写的TCP报文，然后你离职了，另一个人来维护，玩犊子了，为什么？没文档，就是写Bug，所以为什么？这个就是我追求的稳定性，而他追求的是能完成任务就可以了，没有任何考虑，也不先进，也不稳定，我说的稳定，不是说他写的代码不稳定，而是由于在改动过程当中很容易引入bug，为什么？因为他用纯c去操作TCP报文和用c操作HTTP来，我小朋友问你个问题：这两个哪个简单？为什么？因为HTTP是人尽皆知的，所以简单，但是非常底层的裸TCP，自己写的报文，他不简单，为什么？因为他是闭缘，他是不开放的，很少人去了解他，所以问题在于没人了解，TCP那么难，还那么多人学，为什么？因为大家都用啊跑不掉，所以如果可以的话没有人愿意去学的，但是你天天要接触他，你必须得学，看到没有TCP就很难懂，我上学的时候TCP/IP卷一卷二卷三，我可是全部都看了一遍，反正我看了几遍我都没感觉中间有些东西没看懂，为什么？哇，那个报文，他发了个表格，他说第几位，第几位是什么？为什么那么搞啊？我说这帮老头子在干嘛？我永远都看不懂，但是我工作过后接触到这东西，我再回来看，嗯，有道理。所以那个书不是给新手看的。</p>
</div>
<div class="paragraph">
<p>所以这个地方交换数据选的是HTTP是因为要让我们的维护更方便，然后让我们的使用性更高，你看我们通过这个配置的方式模块画的方式已经不限制我们的用户用哪种方式收集数据了，然后再加上又可以用HTTP接口往上报，进一步放宽了，甚至说Docker，他机器上做了五个Docker镜像里头朝这个地方报可不可以啊？但是你用说Socket可以吗？纯Socket的文件是不能跨机器的，不能跨机器意味着你的Docker和你的宿主机是隔离的，然后这个是，你必须当成两台机器，你看到没有，我没有限制可能性，只要不限制可能性，他任何事情都可以满足。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>比如说我的老板经常问我：

老板：你这个程序架构又得改

我：为什么？

老板：你看吧，需求变了，你要调。

我：老大，你放心，这个问题你不要再想了，你不用去担心了。</pre>
</div>
</div>
<div class="paragraph">
<p>为什么？我的意思就说你不要再瞎想了，听我的，为什么？因为从做出来到现在过了一年多的时间，我们接入了那么多需求，我们的架构可一点都没有调过。因为我们的设计架构的时候，我从来没有考虑过谁用这个系统，我考虑的是说：这个用户会产生什么样的数据？这个数据本身有什么样的特点？这两个人他产生的数据特点有可能是重合的，重合了过后我是不是只要支持这两种就可以了？但是如果要支持那个人就有问题了，为什么？人的行为多种多样，我最终得到一面红色的五星红旗，管他是捡的、买的、还是偷的，我最终是不是都有面五星红旗，对于我来说我就管红旗嘛，我管你是坑蒙拐骗，所以这个时候我没有去限制用户，我也没有限制进来的数据必须是什么样的，所以我在做系统设计的时候我在用最简单的方式实现了看起来巨大无比巨复杂的一个系统。我最近5、6年一直都在搞系统设计，我以前一直编码，编码的过程再去学捣鼓捣鼓反复的重构，那么我重构到了一定阶段，我就积累足够的经验，我就开始搞专门的设计了，所以我觉得设计非常非常有意思，为什么？我觉得很多时候把最简单的东西合在一起，它能产生无穷的力量，为什么？刚才我说的这个结构，对面可是拿年薪的，我跟他两个沟通的时候都在讲这个事，而且他都不掌握，那你掌握了是不是也可以拿年薪了？两个拿年薪的人都在沟通这个事情，但这个事情你都听得懂，这就说明你发现编程的本质实际上并不复杂，而复杂是他包裹着很多迷惑人的外衣。第一个，这次业务你不懂，你的资历浅，你说了没人听，然后还一个你不敢说，这个时候你会受到很多外在的因素，所以编程的本质其实非常简单，你掌握了一个个轮子往那一拼，完事。</p>
</div>
<div class="paragraph">
<p>就像刚刚讲的火药，几千年前发明的火药到现在还是硝酸啊？什么甘油啊？以前造了火药，到现在你还是靠冲击力迸发出去然后产生个惯性嘛？然后打出去，炮弹也是靠这个原理，你看，都是非常非常基础的东西，你掌握了几千年都不用变。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调用配置文件">7.6. 调用配置文件</h3>
<div class="ulist">
<ul>
<li>
<p>PUT方法</p>
</li>
<li>
<p>URL：http：//localhost：8080/model/disk，这个我们一般在URL里面我们会用过动词来表示这是个什么动作，但是这个地方我们也没用的post，因为说白了，我这个机器上头就只有模块才用这个url，所以我们就标准的restful api接口就有什么就用这个post的表示提交意思，这个地方我就不加动词了。通常来说，如果你是一个阿里云，你要向用户提供sdk，你的URL有超多，这个时候千万不要用这种标准的这种Restful Api规范,就用get表示获取，POST的表示提交更新，PUT的是增加，DELETE是删除，所以这个地方要用PUT。</p>
</li>
<li>
<p>接下里就是我收集到数据我要向上面报，拿着个时候我打个比方，我用命令行，curl-x PUT http：//localhost：8080/model/disk -d‘,引号后面就可以跟内容了。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>拼成一个json：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
   “name”：“disk”，
   “time”：“20121/8/16 09:00”，
   “timezone”:"Aisa/shanghai",
       "data ":{
            "filesystem":"ext4",
            "mount":"/",
             ....
           }
     }</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_agentd设计第一阶段">7.7. Agentd设计（第一阶段）</h3>
<div class="ulist">
<ul>
<li>
<p>Web Server（通信用的是HTTP）</p>
</li>
<li>
<p>Web Client（相当于User程序来说）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个程序在系统上面，你把它启动起来，那启动起来过后，他会默认监听一个8080端口,那监听的端口过后，那么他就相当于是说等待别人的连，等待别人往上报数据，那这个时候就相当于是说，我打个比方，就刚刚那个Put那么报上来的时候，那这个地方他应该每次报数据的时候他处理应该不影响后面数据接收，他应该是异步的。如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Agentd.png" alt="Agentd">
</div>
</div>
<div class="paragraph">
<p>就是他应该是多线程的，这是最基本的要求，当然你用现在的框架基本上都是这样的，你不用去担心这个异步的问题，但是你得知道，就算框架帮你封装了，你也知道，你不能说前面那个没有处理没有接收处理完的后面全卡住。他收到用户程序往上报的这个结果过后，他应该把多个模块的数据组合一下，再定时的报出去，什么叫定时报出去，比如说每一秒钟，这是一种策略。还有一种策略就是说，如果我这次报的数据和上次数据没有变化，我就不报，当然这种这种策略是因为在物联网上比较值钱，为什么？因为它可以省流量，但是现在我们用的都是网络，我们并不关心流量，如果我真的关心流量，我就相当于就是在上面往上报的时候这个地方加个GZIP压缩就可以，这压缩在Nginx上面开就可以了，你程序一行代码都不用写，这样的话能节约分之30以上的空间，浏览器或者你的服务端收到他自动会解压的，所以这个地方我们就不考虑带宽了，就相当于是说我们这个8080，他是第一个起个端口嘛，做异步接收，那么第二个他收到数据过后，那么要汇总（如上图），就像第二个大的逻辑，他要汇总所有的模块数据，那么汇总完了过后也要形成一个Json。如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
     "HOST":"..."
     "Name":"..."
     "Time":"..."
     "Zone":"..."
     "Modles":[
          {   “name”：“disk”，
              “time”：“20121/8/16 09:00”，
              “timezone”:"Aisa/shanghai",
              "data ":{
                  "filesystem":"ext4",
                   "mount":"/",
                    ....
               }
            }
         ]
      }</pre>
</div>
</div>
<div class="paragraph">
<p>所以说服务端会传上面做个Json到 Server，这个传就是Web Client，User报数据报给80端口，80端口收到过后，做一些处理，实际上这个Client指的不是一个模块，因为他是汇总所有模块嘛。是这个地方都是基于Json的一个客户端，所以他收集数据应该是等到某一个时间段，比如说每隔一秒钟把自己缓冲的数据组成这样丢出去，所以说他在他自己这个里面一定有最后一条这个数据的缓存第二次把它覆盖掉，比如说第一次disk传的一个数据上来，然后这个时候，他就如果你不主动删了，他一直放在你的那个静态变量放在那里，你第二次disk刷新了，你传数据给我，我是不是重新写一遍，然后当我到了那个一秒钟间隔的时候，我要把这个数据转成这个Json丢出去，你把这个用户端和这个服务端结偶了，就是说Server和user没有关系，你不要强行的说等到这个报的时候一起直接报上去，那你要汇总Modle数据干嘛呀，所以这地方，实际上是有cache的，是有缓存的，你缓存的时候最后一次上报的状态，所以说他什么时候缓存失效啊，等下一次覆盖嘛，他要是那个程序一直出错，他一直不覆盖怎么办？出错就出错嘛，你去解决出错的问题啊和我缓存没关系嘛，然后到后面就发现一个bug是吗？你们这个模块死了，这个缓存还在往上报。然后你要写一个东西去检测这个问题了，比如说你发现这个User请求不上去，他都通知不了，所以说你那个cache加个过期时间，你看系统是不是设计出来了，缓存加个过去时间，比如说过期五秒钟，五秒钟以内没报，我就直接把你删了，那这地方我就不会报你的数据了，因为我是基于缓存构造这个嘛，缓存是什么？缓存是这个modles里面的东西，你有三那个模块，我们就应该有三个缓存，所以这个地方我们自己构造一个缓存机制就好了，其实很简单的，因为Redis他是相对于没有技术的人，于我们的这种人来说，如果那个场景下，Redis不合适自己造一个嘛，也不是不可以真的很简单，就你想嘛，cache嘛，就一个静态变量嘛，静态变量生效是在整个所有线程里面都生效，所以你去肯定就有一更新，你肯定就有增删改查嘛，然后这个时候，你肯定还要起个线程定时器嘛，去循环检查这个cache。
当你循环了五轮过后，那个cache没有被更新，直接干掉它为什么？因为你cache每次插入进去那时不是一个时间戳嘛，so easy。</p>
</div>
</div>
<div class="sect2">
<h3 id="_server第一阶段">7.8. Server（第一阶段）</h3>
<div class="ulist">
<ul>
<li>
<p>Web Server</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_linux系统编程六七">8. Linux系统编程(六、七)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_8">8.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(六、七)板书1.jpg" alt="Linux系统编程(六、七)板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(六、七)板书2.jpg" alt="Linux系统编程(六、七)板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_5">8.2. 前言</h3>
<div class="paragraph">
<p>是时候给我们的项目取个名字了，我们之前说我们叫Linux监控系统，然后现在开源领域常见的比如：Zabbix、Cacti、Nagios后面两个都很老了，这个里面Zabbix份额是最大的，主要是因为它现代，Nagios是大概20年前用perl写的，然后Cacti是PHP写的，他只能绘图，功能很弱，基本上没有数据库，所有的图形是放在类似于XML或者是那种图片文件里面的，你要读的时候，他就会读磁盘上的文件，还要配功能很麻烦，所以这两个基本上都不是首选。</p>
</div>
</div>
<div class="sect2">
<h3 id="_zabbix的优缺点">8.3. Zabbix的优缺点</h3>
<div class="paragraph">
<p>那么们自己做的东西和Zabbix不同的点在于Zabbix是专注于cpu曲线、硬盘使用率、你的进程数，它的重点是在于绘制图形，它的重点是在于图形上面，那对于我们来说：我们应该更偏重于管理，Zabbix说白了都不用登他，可能每个月或者每个星期，你登上去看一下，或者出了问题，他发封邮件给你，他说进程数超过500了，这样你会发现他的颗粒度，就是说整体来说比较粗线条，怎么理解啊？</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>不管你有没有Zabbix，他对你的系统管理其实是没有多大影响的，你可能为了向外行做报告的时候，在PPT里你需要那些图，但是现在没东西，你就先把Zabbix装在那运行一年，然后当你需要图的时候，把它截下来就行了，但是对于System admin来说没用的，所以说我除了看这个以外，它有一些功能就是你可以设置它的cpu超过，比如说百分之百的时候，它会发封邮件给你啊，你进程数超过多少，他可以发邮件给你，可以设置阈值，Zabbix偏重于对阈值的一个配置来实现你的一些辅助管理，除了这个以外没有其他的，然后Zabbix特点是什么？刚刚讲的优点就是有图形，然后根据阈值来辅助你的管理，那Zabbix使用简单，可以管很多的机器，每个机器给你编组就像上体育课一样，男生站左边，女生站右边，其他站中间，他可以分组进行管理，最后编组过后，他可以按组来看这些图形，最后你会发现Zabbix其实他对于你管理上并没有帮助，你会发现他的重点其实是在于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一个:图形

第二个:编组（多机器）

第三个:阈值</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方第二个点 <code>多机器</code> 就很有意思，如果你只是想用Zabbix来管理一台单独的机器的话，它其实是没什么价值的，一般机器多的时候用它可能会用，比如说有的公司，它就两个机器，要看那个CPU曲线用top命令就看到了，也不存在做报告啥的，你想吗？我做报告我给谁做报告啊？我给我的Team Leader，就俩人，我给你做报告，我还给你写个Word，不觉得这个公司的组织架构有严重的问题吗？，为什么？一共就两个人，为什么不扁平管理，反而要这种树状管理，那这样的话就意味着：当你的体量小的时候，其实你是不需要这种炫酷的图形辅助你去做报告的，那你应该是直接登录机器去查看有没有问题，没问题就算了，有问题再说，所以其实你在机器少的时候，你是不会用Zabbix的，但是你想一下，如果公司一共有八个运维，出问题了，总得有个高手解决吧是吧，那如果你们公司半个运维或者一个运维，而且那个人又是兼职，现在问题来了，出问题了，所以在运维多或者人力资源充足的时候，Zabbix首当其冲拿来做报告的，做一种事后的辅助，写报告、查cpu什么时候异常、带宽用了多少等等，做这种统计性质的事，为什么我知道他们是这么做的？因为我用它也是这么干的。
高级点的就可以配阈值，配完了过后各种监控，各种报警短信、推送它都能报。</p>
</div>
<div class="paragraph">
<p>现在大家去监控网站有没有问题的方式是是叫什么？</p>
</div>
<div class="paragraph">
<p><code>“360免费网站监控”</code></p>
</div>
<div class="paragraph">
<p>这个就是360那个蜘蛛一直疯狂的爬你的网站，反正爬到你服务器崩了，他就报警了，叮叮叮，官方发短信来了：“你的网址不能访问了”然后问题就是说：他只是告诉你结果，打个比方说什么网站不能访问，网址访问异常，可能是域名解析出了问题，可能是CDN出了问题，也可能是内存死机了，或干脆就是阿里云宕机了。</p>
</div>
<div class="paragraph">
<p>是这样的，出问题我不用你，我知道我出问题了，为什么？宕机五分钟和宕机一晚上没啥区别，你想一下：反正晚上睡觉的时候人也少，宕机就宕机，只是一堆爬虫就挠头了，这个网页咋访问不了了嘞？半夜两三点钟你会发现那个WEN日志量都没少，我跟你讲：如果白天那个Nginx的Web日志如果有一百兆的话，可能晚上就有二十兆，就奇了怪了，那个清晨5、6点钟，那些人都要访问你的网站，你真的是91吗？那么大访问量？，所以这个时候半夜三更宕机其实对你来说是没什么影响的，所以你看Zabbix也是偏向事后，这个偏向事后其实就是用来做事后统计，做一些异常点：比如说半夜三更某个点跑高了，超过了你的一百兆的临界值，然后报警，他解决了什么问题？他只是解决了一种结果性的问题，所以说第三点也就是临界值，就是基于临界值去做各种的辅助，仅此而已。</p>
</div>
<div class="paragraph">
<p>还有个原因就是多机器，但是出问题一般是单机出问题，因为你只有一台一台单机出问题了，你才导致了多机出问题，比如说数据库那台服务器崩了，然后你是通过网络调用那台服务器B的，那么服务器A跟着卡，你访问服务器A上的网站卡着不动，因为SQL查不完，所以他的点就是单台引起的故障，所以这个地方偏向的是这种，所以做系统管理这么多年靠他真没帮我干到啥，这个也是为什么这一次我们要做一个自己的一个Zabbix，就是因为他解决不了我的问题，那为什么不参与他去重购？他本来就是开源的，是这样的，他整个特点都不是面向问题，就说白了，他出发点和我的立足点是不一样的，我的立足点是要保证我的服务器是稳定的，我的系统是稳定的，但它的立足点就是说：我只需要收集，只收集也就罢了，但是你要去自定义他收集的数据的时候，你就真的非常非常的麻烦，你要装各种插件，然后这种插件装了过后处有没有问题？反正除了作者以外，你也不清楚。
他也有我们这套逻辑，但是他整个出发点用的时候，User这个地方没法自定义或者可以自定义，但是一定不是我们这种新手去自定义的，然后中间一出问题，你根本搞不清楚到底是哪出问题了？当然我很熟了，他出问题也就那几个点，但是真的不友好，再加上他是国外的，经常中文乱码，为什么？因为他的server端的界面是用PHP写的，又没有自带中文字体，装了这个东西过后，第一件事情就要用中文字体覆盖到它PHP指定的目录下面去。</p>
</div>
<div class="paragraph">
<p>说白了，Zabbix不符合我们发展这么快，发展这么朝气的行业以及向上的这种趋势，它太保守了，它这种保守体在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一：语言隔离。

第二：社区运营有问题。</pre>
</div>
</div>
<div class="paragraph">
<p>什么叫社区运营，就是用户能参与其中，能提出自己的观点，当然你会说有键盘侠，但是那毕竟是少数，他可能会干扰你，但是你只要运营得当，是能够大大的得到更多的需求和反馈，用户会告诉你他需要什么，那么就会促进你的迭代，但Zabbix是一家商业公司，是商业公司开发的，那么他相对偏保守，而且他的社区到现在为止我没听说他有啥社区，当然他装了个论坛，那个算不算社区，我不清楚。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们需要什么">8.4. 我们需要什么？</h3>
<div class="paragraph">
<p>那么在监控系统领域，我们自己要一套什么东西？</p>
</div>
<div class="paragraph">
<p>当然Zabbix里面的这些东西肯定是必备的，为什么？</p>
</div>
<div class="paragraph">
<p>就算我们做了过后，图形我们肯定也是有的，至于分组，个人觉得分不分组好像也没啥关系，为什么？总不会你的服务器多到自己都不知道ip地址了，就是如果你都那么大量了，说白了，你这种属于特殊需求，可能1000个人里面就那么1、2个，再说了，你是腾讯，你有一千台服务器，你给我钱，我直接帮你定制嘛，所以我认为分组不是必须的，像这种临界值预警的可以考虑，但是，我个人认为，说白了你平时都不在电脑旁边工作，就算我通知你了有啥用？那么不需要做判断，也不需要发短信，你给我回调，我通知你，我一不用发邮件，二不用发短信，你让我回调你，你回调调不了我也没办法，所以我们是可以通过回调的，为什么？回调比邮件方便，我发邮件万一你说我是垃圾邮件把我给干了，我发短信我还得给钱，真的，你要申请一个发短信的平台，你得先有个公司，公司人人都有吗？但是如果你给我一个回调，随便你怎么玩，所以现在我们除了这那些以外还要要解决的问题就是说：我们为什么要自己造一套？</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们为什么要自己造一套">8.5. 我们为什么要自己造一套？</h3>
<div class="paragraph">
<p>如果这个问题回答不好，再往上走，我们就可能会出现偏差，今天很明显我们要设计Server，这个地方是核心，User是边缘，这个起手就可以做，没有啥设不设计的，但Server就不一样了，我们要怎么实现下面的点：</p>
</div>
<div class="paragraph">
<p>1.更小的颗粒度</p>
</div>
<div class="paragraph">
<p>2.更好的生态更现代</p>
</div>
<div class="paragraph">
<p>什么叫更现代？ <code>Reset For</code> 就是更现代，不要再用Socket了，然后前端是时候与时俱进了，大家都这么做了，你这样做了过后至少能让别人参与进来，为什么前后端分离吗？最根本的原因就是因为人力不足，人力不足不是因为没有人，人力不足是因为你花不起那么多钱请一个全栈把它做完，前后端分离的根本目的就是这个样的，为什么？你要是腾讯有一个亿，那还分啥前后端，每个端都是全栈，公司随便拎一个人啥都可以写，你还分啥前后端呢？</p>
</div>
<div class="paragraph">
<p>那么先解释完这两个，看后面还没有问要补充的</p>
</div>
<div class="sect3">
<h4 id="_更小的颗粒度">8.5.1. 更小的颗粒度</h4>
<div class="paragraph">
<p>第一个：更小的颗粒度，最直观的体现就是时间和 模块。</p>
</div>
<div class="paragraph">
<p>时间是指的采集上报的时间，是可控的，反正Agent负责收数据，那你想报多快就报多快，假设100毫秒报一次是可能的，这个地方是不限制的，你有数据就使劲往上报就行了，看到没有这个地方我是不限制的，那这个第一个是时间。</p>
</div>
<div class="paragraph">
<p>模块意思就是很多，那模块多了过后，你的系统，是否还稳定？因为是那样的，首先，一个系统它是固定的，打个比方，这个笔记本是我们的观测目标，我为了多维度的观察它，我应该要更多的模块，模块越多，我观察的越仔细，我观察的越仔细，意味着我可能更了解他，但是如果我只了解三个点，我可能就更少的了解他，就没有那么了解，所以这个时候你的模块应该是多维度的去观测你的目标，这样你才能找到更小颗粒度的问题，比如说有的时候出问题，就是那么100毫秒的个地方，啪一下，起来了，然后又变正常了，这时候你观测的时候，生成的曲线会很直观的展示出来问题的所在。</p>
</div>
<div class="paragraph">
<p>所以用我们这个系统更大的目的是为了什么？</p>
</div>
<div class="paragraph">
<p>提升你的系统或者应用程序的性能，你可以从每一个可能点去观测你的应用程序，而且不侵入你的应用程序，提供一种客观的数据能够让你提升你的性能，能够帮你找到你想解决的问题。</p>
</div>
<div class="paragraph">
<p>比如说那天一个朋友微信上说他有问题，然后帮他解决了，就重启一下啊，你懂的，反正没给钱嘛，就义务重启一下重启完了，他说那个移动端的网站打不开，结果我一打开，这个不是打不开，域名解析正常、数据包也进到了那个系统上面，但是他访问他访问的时候就在转圈圈，然后我就跟踪PHP的进程，然后就发现他唯一访问那个移动端，他就跑去请求一个ip地址啊，巧了那个ip地址这么写的：api.wechat.com，公众号他解析出了一个ip地址，他就请向他发请求，半天没回来，我就告诉他：你那个移动端的网站，是在请求微信的接口，或者回调，报错或者超时了一直卡在那，他就给我发了个红包，我友情重启，他不给我发红包，我把他这个解决了，他发红包，说白了我也没解决，我就看这个花了大概十秒钟，然后他那个红包我24小时没收，超时了，哎呀，亏了，但其实我更觉得没有必要去收那个红包，因为顺手嘛。</p>
</div>
<div class="paragraph">
<p>你看到没有，我只是从我认为的一个点，但是那个经验是我的经验，是在我脑子里，他没有办法辅助你，所以说我就应该把这种经验变成模块，你可以解决你的问题，不一定所有模块都要随时随地启用，你想解决这种问题的时候，再把这个相关的模块启用，然后这个时候，数量啪啪啪就上去了，没关系，你反正是为了解决问题，然后等访问两次那个移动端的网站，再把这个模块禁用，剩下的再去分析日志，你看，就应该这个样子，所以说更小的时间，更多的维度，更多的模块，帮助去解决问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_更现代更好的生态">8.5.2. 更现代，更好的生态</h4>
<div class="paragraph">
<p>我们刚刚讲的我们除了有现代的API以外，我们还有回调，有回调就可以通知用户，因为那个回调的网址是用户的，我会向他定时的推，至于他用回调来发短信还是啥？和我们没有关系，也不需要改我们的代码，只需要提供这一个口子就可以了，而Zabbix很全：短信、邮件，好像就是没回调，因为在国外邮件用的多，然后短信好像他默认是不支持，要装插件，邮件的好处是他有个邮箱就可以了，不过邮箱不是所有人都要用的，但是起一个app server可是每个人都会的，邮件肯定简单一些，但是你都在解决性能问题了，你是个新手吗？再说了实在你不会写回调我再给你开发一个小Demo，你啥都不会，就把Demo跑起来，刚好也是pgp的，或者是Python的，你把那个东西跑起来，至少回调会发到你的服务器上，你看到没有，这就相当于是两件事情。</p>
</div>
</div>
<div class="sect3">
<h4 id="_视角">8.5.3. 视角</h4>
<div class="paragraph">
<p>然后第三个视角的问题，就刚刚更小的颗粒度这些东西就是总结出一个视角的问题，我们的视角是：第一个提升性能，其实提升性能的过程就是解决问题的过程，所以我只是把它单独拎出来了，第二个应该是解决问题。</p>
</div>
<div class="paragraph">
<p>比如说，你可以在我们的系统上面把那个系统的SSH登录日志，可以写个插件把那个日志整理一下推到我们这个Web端去，然后就知道有谁登过吗，某个ip地址、什么时间登录的、用户名是什么、端口是多久，还有个注销，你不用说持续多久，就一个登录一个注销，用户自己看那个时间，你不要去帮他算了，当然也可以上服务器友情赠送嘛？因为在我这个地方，所有数据都有了，不用挨个去查，就是有种可能性，你查是查不到的，为什么？有些工具人，他用他那个工具登到你的服务器上过后，他干完事情就会把日志给删了，然后等你去看日志的时候，黄瓜菜都凉了，但是我这个一秒钟一次，他都还没来得及删，我都已经传走了，相对来说就更可靠一些。</p>
</div>
<div class="paragraph">
<p>比如说以前我不是发过一个网站被入侵，它里面那个ps命令都被替换成了工具人自己的ps，他那个ps里面有个排除挖矿程序，所以说你用Top命令或者ps命令去看的时候，永远看不到异常进程，你很奇怪，但是我们收集这些信息不是通过top命令，他不可能把/proc下面给改了吧,他这么一改，他就得一直改，那个难度就有点大，所以这样的话，对于我们来说，有助于解决我们的问题。</p>
</div>
<div class="paragraph">
<p>用户为什么要装我们的软件？很简单嘛，一定是稍不注意把数据给删了，但是也不知道是谁干的，就可以装这个，或者是说你从程序层面来看的话，程序不可靠，那么运维说我要自己想解决找这个问题或者线索，那么也可以装我们的软件，但是你用Zabbix，对不起，装上去啥都不能用，就一个cpu带宽、网络，你告诉我除了好看外这些东西有啥用？</p>
</div>
<div class="paragraph">
<p>所以我们就是基本上就是三大类啊，然后视角里面还有一个，我们着重强调的是单机管理，只能说1.0，万一2.0我有钱了，加个集群功能、分组也不是不行，但是我们强调的应该是实时管理，而这个实时管理，相对以前来说，以前可能是一个月对一次，你现在可能是你一直挂在上头，这个时候，对于你来说，要解决问题，肯定是这一天都在这上的混，不可能说问题没解决，把软件一装就完事，不会的，因为数据按正常来说，只要你把这个系统搭起来，跑起来几秒钟以后就有数据了，Zabbix的数据是随缘的，因为你不知道哪个地方出错，当然这个Reset For其实你也不知道，但是好歹你能排错，Zabbix是排不了错的，为什么？我到处都是模块化，他能不能工作，你拿出来运行一下就知道了，再说了，强哥是日志工程师，作为日志工程师来说，我会有完整的日志。</p>
</div>
<div class="paragraph">
<p>所以这是主要的几个区别，好了讲了这个那么基本上给我们服务端这边东西定性了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_取名字的作用">8.6. 取名字的作用</h3>
<div class="paragraph">
<p>谁知道为什么：名字取不好代码就写不好？</p>
</div>
<div class="paragraph">
<p>名字取不好就证明你不清楚你的娃，你想让他成为什么样的人才？你对他的希望就属于随便一个都可以，然后换成写代码这件事来说的话，好像这个功能也可以加，然后写到中途就加了五个需求，好像分组也要，好像那个阈值也要，好像短期推送也要，都加上，然后到后面了，似像非像，到时候变成了不像个日子管理系统，也不像Zabbix，你也不像你自己，我就不一样了，我这种人就是一根筋，我要做的事情我想着法说服你，你必须要这么做，你不这么做，我就来，我带着你做，如果你反抗这么做，我换人，要么是我把你开了，要不是老板把我开了。</p>
</div>
<div class="paragraph">
<p>所以名字取不好就意味着你对你的程序功能不清楚，如果名字不好，就意味着需求或者是功能不明确，需求或者是功能不明确的话，你代码一定写不好。</p>
</div>
<div class="paragraph">
<p>刚刚讲的为什么要造轮子就相当于是明确需求，说白了就是项目背景，只是现在我们还没有到整理项目文档的时候，为什么？写程序写代码永远是从代码和技术出发，不要一来就给我整项目文档说明书啥的，那个东西是用来做企业管理的，作为一个普通人，你不应该去考虑那个东西，你应该考虑你的用户怎么用，就算你不写文档，你那么做了，用户也买账。</p>
</div>
<div class="paragraph">
<p>所以文档是用来做沟通的，是用来做团队配合和管理的，所以现在知道为什么名字取不好代码就写不好了，因为你的需求会无限膨胀，我以前给波波讲过一句话叫什么？</p>
</div>
<div class="paragraph">
<p><code>你写代码的过程实际上是一个收敛的过程。</code></p>
</div>
<div class="paragraph">
<p>它在聚拢，需求在聚拢，你的重点也在慢慢的聚拢，为什么？你写完了你的代码应该有几个重点，凡事和重点无关的都是次要的，到现在为止我们都没有讲接口访问需要验证，因为他现在不重要，你的内部还是α版本时候，他是不重要的，但是一旦你发不出去，那个时候就重要了。</p>
</div>
<div class="paragraph">
<p>所以这个时候，我们在这个阶段，你要聚焦，你要收敛你的重点、收敛你的需求、收敛你的思维、收敛你的精力，把它们聚焦在特定的某些重点上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_球眼系统qiuyan服务端设计">8.7. 球眼系统（QiuYan）服务端设计</h3>
<div class="sect3">
<h4 id="_postgresql">8.7.1. PostgreSQL</h4>
<div class="paragraph">
<p>就是为什么不用Mysql，Mysql其实是很廉价，其实也就很普通，一个关系性服务器，PostgreSQL的话，相对来说它的代码包括它的理念都是非常非常好，Mysql那会儿没事务，那么PostgreSQL很早以前就有事务了，两个相差多久了？大概4-5年，所以你知道他们两个带差了，基本上差一代到两代，所以第一个就是持久化存储，选择用PostgreSQL。</p>
</div>
<div class="paragraph">
<p>这里面有几块数据：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>统计：我们有统计类的，但是我们没有用ES也是意味着我们在写代码的时候，你要考虑不要跟我写慢查询了，要合理的设计，规避复杂的查询，当然我没有说加索引解决不了，他能解决，但是他一定是一种被动措施，那个一定是没办法的时候加，正常来说你写代码肯定是要加索引的，但是你不能全靠所索引，为什么？因为所以像like 关键字，很多东西是没有办法生效的，然后这个时候，你不要和他违背，随着你写代码的时候一定要通过良好的设计，避免去做复杂的查询，什么叫复杂查询，一次性查五个表，你那有问题，你知道吗？你既然一次性查五个表了，你为什么不考虑一下第一个？为什么你要查五个表，你查五个表正确的选择？你需求拆分出了问题？如果需求有问题拆需求，如果表有问题拆表，如果都没有问题，请你自己提高你的技术水平。</p>
</li>
<li>
<p>持久化：持久化是将程序数据在持久状态和瞬时状态间转换的机制。 通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）。</p>
</li>
<li>
<p>缓存：通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP缓存，变得更加响应性。</p>
</li>
<li>
<p>时序（集群）：打个比方，你手机里面你要监听控他的cpu，那你应该是只有一个cpu的使用率。再加上个时间戳,上一秒90%，下一秒100%，下一秒10%，你看到没有它的列一共就两列，而且是随着时间一直在不同的变化，那这样的话，这种数据非常非常容易绘图，这种非常容易绘图的数据就是时序数据，为什么？因为他不会随着业务，其他的变化你也都发生变化了，不会的。它使用就是这个cpu，那个字段一直在不停的变化，你是服务器嘛，无非是多了几列嘛，你现在是每次收集一次基础信息，那就是一行，比如说你要把cpu内存单独放，也不是不行，他也是随着时间变化的变化，所以理解什么是时序数据库。这是时序本身也支持集群。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以有统计类的数据就是这种是要保存的数据，还有一种缓存，然后这地方涉及到一些时序数据，所以选PostgreSQL是非常非常正确的选择，Mysql没有办法兼顾那么多，这个是大的技术点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_springboot">8.7.2. Springboot</h4>
<div class="paragraph">
<p>选的是Springboot，选Springboot是这样的，服务端嘛你给我两三百兆内存，让我跑一下那是可以的，就一个嘛他又不多，为什么选他？其实你除了Java以外，你就只有PHP可选的，但是你写PHP的话，你以后接手的维护的时候很麻烦，因为人太少了，你的生态不好弄，你用PHP就会把你的页面的展示还有你的整个逻辑全部用PHP代码合在一起，然后这个时候你就没有办法分开，那这样的会导致在维护的时候，你可能那个人又要懂界面，又要懂PHP，而且调试的时候很麻烦，因为PHP调试的话，虽然他有方法，但是他始终没有Java成熟，打个断点就调了，这个是一个，然后另外就是虽然Web编程PHP更快，但是Java能够写更少的bug，这个也是选择他的原因哈，所以服务端我们都不叫他Java应该叫Springboot。你装个PostgreSQL装个Springboot，啥都不用干，你只要装了Springboot你连Nginx都不用配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_react">8.7.3. React</h4>
<div class="paragraph">
<p>我们当时说是用React，为什么用它，主要是因为它复杂，他要是简单我才不用他呢，为什么不用简单Vue要用React，之所以他复杂是因为他有设计，还有各种设计模式，还有各种编程的抽象，那么你写他的过程当中，你会体会到这种设计带来的好处。还有你要付出的代价，设计的越好意味着使用成本越高。界面用React，然后至于，CSS平铺这些东西就bootstrap就可以了，那个React里面在那个界面布局没有，就用bootstrap做布局哈，扁平布局。</p>
</div>
</div>
<div class="sect3">
<h4 id="_only_pc">8.7.4. Only pc</h4>
<div class="paragraph">
<p>只有pc端没有移动端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_时间通知回调http">8.7.5. 时间通知，回调（HTTP）</h4>
<div class="paragraph">
<p>事件通知嘛，我们直接用回调，肯定用HTTP。</p>
</div>
</div>
<div class="sect3">
<h4 id="_大致过程">8.7.6. 大致过程</h4>
<div class="paragraph">
<p>用户代码调用我们的sdk，构造了一个URL向Agentd上报数据，比如说每隔一秒钟向Agentd报一次cpu的数据，报到Agentd，那么他要做汇总，他汇总完了过后再把那个Json统一报到Server，等于说他汇总，比如说这个地方是一秒一次，那一秒他如果收到数据他就报没收到都就算了，那等于说他每一秒钟都会报，空的也不是不可能是可能的，那空的你报啥呀？空的请你直接跳过，谢谢。这样报到Server，这个地方首先是Springboot收到了，收到了过后，他要把那个Json转成Java对象，那么做一些简单的业务处理，该保存保存，该怎么怎么样，然后最后就落地嘛，就保存到数据库里面做持久化，然后这个时候做完持久化有一些东西要做缓存的，他加到缓存里面有效保存到时序，比如那监控数据，你可能就放到时序（集群），统计数据是什么时候用的，是用户来访问网页。这个是技术点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_怎么使用">8.7.7. 怎么使用</h4>
<div class="paragraph">
<p>我打个比方，你肯定有登录界面，我这个时候就从用户出发了，用户来请求，那用户来用的话，首先肯定是怎么登录？那肯定就是典型的账号密码咯，典型的账号密码登录那登录进来，登录进来过后，那么你有首页，首页虽然我现在不知道长什么样，那肯定有，有什么目录菜单之类的东西嘛，Zabbix他是把他的菜单放在中间就是顶部的，他是放在一排他不是竖着放的，还是横着放的，但是那个感觉不符合中国人的习惯，我们都叫球眼呢，都用拼音的，自信一点，我喜欢竖着排的，那所以这个地方大大概的布局应该是这样的，这个地方应该有logo，然后这个地方是菜单，然后这个地方是应该一些登录的注销，然后这个地方是应该是一些，当然可能有些文字，大概是这种布局噻。</p>
</div>
<div class="paragraph">
<p>那这个数据里头肯定有一类是这个样子的就是这图形里头肯定有一类数据是这样的。如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/折线图.png" alt="折线图">
</div>
</div>
<div class="paragraph">
<p>这个就是统计类的。</p>
</div>
<div class="paragraph">
<p>另一类是这个样子的。如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/表格图.png" alt="表格图">
</div>
</div>
<div class="paragraph">
<p>这个就是展示类的，去浏览信息的原始数据。</p>
</div>
<div class="paragraph">
<p>当然有柱状图折线图，我只是说有图，有图有表，你肯定还有某些表单嘛，那是表单那种是涉及的编辑的，现在对于我们来说，我们先管上报的，上报出来有一类统计类嘛，而表格是展示，就是让你浏览，去浏览那个信息本是原始数据嘛，那这样的话你倒过来，你登录，登录到了这个界面，然后点某个菜单你可能浏览某些一条一条的数据，然后你可能还在首页上面有些图形简单的，比如说你有几台机器，你可能在这个地方，你两台，然后这个地方就是当前有些是异常的数据或者是说你能判断的东西也会概要嘛，那除了这个以外，这种是浏览性质的，然后你浏览完了后面不是有操作按钮，然后什么增加删除啥的，总的就那么两类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_界面概念图">8.7.8. 界面概念图</h4>
<div class="imageblock">
<div class="content">
<img src="images/登陆概念图.png" alt="登陆概念图">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/界面概念图.png" alt="界面概念图">
</div>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_QiuYang_chapter">9. 球眼系统设计(八)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_9">9.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/球眼系统设计(八)板书1.jpg" alt="球眼系统设计(八)板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_控制策略">9.2. 控制策略</h3>
<div class="paragraph">
<p>之前我们一直讲的是说我们的用户程序直接往上报，服务端是不需要管任何就是情况的，但这个地方有一块必须得讲的，就是说服务端一定会去下发某些策略去控。</p>
</div>
<div class="paragraph">
<p>打个比方，我们昨天简单地提到一个启用、禁用的问题，首先禁用那个程序本身就是User程序本身不应该让用户去修改配置文件，因为那个东西太原始了，如果这么玩的话，那不得把人给累死，所以在这个时候，用户是不需要去修改配置文件，由他在Web服务器的网页上，点一个启用、禁用后，插件就不应该停止工作，所以涉及到启用、禁用的问题，我们之前有讲一个就是命令，当时我们是这么写的</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`agentd -m cpu start`</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方有start，那就应该有一个stop。</p>
</div>
<div class="sect3">
<h4 id="_when">9.2.1. When？</h4>
<div class="paragraph">
<p>那现在就应该是说什么时候启用、停止？</p>
</div>
<div class="paragraph">
<p>就是说我默认情况下面Agent启动的时候它首先应该扫描，然后扫描到有那个配置文件，然后，就把对应的模块自动启起来，但这个是基于我们的默认控制策略，那一定还有用户端的配置策略，所以在启动的时候，Agent应该问一下服务器，扫描到的这些插件，默认我要启动了，那服务端应该告诉客户端，给客户端个清单，启用清单或者禁用清单，首先你要把扫描到的配置报给服务器，服务器收到过后，告诉你这些配置里面哪些是禁用的，就相当于把那个清单先发上去，他就回你，因为是这样的，比如说这个机器上面启用了哪些模块，就是默认能找到哪些配置文件，一定是他去扫描过后才会得这个清单吗？所以服务端的这些模块、配置也好，应该是来自于客户端的扫描，扫描过后上报给服务器，然后用户基于上报的清单，把它拿来做编辑，编辑完了再下发给客户端。
那这个过程当中有没有必要去做一些存储的东西？比如说你的，服务端记一下有哪些模块是客户端的，有哪些模块怎么怎么样&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>那有个问题：</p>
</div>
<div class="paragraph">
<p>要是你在数据库里面去记录了这个模块的清单，那啥时候更新？</p>
</div>
<div class="paragraph">
<p>这里从我的直觉来说，客户端他在启动的时候，每次启动都报一次，或者每次Reload的时候，意思就是他只要重载了配置文件，他就报一次,那关键是还是有个问题，服务端用户，他肯定有启用，禁用，启用肯定不用说。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_交互过程">9.3. 交互过程</h3>
<div class="sect3">
<h4 id="_简单的梳理逻辑">9.3.1. 简单的梳理逻辑</h4>
<div class="paragraph">
<p>所以说就要讨论这个交互过程啊，首先，我把这个逻辑简单梳理一遍：</p>
</div>
<div class="paragraph">
<p>1.agent启动的时候要做扫描Config文件，然后得到一个Mod的清单，包括一些配置。</p>
</div>
<div class="paragraph">
<p>2.配置完了过后Agent把这些数据ConfigA直接报给服务端。</p>
</div>
<div class="paragraph">
<p>3.不管他中间发生了什么，服务端又把这个ConfigB下发他</p>
</div>
<div class="paragraph">
<p>4.Agent收到ConfigB的时候就Reload</p>
</div>
</div>
<div class="sect3">
<h4 id="_合理性">9.3.2. 合理性</h4>
<div class="paragraph">
<p>这是我最简单的一个直觉啊，就是我觉得应该这样做，所以我们现在讨论它的合理性或者说这过程当中有什么东西没有考虑到的，你肯定自己的配置文件里面要配服务端的ip地址啊，要长链接吗？他既然能上报他，第二次再来请求一下处理结果吗？上报的时候服务端自动就下发了，打个比方，我们先讨论大的逻辑，波波提了个很好的问题，因为HTTP是没有状态的连接，他请求完了，就会断掉，然后这个时候，服务端是不能向客户端发送数据的，所以以前的Zabbix是长连接，是用的Socket，就可以一直保持在那个地方，但对于我们来说，我们应该没有动机去做一个那么长的连接，顶多是在这个业务的发送期间，一秒一次那个连接数，我觉得它不是个问题，要是你有那么多机器，你直接把那个HTTP的keep live打开，其实性能是没有问题的，但是在业务上面，其实就是断掉的，因为HTTP是没有状态的，上次我们在讲报文的时候没有提这个是因为HTTP的行为，还不是现在考虑的一个因素，所以现在整个逻辑当中还是有问题的，就是用户在什么时候去配置那个东西？打个比方，你之前报了个清单上去，然后用户改了还往下丢，那么在丢的过程中，客户端怎么来拿？比如说是客户端下一次来请求的时候。</p>
</div>
<div class="paragraph">
<p>这个地方先提个概念：</p>
</div>
<div class="paragraph">
<p>pull和push，在git中用push的时候就是你作为客户端向服务端推，这就是Push，然后pull的话就相当是说你作为客户端把服务器上的东西拉过来。</p>
</div>
<div class="paragraph">
<p>这个地方也有这个概念，以你自己为基点，你向服务器推还是向服务器拉都是用的HTTP，都是客户端主动发起的，就像你的浏览器一样，你不点他，他不会有自己请求的，但是聊天室就不一样了，为什么？聊天室随时随地都在发消息，收消息，他是一直有交互的，所以这个和典型的聊天室是不一样的，是基于C/S结构，基于C/S结构的时候普遍意义上都是这种状态，当然如果是典型的Socket连接，他是可以做的长链接的，但是他也是有推和拉这两个动作，只是说那个连接断不断的问题，但是我们这个地方连接是断的，那直觉讨论的话，这个里面还是有些细节问题，我们就不管这个。</p>
</div>
<div class="paragraph">
<p>首先默认情况下面我们默认的模块，它是不能禁用的，禁用他没有意义，我们就假设默认模块是不禁用的，但是像那种HTTP监控它很耗资源的，用户就可能考虑要不要用的问题，所以这个时候相当于是说系统一定是先跑起来，有了HTTP整个监控，然后他不需要这个东西，把它禁用了，这是一种，还有一种就是说那个东西本来就非常非常耗内存比如说就TCP监控，HTTP比较还是少数，但是tcp包含了很多的东西，那这个时候你的监控啥的，东西就很多，这样的话就更耗性能的，所以TCP监控默认情况下应该是禁用的，因为越耗资源的东西就是不应该启用，这种时候，用户禁用有几种办法？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一张情况：登录那个客户机上面，把配置改一下，改完了过后把Agent Reload。

第二种情况：在网页上点。</pre>
</div>
</div>
<div class="paragraph">
<p>既然我们之前说的你用我们这个系统，就基本上可以脱离人工管服务器，简单的意思就是说，你要在服务器上那个网页上去实现启用和禁用的问题，所以这个地方就应该有同步，什么意思？你的机器上面有一份配置清单，那在服务器上看起来应该也有，不然他编辑页面出不来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方：

这次我禁用了，等一会你把Agent重启一下，可能又启用了。</pre>
</div>
</div>
<div class="paragraph">
<p>那这样反反复复的对用户体验不是很好，所以我就理解为这个过程当中应该是这样的：首先客户机有个注册的过程，这个注册就比如说你的ip地址是A，那么你把这个A告诉服务器说A上线了，请接收一下，那么服务器说ok，服务器清单里面有这台ip地址，那服务器就信任你了，开始接受你的数据，所以机器应该有一个注册的过程，这个地方控制策略其实涉及到一些基础的交互策略，我没有把它单独拎出来讲，是因为它属于很多业务功能里面必须的东西，是逃不掉的，所以到时候我们遇到的时候，单个单个来讲，那现在看起来是这样的，就是这个Agent上线的时候，他应该向服务器有一个注册的过程，注册过程发起过后，服务器应该有个白名单，总不能谁的都收，那就解决了安全隐患。</p>
</div>
<div class="paragraph">
<p>所以服务器上应该有个白名单或者是说注册的时候带秘钥或者Token，然后Token是服务器颁发到你填到配置文件里面，不管是服务器白名单或者带Token都可以验证身份，但是这个不是我们现在要考虑的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_怎么同步客户端和服务端的清单">9.3.3. 怎么同步客户端和服务端的清单？</h4>
<div class="paragraph">
<p>现在我们要考虑的就是：注册完过后，什么时候服务器要刷新那个清单？</p>
</div>
<div class="paragraph">
<p>这是一个问题，我的理解是要刷新的话，就是Agent要向服务器报，首先启动的时候要报，Reload的时候，要报，还有加载配置的时候，也要报，但是这个报的话，他报的这个东西如果用户编辑过怎么办？那Agent要把这个东西记下来，但是我觉得这个好麻烦，有没有更简单的方式，就是能不能让Agent不去记录这些东西或者是说只有一个人有这个清单就可以了，我打个比方用户编辑清单的时候服务器上不保存。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

用户打开插件列表的时候，应该是Agent上一次报过来的清单，那这个清单，就是在服务端上是个缓存，用户编辑过后，下一次Agent再来报的时候，服务器就把最新结果返给他，因为请求嘛，我要发给你东西。</pre>
</div>
</div>
<div class="paragraph">
<p>所以现在看起来这个是Agent应该有一个定时的心跳，比如说每隔几秒钟有一个心跳，问一下服务器你有没有东西要发给我，然后这个时候，你把你要控制的东西发给他，因为HTTP没状态，就是这个样吧，要不停的问，然后这个机器多的话会不会有问题？</p>
</div>
<div class="paragraph">
<p>比如说，假设有1000台机器吗？1000台机，每五秒钟问一下，或者每十秒钟问一下，相当于一秒钟就有100台，每一秒钟就有100个并发，还是有点吓人，那这个并发有点多，1000台有100个连接，不对，我们之前是每隔一秒钟，客户机就会向服务器报，那1000台，肯定最少都有100个兵法，用长链接也会有这个问题，但长链接的好处是这100个病发不用三次握手，但是如果100个app的话，就把keep live打开，他也不用握手，其实性能没有问题，那这样本质上是一样的，性能没有问题，就假设你这种配置你一定不需要马上生效，30秒生效都是可以的，所以我把它降成30秒，因为禁用这个东西又不是啥重要的，但是用户启用的时候可能就很着急，之前规划Agent本来就有个端口，那就直接把它作为服务端，让服务器来请求他，那这样的话就没有定时轮循的问题了，客户端每隔n秒向服务端发一次，叫定时轮询，那Agent本来就有一个端口，因为你的用户程序向客户端上报吗？那个端口也可以让服务器用，所以相当于是说Agent又是服务端，也是客户端，那这样的话才能保证，因为如果用TCP的话，那个维护难度对人员的要求太高了。</p>
</div>
<div class="paragraph">
<p>内网必须要公网ip，有没有那种内网？我觉得这个应该不是我们关心的，打个比方，你的服务器都有一堡垒机，你把那个服务器部到外面客户端里面，我觉得你是吃饱了撑的，然后如果你服务器在云端，然后你说客户机吗就自己用Frp内网穿透吗？关我啥事啊？我才不考虑这个问题呢，因为这种问题毕竟是少数，甚至你用ip tables都可以解决，你无非就是个端口转发，相当是用Nginx加个反代，因为我本来就是HTTP，我用它的目的就是为了维护方便，你就反代嘛，你加个反代有啥问题？但是你像Zabbix用Socket连接来反代，肯定麻烦，你还搞不来，但是HTTP是个人都可以。</p>
</div>
<div class="paragraph">
<p>看起来这个地方讨论出来了，就是相当于是说Agent，他有一个8080的端口，我们的服务端在注册的时候顺便把自己的回调的URL告诉了服务器，然后服务器有事通知他就回调，所以他在启动的时候哈，他要做几件事情他要去注册，注册的时候包含了什么？包含了自己的ip地址端口，那么还有回调就是用于更新配置，所以他的启动是要去注册嘛，注册的话就相当是有这几个，当然你说有注册肯定有注销，那服务器把你删了就可以了嘛，我觉得这个讨论清楚就是他的行为就是更新配置就用回调，然后用户改了某个插件然后回调，然后Agentd收到过后，看起来Agentd应该有数据库要存储，那客户端我肯定不会装PSQL的，我看一下，那就用那个SQLite等于说Agentd这边就有数据持久化，但那直接给配置文件呢，我就相当于是说我不关心存在，那我存在文件里面也是可以的，那持久化配置啊，直接用文件去做这个处理，我一个数据库我都不想用，因为你能配置东西其实很少，就刚刚涉及到的嘛启用禁用插件，涉及到要配置的东西就是启用禁用，更新插件，用户说他改了东西，要重启下，插件要重启嘛，在服务端上上传插件分发，等于你要去管理他了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_分发系统">9.4. 分发系统</h3>
<div class="paragraph">
<p>上面说我们不想用数据库还有为了方便用户，我们是时候写个yum，因为我一点都不想去做分发，我想的是调那个yum命令然后那个命令自动自动把这些东西装好，包括配置文件都配好，所以这个地方看起来涉及到插件的启动，因为插件的启动有可能你更新的过后你不要不想手动去启动，就这个地方类似于Reload，那这个地方看起来有一个插件的升级和分发，是时候写个yum了，然后yum根据规则我们定义好，我就告诉这个客户端执行这个程序分发，有什么情况下他需要去更新那个东西？首先，他有几种情况嘛？他是命令都换了，他重新注册插件，所以这个地方有升级还有插件的注册，我觉得这个才是我们想要的目的嘛。我们先不要考虑他的复杂性，用户点的越多我们越复杂，有多少人就有多少智能，那所以这地方看起来有注册嘛，有升级嘛，肯定还有删除这些去管理操作嘛，所以这个地方插件启用禁用，还有一个开启和关闭，其实可以这样做，就是Agentd就是把所有的东西全都装上了的，只是全部是禁用状态的，然后他就是想要什么点开的时候只把要才能启起来，不过他自定义的时候呢？都能自定义了，自己上去摸一下，当然就是你的意思就说都是我们写嘛但是我们得为长远做打算你刚说的是1.0版本，我们可能1.2的时候就支持用户他用我们的sdk自己写一个插件啊，自己写个插件过后怎么去注册呢？相当于是说我们的服务端是一个源，然后他用yum命令去调这个源上的数据，首先东西的分发绝对不可能通过这种我们这种HTTP来完成因为他是个单独的逻辑，就像极了你在你的电脑上用pacman装PSQL但是我们比那个PSQL更高级一些，因为配置啥的都没改，他只是装上，我们相对是带了一个我的大脑，然后你调我们的那个yum的时候，他会把这些配置啊或者你想要的密码全部都给你配好，所以分发绝对不会和主系统合在一起，他应该是两套子系统，分发只是触发了这个动作，他触发了那个Agentd去调用一样，我们先不讨论那个HTTP请求，你那样就把这个分发搞复杂了你的pacman /yum是怎么样的，我们写的东西也是怎么样的，没有没有区别啊？就相当于是说Agentd去调那个yum，比如说yum install  cpu模块，然后这个时候yum就会去请求他的原地址，他原地址上就有一个URL，然后他就把它下来装到电脑上然后比如说刚好我们那个规则里面有一个东西是写配置文件，写到他的目录下面去，就等下一次Relaod，当我们发现有更新的时候就Relaod的，Relaod他装完了，因为就像yum命令执行结束嘛执行的过程，我们的这个监控系统是球眼是不关注你的执行过程的，但是你的yum执行成功嘛，然后他就会自动执行Relaod，因为是他触发的这个调用yum嘛，所以说一旦上一条命令执行成功就Relaod，如果执行失败就不Relaod就报错嘛，就返给服务端，主动告诉他说有错，所以那这个地方就相对是我们有自己的一个分发系统。</p>
</div>
<div class="paragraph">
<p>那分发系统有了，然后Agentd他调他调完了触发安装过程，安装过程他不管，他只管上条命令执行成功，现在问题来了，分发系统啥时候装啊？是装Agentd的时候顺带就装了吗？所以刚刚说的我们应该有一个分发系统，这个分发系统一定是独立的，而且一定是通用的，不仅是应用在我们这个项目上面，他应该是把我的运维经验， 用配置规则的方式把我的经验纸面化，形式化，那这样的话就是你不用再担心装了Mysql下一步应该干嘛，你一般你装的Mysql你要先去start，start过后发现没有用户的去建用户一堆乱七八糟的事情，所以要把这些过程按照我的经验，我的经验不行，你再把你的经验文件传上去嘛，然后这个时候名字不一样噻。你肯定是安装的时候你要跟个fifilu/Mysql，这是表示我的仓库嘛，那这样的话就用我的经验，然后用Lixi/Mysql就用了李喜的。用户至至少自己可选，就把他的经验重复了，一旦重复，那个剩下的人就没有价值了，工具人连工具都不是了，所以那这个地方分发系统之前我还没想过这个，但是想到这点跑不掉。因为因为什么啊？因为我可以完全可以写一个李喜/球眼—model—cpu嘛，所以这个地方受到插件管理，还有分发的应该就这些，就这些具体去管Agentd的应该是没有的，为什么？因为这个东西是一个中控。他的中间要去调度控制或者接受控制，所以对于他应本身应该没有什么管理，主要是对他下面User这一层。你要启用禁用分发新增删除，删除很简单嘛，remove，如果他真的要删的话，但是一般最好禁用，但是他是强迫症他想删，你让他删，但在默认的cpu内存硬盘这种就不要删了，为什么那种东西在proc下面的文件又不耗内存又不耗性能啥的删他的干嘛，删的一定是那种他自定义只有自定义的才能删，我们自定义的他只能禁用，不然用户会把你系统搞坏的啊。所以又回到最初那个问题就是服务器怎么去完成这个动作。就之前想不通Agentd怎么交互的，回调，用回调就解决了，因为有回调啥事都可以做了。至于刚波波说的内网的问题啊，这个地方回调涉及到一个内网穿透的问题。这个问题就是我们不处理，他作为专业的人，他应该清楚，所以我们以后在我们的这个球眼的官网上要注明，服务端和客户端如果不在一个局域网，请内网穿透，详情请见frp文档，就是你都搞得那么复杂了。你一定是个专业的人。我相信你。你能搞定的，如果你搞不定，请你把它挪到一个局域网去，当然他说他要加速VPN更牛逼了,企业级内网穿透。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_QiuYangAPI_chapter">10. 球眼系统设计(API系统)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_10">10.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/API系统板书1.jpg" alt="API系统板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是api">10.2. 什么是API</h3>
<div class="paragraph">
<p>API（Application Interface）就是应用程序接口</p>
</div>
<div class="paragraph">
<p>我们之前在做设计时Rest For规范，当然这个东西肯定是基于HTTP的，存在一层递一层的关系，那API有什么东西需要我们特别关注，单独拎出来讲，而不在我们设计的过程当中讲？因为所有基于浏览器前后端分离的项目，它都有API，它是一个很重要的子系统。</p>
</div>
<div class="paragraph">
<p>API系统设计，里面掺杂着很多的点，打个比方</p>
</div>
<div class="sect3">
<h4 id="_参数校验">10.2.1. 参数校验</h4>
<div class="paragraph">
<p>第一个，要用API通信，你的后端是Spring Boot，那这个时候你有Controller，上面就有url的映射，那里面应该还有参数的解析，因为他要把HTTP报文解包，解包完过后，你的Controller就收到一个参数对象，然后拿到参数对象过后，要在里面做逻辑，这个逻辑，拿了参数过后，第一件事情要判断参数是否符合你的预期。</p>
</div>
<div class="paragraph">
<p>在行内，有一句话叫： <code>“用户的输入永远都是不可信的。”</code></p>
</div>
<div class="paragraph">
<p>那这个时候你要对参数进行校验，校验完了过后才是怎么去用参数，比如说你用那个参数去拼SQL或者用参数去构造对象或者各种数据结构，然后传给下一个Service，这个时候逻辑才是通的，这个过程当中，还只是讲了参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_身份认证令牌">10.2.2. 身份认证（令牌）</h4>
<div class="paragraph">
<p>那第二个问题就是：谁都可以访问这个API？这个时候你就要对身份进行验证，你是预期的那个用户吗？像以前我们做身份验证就很简单嘛，一个账号一个密码，但账号密码有个问题，你在网络上传输账号密码那个是不安全的，虽然你可能用了HTTPS，但是你也不敢堵定他机器上没有木马，这样的话，一旦密码被泄露了，你就要登录到网站上去修改密码，这是个很复杂的过程，所以后面大家在做API通信的时候，就倾向于使用Token，意思就是说我发给你了一个东场的令牌，你可以畅通无阻的进入到这个系统里面，不管是你出关或进关，都ok，为什么？亮出你的令牌就可以了，这个令牌中文叫令牌，英文叫Token，所以Token就是一个叫身份标识的东西，用账号密码其实都是可以组成Token的，但是账号密码太重量级了，什么意思？比如说一个人今天登录一下我的服务器，我就心想：我要给他密码的话，我的网银也是这个密码，万一他知道我密码连蒙带猜的话，他就能猜到我的银行卡的密码了，那这个时候我肯定不会给他我服务器的密码，那怎么办呢？给他一个证书嘛，给他一个令牌，这个令牌就是身份标识某种介质，这种介质证书里面就包含令牌，也可以用字符串，那个字符串内容就是令牌，或者给你个U盾，你U盾不插到电脑上，你付不起款，为什么？你不能访问银行的付款系统，看到没有，这个是令牌。</p>
</div>
</div>
<div class="sect3">
<h4 id="_整体设计思路">10.2.3. 整体设计思路</h4>
<div class="paragraph">
<p>API系统除了这两大块还有第三块，就是他的整个设计思路，一般来说，一个前后端分离的项目会面临一个问题，如果你是团队协作的话，经常会出现一个人的问题：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`“听前端还是听后端的？”`</pre>
</div>
</div>
<div class="paragraph">
<p>这是一个老生常谈的问题啊，听前端就意味着前端要什么格式，给什么格式，但是你不要忘了一件事情，如果前端要什么，给什么，这就意味着你的代码是非常非常凌乱的，最后就变成了祖传代码，谁也不想去动，为什么逻辑是乱的？因为动一下就有Bug，最后就不敢动了，所以像我的代码，我十年前写的代码，现在我GitHub上的代码很多都是十年前的，就算十年前的我相信到现在你都是能看懂的，为什么？因为我有自己的代码规范，然后我的函数命名也是ok的，整个逻辑是清晰的，所以为什么把API提成系统？是因为你这个API里的各种接口，它要组成整个球眼系统的后端逻辑，就是除了Web界面以外，所有的逻辑的蕴含在你的Agent层面上面，为什么？你的Agent是给其他子系统模块做交互的，我之前讲过的，其实你在内部写的再丑没关系，但是你的接口给出去如果很难用就麻烦了，打个比方，你是阿里云的程序员，你写了个接口，用户可以获取你的云服务器的信息，但是你设计的接口，他可以获得整个大服务器的ip地址列表，然后用户拿到那个列表过后，自己在里面找哪个是你的？我相信我都不用再讲下去，你就知道这个设计是有问题的，都先不管他安全的问题，明明我只需要一条数据，你给了我1000条这是有问题的，这是过量的。</p>
</div>
<div class="paragraph">
<p>所以在这个情况下的API系统涉及到第一个那么就是说，他是整个业务的入口，那么你要做基础的校验这些东西，那么你就需要把它提到一个子系统的高度，在参数校验的时候应该有统一的逻辑，统一的处理方式，比如说要解决SQL注入的问题，别人乱输入一个参数，比如说输出个rm -rf就把文件给删了那是不应该的，这种就叫参数安全，还有一种安全叫身份认证，你要知道这个用户是谁？他有什么权限？你必须要有个用户标识，以前我们做登录系统的时候，就是说我可能有一个用户名和一个密码，我登录完了过后我在数据库里面查一下，我就得到个user id，我就在我Java代码里到处用那个，以前是这样做的，然后现在你拿到Token后，就只需要从那个Token里面把User ID解出来就行了，那个字符串里面是有藏着秘密的，这个等一会我们再提。</p>
</div>
<div class="paragraph">
<p>那么第三个就是：API系统是整个系统的核心，它必须有完整的，严谨的设计，所以在这个地方什么是API，或者是说API的作用，这个你是不需要过多解释的，你想的应该是API怎么用？那么我就把两个问题合成一个问题。</p>
</div>
<div class="paragraph">
<p>API就是模块间交换数据的手段，但并不是唯一手段，你可以有很多种，SQL可以FTP可以，纯HTTP也是可以的，甚至你可以用图片，比如说那个在图片上藏了密码，你带上个特殊眼镜，你就能看到那个上面的密码，看到没有这个也是在交换数据，只不过他的媒介是很特殊的东西。</p>
</div>
<div class="paragraph">
<p>所以总结下来：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`API是模块间交换数据的手段，我们是通过Rest For API接口实现。`</pre>
</div>
</div>
<div class="paragraph">
<p>这样就可以了，不要去解释什么是数据，那是不应该的.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_api的特点">10.3. API的特点</h3>
<div class="paragraph">
<p>那API有什么特点?它有什么？</p>
</div>
<div class="paragraph">
<p>这个时候我们讲的肯定不仅仅是我们的系统，我们设计了这个球眼系统，它是标准的前后端分离，可能没做之前，大家会认为一个监控系统能有多难，但我相信现在设计完了，你知道你一个人绝对做不完而且给你一年的时间你也做不完，为什么？因为它有难度，你可能能够做其中一部分，但是你做不了一个完整的系统,为什么？</p>
</div>
<div class="paragraph">
<p>因为没有任何一个软件系统是简单的</p>
</div>
<div class="paragraph">
<p>如果一个人软件简单，那一定是幻觉，为什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

比如说波波，他的业务，他说两个星期就做完了，真的吗？真的是两个星期吗？还是说你是限定需求，我只是实现某些需求，或者是我把需求的范围给限定，然后这各种卡，最后你做出了一个迷你的软件系统。</pre>
</div>
</div>
<div class="paragraph">
<p>所以它是相对简单，他也不简单为什么？要是那么简单，你的老板咋不自己做呢？五点钟跟你确定了需求，5:30就问你做完没？那这个时候你恨不得对老板说：“来你来，你做完我给你发工资。”</p>
</div>
<div class="paragraph">
<p>这个时候一个标准的API系统，我这个地方强调的标准是我认为的标准，我肯定是最严格的标准,但是当我看到业界这些程序写的代码的时候，参数校验是啥？不知道，为什么？我就这么跟你讲：十个程序员中的九个，校验他只做一件事情，那个密码的长度最长20位，完了，至于里面是啥，不管，甚至很多时候如果你不强调这个校验长度的话，那九个人就连那个长度都不想验证，我都的高估他们了，他们之所以去写这个校验，是因为是别人提的需求，但是如果大家都不提的话，你放心，参数校验没有一个人做，所以参数教练看起来是一个大家都知道的事情，但是大家不愿意做，为什么？因为他没有效果？那什么时候有效果？你被黑的时候就有效果了，然后这个时候，你花了一个通宵把你公司被黑的问题解决了，发个邮件煞有介事的说我们修复了一个安全漏洞，那个漏洞可能就是你自己留下的把柄，自己给自己擦屁股可爽了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_api的标准">10.4. API的标准</h3>
<div class="paragraph">
<p>那么我说的这个标准，肯定是最严格的，就是他应该是什么啊？我们有自己极客营的标准。</p>
</div>
<div class="sect3">
<h4 id="_参数校验_2">10.4.1. 参数校验</h4>
<div class="paragraph">
<p>第一个，那肯定是参数教验，参数教验包括什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

一个用户注册，他肯定有用户名，那么这个时候，校验你可以分几类？</pre>
</div>
</div>
<div class="paragraph">
<p>第一个：用户名应该由纯英文组成或者下划线，这个时候你肯定是对他的格式，英文数字，字母，数字下发线组成，这叫格式，格式以外就是长度啊，比如说我们以前写域名系统的时候，就是qq.com这个域名，然后我们当时有一个最奇葩的问题，我们程序员因为那个问题改了三天，为什么啊？他是这么注册那个域名的，就是：妈妈说google百度不能抓取这么长的域名，是用拼音组成的，大概刚好128位，然后那个域名注册了过后来，我们后台要显示嘛，他的长度就把我们后台那个页面给撑破了，出现了排版混乱，每一次到了他域名那一页就要乱，但是他这个域名是合法的，因为他的域名是合法的，他没有超过那么长的位数，所以这个时候就是你程序写的时候，你就不应该展示完，你可以等他点进去嘛，所以说，你要对这些事情心里有数，当时我们那个程序员没遇到过这种情况，他就没有去多想啊，当然这个只是一个个例，但是你注册用户名那个地方我写个SQL可以吧？inset into usertable然后你成功被注入了，那他里面写的是scrptjs代码，每一次打开公司的首页，正中间弹个弹窗，对的，就是查数据库的时候把那个介词从数据库查出来了。</p>
</div>
<div class="paragraph">
<p>这就是参数教验啊，分两个步骤，第一个对格式进行校验，第二个是对长度进行校验，但我认为的格式不包括长度，长度是另外一种东西，为什么？因为长度是最简单的一种校验，他的格式是很复杂的，比如说你注册用户名的时候，哔哩哔哩他不允许你正中间出现下划线，他说：你可以当做开头，但是不能以下划线结尾，所以这个时候他的那个校验是很复杂的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_身份标识token">10.4.2. 身份标识(Token)</h4>
<div class="paragraph">
<p>身份标识这个地方通常意义上指的就是Token，你会受到几个概念？Token，cookie，session大概是这几个，其实他们从本质上讲都是一个玩意儿，这个以后再讲，但是它们的使用场景是不一样的，比如说，我是你的教练，我是你的Leder，但回到家，我是我妈的儿子，那难道在家里我就不说我了吗？，所以Token，cookie，session就是这个意思，那现在我们这个地方讲的Token，那Token是什么？你知道用他来做身份标识，但是你并不知道他是怎么组成，我刚刚讲的，他就是一个字符串，通常意义上来说，Token里面包含了几类信息？为什么？看到那个字符串，程序咋知道那个字符串标志的是谁呀？不觉得好奇吗？那个U盾插上去他居然知道是你，那就说明他里面有东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>那Token里面有几个东西组成？

第一个一般是用户编号（UserID）这是基本上必备的，表示是谁。

第二个就是Token生成时间，表示这个Token是什么时候生成的。

第三个是Token的有效时间。</pre>
</div>
</div>
<div class="paragraph">
<p>基本上就是这三类，生成时间和有效时间肯定是相对的，如果没有生存时间你咋知道什么时候过期，为什么要过期？比如说那个U盾每五年要换一下，身份证到过期你也要换，那么何况是这个身份证标识，他也要过期，但是现在有个问题，他不像身份证，花几块钱，还要做张卡，你没有那个东西？那怎么办呢？这个东西是虚拟的，你会生成一个字符串，大概是什么样子：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`ef87562c5768...`</pre>
</div>
</div>
<div class="paragraph">
<p>它就是个哈希，这个哈希要看你怎么理解了，当然有的公司为了图方便，因为哈西是不可逆的，这个时候可能为了携带这些信息，会选择另外一种方式，就是AES/DES，它是对称的，这个地方涉及到一个概念了：对称和不对称，没关系，密码学的问题，我们以后再补，现在你就只需要知道哈希是推不出字符串所隐藏的信息的，你只知道他是有效的，为什么？比如说你要把123转成哈希，但是他有没有是固定的，除了这个有啥用呢？你不可能挨个123567去去试吧，或者是拿着信息去拼，比如说你用AES/DES，它是对称的，对称的，什么意思？就是你的钥匙插进去，它能打开，如果用的错误的钥匙，他就打不开，你可以这么想嘛那钥匙是谁？谁有钥匙？肯定不是用户有钥匙，你的用户都知道你的钥匙了，那所有人都知道了？那你就加密加了个寂寞。</p>
</div>
<div class="paragraph">
<p>所以说这个是钥匙是在服务器上面的，这个Token是你的服务器生成的，用户第一次用这个接口，你生成给他的，像你用阿里云的时候，他有个地方叫access key管理，那个地方，有个生成功能，他就是生成Token，所以这个东西是服务器生成给你的，只有服务器有钥匙，比如说我，我是服务器，我生成好了一个串，然后告诉你请保存好这个串，不要遗失了哟，然后你就剩下拿了个串，现在你就可以去访问阿里云的接口、短信什么的、各种API服务，各种监控都是可以的，所以自己的Token不要泄露了，要是把你的Token发到你的微信群里面，你就等着被黑吧，为什么？因为系统只认Token不认人，钥匙也是嘛，我把钥匙拿给别人，他能开门不？他能开。</p>
</div>
<div class="paragraph">
<p>所以服务器上会有一把钥匙，然后他根据这个钥匙加上这个算法就生成了一个加密结果就叫Token，看到没有，这个地方叫加密结果，拿到API上做传输，就叫Token。</p>
</div>
<div class="paragraph">
<p>那么根据这个算法加上一个密码，我就可以跟把这些东西拼成一个原始字符串，然后把这个字符串给这个算法，他就会生成一个结果，所以如果服务器下次收到这个Token，我能用那个钥匙把它解开，解开是双向的，只要解开是不是就得到了服务器要的校验信息？这样服务器就判断这个用户在不在，是不是有效的UserID，万一用户都不在注销了呢，虽然你可能遇不到这种情况，但是你要判断另外个情况，他生存时间，你要拿出来然后基于这个生成时间加上这个有效期，你算一下是否过期，如果过期的话就提醒用户Token已经失效，请重新申请，为什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

我今天不小心把我Token发到微信群里面？好歹微信能撤回，但如果Token已经被人复制走了，不管是哪个地方泄露的，那就应该登录阿里云那个网页上头把以前的脱坑删掉，然后重新生成一个，那这个泄露的托克既然你删掉了，那服务器上做对比，那么哪个拿到你泄露的Token准备干坏事的人就没什么办法了。</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_api_逻辑链业务">10.5. API 逻辑链（业务）</h3>
<div class="paragraph">
<p>你的API之间有关系嘛，你的整个核心都是这个东西，你的上一个API是登录，下个API是注销，那都是有关系的，所以你可以简称为逻辑链嘛，就业务层面的东西，他这个地方就涉及到业务了。</p>
</div>
<div class="paragraph">
<p>然后这地方逻辑链，逻辑链是什么意思？比如说我刚才讲的，你肯定首先有获取的Token，我们刚刚讲的，我们使用的是标准的restful API，是靠PUT、POST、DELETE来处理的，所以这个时候你的URL肯定是一样的，那么这个地方肯定是这样的：/Token，Token是一个名词，没有意义，为什么作为接口应该是动词，所以获取Token是这样的，肯定要get获取Token，那么有获取Token你就有什么，就有删除Token，或者是失效，或者列表，如果你要列表的话肯定就不仅是那么简单了，应该是也写个List，我这地方是获取吗？那么获取列出来了，然后比如说有个列表的东西哈，那这个地方就可以是这样。列表的话就/list get。然后这个时候，你肯定还有方法让他失效嘛， 所以这个地方你肯定还有个delete。Token是不需要修改的，因为你颁发出去，就不应该改他，所以说是没有POST的，也没有PUT，因为PUT的话是用户把Token传给你，但现在是你给用户，所以那这个时候看到没有/token get/delete和token/list get他们俩是有关系的，API之间是有就是之间是有各种逻辑关系。</p>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>你的用户程序朝上面报的时候，你的Agentd层里面应该加上Token呢？那问题来了，Token什么时候拿到的？你肯定有个get方法去获取从服务端获取Token，而且那个Token看起来应该是一旦颁发过后就不应该让他失效，除非重新获取，所以这个时候应该是怎么样？应该是他去注册的时候怎么样返给他的，他先注册嘛，然后返那个200ok，这个注册只是一个请求注册，叫请求注册，但实际上服务端没批准呢？然后一旦服务端批准，那么就反就调用那个Agentd的回调，把Token下发给他是不是可以。</p>
</div>
<div class="paragraph">
<p>我都不用做严格的设计，就是理论上这是可行的，我在服务端上接收注册嘛，我只要接受他ok，那这个时候自动发一个Token给他，他就寄到他的配置文件里面去，下一次别人来调的时候直接从文件获取，那这个时候用户程序通过SDK上传上来到了Agentd里面，在他服务器报的时候，那就应该有Token。</p>
</div>
<div class="paragraph">
<p>第二个问题，Agentd下面有用户程序，那用户程序报cpu监控数据的时候需不需要有Token？如果在公网上访问需要，但是他都是本地所以不需要，因为他没有跨网络，说白了你多报点数据有啥危害？危害在哪个地方？当然他要出发，一堆东西往上报，看起来这个还是有问题的，所以可能还是要教研一下，就用一个Token就可以了，就解决了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_api命名规范">10.6. API命名规范</h3>
<div class="paragraph">
<p>因为这个API会给很多人用，如果看到你的名字就见字不见人的话，那就是有问题的，比如说:</p>
</div>
<div class="paragraph">
<p>你取了个API的名字，叫getList，请问啥List呀？哪种List呀？你这个时候你就肯定很蒙逼了，比如说:</p>
</div>
<div class="paragraph">
<p>/Data1、/List1</p>
</div>
<div class="paragraph">
<p>这种就不要来哈。API命名规范跟参数校验这两个东西。百分之百的软件系统都没有人写，如果有人写的，一定是发生了什么意外。为什么因为他是随缘取名字的。</p>
</div>
<div class="paragraph">
<p>举个例子：</p>
</div>
<div class="paragraph">
<p>我们前人的代码，一个数据库有一共有6个字段，其中四个字段的拼写是错的，还有三个是拼音的缩写，然后第四个错的是什么？是他用英文把单词写错了,单词就像那天那个line一样，他写成lien了，我真的看了好久，虽然我才疏学浅，但是我非常确定的告诉你这不是一个英文单词，所以他真的就写错了，我看了好久，我至少那张表我看了半个小时我才理解他什么意思，我怎么知道的？我看了一下他那个表里面的那个内容，刚好有中文呢，有些东西我是瞎猜，当时那个表里面有个这个东西，dtxx，这就是一个拼音缩写，后面那个xx你不用管，你猜这dt是什么，dt是电梯，这个是我第一个猜中的，但是后面那个dtxs，请问xs是什么？你就瞎猜了，对不起，我也不知道是啥。</p>
</div>
<div class="paragraph">
<p>所以这个地方在API这个层面命名规范尤为重要，数据库表还好的用户看不见，但这个东西可是大家都会看见，为什么？因为你咋知道哪天你的API会被谁调用？每次别人调用一次就吐槽一次。所以这个时候在和别人产生交互的时候，你的名称，你的命名尤为重要，不仅仅是说那个API本身那个名字包括它的内容。
&lt;&lt;&lt;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_DaimaTongshi_chapter">11. 代码设计（通识）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_本源">11.1. 本源</h3>
<div class="paragraph">
<p>本源是什么？我们拆开一个字一个字地看。</p>
</div>
<div class="paragraph">
<p>首先本字就代表着：本来、本质（目的）字面意思就是指的：</p>
</div>
<div class="paragraph">
<p>事物本身所固有的根本属性，它对事物的性质、状况和发展起决定作用。</p>
</div>
<div class="paragraph">
<p>而源字代表着：源头，比喻事物的开始部分。</p>
</div>
<div class="paragraph">
<p>看得出来，本和源存在着因果关系，当你有了源才会得到最后本，也就是有人源头才会得到最后的结果，这个结果也可以说是本质。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编程的本源">11.2. 编程的本源</h3>
<div class="paragraph">
<p>那么编程的本源是什么呢？</p>
</div>
<div class="paragraph">
<p>上面说的本代表着本质、目的，它们对应到程序这里简单来说就是结果。</p>
</div>
<div class="paragraph">
<p>而源代表的是源头，在编程方面就是起因。</p>
</div>
<div class="paragraph">
<p>之前讲过编程是个动词，而动词一般形容的是人或事物的动作，动作都会带上工具，那么这样可以说程序就是工具。</p>
</div>
</div>
<div class="sect2">
<h3 id="_工具的作用">11.3. 工具的作用</h3>
<div class="paragraph">
<p>首先工具是指能够方便人们完成工作的器具，它的好处可以是机械性，也可以是智能性的，但这是字面上的意思，在日常生活中，我们使用工具，比如说：用斧头砍柴、用水桶提水、用通道传递东西，在这些例子里面，斧头、水桶、通达都是工具，它们都能方便人们完成工作，这也是工具的主要作用之一，那么还有一点是啥？</p>
</div>
<div class="paragraph">
<p>上面说的用斧头砍柴、用水桶提水等等都是靠得工具，那要是这些工具没发明之前人们是怎么生活的？为什么要发明这些？</p>
</div>
<div class="paragraph">
<p>在很早之前，人们需要取火，用来保暖和加工食物，这时候的火源就来源于地上拾取的木头或者树叶，但是那时候没有斧头，木头都是特别粗的，然后发现在火烧完后，那根特别粗的木头不会烧到中心不分，可能外面都化成灰了，但是中间还是完好的摸样，所以人们就想怎么才能把木头分成一小根一小根的，这样能更方便燃烧，这时候不能可能用手直接掰开呀，为什么？第一没有足够的力气，第二强行掰开的话，手会磨损、受伤，这时人们就想有什么有什么东西能代替手，而且要比手更锋利。</p>
</div>
<div class="paragraph">
<p>最初的斧头就出现了，人们发现地上的石头有一些是扁平形状的，如果把石头的一端磨的很锋利，就能基本的割开一些东西，也包括木头。</p>
</div>
<div class="paragraph">
<p>所以得出的结论就是斧头、水桶等等这些工具都是为了服务人类而发明的，而且还能帮助人类提高劳动的效率，那么偷换概念，程序也是工具，那么程序的诞生一定也是为人类服务而且提高人类做事的效率。</p>
</div>
<div class="sect3">
<h4 id="_程序是怎样提高效率的">11.3.1. 程序是怎样提高效率的？</h4>
<div class="paragraph">
<p>那么程序是怎么提高人类做事的效率呢？</p>
</div>
<div class="paragraph">
<p>1.重复（算法）</p>
</div>
<div class="paragraph">
<p>在编程中，算法占据了很重要的部分，而某些结构里，如果有两个点的功能目标相同，编程可以让算法成为一个函数，从而达到重复使用，而不是遇见一次就重新写一次。</p>
</div>
<div class="paragraph">
<p>2.速度快</p>
</div>
<div class="paragraph">
<p>速度快顾名思义程序是部署在计算机上的，而计算机的速度是很快的，强大的CPU能够让它做出每秒几亿次运算。</p>
</div>
<div class="paragraph">
<p>3.稳定、可靠</p>
</div>
<div class="paragraph">
<p>编程相比人来说，它的整个运行规律，逻辑都是人类编写的，它不会像人类做事情做到一半，然后突然冒出什么事来打扰到它工作，从而产生很不好的结果，而且它们能做到这些功能之前都是经过测试的，很大程度上减少了出错的概率。</p>
</div>
<div class="paragraph">
<p>4.模块化</p>
</div>
<div class="paragraph">
<p>这里指的是编程将整个程序的代码分成更小的结构，从而促进大型软件和系统的建构，这样会大大的节约成本，以及避免重复创造。</p>
</div>
<div class="paragraph">
<p>5.持续输出</p>
</div>
<div class="paragraph">
<p>程序相比于人类来说，他不需要睡眠、不需要吃东西补充体力，也不知道什么是睡眠，他就能每天24小时不间断的运行，如果人类不停的思考计算，身体肯定撑不住，不允许这么超负载的运行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_怎样设计程序无限贴近工具的特质">11.4. 怎样设计程序无限贴近工具的特质？</h3>
<div class="ulist">
<ul>
<li>
<p>算法高效：简单，复用，逻辑清晰。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>举例子：</p>
</div>
<div class="paragraph">
<p>SQL慢的原因：相关性弱，复杂(逻辑)、查询多、行多，结果集数量多。</p>
</div>
<div class="paragraph">
<p>API————迟（网络延迟）：域名（错误的DNS会使请求的时候绕大半个地球才请求到服务器），响应慢。</p>
</div>
<div class="paragraph">
<p>代码慢：一个程序里面的代码全是Static Class，一点运行要跑半天才能运行起来。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理异常无bug：处理好代码中的异常问题，最后运行的时候不能有bug出现。</p>
</li>
<li>
<p>运行更快：高效的算法逻辑写出来无异常无bug的程序能够很快的跑起来，而且会持续输出。</p>
</li>
<li>
<p>更合适的模块封装：将每个模块的拆分的很细，就能很清楚的知道每个模块怎么做，该做什么，再进行封装，达到代码复用的地步。</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_JPA_chapter">12. Spring JPA</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_11">12.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/SpringJPA板书.jpg" alt="SpringJPA板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jpa是什么">12.2. JPA是什么？</h3>
<div class="paragraph">
<p>刚刚讲了JPA的英文是 <code>Java persistence API</code>，翻译成中文就是J <code>ava持久化API</code>，那JPA具体来说他支持什么？JPA支持常见的关系型，比如说：MySQL、P SQL，甚至在官网里看到还H2，当然肯定还有SQLite等等，你会发现，这些都是可以写SQL的，但凡能用Select * from XXX查找数据库数据的，JPA都能支持，不过像Radies，MongoDB、ES那种就不一样了，JPA中的P叫持久化嘛，所以这个地方直接就理解为只支持 <code>关系型数据库</code>，其他都是不支持的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jdbc和jpa">12.3. JDBC和JPA</h3>
<div class="paragraph">
<p>大家都知道Java要去查数据库的话，必须要用个东西，那个东西叫JDBC，那这个JDBC是什么？JDBC的英文是： <code>Java Databas Connectivity</code>，翻译过来就是 <code>Java数据库连接</code>，是Java語言中用來規範客戶端程式如何來存取資料庫的應用程式介面，提供了諸如查詢和更新資料庫中資料的方法，那JDBC和JPA是什么关系？</p>
</div>
<div class="paragraph">
<p>首先JDBC是Java提供的一个驱动层数据，这之前先了解一个概念：ORM</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ORM全程是Object Relational Mapping，翻译过来就是对象关系映射，简单来说就是在编程中，把面向对象的概念跟数据库中表的概念对应起来，这个以后会仔细讲，现在只简单提一下。</pre>
</div>
</div>
<div class="paragraph">
<p>那么这个JDBC，它对应的直接是数据库，因为MySQL官方的下载页面，它里面有直接下载JDBC Jar包的链接，这些MySQL收口提供了JDBC的驱动，正常来说这个时候，如果我是那个Spring Boot的开发者，我会把JDBC和JPA持相同的层面，其实这两个是一个层面的东西，而数据库只和JDBC发生关系，因为这个官方就支持这个东西，官方他不可能因为JPA而重新开发，JDBC用起来太麻烦了，JDBC就像以前的Spring，而JPA就像现在的Spring boot，那Spring和Spring Boot谁方便？那肯定是Spring Boot啊，所以从这个层面的时候说JPA只是一个操作器，让你更方便，写更少的代码，封装程度更高，但是他并没有和数据库直接发生关系，而是JDBC和他发生关系，为什么我知道呢？MySQL都没给JPA写驱动，那肯定是这样的。</p>
</div>
<div class="paragraph">
<p>所以理解一下这一层的关系，比如说你写的跟属于里的DB，然后你要让Java能够调你的，那这个时候你的DB应该有请求报文，为什么？因为他是一个用TCP通过端口连过去的，那这样的话就相当是用Java先连一个端口，连上那个端口后，Java拼一个报文，SQL就是要报文里头，报文里就有是哪个数据库，哪个表，什么编码，SQL是什么，然后把这些拼成一个报文丢给你的，Java把丢报文丢给数据库，数据库收到报文过后解析报文，报文解完就把那个SQL拿出来，然后数据库查完了，再反结果给你，通过响应报文传给Java，Java的拿到响应报文后解析格式啊？你解析完了或者写完了这个东西，那他就叫JDBC驱动，这个东西和HTTP没啥区别，就是报文不一样，这样你甚至可以给Rust的写一个。</p>
</div>
<div class="paragraph">
<p>所以这个地方官方会给他提供Driver，就是驱动的意思，就像那显卡驱动一样，只是说层次不一样，但是他们都是驱动。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jpa为什么方便">12.4. JPA为什么方便？</h3>
<div class="paragraph">
<p>我们先将JDBC和JPA作对比。</p>
</div>
<div class="sect3">
<h4 id="_jdbc是怎么用的">12.4.1. JDBC是怎么用的？</h4>
<div class="paragraph">
<p>以前我们要写JDBC的话，</p>
</div>
<div class="paragraph">
<p>1.首先你要连接connectivity db，就是你要先连上数据库，连上去后，假设我连的是MySQL，你就要这么写</p>
</div>
<div class="listingblock">
<div class="content">
<pre> mysql://localhost:3306</pre>
</div>
</div>
<div class="paragraph">
<p>当然，你可能会跟一些数据库名字或者用户名字之类的。</p>
</div>
<div class="paragraph">
<p>2.连上数据了过后，第二个就要切换数据库，你要告诉他你的那个数据库上面，当然，这个地方他默认就会有一个，但你也可以手动切换，现在我们假设你已经进人数据库里头了，那现在要查SQL，在JDBC里，你要查SQL，你要怎么准备呢？</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="listingblock">
<div class="content">
<pre> sql = Statment.preare(“select * from ...)</pre>
</div>
</div>
<div class="paragraph">
<p>你要有个准备一个preare，然后再加上一个SQL字符串。</p>
</div>
<div class="paragraph">
<p>3.第三步就是你要有一个结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre> result = Statment.execute(sql)</pre>
</div>
</div>
<div class="paragraph">
<p>这个执行SQL过后，得到的是查询的结果，然后你要把结果拿出来，但是现在你并不知道这个结果有多少行或者说你能够得到多少行，所以你要写个For循环。</p>
</div>
<div class="paragraph">
<p>4.写个for循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>for (i=0,....&gt;result.row,i++)

....

....
....

row = result[i]</pre>
</div>
</div>
<div class="paragraph">
<p>这个过程当中，你可能能得到单行，单行你是能拿到的.</p>
</div>
<div class="paragraph">
<p>然后设一个变量，就是：row = result[i]，然后就得到了一行，但现在是这一行里还有有五列，那还要循环这一行，把列拿出来，最后得到一列的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>for (row...)</pre>
</div>
</div>
<div class="paragraph">
<p>那么得到数据后，肯定要把数据保存下来，那么你肯定要创建个class，挨个挨个把数据填充到你自己Class的属性里面去。那么这个过程当中你最终输出的是有一个Class。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>row_class.cod[j] = result[j]
...
...</pre>
</div>
</div>
<div class="paragraph">
<p>那么假设是一个数组来保存的，慢慢填充填完了，这样的话就把先一行一列全部都填充到对象里面去，填充完了那个对象就可以用了，所以这个是程序的算法，完了过后就要把他关掉，上面的就相当是清理这些东西了，最后就要关闭连接，好了，你终于搞完了一张数据表了，那我问你个问题，万一这个地方查出来很多行很多列，那你不得把它写死，而且最关键是你会发现这个地方他运算的时候无非就是行和列，和表没有关系。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

如果这个表所有的列都是Char，那这个地方是可以写死类型的，但是他如果是JSON或者INT格式，这个地方还要判断一下他的格式，累不累？</pre>
</div>
</div>
<div class="paragraph">
<p>所以这就是以前我们最开始没有hi，没有JPA，没有Mybatis的时候我们干的事情，就全靠自己去搞，虽然也不是不能写，因为我们写c和c+ + 的时候就这么搞的，逻辑一模一样，用C+ + 连MySQL也是这么弄的，只是语法更复杂一些。</p>
</div>
</div>
<div class="sect3">
<h4 id="_jpa怎么做的">12.4.2. JPA怎么做的?</h4>
<div class="paragraph">
<p>然后JPA是怎么弄的啊？如果是JPA的话，你要的第一件事情就是假如现在你有一张表，你要把这张表映射映射成一个Java的class，就是你表有几列，对应的Class就有几个属性，巧了，这个东西在MVC里面叫Model，当然层次不一样你也可以叫JavaClas都是可以的，然后有的人他喜欢叫DAO。</p>
</div>
<div class="paragraph">
<p>什么是DAO？就是Data Access Object（数据访问对象），是为某种类型的数据库或其他持久性机制提供一个抽象接口的对象，但是不管叫什么都是一样的。</p>
</div>
<div class="paragraph">
<p>那这个地方就相当是表有几列，他就有几个属性，这个做完了过后第二件事情无非就是把行和列的关系绑上了，因为你要去做各种运算和查询，所以他把这个封装成了一个统一的逻辑，我们就把它叫数据仓库，这个数据仓库干啥呢？你去看他那个源代码，你点进去他会有个那叫CUDR增删改查，然后把它封装了一下，然后这个R他又给你们封装好了，就是quray，平时查询是怎么查ID的，所以他就给你封装成这种方法翻译成findByID，当然他可有另外一种写法，比如findNameAndAge，巧了，这两个也是你的列名，这都有And了，那就应该还有All，那么有时候你所有的数据都要查翻译那就是findAll，但是和之前的不一样，层次不一样，上面查的时候，你并不清楚你要查出几个数据，一般情况下，我们查出的是一个，当然All这个地方可能是个列表，返回值不一样，所以findAll，他指的是说查出所有，所以你会发现这个时候时候，他后面不是有括号吗？你会发现的括号是空的，里面是没条件的，所以他返回的是整张表的所有数据，那么代By的可能返的是一条，也可能是三条五条，但是你会发现他都是find开头，无非是后面的词不一样，那么它们就会有不一样的行为，但是这样解决不了一个问题：连表查询，你想嘛，这样只能在单张表里面找那个列名，那如果你要查两张表呢？那就是比较高级的技巧了，现在不讨论。</p>
</div>
<div class="paragraph">
<p>所以你会发现这个东西，这个仓库他给你封装CUDR增删改查，但是他那个叫save比如SAVE命令，那么意思就是repo.sava()，括号的中间是一个对象，等于说你把那个对象先查出来，然后掉他的set把值给改了，然后再传给数据库，save可以做新增也可以做更新，比如说这个地方你不是查出来的，你是自己new了一个不一样的逻辑，但只要能掉save就能保存进去。</p>
</div>
<div class="paragraph">
<p>相比JDBC来说的话，JPA有了算法，还有了数据结构，而且层次非常清晰，你要改表的话，就改最上面的映射，如果你有相关查询你就改函数，如果你新增一列，你根本就不查，那这个地方都不用去改，反正查出来默认在里面放着的。</p>
</div>
<div class="paragraph">
<p>JDBC你只要加了一列其他全都得改，累死你，而且还容易出错，但是JPA也有个问题，他封装太好了，你可能不清楚这个规则，默认情况下，那个findById肯定是在，甚至说那个仓库代码里面啥都不写，你只把那个内继承一下，空的放在那，这些方法都可以的，只是他没有语法提示，但是他在运行的时候，他就会分析你的那个表里有几列，所以说JPA里头，你甚至可以不写函数，你都是可以用的，因为他是自动帮你拼装的，他都帮你拼了，你还写啥。</p>
</div>
<div class="paragraph">
<p>所以经常你会看到类里面是空的啥都没有，但是他又能用，你就很奇怪，作为一个新手就很恼火，为什么？凡事都靠懵，搜索文档都搜不到，所以JPA更简单但是他封装太好，对新手一点都不友好，然后我学习是连蒙带猜，就猜他会怎么做，然后看了几个例子，看到有人用了，我就知道大概怎么回事。</p>
</div>
<div class="paragraph">
<p>当然，有种情况就是：你可能只能拼这种语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SQL(“select * from t where id = 2 “)</pre>
</div>
</div>
<div class="paragraph">
<p>你可能只能拼这种，但是如果你有更复杂的怎么办呢？那个时候你就可以自己写一个find的方法，在find方法上面把那个SQL填进去，比如说</p>
</div>
<div class="listingblock">
<div class="content">
<pre>T=findByXXX(......){

}</pre>
</div>
</div>
<div class="paragraph">
<p>这个就返回了一行，所以你可以写个SQL，然后他掉这个SQL，最后查出来帮你转换成T，就是你可以自己写，当然不一定要叫find什么，就自定义查询嘛，这个地方你也可能是几个连表，那你会发现写着写着还是Mybatis香，因为他就是专门搞复杂SQL的，而JPA只能做简单的，那为什么还要JPA呢？SQL是简单还是复杂是根据你的设计定的，要是啥设计没有，当然复杂了，但是大多数情况你是可以构造成简单的SQL。</p>
</div>
<div class="paragraph">
<p>所以Mybatis适合外包，就是那种业务系统，非常非常复杂，然后设计又结不了藕的，不能做简单查询的，你可能Mybatis合适一些，然后剩下就是JPA，JPA他不是自己写的，他是基于Hibernate的，JPA是简单的把Hibernate封装了一下，这中间有别人的劳动成果，运行的时候都打了Hibernate的，Hibernate跟他其实就是孪生兄弟，Hibernate肯定是更偏JDBC，只是步骤可能少了一两步，当然也是可以写SQL的，就看你怎么弄。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_补充list">12.5. 补充：List</h3>
<div class="paragraph">
<p>然后刚才提到一个说语法看不懂，比如说是这个函数：</p>
</div>
<div class="paragraph">
<p>List&lt;User&gt;  findById()</p>
</div>
<div class="paragraph">
<p>findById是函数名字，括号里面是函数的参数，List&lt;User&gt;这地方是函数的返回值,返回值里面意思是说这个函数会返回多个user,然后你要调的时候，比如说你调了这个函数，那调他过后怎么去用呢？</p>
</div>
<div class="paragraph">
<p>u = result[0]</p>
</div>
<div class="paragraph">
<p>就是result这玩意儿调用数组下标。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_SJKTS_chapter">13. 数据库通识</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_12">13.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/数据库通识.jpg" alt="数据库通识">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是数据库">13.2. 什么是数据库</h3>
<div class="paragraph">
<p>数据库简单理解的话，它就是一个存数据的地方啊，有人说书上写的是存放数据的仓库，这个就要看你怎么去理解这个仓库了，比如像SQLlite或H2，他们就非常非常迷你，你要说他们是仓库吧，我觉得这两个更像个盒子，所以仓库可能是迷你仓库，反正只要是仓库都可以。</p>
</div>
<div class="paragraph">
<p>那我们能不能换一个通俗点的看法？首先，数据库的英文是Database，那么把这两个词拆开，Data是数据的意思，那这个Base是不是就是打游戏里面不是：“我们的基地被攻击”那个里面的Base好像就是基地的意思，因为我看到这个词的时候，第一印象的就是基地，当时那个数据库原理书上面，我刚看了第一眼就是想打游戏，所以这里的Base就相当于数据库，那既然你要解释什么是数据库，你会发现Databa是一个合成词，数据是一个名词，库也是一个名词，但是两个拆开是单独都有自己的意思，所以他是不管是中文还是英文都是个合成词。</p>
</div>
<div class="paragraph">
<p>那这个地方的话解释一下，那么数据这个没得解释，就是字面意思，那库怎么解释？他因为原意有基地的意思，看起来是这样的数据的基地，或者数据大本营，那你说是放数据的地方或者说存数据的地方也是可以的，刚刚不是有人讲：数据存储的仓库啊，这个仓库就很难去理解，因为如果我是一个新手，你说仓库，新手好不容易搞懂了什么叫数据库，然后一听数据仓库就懵了，我们就尽量不要用仓库这个说法。</p>
</div>
<div class="paragraph">
<p>所以你该怎么讲？</p>
</div>
<div class="paragraph">
<p>首先，基地它就是库吗，也可以说是大本营，那到大本营肯定就是要集合呀，所以这个地方其实是这样的，数据库，你听不懂，但是集合这两个词你是听的懂的，因为从小学、初中、高中，集合两个字已经出现过无数次，那数据库有集合的意思，但肯定不是全部，我们把它拆开，首先数据肯定在一个大本营里面，那一堆数据放在一起那就是集合。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

我把一堆纸上面打印上东西，然后把那一堆纸压在一起，它就是一本书，书从广义上也是数据的集合，但是它能叫数据库吗？书不能叫数据库吧，那我问你一个问题，你怎么区分MySQL和P SQL的？</pre>
</div>
</div>
<div class="paragraph">
<p>首先我刚刚讲的，一本书，知识也是一种数据，那么书就是知识的集合，脑子里面叫知识放在书里面就叫数据了，为什么？你要去读他，在你读的时候就像读数据一样，所以你看书你不叫数据库，但是可以叫数据集合，那肯定是除了数据集合以外什么东西他能称得上数据库，那我就问那个问题：为什么你要选不同的数据库？用一个数据库不就够了？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你买的书，他是不是都有固定的排版格式？不管哪种书，现在全世界通行的书都是从左往右，然后从上到下，但不排除比如说像台湾，现在保持着民国的作风，写信的时候他们就像我们小学写信，小学的时候，我们可是学了写信的，这辈子我都没有写过信，除了情书，看到没有对我们来说已经过时了，但是你看民国那个时候，他是这么竖着弄的，那现在他可能也是竖着，有的地方是保持这种格式，就假设有竖着的，有从左到右的，从上到下的，看到没有，特定格式的才叫书，那如果把它打乱放在一起，那叫天书，天书也叫书，只是难看，但不表示你看不懂。</pre>
</div>
</div>
<div class="paragraph">
<p>所以要怎么去定义一本书？因为书也是一种数据集合，那这个时候那定义一本书或者什么叫书？书就是很多很多的文字，把它们组合在一起，就是一个文字的组合，那么一篇文章，它也可以叫书，为什么？只是这本书比较薄，只有一页，但是这个时候我们有个简称，就把它叫文章，仅此而已，因为文章，其实也是个集合，广义上它也是一种书，那这个时候你可能就对书有更具体的要求，你说书的有目录啊，书的有前沿，我文章我也可以加目录，就那种超长篇的文章嘛，比如微信上面划了20下，那个文章都没划完的那种，你可以说他是书。</p>
</div>
<div class="paragraph">
<p>所以从广义上的图书来看，你要去定义它的话，就是：很多文字的一个组合，一个集合，然后把它排列在一起，可以用人类可读的文字或者语言编写的，你会发现这里面文字、编写什么的，格式我都不提他，因为你文字肯定能阅读，至于怎么阅读，从上到下还是从左到右我都无所谓了，只要阅读都可以，那么就对格式有要求了，文字要印在纸上，但是现在有电子书，就是用电子设备打印的纸张，所以说这个叫电子书，他也是一个集合，他不叫数据库。</p>
</div>
<div class="sect3">
<h4 id="_关键词">13.2.1. 关键词</h4>
<div class="paragraph">
<p>那为什么你的书不能叫数据库？</p>
</div>
<div class="paragraph">
<p>那是因为数据库它整个存储格式都是0101，所以我得限定一个范围，限定什么范围？我们就打关键词：</p>
</div>
<div class="paragraph">
<p>第一个：计算机领域。</p>
</div>
<div class="paragraph">
<p>第二个：数据集合。</p>
</div>
<div class="paragraph">
<p>这个数据，我可没有指定具体是什么数据，你看，在计算机以外，文字他算一种数据，语言其实也算数据，图片你看那个照相机，他不是电脑呀，以前那个照一下还要弄闪光灯，还冒烟的，但是和计算机一点关系都没有，甚至和电子都没有关系，他纯靠那种火药燃烧，只要我曝光足够强，人的影子就被打到背后面去，这是纯物理层面，所以这个时候，照片他也可以称为数据，语音也是可以的，那么视频这种眼睛看到的东西也可以称为数据，所以数据的范围很大。</p>
</div>
<div class="paragraph">
<p>这里我们第一点就限定范围，然后第二个就是告诉他是一种什么类型的东西，我们刚刚讲图书嘛，因为我的认知里面数据库就是MySQL，但是我从来没想过怎么去解释他，所以我也其实不知道，那现在我们就挨着挨着推嘛，我们刚刚讲到书是文字的集合，但文字是要按规则排列的，说白了文字是有格式的，比如说你的新华字典或者新华词典上面的那些东西，它的排列都是有规矩的，再比如说电子，你不能说子电吧，这个词还没发明出来，所以你会发现你的文字排列是有要求的，特定的文字，要出现在特定的地方，电子的电一般出现在前面，但是台积电哈的电是在后面去了，为什么？这是个名字，是不一样的，但是它也是有规则的。</p>
</div>
<div class="paragraph">
<p>所以书，是可以称为排列，那如果是计算机领域的这个数据集合，那我们就应该叫数据格式，什么格式？MySQL是有MySQL的格式，比如说MySQL的配置文件里面写了个默认的存储格式，叫innodb，在这个之前有另外一个很老的引擎叫myisam，但他不支持事物，比如说你你更新的时候，他要锁表，意思就是说，有一个人Update，所有读这张表的人必须等到Update完了过后，才能使用，但是不妨碍他简单，他就是因为简单大家才用它，不是因为好，要论好的话，好的数据库多了去了，比如像那个美国的有一家收费数据库叫sybase，那家公司是商业数据库，既然叫商业数据库，那么就要花钱，那肯定好了，oracle也不差，但是你为什么不用？我都不说他安装的问题了，就光他那稀奇古怪的特性，你用的也难受，本来我用PSQL就是图快，结果用个oracle就把机器内存吃了2/3，还要学特殊的语法就非常难受，所以你不会去用orcle的，那这个地方P SQL肯定有他的格式，那SQL server也有的，它装到windows上面，有个两个文件，一个叫mdf文件，一个叫ldf文件，mdf文件就是他的一些原数据，说白了，里面有数据，ldf是日志文件，里面有他的一些操作的信息，你如果把其中一个弄丢了，对不起，数据就会缺失，但是如果你有mdf的话大概率能够恢复的，只能说大概率，为什么？你咋知道数据是第一个版本还是第二个版本的，他有可能这个里面包含了很多版本的数据，你不知道用哪一个，可能包含了一些读写的信息，看到没有，你会发现数据库好像都是这样的。</p>
</div>
<div class="paragraph">
<p>SQLlite最简单的数据库，是单机的，这个数据库通常浏览器什么的，它里面一般都是用的这个，还有很多那种特殊的软件，他就想单机，比如嵌入式用的很多，因为嵌入式里面不可能得起个MySQL，这个数据库它没有进程，它就是个文件，你甚至都不用启动他，他根本就不是个程序，他只有格式，但是不妨碍他叫数据库，而且下的人还挺多的，很多那种用windows下，你装的软件过后，有些作者他为了操作数据方便，他不想用配置文件他就用SQLlite，然后再给你加个密码完事，但这个东西加个密码形同虚死，我直接把你那个二进制未替换了就可以了，你总有地方替换嘛，为什么？太简单了，他只有一个文件，比如说像Redis，也叫数据库，Redis也有db文件，看到没有，我能举一万个数据库，他们每一个都有自己的数据格式，这就像了Windows，Windows叫操作系统，有几个操作系统嘛？Windows，Linux，Unix还有比如说VX那种航空飞机上用的实时数据系统，那种系统就是以毫秒来计算它的运行速度，那操作系统你会发现各种不同，多样的，那为什么不一样？Windows的格式能在Linux运行？不能，为什么？它们的内核是不一样，执行程序的格式是不一样的，数据库也是一样的。</p>
</div>
<div class="paragraph">
<p>所以我们现在知道，计算机领域，一个数据集合，那么这个数据集合是有格式的，那基本上这三点看谁符合，SQLlite符合，但是MySQL比他多，为什么？因为MySQL有端口。</p>
</div>
</div>
<div class="sect3">
<h4 id="_网络读写">13.2.2. 网络读写</h4>
<div class="paragraph">
<p>所以我们加一条，这条是可选的，就是有自己的叫程序进程，比如说像MySQL，他进程是用来做什么的？</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>如果卖MySQL把网络访问这一块砍掉，他也可以像SQLlite一样，所有的数据库，把那个网络通信都砍掉，都可以在本地读写这些格式。</p>
</div>
<div class="paragraph">
<p>所以这个地方严格意义上来说，他不应该叫程序进程，他应该叫网络读写，这是一个可选项，因为它不是必须的，理论上每一种数据库就是一个文件系统，就像你的电脑上的NTFS一样,他就是一个文件系统，不用怀疑，一模一样的，只是你的文件系统是用来存那种图片、pdf、影片的，然后这个时候你的这种存储是属于一种通用存储，什么意思？可以放任何类型的东西，但在数据库里：</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>你要传东西进数据库，你首先要创建数据库，然后创建表，这里创建表像极了建个目录，创建表相对于的目录里面有一个EXcel，然后INSET操作像极了在excel里面加一行。</p>
</div>
<div class="paragraph">
<p>那么我这么比喻你应该就知道，这玩意儿就是个迷你的文件系统，虽然我们可能现在没告诉你什么叫操作系统、文件系统，但是你知道NTFS，Linux下面有Ext4、XFS就跟那个东西是一样的，所以做操作系统和做数据库这块的大牛啊，他们是重叠的，都是那帮人，就是那帮老头子，所以你不用怀疑，就是这么回事，然后我就问你个问题嘛，我通过远程去操作windows和我通过远程操作MySQL是不是一个道理啊？无非就是我让你本地产生读写，所以这地方是网络读写，所以你现在会发现：“我靠，我更不懂数据库了。”</p>
</div>
</div>
<div class="sect3">
<h4 id="_总结">13.2.3. 总结</h4>
<div class="paragraph">
<p>那我们现在总结到底什么是数据库，总结这个我们花半个小时，为什么？你之前都搞不明白它是什么，就算你把“存储数据的仓库”这句话背下来了，也没用，为什么？你根本就不知道什么叫数据仓库，因为数据仓库的描述是不准确的，为什么他没有描述他的全部？因为仓库这个词，是可以剥离出很多很多的概念的，所以这种概念是给高级的人士理解的，对于你来说你不配。</p>
</div>
<div class="paragraph">
<p>所以这个地方我们要总结出一句话，看看能不能把上面的连起来，那数据库就是：“计算机领域的一个数据集合，这种集合有自己特殊的格式，能够通过网络读写。”</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_2">13.3. 使用场景？</h3>
<div class="paragraph">
<p>所以这个地方讲的是where，那这个地方就是使用场景，你使用场景是非常非常具体的，你想一下嘛？这个是从脑子里面总结出来的，但这总结一定是事后才总结的，他发明Mysql的时候，他一定不叫Mysql，你想嘛？那Mysql的雏形还是个小鸡的时候，他肯定可能不叫Mysql，叫municode，那是有可能的，所以那这地方使用场景的话，我们就现在来总结一下嘛，就是我们平时用Mysq是怎么用的？</p>
</div>
<div class="paragraph">
<p>我们有量比较多的数据，类型也多就是量大，我指的量大不是两条，不是五条，有可能是200条，这个量已经很大了，再加到2万条叫巨大，因为一个是要打开2万行很容易崩的，这不是我吹牛，20万你的机器卡五分钟能打开，那是没问题的，你可以想象一下，你每次读数据库要花五分钟，打开一下你的数据库，你不敢想吧，所以这个时候一定是以量为基础，第一个量大，第二个类型多，Excel他只能解决一个问题，就是一个Excel的shift。他只能保存某种格式的数据，你想象一下，你如果那个表格不一样，你能放在一个shift里面打印出来吗？很难，而且会发现是个缝合怪，所以通常我们一个工作表里头，我们只会放一种逻辑的数据，比如财务的阅读统计，我们可能会放到那儿，然后第二个shift可能是年度的，然后第三张可能是明细，你看到没有你会有意识的去分，那数据库其实也是一样的，所以用数据库的场景作为我用的话，第一个数据的量大，第二个，数据的类型多，这种多可能不是三个，你可以想象想你打开一个Excel下面那个工作表那个那个列表列出20个我没见过，你见过你截图给我看。我相信你的做的那个份上的一个Excel跟那个Access  db更适合你，为什么？你都做的那么大量了，那个Excel的管理怕是个问题哦你现在改了个数据，等一会你关掉，然后你重新打开，刚才我改了啥来着？瞬间失忆，量太多人脑是记不住的，所以我见过工作表哈最多的也就5、6个，算顶天了，十个的我有，但是那十个是我自己的，而且不咋改，那你看到没有excel适合去做一些简单轻量的。</p>
</div>
<div class="paragraph">
<p>举个例子：</p>
</div>
<div class="paragraph">
<p>曾经有一个我忘了他们叫什么家具我就假设是八一家具的，那个美女她是那家具的老板，他说有一个人向他们推ERP，他说3万块钱套值不值得，他当时问我，我就问了他一个问题，我说你为什么要去考虑用这个ERP？他说其实我没有考虑，但是那个人上门推销了，他说我觉得还可以，然后我就开始问了他几个问题，我说在没有那个ERP的时候你是怎么一个工作状态？说白了你用ERP为了记某些财务的，表单的，你记的过程当中一定有问题急待解决，那这个时候可能日常的Office满足不了你，你可能才会考虑ERP嘛？什么叫ERP叫企业管理流程之类的。就类似的企业管理的流程管理，财务管理都会都可以叫ERP叫财务ERP叫OA ERP，他只是有分类吗？然后这个时候，我问的过，他说以前我没有这个东西的时候，我是用Excel，他说那Excel，大概有十兆，二十兆的样子也不大。但是呢他每次打开就很慢很卡，他说那个人刚好推销，就换一个，我说是这样的，首先呢那个ERP买要3万而且你还配一台电脑，那台电脑你估计5000块钱搞不定，而且你还要维护，你可能有维护年费一年5000，那么电脑的购买费用我就给你假设是1万块钱，ERP的初始购买价格是3万他肯定还有服务年费，那可能那5000块钱再加个5000就相当1万人工加上管理费，然后就是每年1万的续费的费用再加上初始建设的3万，就4万加上买那个电脑的估计要花钱我觉得算便宜点45000，我说是这样的，1万块钱你能买一台很好的电脑，你觉得我说的在理吧，就是我这么讲的过后的，然后他买台电脑就解决了所有的问题，为什么只要他企业的业务不是翻翻，这种买台电脑还能撑两年，2万块钱撑两年还不用请人，还不用改造自己的企业的管理流程，很棒的一个建议嘛，你看到没有这个时候其实我就问了一个问题，我说没有一些ERP的时候你是怎么做的？说白了ERP相对更智能一些，以及重复性的工作，他可以帮你解决，但是你现在量没那么大，我看起来不是必须的，那就是随这个情况下面我那个建议就应该值1万，他应该可以把佣金，你看到就是装路由器的，顺带他就问了一下，我就讲了一下，你看以后我再也不讲了，这个太血亏了，亏两倍。</p>
</div>
<div class="paragraph">
<p>所以那这个地方使用场景我们刚想到数据量大，那么数据类型多，刚才我举例子那个老板那个事情，你会发现他的量不多，他属于类型很单一就是一些财务数据，你用任何东西都可以记的，那么这个时候量大类型多还有什么，
还有个原因就是读写频繁，我指的频繁是什么意思？你等会儿要读，等会儿要改，Excel可是满足不了的，Excel在改的时候他有文件锁？你其他人就不能改了。</p>
</div>
<div class="paragraph">
<p>所以Excel他在频繁读写的时候是有问题的，什么问题？他是一个文件，如果一个人写的时候，另外一个人必须等，然后这个等的过程那怎么样？就是一个新的损耗，这是一个读，也是一个问题，为什么他每一次读都是从硬盘上硬读，就硬读，没有一点缓存可言，操作系统是对热点文件是有缓存的，但那种缓存是一种通用的策略，他不是针对数据库的，所以一定没有专门的数据库来得快，所以量大，类型多，读写频繁，那个数据库是真的读写频繁，如果你想一下嘛100个人读你的Excel你不崩，绝对崩哈，大家都知道就不用我再举更具体的例子，那除了这个以外刚刚说的吗？我想网络读写，我不想单机，还有什么？刚波波说嘛，关系。这种关系已经超越了Excel里面简单的透视图这种关系，那种关系一定是少，我就问你个问题，比如说你有十张表，十张表，表和表之间如果一一对应的话，就相当是说这个样子的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Excel.png" alt="Excel">
</div>
</div>
<div class="paragraph">
<p>这是第一张表，这第二张表，第三张表等于说，你有三张表的话，你总数是n减一，那我问你如果有十张表来就是10-1嘛，好简单，等于九，但是你错了，数据库的关系可是这样：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/数据库.png" alt="数据库">
</div>
</div>
<div class="paragraph">
<p>他和他有关系，他和他还有关系，他可能查这个地方，然后这个时候数学公式已经失效了，为什么？因为数学公式解决的问题是一种通用或者是叫广泛意义上的规则的一个总结。你设计的数据库和我设计数据库，你能用数据公式总结出来？你只能总监用微积分简单算一算，范围落在哪个地方，但是已经没有办法明确了？为什么？因为关系处于交叉，这种交叉你只能算最少有多少个关系，就像这种嘛？那比如三张表嘛最少的关系就是没关系，最多的关系就是两两之间有关系，他只能算这个区间范围，他没有办法算出准确的？所以这个时候，数学在这个时候也失去了意义了，数学不是干这个事情的。</p>
</div>
<div class="paragraph">
<p>总结：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据量大</p>
</li>
<li>
<p>类型多</p>
</li>
<li>
<p>读写频繁</p>
</li>
<li>
<p>关系（巨）多</p>
</li>
<li>
<p>统一的读写方式（SQL）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>我相信没有SQL让你去读那个二进制你是不愿意的，你想象一下，我就是给你弄个单机的那个Access db，你每一次读Access db的时候，你要想读Excel，先定位到A1这一列，定位到了，在定位到E2这一行，然后你就查出了一条数据。然后如果你要取区间的话就是E1&#8212;&#8203;Z1,然后这一个时候你就很多，所以你看这个时候你就不再是说以前能解决这个问题了。</p>
</div>
<div class="paragraph">
<p>所以这个地方有个统一的读写方式，那这个时候它才是最重要的，其他都不重要，你想一下，读写文件，你是按行读的，这玩意儿你都不知道在第几行，所以说这个方式才最重要的，没有这个东西，前面的都没用，所以我用数据库最简单的原因就是统一的读写方式，这也是最重要的，想象一下嘛，其他的一个你都可以忍，硬件方面提升只要钱够都不是问题，但是没有这个玩意儿他就不是一个我们认为专业的数据库软件了，我认为就这些，当然还有一个网络，网络也很重要的，这个地方指的肯定是普通意义上的数据库，他要有网络读写，说白了，就是要做网络交换数据。</p>
</div>
<div class="paragraph">
<p>那还有没有后面的特点？就你为什么要用数据库？首先，让你自己去解释，那个MySQL的报文，你肯定是不会愿意做的，所以那这个时候你用数据库最重要的一个原因肯定不仅仅是说他能网络读写、交换数据还有个很重要的原因，就是数据库提供了驱动层，也就是JDBC之前的那一层，所以这个地方就是数据库他提供了什么？提供了SDK，封装了他的读写行为，然后这个时候能他上能对接语言下能对接他的操作系统和文件系统，所以就处于这个位置，如果要画一个拓扑，应该是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tuopu.jpg" alt="tuopu">
</div>
</div>
<div class="paragraph">
<p>下面是OS操作系统，具体到他那个FireSystem文件系统这一层，然后上面的话就是属于语言，比如说Java，然后这个时候，打个比方，比如说最上面是Java，那下面这个地方就应该是JDBC，那JDBC下面一层应该是MySQL的Driver，这个以后我们讲原理的那一块，我们会具体讲啊，涉及到ORM和数据库原理内存，然后Driver下一层就应该就是MySQL，然后下面才是OS，里面肯定有内核、文件系统。</p>
</div>
<div class="paragraph">
<p>上面的Driver怎么理解？换一个解释的方式：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tuopu2.jpg" alt="tuopu2">
</div>
</div>
<div class="paragraph">
<p>OS还是OS，MySQL换成Nginx，Driver换成HTTP，然后JDBC换成Restful API，最后Java还是Java，然后你会发现这两个概念就是一模一样的，所以这个地方的Driver，他做了一件事情，就是解析报文，他把报文的封包、解包行为全部囊括在里头了，而另外一个的语言JDBC，只需要把报文的那个decoder和incoder调用一下，他就能把报文拿出来，那剩下的就简单了，我都能把包文解析出来，如果我能自己写，我都不需要你这个Driver，所以这个东西纯粹就是解析报文，然后JDBC是语言里面的规范吗，这种规范是Java官方强制要求的，你按规范做，就可以去对接上层，所以JDBC这个东西实际上没有任何意义，如果只是说叫JDBC的话。</p>
</div>
<div class="paragraph">
<p>我们一般用JDBC的时候是这样的，JDBC加MySQL，然后这个时候你才能写代码，如果你仅有个JDBC放在哪里，请问你启动起来连谁，所以JDBC是不能单独存在的，是一种规范，所以这么一对比，你会发现，如果没有Driver层是没有任何作用的，所以说MySQL的官方，他要提供编程的API接口。</p>
</div>
<div class="paragraph">
<p>现在我们再回过头看Excel，你为什么在Java写的时候，你用Excel去保存你数据库？他也有编程接口，但是我们要的编程接口可是易用的，微软，他用com组件，CVM，用串口的方式实现的Excel的读写，但是特别难用，我跟你讲，我用完一次，就不想用第二次，所以微软那个接口相当于没有，它是一种统一的接口，Excel只是囊括在里面，通过中间一层驱动层实现的，那个驱动叫ODBC，以后会接触，既然有JDBC，那微软搞了属于自己的叫ODBC。</p>
</div>
<div class="paragraph">
<p>所以编程接口是非常非常关键的，如果按顺序的话，最重要的是哪几个？有SQL，有接口，然后网络读写，如果你没有接口，但是没有网络读写，没关系，网络读写我能自己写，大不了用Spring Boot封装一个Conterllor，所以说除了这三个剩下的其实就不是很重要。</p>
</div>
<div class="paragraph">
<p>那么你会发现，这并不是我强行总结出来，这是因为我有需求，如果数据量不大，这些东西都白搭，为什么？我要是数据量不大我就不会搞这个了，我一定是有数据量大，有基础我才搞，虽然前面不是重点，但前面是我的基础需求，这种需求延续下来，他不一定要选MySQL，所以说一定是有各种条件需求，对应需要的条件需求做一个筛选才选出来的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么用how">13.4. 怎么用？(How)</h3>
<div class="paragraph">
<p>这个地方是怎么理解?首先，刚才讲的What，那肯定对应会有一种数据库固定的使用套路，首先，我们说广义上的数据库，它其实是有网络读写的，你既然是通过网络读写数据库，那肯定是有连接的。</p>
</div>
<div class="paragraph">
<p>所以第一步应该是：</p>
</div>
<div class="paragraph">
<p>1.连接数据库。
当然，这个连接数据库肯定是根据语言不同，就有不同的方式，但是你知道的，就算你用Py或者Java，它们其实连接MySQL的时候，甚至那个查询，那个连接串都是差不多的，实际上，你掌握了一种，第二种就没有问题了，所以你第一个就是考虑的连接数据库。</p>
</div>
<div class="paragraph">
<p>2.切换数据库</p>
</div>
<div class="paragraph">
<p>一般连接数据库过后，你应该切换，就是白了，要进入数据库，你切换完了过后，现在开始就可以正常用了。</p>
</div>
<div class="paragraph">
<p>3.读取结果</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>我用的时候，正进行一个表的读写，那我切换数据库，下一个应该是查询，所以这个时候我应该用SQL，然后现在SQL查询其实是有很多小步骤的，我肯定是通过前面讲的使用场景的某个东西，但是又发现在这个地方其实根本就不重要，为什么？因为你SQL查询，不管你是哪种语言，步骤都差不多，打个比方，你用非常原始的JDBC，你要先用pre去加一个satement，先把这个SQL预编译放在那，因为他做语法检查，然后你要用什么accq去调用这个SQL做执行，把它发送给MySQL服务端，然后他收到过后，要响应你一个结果及result，说白了，你不管哪一种数据库，他的行为都差不多，你不管哪种语言，他都差不多，没有本质上的区别。</p>
</div>
<div class="paragraph">
<p>然后你说我用JPA的时候，或者Mybatis等等的时候可不是这样的，它们只是把这个行为帮你做了，所以这个地方我们就忽略掉那些细节，因为现在我们不关心，那这个时候我查询完了，有个读取结果，当然，这个地方我有意忽略掉了网络的传输，因为那个东西不该我管，为什么？他的Driver层已经实现了，和我没有关系。</p>
</div>
<div class="paragraph">
<p>4.释放资源</p>
</div>
<div class="paragraph">
<p>取出结果后吗，我也使用完了后，它是需要释放的，这个和语言有关系，但是我还是把它写上，就是这个地方应该是释放资源，分配可能是前面，你看我前面没有说分配，那为什么释放呢？所以我说这个是广泛的一种型，释放资源不是每一种编程语言都要做的，是根据你语言不同导致的，比如你有Java，他有gc，有gc你是不需要什么释放的，如果你用GO语言，你如果不是写GO语言的runtime的话，他是没有gc的，为什么？runtime的意思就是说是内核的那一部分，GO的内核的一部分是不需要做gc的，但是GO的runtime以外的代码你是可以让他的gc帮你托管，所以说，在GO的runtime里面，说白了他自己实现自己，他肯定没有GC，所以他自己的内核里面是不会有提示的，是手动处理的。</p>
</div>
<div class="paragraph">
<p>那么用GO是可以写个操作系统的，但要看你怎么去用，那么C++就要手动释放了，C也是，Py看起来不用，但是你会发现Py有时候要掉个close，其实也是干这个事情的，所以这个地这一步不是必须的。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_HTTPYY_chapter">14. HTTP协议(应用)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_13">14.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/HTTP应用板书1.jpg" alt="HTTP应用板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP应用板书2.jpg" alt="HTTP应用板书2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP应用板书3.jpg" alt="HTTP应用板书3">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http是什么">14.2. HTTP是什么？</h3>
<div class="paragraph">
<p>今天我们讲一下HTTP协议，我们之前讲过HTTP报文，还有HTTP和Java的一些结合，那今天我们讲应用，首先老规矩啊，他是什么？他能干嘛？</p>
</div>
<div class="paragraph">
<p>首先我们把HTTP一个字一个字拆开：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>H-----&gt;超（Hyper）

T-----&gt;文本（Text）

T-----&gt;传输（Transfer）

P-----&gt;协议（Protocol）</pre>
</div>
</div>
<div class="paragraph">
<p>这个HTTP就是超文本传输协议，上一次我们在讲HTTP报文之前简单提过，今天我们讲的肯定就不是着重讲他的封包和解包，我们现在讲的是他的应用，也就是他应用在哪些方面，用来干什么，用完了过后看着是什么效果？然后讲完这些过后，我们再讲一下HTTP/1.1和HTTP/2.0甚至还有HTTP/3.0，它最终是一种什么形态，为什么需要它？</p>
</div>
<div class="paragraph">
<p>首先，那么超文本我们还是接着上次就是的讲，上次我们讲的超文本是什么意思？超越文本，所以他是超越文本的传输协议，那什么叫超越文本？首先在回答这个问题之前我们要搞明白一个问题：“什么是文本？”首先你要搞清楚文本，比如说文本的话，你可能会见到:</p>
</div>
<div class="paragraph">
<p><code>ABCD测试</code></p>
</div>
<div class="paragraph">
<p>这可能是你某个文件里面一段文本，他只是字数少或者字数多的问题，那么超文本。</p>
</div>
<div class="paragraph">
<p>打个比方，这里我们有下面的文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;html&gt;
    &lt;H1&gt;
      Hello,World!
   &lt;/h1&gt;
&lt;/html&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>这段他也叫文本，你用英文，要是我这个地方写两个中文就是中英文混合，那它也是文本，这两段同样是文本看起来是不是现在这个有点特殊。</p>
</div>
<div class="paragraph">
<p>那么第一段“ABCD测试”，如果把这段文本放到计算机里头，计算机认识他吗？或者说计算机能轻易知道他的内容吗？</p>
</div>
<div class="paragraph">
<p>比如说你是科大讯飞的，你拿着这个文本啥都不干，我就问你科大讯飞的输入法或者是你的识别程序能识别它吗？能识别到哪种程度啊？它能理解吗？</p>
</div>
<div class="paragraph">
<p>那再问你个问题：我随便写个程序能识别第二段文本吗？</p>
</div>
<div class="paragraph">
<p>这一段文本有个特殊的点就在于它是对齐的，成对出现的，这就意味着什么？首先他是文本，那这是文本里面的哪一种？它是一种结构化的文本，那什么是结构化吗？他有结构，那什么是结构呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

修房子，你没有图纸，但你得有顶梁住，图在心中嘛，不然怎么修的房子呢？修房子有图纸，你把图纸画出来，它是什么样的？和这里的结构化文本区别在哪？工人拿到图纸知道怎么去施工，因为你房屋修建，房屋建设这种，他是有一定的行规，所以你刷图纸的时候，大家都知道你画的是什么，就算工人不认识图纸，他都不可能把你这个房顶弄到地基下面去。</pre>
</div>
</div>
<div class="paragraph">
<p>所以那这个时候，这种东西叫结构化文本，首先你要看他当中的一些潜在规律，html和/html是对齐的，意思就是说，在他和他之间的内容一定有特殊的意义，然后中间这个h1和/h1也是这样的，就算是学过简单HTML的人都知道他是这个是一个标题，这个就是结构化的好处，为什么？因为它有规律，还有规则，只是这种规则可能你现在不了解，但是你知道它是结构化的，那我把第一段话改造成结构化，怎么改？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方：

&lt;B&gt;abcd&lt;/B&gt; &lt;Test&gt;测试&lt;/Test&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>这样是不是就改成结构化的了？然后再换一种写法：</p>
</div>
<div class="paragraph">
<p><code>#ABCD#测试[Http://qq.com]</code></p>
</div>
<div class="paragraph">
<p>改造前它是一段文本，改造后它也是一段文本，但改造前的文本拿给程序没有任何意义，他顶多就是说当一个工具人啊，你输入什么，他输入什么，但改造后就已经是智能的人了，带智慧的人了，为什么？因为他会把#ABCD#这个标黄，在那个SC里面，还可能加粗，后面的可能是链接，那为什么能实现这种效果？首先为什么讲这个，我的意思就是说超文本传输协议，说白了，这句话要怎么看：</p>
</div>
<div class="paragraph">
<p>“ <code>超越文本</code> 的 <code>传输协议</code> ”</p>
</div>
<div class="paragraph">
<p>HTTP是传输协议，没有问题，那你会发现这个超越文本是可以省略的，那么HTTP就是传输协议的一种，我们要挨个解释，怎么解释啊？这里面肯定有几个东西：</p>
</div>
<div class="paragraph">
<p>1.文本</p>
</div>
<div class="paragraph">
<p>文本就是所看到的文字，比如：英文、中文、法文、日文、印度文、马来文他们都是文本，甚至说，你自己随便乱画，写玛雅人的文字，虽然不认识，但是他也是文本，反正你的眼睛看得见的，反正只要不是图片，统一归纳成文本是没毛病的，甲骨文也是文本，但是你并不认识甲骨文，所以我们讲文本的时候，一般是指的广泛意义上的文字，至于我们认不认识这个文字，我觉得没有关系，比如说像法文，我就不认识，但是你能说法文不是文本吗？所以这个地方的文本肯定是指的是什么，那么它通常意义指的是计算机领域的，因为你在计算机以外，这个文本可能叫书、报纸、说明书，甚至是墓碑的碑文，比如说那个中国古代有些古墓，他就会立个墓碑说这里面是谁谁谁，记录上他的生平事迹，你看，文字有各种各样的名称，为什么？只是因为每个文字对应的载体不一样。</p>
</div>
<div class="paragraph">
<p>就比如：看书载体是纸张，然后你说你在干嘛，你说我在看kindle，那难道kindle上就不是书，不是文本了？他也是，然后别人问你干嘛，你说我看报纸，那你看报纸不也是看的文字，但是你不会说我看文本你说我看报纸。</p>
</div>
<div class="paragraph">
<p>所以你会根据你的载体不同，就可能会看到不同的东西，但在计算机领域这些东西都可以统一称作文本，为什么？因为在计算机的眼睛里头，不管你的载体是哪一种，最终传递的都是信息，信息很可能就是用我用文本的来传递的，程序写代码，他用JSON传给你，或者是我在qq上文字传给你，通常也都是通过文本来传递的，当然0101它广义上也是文本，只是你不懂，但是计算机是懂的。</p>
</div>
<div class="paragraph">
<p>所以这个地方：</p>
</div>
<div class="paragraph">
<p><code>文字：-&#8594;计算机-&#8594;文字</code></p>
</div>
<div class="paragraph">
<p>文本是载体，那么只要载体是计算机，然后再加上文字，至于这个文字是认识不认识的都没有关系，说白了，你可以理解为Data，任何东西都是Data，甚至图片也可以Base64传，pdf也是可以的，把pdf弄成Base64，他也可以传，当然我如果不转成Base64，把那个mp4直接播放给你看，你看的是流媒体，它也是文本啊，只是说这种文本非常特殊，你专门给他取了个名字，叫视频流，那超人不是人吗？但是你会把他叫超人。</p>
</div>
<div class="paragraph">
<p>所以说凡是在计算机领域，我们指的文本一般是指的文字，这种文字有英文、法文、还有一些符号，这些我们都会认为他叫文本，你理解为文字是没毛病的，但是一定不是新华字典上那个范围啊，新华字典那个范围太窄了，我们讲的是那么很大的字典，凡是手能写的都是。</p>
</div>
<div class="paragraph">
<p>2.传输
传输怎么理解，计算机在没有互联网之前，大家都是拿软盘拷来拷去的，我们那个时候不叫传输，我们那叫copy。</p>
</div>
<div class="paragraph">
<p>讲个冷笑话：以前我们合作公司有一个美女叫张燕，他那天跟我讲那个冷笑话，我也不知道是故意逗我玩了，还是真的发生了，她千里迢迢跑到隔壁公司，把我叫过去，她说她遇到个问题，什么问题?然后她说：我在家里面Ctrl+C，然后到公司Ctrl+V可是没有东西，当时我楞了一下，好像是有道理，然后看到她表情很严肃，这时候我也不能笑场，我就给她说这个不能这么拷，你要在同一台电脑上做，我不能直接说。</p>
</div>
<div class="paragraph">
<p>所以传输它完成的是一种Copy动作，那什么叫传输？就是网络Copy，那怎么理解网络Copy呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

在以前Copy的时候，是拿那个软盘，你把它Copy那个软盘上面，然后你要让很远的人来Copy资料，那么你去拷贝这个过程当中，是不是还要买机票？比如说女朋友在海南，你在北京，这个时候你就要买机票，所以怎么样，贵，还不方便。

那这个时候大家想的能不能通过网线直接把这个数据传过去传说，这也是在做Copy，那么这个传输你可以理解为通过网络Copy数据，因为这个地方讲的是传输这个词，那肯定是用数据嘛，数据比文字的信息范围更大，所以传输的话就是通过网络复制数据，从A点到B点，他完成是这种动作。</pre>
</div>
</div>
<div class="paragraph">
<p>3.协议</p>
</div>
<div class="paragraph">
<p>什么是协议？可以理解为字典、说明书，字典说明书是什么意思？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你不会说普通话的外国人，你随时带一本新华词典，就以前没有app的时候，然后你走到一个人前面用蹩脚的发育说：“你好”然后不知道吃饭怎么说，你就打开字典，在对那个人说：“我要去吃饭。”那这个时候一个不会说普通话的外国人，他能通过一本词典和你搭上线，那么搭上线过后，剩下就好办了。</pre>
</div>
</div>
<div class="paragraph">
<p>就是我我经常在网上看到有些人就是出国玩，跟的一个旅行团，里面全世界的人都有，然后有一对英国夫妇，然后还有一对日本人，然后他们是中国人，他们6个人坐在那个地方看世界杯聊天，怎么聊的呢？中国人先把自己想说的翻译成英语，然后给英国人讲了一遍，他们就用那个翻译机之类的，然后他们聊完了英语，再翻译成日文再跟那一对日本人聊，虽然这样聊天很累，但是他们坐在那地方聊了整整六个小时，他们聊的过程当中还会嘻嘻哈哈的，为什么？如果那个事情不有趣，我相信你不会在那做一天的，不过有可能是外面下雨，所以通过一个词典或者一个翻译app，你就能做到和别人沟通，所以那个的词典就叫协议，只是那本词典是给人用的协议，而协议是给计算机用的，肯定不是人和人之间的，你想想我跟你一起说话的时候用HTML语言说，一个一个字的念，人肯定觉得很烦而且听不懂，所以协议一定不是人和人之间的。</p>
</div>
<div class="paragraph">
<p>所以那个的词典就叫协议，只是那本词典是给人用的协议，而协议是给计算机用的，所以这个地方指的协议首先类似于人和人之间的词典，那要去解释他的话，表示的是用于计算机和浏览器之间的，为什么是浏览器？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

刚刚举了计算机给你讲HTML语言的例子，人会去嫌他啰嗦，而且你还听不懂，所以这个时候计算机和浏览器讲呢？它们能听懂的，这个地方的传输是指用于计算机之间传输数据的载体。</pre>
</div>
</div>
<div class="paragraph">
<p>那载体是什么？我们第一点讲的文本，它就是内容的载体，这个地方协议也是用文字写的，很巧吧，为什么那么巧？你的协议，就像我刚刚念给你听的HTML语言，他也是文本，所以这个地方传输数据的载体，而这种载体你可以理解为传输数据的一种格式，那么这个载体的话就是相当于一种特殊格式的文本集合，当然这个地方为了表达清楚我的意思，我可能用了几种不同的方式去表达，但是你得知道这个地方，最终他肯定是某种规范或者说明书，总的来说就是：“相当于一种特殊格式文本集合的说明书。”</p>
</div>
<div class="paragraph">
<p>这里说明书你可以理解为一种规范，而计算机和计算机这个地方就表示是在限制范围，后面两句话才是真正的解释，你想嘛，我们讲协议的时候，肯定是讲了一本说明书，所以这个地方其实载体意思就是说，传输数据你得有说明书，那个说明书里有说数据是怎么用的。</p>
</div>
<div class="paragraph">
<p>我们以后我再整理一个更完整的表达，但是现在我先表达清楚我的意思啊，就是可能你没有办法讲得非常通俗或者是一句话讲明白，但是你知道，协议就是词典，就是类似于说明书。</p>
</div>
<div class="paragraph">
<p>现在撒回过头来反过来看这句话：</p>
</div>
<div class="paragraph">
<p><code>超越文本的传书协议</code></p>
</div>
<div class="paragraph">
<p>这个地方协议，就是本说明书，传输协议就是用于通过网络复制数据的说明书，然后加上超越文本就是：超越文本的传输说明书，所以前面是在限定他这个说明书的范围，这地方的超越文本很重要，说白了，这个地方的意思就是说HTTP是一个文本的传输说明书，然后加一个更具体的词：“超越”，那就是超越结构化文本的说明书，所以这个地方HTTP真正要有个更完整的解释的话，它是一个：</p>
</div>
<div class="paragraph">
<p><code>结构化文本</code> 传输协议</p>
</div>
<div class="paragraph">
<p>其实前面用的的话，其实都不是很正确，因为他们没有所属关系，是平等的，然后我把这个词再换一下：</p>
</div>
<div class="paragraph">
<p>结构化文本 <code>网络复制</code> 协议</p>
</div>
<div class="paragraph">
<p>如果是新手的话，网络复制比传输好理解一些，但是这里没解释协议，在补充一下：</p>
</div>
<div class="paragraph">
<p>结构化文本网络数据复制 <code>标准</code></p>
</div>
<div class="paragraph">
<p>这就是我们通过一层层偷换概念，做等式替换，最后得出的一个结论。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http的使用场景">14.3. HTTP的使用场景</h3>
<div class="paragraph">
<p>我们之前讲过的，像这种总结，不要去总结他的特点或者他的优点或者劣势，为什么？你把使用场景讲明白了，用在那个场景下面，他肯定就简单噻，所以特点优点那些东西都是什么强行总结出来的,所以我们直接讲这玩意儿用在哪儿?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>浏览器</p>
</li>
<li>
<p>Web服务器</p>
</li>
<li>
<p>手机APP（mini浏览器）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我把这个浏览器装在那种电梯里面的广告大屏里头，也是可以的。那我装的摩拜在单车里面呢？你会发现，如果我们以工具来讲这个事情的话，你会发现世界万物都有他的身影，但是你要用特殊场景的约束的话，其实和他没关系，为什么？因为什么什么都可以，所以我们这地方讲的时候，迷你浏览器，这个地方就有意思了，那么使用场景，这是其实就是规的一类，就是浏览器，那么现在解释浏览器，浏览器有什么作用哈？</p>
</div>
<div class="sect3">
<h4 id="_浏览器">14.3.1. 浏览器</h4>
<div class="paragraph">
<p>就是你用浏览器的时候，首先它有个漂亮的网页。他你输入域名过后能看到网页，然后他看起来能和Web服务器通信，现在我们来解释一下浏览器的作用。浏览器在这个时候，其实它是什么，我们之前讲过的，一个叫服务端，一个叫客户端？但是我们要回避这个概念，为什么？因为这个概念在第一阶段讲得过多人会晕，因为太专业了，所以现在我们只讲浏览器。</p>
</div>
<div class="paragraph">
<p>浏览器可一点都不不比操作系统简单哈，上一次我看他们讨论这个问题，浏览器的代码量好像突破3000万行了，Chrome浏览器的3000万行，所以浏览器它很复杂，但对于我们来说用起来简单，我讲过的，你使用越简单的东西，实际上实现代码越复杂。</p>
</div>
<div class="paragraph">
<p>所以那浏览器第一个作用展示网页，那第一个它能展示网页，那下一个它有什么用？你都要展示网页，你的网页哪来的呀？传输数据不准确，为什么？浏览器现在它是个孤零零的，他一个人是不能传输数据的，你可以讲接收数据，或者发送数据，你不能讲传输数据，你要讲传输数据，一定是说a和b之间传输数据，而你从你自己出发，你应该这样的，要么你发送数据，要么你接受数据，这个才是和你相对的。两人你可以说传输，一人你只能说发送或者传收到，所以第一个肯定是展示网页是最重要的功能，但是在有网页之前，你要先输入一个网址，然后这样的话应该请求网页呀，你肯定要去请求网页嘛，请求嘛然后怎么样嘛？收到撒，那我们按顺序来写吧，没有顺序的话可能理解起来很麻烦，讲HTTP一定要讲这个，如果你不理解他，你理解不了整个HTTP，为什么？和你的生活八杆子远。</p>
</div>
<div class="paragraph">
<p>谁知道为什么我要讲这个，为什么我要用这个角度跟你讲，知道为什么吗？一样事物你在两句话以内你让别人听不懂，你就是不理解他，我指的这个理解说你和程序员沟通你肯定不用给他讲什么是HTTP，为什么？你默认他是知道的，如果他不知道他自己去补课，但是你和你的同事老板沟通，可能有时候的同事是个销售，所以你为了你自己沟通怎么样？你要沟通这个问题的话，你要先去理解，而不同的讲话对象，你的沟通方式是不一样的，写代码其实相比你说话来说写代码容易多了。</p>
</div>
<div class="paragraph">
<p>所以浏览器的作用就是先 请求网页请求网页，那么我请求肯定就收到噻，就像我订报纸一样，我交了钱，你得给我报纸嘛，拿着报纸过后干嘛呀？看报纸啊，你生活里面也是这样的，既然浏览器这个作用，那Web服务端和浏览器是相对的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求网页</p>
</li>
<li>
<p>接收网页</p>
</li>
<li>
<p>展示网页</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_web服务器">14.3.2. Web服务器</h4>
<div class="paragraph">
<p>浏览器既然能请求网页，第一步就是受到请求，这个地方收到请求肯定是省略了网页，第二个就是处理请求，处理请求的意思就是说，他得知道是访问到哪个网址，然后他知道这个事过后，他应该先去准备网页呀，准备好了快递再给你寄出去，所以第三个就是生成网页，最后一个是发送网页嘛。</p>
</div>
<div class="paragraph">
<p>请求网页是对应收到请求，接收网页是对应发送网页。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>收到请求</p>
</li>
<li>
<p>处理请求</p>
</li>
<li>
<p>生成请求</p>
</li>
<li>
<p>发送请求</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在你知道了使用场景是这样的，就是我们看图说话：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/简易Web图.png" alt="简易Web图">
</div>
</div>
<div class="paragraph">
<p>就是用户在浏览器上面输入网址过后，敲回车会产生一个请求网页的动作，然后这个时候服务器收到这样这个请求，然后去理解去查看这个网址里面具体要访问哪一个，他就说白了这地方是查看或者分析出要查看分析哪个网页，找到那个网页的地址，如：/index.html，找到那个网址过后，那么交给程序代码去查数据库，去读取服务器上的各种应该处理的或者说分析的东西，然后最终拼凑出一个网页，那么拼凑出完了过后把这个网页原路发送给浏览器，浏览器收到网页内容过后把网页展示出来。</p>
</div>
<div class="paragraph">
<p>这个地方再做个补充，就比如：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/关系对应图.png" alt="关系对应图">
</div>
</div>
<div class="paragraph">
<p>qq.com，然后qq.com的请求过去了，然后返回回来的&lt;html&gt;标签嘛，就刚才结构化的文本，服务端把网页发给浏览器了，然后展示出来。</p>
</div>
<div class="paragraph">
<p>这是个引子，现在同样事情我们再把它往细了讲，在中间这个地方涉及到通信。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CS模拟图.png" alt="CS模拟图">
</div>
</div>
<div class="paragraph">
<p>所以浏览器是C，Web服务器是S，他们之间要发生各种请求和响应，那你要发生请求和响应，这个高速公路名字叫什么呀？然后这个高速公路叫HTTP高速公路，那这个高速公路上跑的车，那个车是HTML，现在我们就开始解释这个高速公路。</p>
</div>
</div>
<div class="sect3">
<h4 id="_客户端与服务端之间的传输媒介">14.3.3. 客户端与服务端之间的传输媒介</h4>
<div class="paragraph">
<p>然后我们现在详细来讲一讲这个高速公路上发生了什么，我们刚刚讲的是c这边和s这边它整个说话的过程，一共看起去两步嘛，然后这两步解决了他说话的过程，然后我们再了解一下他们两个说话过程当中传输媒介，这高速公路就传输媒介嘛，网线是一个传输媒介，软盘是一个传输媒介，u盘是一个传输媒介，光盘是一个传输媒介，空气是声音的传输媒介，水能传输声音，它也是一个媒介，但是你在太空里面说话有媒介吗？没空气就没媒介，为什么？声音就传不了？当然你把大海的水倒上去也不是不可以，那也可以传输了，就是有点有点废油哈。</p>
</div>
<div class="paragraph">
<p>所以那这个时候，我们就把这个高速公路展开。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/网线原理图.png" alt="网线原理图">
</div>
</div>
<div class="paragraph">
<p>我假设这边是C，这边是S，中间有一条河，所以那这个中间这个高速公路名字叫HTTP，所以就表示是中间这一块，那刚刚浏览器这个地方我就弱化这个里面具体的东西哈，我们着重讲一下浏览器这个地方他有个请求网页，所以这个地方我们他发生了一个叫请求，然后Web服务器这个地方他又回去了，我们把它叫响应，为什么刚才不叫响应，是因为刚才我们还在讲这个事情初级阶段我不敢用响应，然后一个请求，一个响应，他们中间的传输媒介是什么？HTTP，就像及了高速公路，然后这是往左边跑的车，这是往右边跑的车，只是车的牌子，一个叫响应，一个叫请求，仅此而已哈，然后说白了这个时候，你可以理解中间这个东西，物理媒介，这个中间是网线嘛，现在是这样的，我们把这个图倒一下，先画一个网线，用波浪线哈表示网线，然后这边是C，这边是S，然后那网线上面他有一条高速公路，当然你会发现其实高速公路上还有很多其他的东西，而这个地方最开始C向它发起了一个动作，那这个时候C朝S这边发送了点什么</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/请求.png" alt="请求">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/响应.png" alt="响应">
</div>
</div>
<div class="paragraph">
<p>所以这个时候S应该响应，现在有个问题了，那现在是HTTP是说明书，那它是一个规范吗？在规范里面肯定有关于传输的东西，我们刚刚说网页是通过他传的，既然你是传输协议，传输协议你肯定有关于传输的东西，现在讲的就是传输的东西，那应该还有协议相关的东西，我们刚刚讲的还要传输一些结构化的文本，文本在哪？就在这个车上面，所以这个时候他会把HTML源源不断的朝这边发，其实这个地方不是HTML是什么，其实准确来说就是应该是报文报头，所以这个地方其实你最开始发过去的东西不是HTML，所以这个地方准确说应该是什么，报文太专业了，换一个词，所以这地方你可以叫请求数据包，但是通俗点的说法叫网址，你就是把网址传过去了，只有网址上面带参数，我是普通人，我也不关心参数，比如说你问李俊祥他用鼠标点的时候他看得过参数吗？他想都没想这回事，你在QQ空间传相册的时候那个从来没有想他说他发起个POST的请求，为什么？你脑子里面不会想这些事的，为什么？因为和你没关系，反正也可以用，所以这个地方你是请求请求数据， 准确的说的话，这个地方应该是网址，你把网址相关的信息丢过去了，网址相关肯定包括网址本身，还有那个问号后面给他参数嘛，他如果是一些上传图片的操作，肯定还要把图片带过去嘛，所以叫网址相关，那我把网址相关的东西丢过去了，所以这个时候你回的时候回的是HTML数据，实际上你就可以理解为一个网页，过去是一个请求，请求数据网址相关的东西包含参数，回来的时候直接就网页了，所以你看到没有使用场景，他使用场景是这样的，发生在两端，当然真实的情况下头他肯定不是说是一对一的，真实情况应该是这个样子的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/多对一关系图.png" alt="多对一关系图">
</div>
</div>
<div class="paragraph">
<p>这是个s，那么s的话应该接受怎么样？全世界的人访问，所以你看到没有，那他要接收很多很多人同时访问，所以其实他是很厉害的，所以知道什么是服务器了吧？你搞清楚一对一的关系，你无非是在这个地方变成了多对一，所以c和s之间的关系是多对一。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http1_1_vs_http2_0">14.4. HTTP/1.1 VS HTTP/2.0</h3>
<div class="paragraph">
<p>我们在讲HTTP/1.1和HTTP/2.0之前，我们先问一下自己，为什么微软发布了Win7然后还要发布Win10？</p>
</div>
<div class="paragraph">
<p>因为你发版本一定是想塞一些自己想塞的东西，Win7已经塞不下去了，他必须要操了重新拆的Win10里面，你得总有点客观因素哈，这种客观因素因素肯定是你很主观的总结出来的客观因素，比如微软说Win7的架构太老了，我们重新搞一套，改成Win10，Win10更快，性能提升100%然后经常我看到这种新闻，我就很纳闷， 每一次那个发送的Json，他都说性能提高了30%，你是多慢呢？包括那些浏览器这些，也是说自己又提升了百分之多少，你说可以，关键你每次这么说我就很纳闷了，但为什么我感觉不到呢？我讲过的我家里面有一台宏基的上网本，他现在已经打不开淘宝首页了，就是打开淘宝手机是什么现象哈，我那个电脑开着我就没打开过淘宝首页，懂我意思了噻，就是再转圈圈，我也好不容易装上Chrome，为什么说好不容易呢，真的太难了，裸奔的Win七要装Chrome，要经经过各种环节，装上了过后他就淘宝手机一直转圈他就渲染不出来，当然有可能淘宝嫌弃我的Win7，他把我干了，但是不只是淘宝，京东打开也慢，但是京东能打开就是丑了点，为什么？因为可能你换了个新的操作系统，但是意味他消耗了资源更多，我那个上网本一共就2G内存，开了Win7，1.5G就没有了，然后剩下500M，开了个Chrome，占了200M，我也不知道为啥，然后剩下300M，看情况发挥，那就是这个情况，所以你总会塞一点自己的需求进去。</p>
</div>
<div class="paragraph">
<p>那么从1.1到2.0你要是想知道HTTP你得首先得知道一个组织W3C，就是你要是聊这个话题的话，你首先得知道W3C，W3C是什么？是万维网的一个委员会，具体你可以到我维基百科上去查，这个委员会他负责HTTP规范的制定，意思就是说这帮老爷爷管着你天天用的浏览器里面那他跑着的东西，当然我们在说HTTP的时候肯定是包括HTML，因为他们是一体的他们不是分开的，超文本传输协议，你得有超文本，你才有传输，你超文本都没有，你传啥传呢？你传一个Hello Word过去那没用，所以W3C负责制定他的规范，那他制定过哪些规范呢？大概是从1991年，HTTP好像是0.9我忘了哈，到后面过出现过HTTP的1.0，HTTP的1.1，1.1是大家欢迎的，因为用的最多，当然在1.0时候你的电脑都买不起，你更不要说浏览器了，都还没有奔小康呢，现在有HTTP的2.0，当然有2.0就有3.0，然后有巧了哈，2.0和3.0个都和Google公司有关系，所以欢迎更多的中国企业参与，参与互联网的基础设施的这个开发工作和标准制定，但是看起来还是太少了，华为参加的都是一些通信基础设施的，比如说5G的标准，还有一些就是其他领域，但是还是比较少的，比如内核也是有的说的这个，估计这个国内就华为提的多，像小米这些企业内核里面提补丁你想的别想了。</p>
</div>
<div class="paragraph">
<p>所以那这个地方的话，谁是W3C，他是负责规范的制定，那么他制定过哪些规范就是这些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP/0.9(没人用)</p>
</li>
<li>
<p>HTTP/1.0（Nginx默认，一点点人用）</p>
</li>
<li>
<p>HTTP/1.1（最多人用）</p>
</li>
<li>
<p>HTTP/2.0（）一点点人用）</p>
</li>
<li>
<p>HTTP/3.0</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么3.0现在还处于一个孵化阶段，还是个胚胎，那么现在可用的就是上面这些，0.9是没人用的，然后1.0呢？Nginx反带的时候，默认Nginx用的是1.0，为了兼容一些老网站，所以1.0这个有一点点人用,1.1这个用的是最多的，2.0这个是有一点点人用，为什么？因为他太新了。</p>
</div>
<div class="paragraph">
<p>然后现在我们来讲一下为什么你应该从1.1升级到2.0，讲完这个问题过后你就倒过去，就是为什么要去升级，然后讲完为什么升级，我们再倒过去讲它里面的技术细节，倒着来，首先，我讲一下当前为什么有HTTP2.0?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1.1慢（表现在加载网页速度慢，具体指的是同域名下网页加载速度慢，就是浏览器有限制）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你是前端程序员的话，你肯定听说过浏览器的网页并发限制，就是一个浏览器，你可能同时只能一个域名下面打开十张图片，然后十张图片以外，你要想打开的话，你必须得前面那一堆加载完了，下面始终才加载对的排队，就出现了排第现象，特别是购物网站，电商网站的首页的图片是贼多，然后你会发现，他们的图片很大可能性都是放在几个子域名下面，这个慢表现在就是纯说现象的话就是加载图片慢，加载网页速度慢，那么加载网页速度慢，这个地方都加载网页具体指的是谁？这个地方具体指的是同域名下网页加载速度慢，这个速度慢是指的有浏览器限制，这个就是第一个慢，就是浏览器有限制，现在可能有人有人会问，浏览器他活的好好的，他为什么要去搞一个限制？我觉得大家应该追根到底，为什么他要限制？你可不可以开发一个不限制连接数的浏览器？我觉得要是能开发出来大家早开发了，但是就没人干，证明这个活不简单或者证明这个活不可能，他这个地方地方慢是因为操作系统，他这个地方慢是因为他需要一个东西，他需要多个TCP链接，而且他需要三次握手，TCP连接多个三次握手这个东西为什么会导致他的限制呢？那个是因为这个，下面具体来说的话就是操作系统。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

像以前XP的时候，那个时候Windows同时都不用说几千个了，估计几百个你都会崩掉，卡顿重启才能好，可能大家没有在遇到过这种特殊情况，但是浏览器厂商经常遇到，为什么？美国图书馆本来就穷，因为美国人生活在那个水深火热当中，他们现在用Win97、98、XP，你想想今年都是2021年了，那个电脑好好的他们不可能无缘无故去换操作系统，他不可能去换电脑，所以这个时候，如果他上面装了个Chrom，你可以想象一下Chrom一启动，然后电脑就瞬间蓝屏，这不是不可能的，只能重启，没有什么是重启解决不了的，实在不行，换个电脑。

以前我还遇到过Win 7连接多个，Win7也会死，没想到吧，但是你问我具体连了多少个，这个我不方便透露，我只能说我写程序写的有点猛，就是我的那个Win7是作为一个请求的客户端，但是运行着运行着他就崩了，然后Win Server 2003也遇到过这个问题，XP肯定是遇到过的，你只能重启才能解决。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个地方操作系统有连接管理问题，那么操作系统它有各种各样版本，所以做浏览器厂商，要去考虑这些问题，这是浏览器本身的限制，涉及到操作系统层面，那么还有一个，这两个其实是一个原因，都是由于操作系统导致的。</p>
</div>
<div class="paragraph">
<p>那么还有个原因就是你的网络线路运营商的问题，它也会限定连接数，中国电信它的连接数是有上限的，你可以试一下，同时建立500个tcp，你会发现你会变慢，那是因为你开那么多连接去连接运营商的交换机，再去连其他人，运营商也有开销，你把连接端口都占了，别人怎么用？运营商只能说把你限制，为什么？你这种毕竟是少数，大多数十个二十个顶天，但是如果每个浏览器都开1000个连接，中国电信早垮了，所以浏览器厂商，他一定会考虑这两个最大的原因。</p>
</div>
<div class="paragraph">
<p>我相信我是全网第一个告诉你运营商有限制的，大多数人都会告诉你说操作系统有限制，但是你得知道这种限制不仅仅是操作系统有，网络也有，当然你说在国外就没有这个问题，我相信大家的交换机都是一个样子，只是外国人比较少而已，你不能用户少来相比，你人少是你自己不生。</p>
</div>
<div class="paragraph">
<p>这是第一个慢，那么第二个慢，它还是“慢”，有意思了，刚刚慢为什么现在还慢？这里讲的慢是执行速度慢，不管是传输还是执行都慢，所以这个地方分了两块。</p>
</div>
<div class="paragraph">
<p>1.传输量相对大</p>
</div>
<div class="paragraph">
<p>那么第一块就是传输，这个传输量指的就是字节数，HTTP他有自己的规范，有自己的请求报文和响应报文，然后这个时候，他的报文里面的头是不能压缩的，而那个头，你每一次请求网站网站，他都把固定头还给你比如说Cooking，首当其冲的就是Cooking，你访问拉钩、Boos直聘这些网站的Cooking，基本都塞满了，那个地方有200字节以上都不过分，打开F12你去看一下，贼长了，所以这个数据量主要意味着头的开销，尤其是cookie。</p>
</div>
<div class="paragraph">
<p>那么还有一个是重复，重复传输在没有经过任何处理的时候，重复传输一定是有开销的，所以传输量大就意味着HTTP/1.1更耗带宽，那么这个慢就体现在传输量相对比较大，执行速度我觉得都不是最重要的，因为压缩过后，其实按常理来执行速度应该会慢一些啊。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_HTTP1.1VS2.0_chapter">15. HTTP 1.1 VS 2.0</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_14">15.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/HTTP%201.1%20VS%202.0（1）.jpg" alt="HTTP 1.1 VS 2.0（1）">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP%201.1%20VS%202.0（2）.jpg" alt="HTTP 1.1 VS 2.0（2）">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP%201.1%20VS%202.0（3）.jpg" alt="HTTP 1.1 VS 2.0（3）">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http1_1第二个慢是慢在哪">15.2. HTTP1.1第二个慢是慢在哪？</h3>
<div class="paragraph">
<p>我刚刚说了就是昨天讲了就是慢在他的请求头是重复传输的，比如说昨天我举的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>比如说昨天我举的例子，就是cookie，cookie这个字段经常程序员把一些存储的东西，有用户的什么id、域名都会放到里面，那这里面就无限膨胀，可能100字节200字节，每一次的来回传，其实是很消耗带宽的，但是那个值呢？你是没办法解决的，但是那个名字是可以做的，什么意思哈，就是比如cookie，我这个地方指的是名字哈那个值你肯定是没有办法做处理的，你没有说你上次传了我就存一下，HTTP没有这种功能哈，但是那个HTTP头的名字是重复传的，你想象一下，你访问一个网页，然后你肯定有HOST的字段，content-type，user-agent，包括些其他的什么长度这些东西，那这样的话，你每一次访问一个连接，你要发头可能加起来50个字节，第二次加载同一个网站的图片，那个头又来一遍。懂吗？重复传输，所以这地方头在重复传输主要指的是名字，所以第二个慢是，他的头是重复传输的。</pre>
</div>
</div>
<div class="paragraph">
<p>所以HTTP1.1慢，主要是慢在这两个点上。</p>
</div>
<div class="paragraph">
<p>当然还有一个慢是慢在它的内容没有压缩，所以第三个就是HTTP头没压缩，刚刚有人说GZIP，GZIP压缩那是压body的，你想象一下，GZIP压缩要耗CPU，解压要耗CPU，请求头那个东西本来就常用的，每次用之前就要解压，你不嫌慢吗？所以这个地方，这个压缩肯定是一种高效的压缩算法，肯定是追求高效简单，什么意思？我打个比方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>一个Base64你一眼就知道Base64你要反向来的话，任何在线工具你都可以解，所以解码和编码很简单，而这个地方也要用需要类似的东西，如果你这个地方把用7Z压缩了，当然可以压，但是太复杂了，你在协议里面还要加一堆关于压缩的东西，那就不符合实际。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个头确实没有压缩哈，因为头里面经常，我刚刚说cookie嘛， 这个地方我们稍微普及一下压缩它是怎么降低带宽的？我打个比方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>我们传了一个字符串，它是这样的，123abc12579，比如说我们传了个这个字符串，第二次，这个字符串在cookie里面再传一遍，他同样也是这么长，但是呢有没有办法让他变得更简单呢，就是为什么提压缩说这个事，其实你可以不提，但是有这个东西更好，压缩的时候是怎么压缩的，我们看一下这个里面有哪些东西是重复的，1出现了几次？2次，2呢？ 2次，你看，其实这个压缩比率很低，顶多少了几个字节，但是我得再来一个哈,比如说你经常那个创建网站用户的时候，你的手刚好放在左边，你现在会输入这个密码：111111111111，那这个字符串我压缩过后,我先统计他出现了这个类型的次数,1两次，2两次，3一次嘛，就以此类推，然后这个地方一出现了几次，一出现了12次，这是统计次数，统计完次数过后我要干啥，我要把它压缩，那这样的话，你就会写一个公式，你就会写个压缩公式，我们就简单的表示一下:

123abc12579  --&gt;1x2,2x2,3x1... --&gt;11字节
             --&gt;1x22x23abc579  --&gt;9字节+4=13
111111111111 --&gt;111111111111 --&gt;12字节
             --&gt;1x12 --&gt;3字节+3=6

你就写的是一出现两次，这个字符串后面紧跟紧跟1X22X23abc579,这个就是压缩过后的，压缩过后，他会把你的单词出现的频次和位置都记录下来,他在还原的时候，他就能倒着重新还原,你想吧，你看到这个公式，你可以倒着写把它写出来,是可以的我这个表达很简单，但是你知道的那这样的话，原来长度就这个这个乘号可以忽略，那这地方长度是多少？9个字节，那么他有9个字节,那这个地方很明显，他本来是12个字节，我这么写了，过后我写成压缩算法的公式，写完那个过后三字节,而上面这个地方，他本来原来是多少？他原来这地方12字节，再加上一些压缩算法的开销，这个乘号你也算上两个，再加上这个四9+4=13，然后这个地方123好像也是三个，但是它数字是两位，就1234那么抛掉这个一的话就有三个，所以这地方是3+3最终等于六，你看了没有，你的内容重复性越高，压缩怎么样？压缩算法就越厉害，虽然他非常非常复杂，所有的压缩算法，他都是用的这种一样的公式，只是他的这个公式的计算方式是不一样的，他计算完了，他的存储格式一模一样。就是他在他的文件前面一行，始终都是说我是什么压缩算法然后单词有多少长度多少？其实非常简单，你都可以写个压缩算法，只是有没有人用另外一回事，比如一百兆你压出来九十九兆，成功的也压了，只是没人用，只是这这种反向压缩特别明显，你压一个空文件，你压的空文件比你原来文件大多了，这就是为什么会有区别，这个地方就是作为一个就做了一个延伸哈，就是你知道就可以了，这个和HTTP协议没有关系哈。</pre>
</div>
</div>
<div class="paragraph">
<p>那这个地方头没压缩，速度慢，连接有限，都是讲的1.1，缺点找的够多了，TCP连接有限这个我们再重讲一遍，就是他影响的是网页的加载速度，因为连接有限，它最终导致的影响就是网页加载慢。</p>
</div>
<div class="paragraph">
<p>然后请求头重复，可能对你来说没有影响，因为你看不见，但是他是个耗带宽，当然我说的耗带宽肯定是相对而言更耗带宽是一种比较，那么既然耗带宽，我就问你个问题，如果是手机上用除了耗带宽以外还有什么缺点？耗电哈，请求头加载的速度慢，也是耗电呀，所以说白了HTTP1.1就是耗电，你看请求头这个地方没有压缩，耗带宽，那耗带宽肯定就是耗电，所以用HTTP1.1你的服务器其实没啥影响，服务器的电费不是你交的，但是他关系到那么多人，为什么?服务器耗电时有上限嘛，但是你手机一天比如苹果手机充两次电很正常吧，安卓手机一天充两次电就有就有点奇怪了哈。</p>
</div>
</div>
<div class="sect2">
<h3 id="_为什么有http2_0">15.3. 为什么有HTTP/2.0?</h3>
<div class="paragraph">
<p>最主要是移动互联网的发展，那么HTTP协议，他已经没有在这个场景下面就是更高效的一种通讯方式，我们需要更高效通讯方式跟省电的通讯方式，所以这个时候，HTTP2就应运而生，当然最开始google开发的时候，他其实不是为了解决耗电的问题，当时google开发主要是解决网页速度加载慢这个问题，谁知道网页速度加载慢为什么对google有影响？网页加载慢为什么会影响google的生意？不然google开发它干嘛呀？他绝对不会吃饱了撑的，因为影响广告加载了，你自己知道当年google和那个mozilla 的 firefox浏览器有合作，在他的浏览器里面是内置的google搜索框的，这样是为了让用户不打开网页就可以搜东西，到后面google觉得这个样子好像挣的钱还是不够多，如果那个搜索框满足google自己的战略的话，他为什么还要去搞chrome浏览器？真的就是因为那个笔记本os嘛？怕不是哦，他一定是感到浏览器这个方向如果不投钱的话，感觉自己控制不了，为什么？这些用户用的都是垃圾浏览器，我得从我的需要出发搞一个最先进的浏览器，让用户访问google更快，用上google的产品然后最终让google的营收变好，然后事实证明，自从苦有了chrome过后，你打开google再也不卡了，至少你现在卡是因为其他原因而不是浏览器，所以这个地方应该还有厂商的原因，前面讲了一堆缺点，我更觉得一定不是HTTP2诞生的最重要的初衷，一定是耽误挣钱。</p>
</div>
<div class="paragraph">
<p>你想吗？google的广告脚本一般是放在网页的最下头，结果前面都加载完了，google都还没加载完，然后用户都看完了，都关了都走了，google广告都没展示出来，你想吧，google的JS加载不了，那自然而然google的广告图片就不能被调用，然后这个时候用户都广告都没看他就关他就走了，你看到没有google解决这个问题的链路的很长，我大胆推测一下哈这是很影响他的其中一方面，至于google当年说要基于chrome这个浏览器造一个笔记本，我觉得那个是试探性的，我觉得那个不是chrome浏览器被google盯上然后去改造的一个根本原因，所以这个地方影响google挣钱，他通过两个方式解决的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个他提出了HTTP2但是他提出的不是叫这个名字，好像他提的叫spdy：//。</p>
</li>
<li>
<p>然后第二个，他觉得光改造了协议还是不行，所以这个时候，他要搞个更快的浏览器负责加载速度，你会发现chrome是为了加载HTTP2也是为了加载，他们最终都是为了让广告JS文件加载更快。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然他可能有其他的这些作用，因为是这样的，一个事物的诞生，肯定不是单一原因，一定是有需求，这种需求肯定有主要的需求， 就像那个社会矛盾有主要矛盾和次要矛盾，我们在社会主义初级阶段主要的社会那个矛盾是生产力不足，其他的民族矛盾，或者就是那种阶级矛盾的都是次要的，要先发展生产力，所以这个地方对于厂商来说挣钱才是最主要的矛盾，其他的都是靠边站的，包括这个地方可以延伸一下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>就是微软在今年的上半年，他们基于Open JDK自己打包然后自己发布出去，你这个是为什么吗？就是你用Java，你用Yum包，就装了一个Java的软件就能用，那微软为什么要自己搞一个？不是想塞东西，那是因为Open JDK都是靠良心发行版自己打包，然后这个打包过程当中及不及时、版本有没有？比如说经常用着用着版本就没有了，那微软也头痛他的用户要老版本你不给， 然后微软就干脆自己搞了个打包服务，我帮你打包，打包完了过你装的微软的那个JDK里面，你都还塞了微软的云服务的API，你还可以一键调用他云服务的东西，他肯定要塞自己东西，但是塞完了过后怎么用？那个是一系列的，他绝对不是个单一的目的，</pre>
</div>
</div>
<div class="paragraph">
<p>所以，这个地方讲了就是为什么有HTTP2,既然我讲的都是HTTP1那你反向操作就是2了，HTTP2怎么样？解决了慢的问题怎么解决的？</p>
</div>
</div>
<div class="sect2">
<h3 id="_http2_0是怎么解决以上问题的">15.4. HTTP/2.0是怎么解决以上问题的？</h3>
<div class="paragraph">
<p>所以那这个地方HTTP2.0是怎么去解决一下问题的？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个连接数的限制导致加载慢。</p>
</li>
<li>
<p>第二个请求头的重复传输。</p>
</li>
<li>
<p>第三个压缩。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一个HTTP2.0使用的是长连接，所以说为什么刚才我介绍的时候没有说短连接哈，他的那些问题，肯定是短连接导致的，所以这个地方用长连接代替了1.1的无状态连接（就是短连接），什么意思哈，我这个地方画个图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/网络通信图.png" alt="网络通信图">
</div>
</div>
<div class="paragraph">
<p>这幅图表示网络通信的发生过程，如果我们要用1.1的话，这个地方肯定是指的为V1.1,1.1他加载一个网站的时候，你从连接过程能看到什么东西？你会看到这种东西，首先你会有看到他发起了三个连接，然后他连接不是持续时间嘛，所以我现在用这个连接的这个长度来表示他用了多长时间，箭头肯定是表示发生了这个事，所以我现在就画一个，然后你会看到这种图，首先他建立了第一个连接，第个连接比如说我们这个地方叫标尺嘛，就以这个为标准，这个的长度表示一秒钟哈，表示单位时间哈，那么就这画个标尺哈，这个表示一秒可不可以，那是第一个连接，我假设这个网页应该有5、6个连接，他就你会看到这种，我们定义一下，首先这个原点表示起点，然后这个结束箭头表示终点，然后这个地方我刚才讲的这个长度表示t，你表示他用了多长时间，那这个这个x轴和y轴，这个y轴肯定是自然时间，所以那这个地方这个它是一个轴哈，你可以理解为这就是北京时间，然后这个x轴表示的是什么？连接的次数，随着这边是TCP哈。</p>
</div>
<div class="paragraph">
<p>然后我们来看一下这个图代表什么意思，首先在零秒的时候，发起了一个链接，它用了4.5秒，然后可能在第2秒的时候可能发起另外一个连接，这样你会发现他就是这样分布的，现在有个问题，在HTTP/1.1的时候，图上1.5秒的时候同时有两个连接，后面也同样有一个时间存在多个连接，图上举例画的是非常分散的，但是在真正访问网站的时候可不是这个样子的，真正访问网站的时候可能在同一刻有非常多的连接。</p>
</div>
<div class="paragraph">
<p>而操作系统就会限制这个连接数，说白了，操作系统没有针对浏览器这种行为做单独的优化，这个是HTTP/1.1的情况，那这个时候在同一刻连接数太多了，就变成只要前面的连接没有完，后面的连接就要等他们这几个完了过后空出来一个位置再继续，就像排队吃饭一样，饭店总共八张桌子，有一桌吃完了，他把位置腾出来了，然后又塞了一个人进去，但是每一个人的结束的时间你是不知道的，所以始终那个饭店里面就八座人。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fandian.jpg" alt="fandian">
</div>
</div>
<div class="paragraph">
<p>所以第一张图就像一个火车时刻表一样，有起止时间，而第二张图你可以简单的理解为火锅店排队，出来一桌进去一桌，为什么？因为它这个地方容量有限，桌子可不相当于连接数。</p>
</div>
<div class="paragraph">
<p>上面看起来操作系统连接数有限，那肯定是改不了的，你就算弄到HTTP/100.0也会有连接数限制，图像和刚刚举的HTTP/1.0的图的X、Y轴是一样的那么HTTP/2.0是怎么解决这个问题的？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

我们访问的还是同一个网站，那么我们要测试1.1和2.0的区别，测试肯定是同等条件下测试才有意义，那么访问同一个网站肯定JS、CSS、图片包括视频数量都是一样的，然后假设这个网站可能有八个连接。</pre>
</div>
</div>
<div class="paragraph">
<p>那如果用HTTP/2.0，这八个TCP用图来画的话是怎么样的？大概是这个样子的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/2.0.jpg" alt="2.0">
</div>
</div>
<div class="paragraph">
<p>首先，他肯定也会有第一个连接，然后这个图好像就没法画了，为什么？因为HTTP/2.0就只有一条线，里面包含了很多东西，那么这八个TCP应该代表的是八个网页文件，这个地方实际上只有一个连接，那他是怎么连的？这里我们就理解为，这个图就代表的是整一个连接，然后在这一个连接上要做什么事，他同样也要做HTTP/1.1的事情，那先请求第一个链接，请求完了，再请求第二个，也可能请求第三个，甚至请求第四个，从图上看起来和之前分布是一样的，但HTTP/2.0的连接始终只有一个.</p>
</div>
<div class="paragraph">
<p>然后再用另外一种高速公路的方式来画这个图:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gaoshu.jpg" alt="gaoshu">
</div>
</div>
<div class="paragraph">
<p>比如说这个是HTTP/2.0的高速公路，连接数是一个TCP，如果和之前的图同样的方式来讲的话，就是那个路上有几根箭头，它就是几个连接啊，当然可能要想更形象的解释的话，要单独去想办法画得更漂亮，但意思是一样的。</p>
</div>
<div class="paragraph">
<p>如果把这个例子转成火锅店的话，就是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/huoguo.jpg" alt="huoguo">
</div>
</div>
<div class="paragraph">
<p>同样是吃火锅啊，这是一号桌，同样客人有6个，然后大家猜一下他们是怎么吃饭的？一哄而上这个形容，确实效果是这样，但怎么做？这就是就像那个张学友的一个电影里说的：“在座的各位都是垃圾。”意思就是一个一个打太累了，你们一起上，所以他们去吃饭的话就会是这个样子，因为这个桌子够大，现在用那个箭头的长度表示上的时间，就是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/huoguo2.jpg" alt="huoguo2">
</div>
</div>
<div class="paragraph">
<p>所以这里一拥而上是没有规则的，同时上或者按批来都是可以的，所以这个东西有个专业的名词叫TCP多路复用。</p>
</div>
<div class="paragraph">
<p>上面讲的还是只讲了一个连接状态，HTTP/2.0他是通过一个连接，来回穿梭，永不停歇，通过这个方式解决了，那HTTP/1.1不可以吗？它可以这么做，但是1.1这么做的代价是要在服务器上或者是在某些地方关键的地方去设置，程序员不设置的话，他永远是一次没了、两次没了、三次没了，所以那种设置不是每个人都会的，也不是每一个软件都支持，支持这个设置的软件，Web服务器的软件，就很麻烦，所以现在把这个东西集成到了协议里面，解决这个问题了，当然这个地方是个比较夸张表达。</p>
</div>
<div class="paragraph">
<p>一个TCP连接可以处理n个网页，那如果我贪心一点，我建立五个TCP，那就是5N，那速度就更快了，那1000个呢？所以在一个合理的区间里头，HTTP/2.0这种方式更高效，当然其实我这个地方没有讲长连接和短连接的区别，其实并不是说这个跑的路的问题而是你用HTTP这种短连接的时候，操作系统在建立TCP的三次握手是非常花时间，建立的过程花时间，你要等，要等什么？操作系统它一个有个池子，上一堆人建立的摆在那没用，然后操作系统要去管他，管就要画代价，然后又进来一个，他就要管两个，这样的话，管来管去就花了几毫秒，但是如果有几万个几毫秒，代价就很大了，所以问题就是：如果TCP没有三次握手，是不需要TCP多路复用的，所以本质上这个地方是为了更少的TCP三次握手。</p>
</div>
<div class="sect3">
<h4 id="_三次握手">15.4.1. 三次握手</h4>
<div class="paragraph">
<p>是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>如果有a和b两个人，他们握手的话是这样的：

A：“B！”
B：“诶！”
A：“我给你个糖！”
A——糖——&gt;B</pre>
</div>
</div>
<div class="paragraph">
<p>首先A叫B，然后B答应了，然后A就开始要给B传东西了，就是这样一个过程。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sanci.jpg" alt="sanci">
</div>
</div>
<div class="paragraph">
<p>所以这个地方首先A给B一个SYN，然后B收到了给A一个ACK，然后A再给B一个SYN+ACK，第一步是A叫B，然后第二步B说收到，第三部A就说我要传个糖给你，接下来，A就直接把糖传给B就可以了。</p>
</div>
<div class="paragraph">
<p>这个过程超级花时间，因为这地方已经来来回回三次了，</p>
</div>
<div class="paragraph">
<p>刚刚说HTTP/2.0一个TCP连接有N个网页，那么就是1N，那么再加上一个三次握手，那就是1N+1SYN，那么HTTP/1.1同样是8个连接，那么就是N+N*SYN，那么相比下来就少了很多次三次握手，这个才是HTTP/2.0的精髓，所以市面上讲HTTP/2.0的都没有讲到这个，因为他讲不明白，也没办法跟你讲明白。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_减少http头部的传输量">15.5. 减少HTTP头部的传输量</h3>
<div class="paragraph">
<p>先写个最最简单的报文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GET /index.html HTTP/1.1
Host: qq.com
User-Agent: Chrome/90.0</pre>
</div>
</div>
<div class="paragraph">
<p>这个是HTTP/1.1的请求报文，然后首先看头，头里面又分了头的名字和头的值，所以这个地方它是由：“名称：值=HTTP头”组成的，这个是HTTP/1.1，它在访问的网页上的每一个链接时，比如都是腾讯网页，同一个域名下面，它访问每一个链接的时候，这些东西都是硬开销，你想一下，哪怕是换了个网站，这个头也是在的，只是后面的值在变化，比如说，一个人用Chrome/89版本，另一个人用90版本，那么头部的值是要变的，域名也是会在随着你访问的网页在变，所以你会发现前面的名称都是硬性开销，他会重复的传无数遍，而HTTP/2.0的协议报文其实已经不是这个样子了，但是我为了更好的表达我的意思，还是写成和HTTP/1.1一样的格式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GET /index.heml HTTP/2.0
1: qq.com
2: Chrome/90.0
Datetime: 2021-10-10 12:00</pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2.0头名称对应表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1--&gt;HOST
2--&gt;User-Agent
3--&gt;........</pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2.0在浏览器的代码里头，都有头名称对应表，包括手机上的浏览器，这个时候你会发现他传输的时候变的是头名称那一部分，从以前的N个字节变成了现在顶多2字节，因为他头很多，假设有99个头，九十九个常用的，不常用的比如说你自定义的就直接传名字，因为你自定义的在浏览器内置里没有这个东西，所以他减少是内置的东西，上面的Datatime就是我们自己定义的，它就没有办法用数字来代替，为什么？因为你的浏览器内置没有这个，这个必须这个协议的制定方，比如google，比如说W3C，他们加到表里面的才有，没有的就是文字，这样就省掉了那种常用的头，然后服务器再按那个对照表挨个个还原，所以区别就在于常用，那么HTTP/2.0就是用数字代替名称来减少传输字结数。</p>
</div>
<div class="sect3">
<h4 id="_http头压缩">15.5.1. HTTP头压缩</h4>
<div class="paragraph">
<p>刚才已经够简单了，但是感觉头部还可以加点东西，那为什么不干掉第一行？因为第一行大多数情况下都在变，变化性太高了，你加压缩的意思就是说他重复的几率不可控，比如说111.html，关键是服务接收到后连你是啥请求都不知道，服务端还要先解，他都不知道你是HTTP协议，为什么？你这样都没有用HTTP的方法开头，所以他不知道你是谁。</p>
</div>
<div class="paragraph">
<p>那第一行是起的自报家门的作用，非常重要，所以第一行你不能压缩，你压缩了过后，别人就不知道你是什么协议了，为什么？就像刚刚说TPC三次握手，你都不握手了直接传东西，我咋知道你是谁？</p>
</div>
<div class="paragraph">
<p>那下面的头可不可以管呢，现在就有问题了：请求报文除了头以外，响应报文可能还有Body之类的，我们就先不讨论，现在我们先把焦点聚在头上面，我们可以数一下头的值里有多少个重复的字母，其实上面写的是最简答的，字节比较少，现实中这个地方很长这一段，你们可以去看一下自己浏览器上面这一段，超级超级长，甚至里面还包括了苹果的标识符，苹果那个叫Safari浏览器的标识符特别长，所以才针对这一块压缩，因为重复性越高压缩比例就越高，我们先不讨论算法的优越性。</p>
</div>
<div class="paragraph">
<p>我们先总结下特点，头里面有包含的有数字、字母还有一些常用的符号，所以常用的东西就是这些，如果按量来说的话，字母最多、数字第二、常用符号最少，所以要压就先压字母，就不要挑软柿子捏了，这个地方就要捏那个出头的，抢打出头鸟嘛，所以这个地方最符合又最简单的压缩算法叫哈弗曼算法。</p>
</div>
<div class="paragraph">
<p>哈夫曼算法是按字母的使用频率来压缩的，常出现的字母压缩比例越高，较少用的字母压缩比例比较低，这样的话传的字母越多压缩比例就越高，那么 `哈弗曼算法+字母再加上剩下的other`最后就等于个功能叫HPACK。</p>
</div>
<div class="paragraph">
<p>这个HPACK有点像包的意思，H肯定是HTTP里面的头的简写，Pack就是打包的意思，这样的话，用哈弗曼算法只要把字母一搞定剩下的数字啥的顺带解决一下，只是不要反向压缩就可以了，不要压了比没压还大，所以这个算法他主要是非常简单，它的论文长达1.5页，意思就是说算法很简单，只需要那么一点空间就解释明白了，那既然他压缩了，带宽就少了，那么带宽少了手机就不耗电了，然后你说：“解压还要耗电”，解压和那个重复性比起来简直就是九牛一毛，都可以忽略不计了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_延伸">15.6. 延伸</h3>
<div class="sect3">
<h4 id="_http的body是不是可以压缩">15.6.1. HTTP的Body是不是可以压缩？</h4>
<div class="paragraph">
<p>正经内容就讲完了，那现在有个问题就是：众所周知HTTP的repository都有他下面的body，那Body也可以压缩吗？怎么处理的？</p>
</div>
<div class="paragraph">
<p>Body在HTTP/2.0出现之前，已经有一个叫gzip的压缩算法了，比如说POST加上Body，那Body可以用gzip，Body的头已经被压了剩下就是这个了，如果是用2.0的话：就是Post+Body(gzip)+Header(Hpack)，这里就是两种压缩，更小了，但是1.1就是：Post+Body(gzip)+Header</p>
</div>
<div class="paragraph">
<p>你会发现不仅是连接状态的问题，还有个头的问题啊。</p>
</div>
<div class="paragraph">
<p>所以这个作为延伸内容，你理解一下可以了，gzip是非常通用的一个算法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_http3_0">15.6.2. HTTP/3.0</h4>
<div class="paragraph">
<p>我们刚刚有一个问题其实我很想讲，但是我憋住了，当时不是说计算那个TCP三次握手，那如果没有握手，就直接解决问题了，还搞那么复杂干嘛，所以3.0就直接抛弃了TCP协议，使用了UDP协议，然后他是不需要三次握手的。</p>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>你放学回家走在路上，突然你妈从后面，拿个苹果扔给你，扔完就走了，结果你成功被苹果砸了，说白了，你妈扔东西给你的时候她没有先给你打招呼，然后你一回头就砸了一个包。</p>
</div>
<div class="paragraph">
<p>所以说他不需要握手，意思就是说，你是客户端或者我是服务端，那么客户端向服务端丢东西的时候就不再握手了，服务器如果被核弹给炸了，客户端也不知道为什么打不开那个网站。</p>
</div>
<div class="paragraph">
<p>那么问题来了：服务器怎么去保证他接收数据是正常的？这时候google就说：“首先的浏览器是我写的，服务端丢东西不给我打招呼，那我自己验证一下嘛。”为什么？刚才不是发了个请求，那我给我每个请求编个号，收到的时候再校验一下里面的ID号码，说白了，以前是操作系统负责帮你传东西，现在是浏览器和服务器之间在操作系统上面加了一层软件，软件和软件之间沟通就和操作系统没关系了，操作系统变成个空壳了他就不再忙活了。</p>
</div>
<div class="paragraph">
<p>那么还有个问题：现在UDP这样，那我不就可以把UDP直接打给支付宝然后让他崩溃，我又不需要打招呼。</p>
</div>
<div class="paragraph">
<p>这就像你妈觉得你冷一样，衣服一层套一层，那这样的话UDP一直掏给你，最后就变成个巨人，如果是服务器的话你就瘫痪了，为什么？因为请求居多。</p>
</div>
<div class="paragraph">
<p>那我直接从我电脑上传一个G的数据到支付宝可不可以吗？可以啊，只要你家里带宽够大，然后支付宝就因为你一个人垮了，所以这种事不要干也不要去尝试。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/google.jpg" alt="google">
</div>
</div>
<div class="paragraph">
<p>由上图可知，google和厂商他们在客户端和服务器之间以及操作系统，上面再加了一层网络层，他们网络层是通过UDP传输的，而以前是TCP，当然UDP肯定是操作系统有了你才能用，但是他现在是把逻辑放到自己软件里面去做校验呢，所以他们现在是一体的，直接把三次握手干掉，速度肯定更快了。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYANMOJO_chapter">16. 智眼设计（采集模块）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_15">16.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/智眼设计-采集模块板书1.jpg" alt="智眼设计 采集模块板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/智眼设计-采集模块板书2.jpg" alt="智眼设计 采集模块板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_网络拓扑">16.2. 网络拓扑</h3>
<div class="paragraph">
<p>今天讲的设计是设计Agent相关的，主要是打通Agent的模块和最前端的配置产生交互的链度打通，所以贯穿了几块地方，今天讲的模块是指的采集模块，先把网络拓扑画一下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/wangluoyoupu.jpg" alt="wangluoyoupu">
</div>
</div>
<div class="paragraph">
<p>就还是之前我们讲的那样，最上面是一个User，那么User会访问前端的Web服务器，那么这个Web服务会依赖于后端的Server的服务端，这个Server就依赖于Agent，那么每一个Agent下头就有各种采集模块，那在采集模块这个地方，就有网络、CPU等等各种模块。</p>
</div>
<div class="paragraph">
<p>整个网络拓扑就这样了，这里就分了几层，User和Web就属于Web层，Server涉及到一些Java间件，那就是Spring Boot层，然后Agent就是纯操作系统层，最后采集模块这里就是Mojo层，Linux这一块肯定涉及的是一些客户端的行为，实际上我们会把它叫做客户端，但是在内部他和模块之间，他是服务端，但是和整个相比的话，他是客户端。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解决问题">16.3. 解决问题</h3>
<div class="paragraph">
<p>那我们今天要解决一个问题，就像我刚刚说的，网络不是要做过滤吗？然后你的Body参数是怎么到达这个采集模块的？</p>
</div>
<div class="paragraph">
<p>刚刚不是说如果我网络监控默认启用的话，他会监控所有的东西，但是实际上我们应该不会允许他在默认情况下工作，Network这个Monitor监控，默认情况下他应该是禁用的或者运行空转，一定要由用户产生具体的配置，他才会工作，他跟CPU模块不一样，他的内容太多了，我昨天在我的笔记本上试了一下那个RUST程序，在没有任何优化的情况下，默认是CPU占用0.0%，然后我把b站的视频打开，然后就多了很多UDP的包，一直往上报，报的过程当中我就看到CPU大概高峰期在5%，低谷应该在2%的样子，当然笔记本的CPU肯定没有服务器的强大，但是不排除对方买了一个阿里云的，他可能CPU频率很低，然后软件工作起来占了50%，那针对这个我们就要做一下优化，过滤掉一些不需要的东西，那么CPU的占用就可以降下去，所以做一下过滤是非常好的事情。</p>
</div>
<div class="paragraph">
<p>那这是我们先要解决的一个问题，CPU这种东西是不需要我们去控制的，为什么我会先写个Network，这是因为昨天我在想的时候，突然晃了一下，就是我的大脑去想了一下，实际上我应该有自己的方案，但是我把它拿出来，我们一起分析一下。</p>
</div>
<div class="sect3">
<h4 id="_补充为什么要着重程序设计">16.3.1. 补充：为什么要着重程序设计？</h4>
<div class="paragraph">
<p>因为写程序最重要的是设计，写代码你总会学会的，但是学设计这个事情，你就算是写十年代码，你也是那个水平啊，就额外讲一个，我今天是5:45下班的，为什么那么晚呢？平时5:25就开始摸鱼，就开始准备走了，就是因为我们的程序员，就是那个十年经验的，一共加起来行数应该有300行，然后他今天一共就动了20行，结果他找了六个BUG出来，他把我正确的代码删了，写了个错误的代码，然后单元测试一跑各种错误，然后他前脚就发现了第二个BUG。</p>
</div>
<div class="paragraph">
<p>所以我讲这个话的意思就是说，在我的高标准里面，这种行为不是一个优秀的工程师应该出现的，为什么？他并不是写不来语法，他的问题出在那个代码不是他原创的，他是懵的，他并不是说不负责任，为什么？他想负那个责任但他也搞不懂，当然你要说归大的责任心，确实没有责任心，为什么？你自己维护的代码，好歹应该全部去了解一下，我设计那个东西，设计加上代码实现还有Demo，我写完的那一刻，我花了整整三个周的工作日，就是除了晚上都在搞，然后这三个周里，我还有各种开会、各种其他事情，所以根本就没有花三个周，但是我跟他差就差了三个周，因为我一旦核心代码写完了过后，我就开始做异常检查，开始填充东西，大家知道我写代码的风格了：greating、Hello World！都是从那来的，然后那三个周里，我设计的过程当中他没有参与，所以他完全是懵的，他都不知道为什么这样设计，然后我给大家画了个图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jieshi.png" alt="jieshi">
</div>
</div>
<div class="paragraph">
<p>意思就是：我的数据是一种事件驱动的服务器，你要有数据进来，然后这样进来然后这么出去，他就懵了，程序里面哪儿的这个逻辑？我没看到了，他是看不出来的，你知道吗？他到现在都不理解这个图是什么意思，我的意思就是说：你数据从这个地方进来，你会经过各种路由，而且它是单线的前后依赖，最终又会从这个起点再出去。</p>
</div>
<div class="paragraph">
<p>其实写代码就是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>IF Something

...........

return....</pre>
</div>
</div>
<div class="paragraph">
<p>这样可简单了，就是这个样子，甚至连IF都没有，然后就一脸懵逼，为什么？因为中间调的东西刚好就是下一个类的，然后又开始调下一个类，就这么嵌套的，最后可能经过了20个类，代码就直接从Return出去了，这样别人一看就看不懂了，所有逻辑全是中间那一部分，他点进去后发现里面还有设计模式，就更头晕了。</p>
</div>
<div class="paragraph">
<p>所以要重设计，重编码，这两个都很重要，没有谁轻谁重的问题，设计的时候不要觉得无聊好吧，如果你觉得无聊的话，就有问题了，你现在都提不起兴趣，到时候写代码的时候更没有兴趣了，为什么更无聊？现在设计的时候好歹可以动一下脑子，但是写代码的时候就不是动脑，而是动手，天天Google。</p>
</div>
</div>
<div class="sect3">
<h4 id="_agent获取用户配置逻辑">16.3.2. Agent获取用户配置逻辑</h4>
<div class="paragraph">
<p>那么刚刚我们说网络它是需要参数的，我们以前说过的，我们在Mojo层，启动模块的时候，会有个配置文件XXX.ini，然后那个里面有这个程序的启动路径，但关键是你在路径那里你不可能写死一个8080，而且万一端口是多个参数，所以这个情况下这个程序启动起来的时候应该没有任何东西，应该是处于一种空白，那么它什么时候有东西呢？应该是动态插入，就像插件一样，什么意思啊，他启动完了过后，然后每隔一段时间去请求一下服务端，问服务端他接下来该干嘛？</p>
</div>
<div class="paragraph">
<p>那看来Net模块肯定不会起服务的端口，肯定是定时去请求Agent，CPU模块肯定是不请求，那请不请求谁说了算呢？肯定是掉我们的sdk去请求的呀，那这样的会变成了一共五个模块，其中一个网络监控模块会定时去请求Agent的服务端口，问他有没有东西给我那么这样的话，就只有一个模块有这种交互行为，其他是没有的，比如像内存监控就是没有的，但是进程是有可能的，进城那么多，不可能每一次都把所有的列出来，所以你可能会有默认需要哪些进程，然后把在把默认的进程情况打出来，你可能还要排除某些东西， 比如系统的内核进程。</p>
</div>
<div class="paragraph">
<p>因为进程太多了，你得有个限制或者筛选，如果你跑了个PHP这种东西，他起了800个进程，你每次检查的时候，不可能把800个都列出来，除非你真的需要那800个，所以这时候里可以选择所有还是过滤后的数据，你也可以排除，这才是合理的，因为你人工去管理服务器进程的时候，你也不是想看所有，你有几种情况，看CPU最高的、看内存最大、还有就是看Mysql进程，然后加个管道把它塞出来，这个时候你日常是这样用的，这个上头其实也是和你日常使用一样的逻辑，只是代替了人工，通过勾选去解决。</p>
</div>
<div class="paragraph">
<p>所以先口头总结一下：我们之前讲过的，在Server这边，一旦用户在这个网页上配置了东西过后，比如说配置某一个监控的一个行为，我们假设现在对所有主机有效，那他配完了过后点保存，那么会触发后端的行为，这个时候后端发现他在正在触发某些功能的时候，他应该从他的配置里面去做调他的回调，那么Agent看起来在启动的过程当中就应该保存，那天我们讲的是，这个东西要持久化嘛，因为你不持久化，下一次如果用户没有新的设置，Agent也没有了，如果不持久话的话就相当说他每次启动的时候去拉一下，这样也不是不行，那么采用HTTP/2.0长连接也是没有问题的，因为只要不三次握手，一般都很快的，那这样的话，HTTP/2.0就会带来一个问题，因为HTTP/2.0默认配HTTPS证书，那看来我们还要自己搭一个证书服务器，顺手把那个什么加密服务一起做了，所以说如果你要用HTTP/2.0的话，你就应该有证书签发，那么签发就有个问题，证书会过期，然后哪一天证书签发失败了，所以这就是为什么没有人去做这个系统，很多人宁愿自己写一个协议，那自己写个协议也有问题：维护性变差了，HTTP/2.0好歹知道过期了，毕竟还是通知到了。</p>
</div>
<div class="paragraph">
<p>所以我们之前讲的就是说这个地方有用户设置的时候，Server会发一个回调，他会把Agent注册的时候带来的回调请求一遍，那么Server请求一遍过后，那Agent就拿到了他想要的数据了，看起来数据应该是是放在某个地方的，我们现在就假设是放在硬盘上的，那他放到硬盘上过后谁来调？也就是说，用户在网页上点了之后，Agent的配置文件会动态更新，然后下面的模块就调配置文件，就相当于是说：你一旦触发这个东西后，他的配置就会Reload重载，我们上次讲到这个地方不想引入数据库，你要是引入个数据库，就太庞大了，你就算用SQLlite也是可以的，SQLlite是很好用的，因为这个地方其实写的情况很少，你在那写让对方等一下也不是不行，为什么？因为这个地方只存的有配置，所以SQLlite其实是可以的，硬盘也可以的，因为你存配置文件他也要上锁的，你每次写的时候，别人读是有问题的，说白了就是文件锁，因为在同一时刻又写又读，理论上是有问题的。</p>
</div>
<div class="paragraph">
<p>那么就相当于是说服务器就调了一个Agent的回调，然后是Agent拿到了想要的数据，并保存的硬盘上面，那看起来这个Network模块，应该去问Agent，因为Agent和模块之间问是有一个好处的，它们都是本地的，而且是通过HTTP通信的，所以通过HTTP通信的话，他以前他不是默认要上报吗？我还有一种逻辑就是一直向Agent拉，比如说每一分钟请求一下，一分钟看起来其实没关系，用户就多等一分钟，主要是为了频率降低，那这样的话，一个小时60分钟，那么一天1200次左右嘛，一天看起来不多然后，但是五个模块加下来肯定不一样，只是说现在只有Net模块会触发这个，其他是不用调，但是进程看起来是需要的，因为进程太多了，说白了，网络监控多不多？进程多不多多？甚至以后我们还有文件读写监控，那个也多，因为随时随地硬盘上都在读写，所以数据多的地方一定有主动请求去问配置，简单的就不用管他了。</p>
</div>
<div class="paragraph">
<p>所以那这个地方触发逻辑是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.用户更改(启用)模块配置

2.Server触发回调(Agent)

3.Agent收到配置数据并保存

4.Agent重启所有采集模块

   4.1采集模块启动时，HTTP Pull配置</pre>
</div>
</div>
<div class="paragraph">
<p>之前我们想的是Agent等待有需要的采集模块pull，现在改一下逻辑，配置完了之后所有模块的Reload，挨个重启嘛哎，这个办法比Pull好，因为Pull有个问题，他有定时开销，那这个地方就应该是Agent重启所有采集模块，那么这个时候就要有一个逻辑了，就4.1采集模块在启动的时候要Pull配置，这样也解决了刚才我们说的延迟的问题，第二个节约了资源。</p>
</div>
<div class="paragraph">
<p>最后我们来复盘一下逻辑，用户在这Web里启用禁用配置，那么Server收到请求过后，他判断是不是负责配置模块的接口，那个模块里面就有个代码，就是要调用Agent注册的回调，然后这个回调就触发了这个Agent的后续行为，就是：一旦他回调收到过后，他会重启下面所有的模块，而模块在重启时，他会加载自己配置文件，还会去从Agent拉，因为配置文件只是说自己在哪启动，启动的间隔是多久，但是没有解决输出结果处理的问题，一般是过滤啥的东西，这样的话，就整个逻辑就完成了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_接口安全">16.4. 接口安全</h3>
<div class="paragraph">
<p>这个地方我们刚刚讲了一个就是API校验的问题，所以我们这个接口安全，一定不是校验，校验的意思就是我对某个参数进行校验，长度进行校验，安全是指什么？整个系统，打个比方，这是整个系统，安全的意思就是说，全方位的安全，全方位的安全可不是指教验一个参数的问题，所有参数，所有网络通信绝对不能出错，传输层必须加密，所以上来HTTPS，所以我这个地方讲的安全，知道他们的区别，校验范围很小，安全范围更大，比如说人身安全，我可没有说是你跌倒了还是掉水里了，只要你人死调了都是安全问题，看到没有，但是视网膜校验，只是眼睛这个地方，检验你的眼睛坏没坏嘛，他不会管你口腔，不会管你缺胳膊少腿嘛，所以那这个地方，既然是安全的话，那么第一个那肯定就是传输层也保持安全，上HTTPS，这地方都是HTTP协议嘛。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTPS</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以这个地方那么安全手段，其中的就是你的接口传输一定要基于TTPS，就是不能被别人直接抓包给你抓跑了，这是传输层，那么传输层解决完了过后那我传东西安全了，那我的接口安不安全就是另外回事了，传输或者通信，通信安全，然后第二个那么就是属于业务层面的了。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>接口</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_身份认证">16.4.1. 身份认证</h4>
<div class="paragraph">
<p>你接口那么安全传过来了，你对这些参数有没有校验？身份有没有认证？所以这地方又分了两块，那么在接口这个地方分两个，第一个是身份认证，身份认证我们一般说像那种接口调用或者是云服调用的，你一般都有个Access key id和secret access key，key id那么用来标识你的身份，那么secret access用来做你的signature签名的加密，加面那个字符串，对方只要解不开那个字符串会怎么样？他就不能改参数，所以那这是一种方式通过signature。</p>
</div>
<div class="paragraph">
<p>还有一种方式就是我把我的token，我完全相信于他，我把我的那个secret 或是token在网络上传输？刚才我们讲的那个Access key id和secret access key的方式，他的那个secret在网络上是不传输的，只传输到他加密的一串密文，对方能够解开你就用，解不开你就活该，解不开你就不能改我参数，因为对方服务端会校验这个参数的，所以这个地方分数又分了两个，第一种就是：Access key id和secret access，通过这种方式他可以加密一段密文，然后还有一种方式就纯粹就是基于token字符串，这种方式就相对说我生成个字符串，你不要告诉别人，就是只要被别人抓到包你就玩犊子了，所以用token这种方式绝对要用HTTPS，但是上面这个是可以不用的，为什么？因为你靠signature，在业务层自己给自己做了一段校验，所以这两种方式都是可行的，所以一般这两种可能有先后顺序，严格意义上的系统，它会先有一个是叫getToken的接口，你把身份认证这段给他过后，生成一个token，token有一个有效期，有效期以内你都不用再做上面这个校验这一步了，所以他可以独立存在，他也可以相互依赖可以转换，为什么？因为第二种简单嘛，不用每次去计算那个签名，你可能会生成个token永远不过期，是不是可以，但是你不要让别人看见了，所以这种情况下就依赖于传输层的安全，当然有人偷窥你屏幕拍了个照那就没办法了，有的人把那个token写到配置文件里面，网易不是有个程序员，他把他那个生产服务器的他token，还有那个数据库密码传github上面去，然后把整个项目开源了，慌得不得了，连夜网易的人加班，把东西全改了，所以这是身份校验，就是who are you？说白了，他问客户端，你是谁，用token我肯定知道你是谁，为什么？token里面一般包含某种东西，你是可以把它解开的，那这是身份认证，我没讲参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_参数校验_3">16.4.2. 参数校验</h4>
<div class="paragraph">
<p>这个时候你第二件事情做参数教验。然后这个参数校验一般涉及到接口的那个参数的数量，参数的名称，参数的长度。格式，这个地方我就不去过度展开，把它简单写一下吧，然后这个值一般要涉及到值的长度，有长度是不是有格式？ 然后这个还只是V2。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接口的时效性校验">16.4.3. 接口的时效性校验</h4>
<div class="paragraph">
<p>还有第三个，接口的时效性校验，就是你接口这些参数，它应该有一定时效性的，比如说刚刚想的15秒20秒，所以一般像哔哩哔哩他们那个视频，你每次请求他那个媒体服务器的时候都要中间到带个时间戳就当前你的时间戳，或者你token生成的时间戳，他那时间戳用的计算你这个接口有效无效的，说白了用来迷惑你的，反正你不清楚，我多一层判断，对于你来说就多一层隔阂和阻碍，所以这个一般是为了防止有人拿到那个接口，他也不知道你的那串数据是干啥的，直接来复制重新执行就扣了你1万块钱，不行吧，以前我们那个程序员就中过招的，PHP程序员，我们的业务系统扣费充值接口，他没校验，别人也没有知道他密码，就把那个网址拿过来复制了一遍刚又没用HTTPS，刚好那个人就自己充值了很多钱。</p>
</div>
<div class="paragraph">
<p>所以你看到没有，这里面就设计到几种，看这个地方和谁有关系？这个地方的通信肯定是所有都用HTTPS，毫无疑问，所有的，当然我刚不是说有到一个问题嘛，你全部都用HTTPS意味着你要有一个域名证书，然后你就域名证书的分发，所以这个时候我们就假设这个东西是先要手动来，大不了以后再单独给他开发一个管理系统，多做一点总有好处的，所以做方案的时候，你要尽量的覆盖完整个逻辑，这个才叫企业级方案，就是说白了你去做，按作业的方式来做，你顶多就把那个demo写完了，然后别人老板拿着也不能用，下一次你心想拷过去发现拷了白拷，为什么？都有，没有价值。</p>
</div>
<div class="paragraph">
<p>所以设计到接口这块的话，这个用户这端有这个接口校验，那server这一端也有，就相当于是说这一段端，agent这一端有，然后整个校验在server这一块，那现在我们套这个逻辑套进来看一下，对于我们来说，因为我们这个系统它不是一个sdk，也不是个云服务，它就是我们自己的业务系统，所以那个这个token的话，就在系统里面直接生成，就不用经过这前面两个东西了，所以我选择他，因为他简单，他不用每次去校验，还有一个问题，对于我们系统来说，你关心就是你关不关心，比如agent这个地方有人来访问，你关不关心他的token身份是谁呀？你并不关心是哪个agent访问的，你只关心说，首先他这个ip地址是白名单是能进来访问的，然后他给了有效token，信任他就完了，为什么？你不可能进我办公室里扫个绿码吧，你不会吧，进大门的扫完了我就相信你了，进来你还扫个密码也不是不行，但是你不觉得形势大于意义吗？为什么？同呼一片空气，你少了个寂寞，所以那这个地方的话就看起来我们整个通信呢就是基于token，那如果我要写个例子的话，就可能是这个样子的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost/index.html

auth：1234567</pre>
</div>
</div>
<div class="paragraph">
<p>有可能是这样的，然后这个是一个get嘛，那么我要带个头，比如说我就加一个请求报文的头嘛他头叫auth什么什么冒号，这个后面是不跟那个token，token比如说是123456，那这样的话我的服务端我把这个头取出来我就知道有没有效了，那么有效了过后，剩下的事情就是说把这个参数取出来，比如说他带了个问号，比如说带了个问号比如说user=abc可不可以，那这样的话你就得信任他，把参数取出来就做后面的事情了，我先讲粗的，等一会我们再讲细的，然后你们到时候去整理笔记的时候，你要把这个例子自己去过做扩展。</p>
</div>
<div class="paragraph">
<p>那这个看起来在这个这一块是管用的，其实是有问题的，等会再讲 问题在哪好了，那这块可以用这种方式，那这一块也可以，你请求的时候带上你的token，看起来web-server ok了，那么server-agent ok了，现在我们要让我们要什么，我们要让user这一层ok，这Net一层ok，总的来说那看起来在这个地方只要是token就可以了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_校验过程">16.4.4. 校验过程</h4>
<div class="paragraph">
<p>那我可以假设，整个校验过程是这样的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先在agent安装的时候，那么在他安装的时候会做一个配置，在这个agent.config文件里头增加一个叫token=的参数，他这边不是生成一个token吗？你手动把这个token复制到这儿来，所以这个地方是给token=，那这样的话他们之间你如果真的想就是让他不一样的话，你生成无数个token就可以了，但是没有必要都是agent，所以你单独给agent生成一个token就可以了，为什么？如果别人都把你网络监听了，那我也没辙，所以那这个地方就填一个服务端的token，那他去请求服务端的时候带上这个token服务端相信他了，所以这个token不能发给其他人，那这样的话就相当于他请求的是带上那个token，再带上一些就他必要东西就能上传报数据了，第一步应该是server这儿生成token，生成token过后，那得到个值。</p>
</li>
<li>
<p>那么第二步你应该把token填到agent.config给里面。</p>
</li>
<li>
<p>第三步那你应该这个地方带token调上去往上推嘛。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_回调">16.4.5. 回调</h4>
<div class="paragraph">
<p>这个解决了，然后这边看起来ok了，因为这个地方肯定和token没有关系，因为他是和服务端嘛，他只要不和服务端直接发生关系的是可以的，现在问题来了，他向上报数据的时候是可以，他调回调的时候呢？调回调他咋知道谁可以调我的回调，肯定是也要个token，所以应该有一个server的token，还有个client的token，这边就应该还有一个什么agent的token，我叫a token，那么生成这个东西过后，那么比如这个是第一步a部，那么这个a步那在服务端这边他去他去注册的时候，去注册，因为他启动的时候嘛，他向服务器注册嘛，当然这种注册应该是第一次，第二次，他不需要再发生注册关系了，你怎么判断第一次注册，第二注册？他注册他的吗？他注册和agent没关系，和server有关系，server上面你是比如上次点了个ok注册成功了，第二次他自己发起注册，没有关系，你返回跟200ok收到就可以了，至于后面的事情，他不关心，为什么？因为注册是让他告诉他我是客户端，请你相信我，然后并且把我的信息和回调留下来，所以这种注册动作，按理来说他是应该是每次启动都发起，至于对方反什么，他不关心，我知道你200ok就可以了，至于你绑不绑定还是怎么绑是你服务端的事情，所以你应该有个列表注册客户端，那个xxljob也有这个东西嘛，那个里面有一个叫机器注册，你点一下绑定完了他才能后面发东西，没有注册光有这个接口token，你是发不了东西，为什么你通过了身份校验，但是通不过业务检查，为什么？你没有完成注册，为什么要注册呢？就是为了处理那个回调，就算你把我token破解了，只要我手动没有点那个绑定注册按钮同意注册，你同样不能发数据上来，是不是更安全了吗？所以这个地方还有个agent，所以你会发现其实这样做下来就已经很安全了，每个环节都是可控的，那这个地方向上面发起注册，然后注册的时候一定要填一个他的回调地址，然后他回了地址的那个问号后面有个token等于多少，所以这个时候那么他产生回调的时候callback，他产生回调的时候是不是要填这种https：//xxx：8080，然后后面可能要跟有什么问号的url这类，我就不管了，比如说什么什么动作跟参数他也要带个头，这个地方填的是a token，所以那这样的话这个倒着来的时候callback，他也要请求个网址，他这里要把token带过来，做双向验证，我请求你有token，你请求我也有token，这个地方有意思的事情了，这token谁先谁后，第一时间那应该是服务端生成个token，你手动把它填到客户端里面去，然后客户端因为已经拿了这个token了，他去注册的时候因为已经通过了校验就把自己token带上去，他用的是拿回来你会发现就是变成了我刚刚说这种，你看这个逻辑你没有两次完成吗？你一步就完成了，这过程当中，你点一下鼠标，点同意绑定，同意注册，对于你来说代价很小的，你不用再把这个token填的服务端去吧，那么傻吗，你竟然相信他了，你应该把他这些东西记录下来。</p>
</div>
<div class="paragraph">
<p>他要先完成注册才有callback，你先填token填好然后配置文件填好了过后启动它嘛，启动他的时候，他向服务器发起注册申请吧，注册申请里面带了个tokne的文字参数嘛，比如说你就带个问号带上去噻，说白了你请求的是服务单的地址，在后面问号跟一个token不行吗？这个地方是我请求服务端他给我的token复制的那个，我就把我自己的给你，让你记下来，是不是可以这两个不一样嘛，所以才那这样的话，服务端就有你的回调了，你的回去就是这个网址嘛这个网址带一个token嘛，你如果觉得嫌麻烦，你直接可以用get把token添了这个地方就不用这种头的形式嘛， 也是可以的，那这相当于是说服务端你要先把token复制过来，然后再启动它，启动他的时候，他会向上请求注册，请求注册的时候，参数里面有个东西，就是他的a token，那这样的话，他产生回调的时候，他自己拼参数 url 8080的url加上token，加上那个要做的动作的参数值，这些东西往下报，agent这个时候是服务器的，server是客户端的嘛。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_apisys_chapter">17. API System</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_16">17.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/API系统板书.jpg" alt="API系统板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_api系统">17.2. What is API系统？</h3>
<div class="paragraph">
<p>API系统，那么这个地方API系统肯定指的是协议对的？我们通常说的API前面都省掉了HTTP，或者可以说基于HTTP的API系统，为什么我们省掉HTTP？你想一下，我都用TCP了，还用问号传参数，屁股后面跟一节就完事了。</p>
</div>
<div class="paragraph">
<p>所以API系统通常都基于HTTP的，那首先我们要知道API是什么？API的英文是(Application Interface)就是应用程序接口的意思，那既然前面省掉了HTTP，那就是HTTP应用程序接口。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_系统system">17.3. What is 系统(System)?</h3>
<div class="paragraph">
<p>系统是啥？</p>
</div>
<div class="paragraph">
<p>日常看到过或听到过的比如：操作系统、数据库系统、ERP系统、OA系统，但是你从没有听说过什么微信系统、支付宝系统，因为你不会叫支付宝系统，可以叫支付系统，那支付系统指的就不是你手机上那个App，而是指的支付宝服务器上那堆东西。</p>
</div>
<div class="paragraph">
<p>所以这个地方指的系统，先拆开看，统字可以理解为统一的意思，但系统这个词很怪，要组词的话不好组，统一，一统、系统、统系都不对，所以它重点在系字，统字单独放到这个地方也不知道啥意思，为什么？因为他翻译出来的，在古代我们可没有这玩意，所以我们换成System来讲，Windows、Linux、UniX它们都是一个System，然后还有一些单片机要用的，非常非常嵌入式的系统，比如就像有些智能设备里的系统。</p>
</div>
<div class="sect3">
<h4 id="_软件">17.3.1. 软件</h4>
<div class="paragraph">
<p>结合上面说的，你会发现这个东西看起来是某一类东西的统称，我们先定义它，首先我们知道它是一类软件的一个称呼，当然OA系统这种很牵强，但是为什么大家通常那么叫？是因为它里面有很多逻辑，那么他一定是复杂的，像Windows、Linux、Unix他们可能偏底层，包括数据库系统也是，但是说到OA、ERP系统，全世界都是、看起来系统有应用层的东西，也有服务器上用的，跨度很大。</p>
</div>
</div>
<div class="sect3">
<h4 id="_复杂">17.3.2. 复杂</h4>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>复杂的东西也不一定非常庞大吗？不一定，为什么？你可能走过了五道保险的还是那种带旋转的保险门，结果就取了100块钱， 所以它不一定复杂就臃肿或者说不一定复杂就臃肿，为什么？有可能写2000万行代码里面都是IF，Else也不是不可以，德国有个政府开发了20多年的软件系统，现在代码好像去年还是前年突破了2000多万行，结果程序员由于受不了频繁离职，那个项目就一直烂尾，那这个系统复杂吗？我觉得不是，我觉得他们可能在坑钱，2000万行Windows都写的差不多了，就是你开发了史诗级的，要代替NASA上火星都没这个复杂。</p>
</div>
</div>
<div class="sect3">
<h4 id="_体量较大">17.3.3. 体量较大</h4>
<div class="paragraph">
<p>体量较大，什么意思？</p>
</div>
<div class="paragraph">
<p>比如说我随手就用Python写个爬虫，它不会叫爬虫系统，但是之后花了一年把这个东西完善了，这个就叫爬虫系统，然后再比如说我们写监控系统，你写两天，你根本不配叫监控系统，但是你在持续不断的完善，覆盖了你想做的领域，完善了功能，又能满足用户的需求，这个时候就可以叫监控系统，但是你只是装一个监控的软件，然后画个图啥的，那就不叫监控系统，为什么？因为你没有解决真正意义上的问题，你的覆盖面是非常非常有限的，而且它不复杂它非常简单，就是一个页面，比如说你有个Blog，不可能就叫博客系统，开发这个的人叫博客系统，但是对于你来说，它就是一个博客页面，博客不是你开发的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_功能完善">17.3.4. 功能完善</h4>
<div class="paragraph">
<p>比如说你说在UNIX或者Windows下头，基本上你所有的事情都可以做，Linux也是可以的，并不是说我只能挂QQ啊，你要是开发个只能挂QQ的系统，叫QQ系统好像也不对，那只能叫QQ。</p>
</div>
<div class="paragraph">
<p>你当然那种飞机上的那种实时调度系统，那可不简单，它包含了自动导航、自动驾驶、自动检测障碍物，还有各种控制，飞机上是有各种各样的子系统组成的大系统，他的系统和系统之间是隔离的，但是这个时候，你不会叫他软件，你说飞控软件？飞控软件指的是你的User Interface，就是你看到的那块，但是对整个飞机来说，你是有飞控的，是叫飞控系统而不叫飞空软件，但用大疆上面那个东西，那叫飞控软件，遥杆摇两下能有多复杂？确实也挺复杂的，但是和飞机那个相比，一架飞机200亿人民币起步，干线飞机可能十、二十亿，主个主线飞机那就不一样了，所以你看这个时候啊，它们体量不一样，同样是飞控，你解决的是无人机的飞控还是解决真正飞机的飞控的不一样的，为什么？真正的飞机出事的时候，你还要保证他的稳定性，但大疆那个撞山就撞山，都没有让Pull Up拉起来。</p>
</div>
<div class="paragraph">
<p>工业标准就是工业期的，产品级是指的互联网，这里面我们可能叫产品级，但是对这种实操、真正实物的东西，我们叫工业级，工业级就意味着零下40度，飞机不解体，系统不死机，好像大疆做不到，所以他是民用级的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_总结_2">17.3.5. 总结</h4>
<div class="paragraph">
<p>上面4个特点连起来就相当是说系统是：</p>
</div>
<div class="paragraph">
<p><code>一种体量较大、功能完善的复杂软件，并且能满足用户在某个场景的需求。</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_apiapplication_interface">17.4. What is API(Application Interface)？</h3>
<div class="paragraph">
<p>最开始我们只是简单理解了API是啥，说白了，就是没有说人话，其实API的意思就是传递数据的一种方式，什么意思？不用API我用TCP也可以传数据，不说普通话说英文也可以实现交流啊，所以问题在哪于怎么让对方能够听懂，就比如你们两个在开始之前约定好，就像小时候玩的一根线两边接着一个纸杯子，然后你在说话，对方听不听得懂，这得看情况，实在说不懂，拿电筒闪两下当暗号也是可以，提请约定好暗号的内容，比如说闪三下是妈妈回来了，两下是爸爸回来了。</p>
</div>
<div class="paragraph">
<p>那么具体到计算机这个领域的话，但凡涉及到这种带Interface的，都是传递数据的，比如说鼠标不是用的USB吗，USB一插上去，就相当于把你的手的动作传递给电脑了，那个摄像机通过USB插到你电脑上，电脑上也可以收到视频，他也是在传递数据。</p>
</div>
<div class="paragraph">
<p>那么Interface在计算机领域是用来传递数据的，我刚刚举例说的是硬件的Interface，那Application肯定是指的软件，但凡知道计算机的都是知道数据，种子是数据，磁力链接是数据，图片也是数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="_什么是api系统">17.5. 什么是API系统</h3>
<div class="paragraph">
<p>把上面讲的结合起来就是：用于传递数据的、复杂的、体量较大的、完善的软件功能或者软件规范，当然我不要求你把两个东西强行合在一起，这玩意儿强行合在一起是别扭的，你把它分开看，你两个都懂得就好了，这个不涉及的那种质变啊，1+1就等于二，单独理解都没问题，合在起也是能理解的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_3">17.6. 使用场景</h3>
<div class="paragraph">
<p>刚刚有个地方很重要，就是传递数据的 `一种`方式。</p>
</div>
<div class="paragraph">
<p>一种，那就意味着有很多种，那就要问个问题了，第一台计算机被发明出来他需要传数据吗？那第二台呢？说白了，最开始美国人造航母可能干了，闲的没事干，发明个计算机也不是不可以。</p>
</div>
<div class="paragraph">
<p>这样的话就相当于是说一台计算机你是不需要传递数据的，两台计算机，你也不需要，为什么？最开始连硬盘是啥都不知道？计算机是用的计算数字的，在计算机被发明之前中国或者国外都有各种机械装置或者那种木的结构旋转，然后就算出到什么数，就是天文学的那种，转来转去，然后知道约什么时候日食，是可以算出来的，那个时候是基于特定的公式创造了这种设备，这种东西叫专有装置，比如说我专门发明一个门铃，那个玩意只能当门铃。</p>
</div>
<div class="paragraph">
<p>所以在最开始啊计算机被发明出来一定是为了代替已有的那一部分东西，后面才变成通用计算机，因为它最开始一定是非常非常贵的，一定是国家才买得起的，然后是政府买得起，后面是有钱人买得起，最后到普罗大众都买得起了，95年过后，电脑就飞进的千千万户的家里面，然后比尔盖茨找到IBM，跟IBM说以后是个人电脑的天下，IBM给了他个白眼，你在说屁呢？</p>
</div>
<div class="paragraph">
<p>所以就说到这个地方，那使用场景的话，既然数量非常少的情况下是不需要传递数据的,而且HTTP0.9大概是在91年HTTP才被发明出来，那么91年就是那个时候，HTTP的才被发明出来，就证明那个之前是没浏览器的，他应该是同时诞生的，不然你那期展示啥呢？Hello World吗？美国人当时发年发明互联网，但是他们当时发明的东西叫局域网，从那个时候开始的才有真正意义上的传输，可能在那个之前，他能够单点对单点就说白了美国人在那个时刻估计发明了一种交换机，交换协议就现在来IP层，就现在TCP这些东西嘛IP层嘛，负责局网的交换嘛，那个时候应该被发明出来，在那个之前，计算机和计算机机之间一定能够靠网卡对连，绝对是没问题的，但是当时对连变成那样的我们三个人你连了我，我在连他，但是你们俩相互不知道对方的存在，那一台机器顶多就插几根网线嘛，你解决不了互通的问题，然后你这个时候就变成了你要满足这种情况，我就要做一种转发，最开始一定是这样的，我的网线越来越多我就想我能不能把数据导给他，慢慢的才应该有这个交换协议的存在呀，他是一个递进的过程，比如说有人不是开玩笑嘛，把3090显卡拿到十年前给那些看，你说能抄出来吗？抄不出来，为什么？他连个打底的模型都没有，他怎么抄？你告诉我，你好歹给他个基础版？让他在比如说97年67年那个时候开始慢慢往上堆那是可以的，但是你给个3090给他对不起抄都没法抄，为什么？因为是有Bug，你慢慢补补着补着那个系统越来越完善，你说这个地方有个idea，慢慢慢的就插上面垒了，一下子他就抄过去？逆向都难，因为他是个整个工业的结晶集成电路嘛。</p>
</div>
<div class="paragraph">
<p>所以这个地方使用场景那讲的这个地方就说，那传输数据的需求从六几年，那美国人而发明的互联网，从那一刻开始，才是真正意义上的传输，可能在那之前有软盘，软盘那个东西只能说叫一种传输介质，它不是一种传输方式，空气是一种声音传播的介质，水也是，它是一种介质，但是你没有听说传输空气，传输声音吧，没有谁这么讲吧，传输的意思就持续不断，源源不断，所以这个使用场景是说第一个一定是交换数据。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>交换数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后既然是交换数据，那你证明是什么？至少两方，而且一般涉及的多方，所以这个是我们去假设，那么最小单位是2。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计算机数量最少为2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个地方的计算机要打引号哈，因为你在你一个电脑上面写起两个端口传数据也是，我们理解的是这个计算机是一种角色，你可以理解为虚拟电脑，计算机一般是非常专业的称呼嘛，我们一般叫。你读的什么系？计科系计算机科学与技术然后这个时候我们没有叫电脑系，是因为计算机是一种非常专业的名词，而电脑是一种俗称，所以我这个地方没有写电脑，computer嘛，所以翻译就看人对方是一个普通人，就叫电脑，但如果对方是个程序员就说计算机，计算机爱好者嘛，有那本杂志嘛，那这个地方至少为2。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>持续传输</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么第一个是交换数据，然后这个数量限定了，应该还有一个，我比如说我拿那个激光闪一下是不传数据是，但是这个玩意是一直不放手，一直传光纤，源源不断，持续传输，这个地方讲的持续传输，不是说的每一秒钟都必须有什么，他是说一种可能性，他可以一直说，他也可以间歇性传，那这地方使用场景是交换数据，计算机数量至少为2然后可以持续传输。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>必须简单</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我就问你个问题，如果你要用这个API来传数据你要倒腾两天你愿意用吗？在这个出现之前，传数据是非常麻烦的一件事情，就是自己撸一套应用程协议，不管那个协议是简单还是复杂，比如说：我们那个HTTP不是起始行嘛，有的人就那行里头规定前五个字节表示什么意思？表示方向向右，后五个字节表示方向上下，我就可以用两个字节表示一套协议哦，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/01表示图.png" alt="01表示图">
</div>
</div>
<div class="paragraph">
<p>什么意思？比如说这个东西是用的那个红绿灯，那个不是有些有箭头嘛，我也这么假设，当这个地方为1的时候那么你表示箭头朝左，当这个地方值为0的时候表示直朝右，然后当这个地方也是一样为1的时候表示上，当这地方为0表示下，所以这个地方翻译一下就是朝右下，是不是一套协议吗？和数学像不像？等式替换嘛，只是说你这个数字是给计算机看的，你要给人看的要翻译一遍嘛，但是你的数据又是在那个网线上流淌的找的，所以这个时候你要让计算机先懂，他懂了你翻译给人那个才能听懂，你不能在网线上传人类的语言那叫语音，所以说数据它的表现形式是不一样的，所以那这个时候，这个就最简单的协议吗？我甚至还可以用一个直接表示上下，就简单一半嘛,那这样的话就相对说你每次传动性是这样的：1字节、1字节、1字节、1字节、1字节，然后这个时候对方说的是这样的，01001000来翻译一下，你知道怎么翻译的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/八位.png" alt="八位">
</div>
</div>
<div class="paragraph">
<p>我现在做一个延伸，当我觉得一个字节太浪费的时候我我告诉你那个交通信号灯一共有八个。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/红绿灯.png" alt="红绿灯">
</div>
</div>
<div class="paragraph">
<p>我现在要要求你用一个字节的表示，然后一个自己刚好等于八个二进制位，所以当这个灯亮的时候是1,我打个比方，然后其他都灭，然后这个时候，你得出了数字是1，是不在刷二进制了嘛，我能够用1个数字，就是从0-9我能用一个数字表示八个交通信号灯更省流量了，那是不是通信协议吗？是不是也在传数据吗？我们都不说那么高大上的，就拿交通信号灯这种来举例子，说到这个地方必须简单，不是可选的，是必须简单的，这就像我们在做监控系统这个智眼的时候，我们在考虑个问题，我们传数据其实也可以照一套我们自己的数据传输的协议，对的省流量，而且安全可控，而安不安全定说，至少可控你自己发明的，你自己知道怎么弄，但是有个问题，另外那个人过来学的时候你又没有文档，你又没有视频教程，所以就很尴尬了，所以那么这个就必须简单好用这个是必要条件，这是必须的，前面这个持续传输我刚刚讲了嘛，你可以传两下都是可以的，然后至于这个数据，那个数字为2你要传输嘛总得两个点嘛， 两个点构成一条直线你才能传上，然后这个地方交换数据，你都不传数据你搞这后面干啥呢？那么使用场景就限定住了，然后这个时候我们讲的是HTTP，他是用这种协议来传输，而这种协议叫超文本传输协议，Wiki上写的是它是一种最简单的应用程协议，然后像你没感觉到还很简单，但是书上都是写的很简单，你们的老师也会告诉你，这是世界上最简单的一个协议了，证明其他协议很复杂。</p>
</div>
<div class="paragraph">
<p>使用场景就就知道了我们我们在延伸下面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>格式化或结构化的参数列表</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那既然是HTTP相关的这个API系统，那么他的场景看起就是为了传输数据，那传输数据的过程当中，接下来这个地方该填啥，使用场景吗？你想HTTP那个Url你是怎么写的？格式化或者结构化的参数列表，问号后面嘛，或者放到body里面他也是格式化的呀，我们认为的HTTP它就是格式化的结构化的参数列表，意思是拿了就用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP + TLS（openssl）= HTTPS</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>具体到HTTP的话，那我们要给这个API系统加密，是不是很简单？直接HTTPS就可以了，就相当是HTTP加上TLS会话层，这个是什么玩意儿？就是你们常见的这个，类似于它openssl，你们每个人电脑上都装到这个库的，他就提供这个算法，那么最终等于HTTPS，所以标准嘛，标准的好处就是加密方便，证书你可以自己生成，你也可以让别人那个花钱给你生成只是说浏览器展示绿色的锁还是红色的叉叉而已，但是已经达到了传输数据的目的，只是对方信不信任你这个证书而已，那么格式化参数，那么就这个加密方便，有加密的你看到没有，基本上这几个一组合在一起。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>灵活</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我问你个问题吗？传参数是你可以放到Url里头，你也可以放个body里头也可以放到头里面，灵活，这就是灵活，我没有强行总结，你用就是这么用的呀，你要说数据库的一致性、原子性的才叫强行总结，你用数据库，你感觉到原子性？你怕没感觉到，但是你吃面包你感觉到香，你喝水你感觉到解渴，所以说如果要成为强行总结，就说别人用完了，没有直观感受到好处，那就是强行总结，比如说我为什么用Mysql，方便啊，然后别人跳出来，你咋不讲原子性一致性呢？没感觉到啊，就是一个命令就装完了嘛，他他刚好能用嘛，我又不是那种专家，用到全世界就我那1%，只有那种人他才会强调这个，你Mysql存过数据，你装个Psql我就不能存数据了？你装个Redis的时也可以存，Redis存，有一天重启了，没数据了，哎，好像有数据，因为Mysql的每五秒钟会down到硬盘上，好歹五秒钟以内不丢，你看到没有，其实很多时候也满足，只是你要求越来越高哈，那你五秒钟以内的都不能掉，这个时候你才会去强调这些东西哈，所以直观的我们这个地方使用场景强调的是直观的，因为用过HTTP，当我没讲，但是你都是用过的，所以这个是一定是灵活的。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_SJKYL1_chapter">18. 数据库原理（一）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_17">18.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/数据库原理(一)板书1.jpg" alt="数据库原理(一)板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数据库是什么">18.2. 数据库是什么</h3>
<div class="paragraph">
<p>今天讲数据库原理，我们讲的数据库原理，肯定是从我们编程角度，需要多次讲多少肯定和数据库原理的论文不一样，比如说你要讲大数据的话，我把Google的三篇论文翻出来给你讲一遍，你听懂了就可以写代码了，但那样的话就没为没显得高射炮打蚊子，因为里面设计很多分布式的东西，那这个地方数据库也是一样的，就是它范围很大，我们把它精简到一个最迷你的一个模型里头，那么既然讲数据库原理，你肯定回答这个问题，你要知道数据库是什么之前你就要举例子，你把你生活当中拿就是遇到过的例子举出来：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mysql：现在我们知道的数据库首当其冲的肯定是Mysql，因为他在的互联网企业当中用的最多。</p>
</li>
<li>
<p>PostgreSQL：一个开源的关系型数据库。</p>
</li>
<li>
<p>Oracle：Oracle在政府和银行用的很多，为什么用的很多呢？因为在那个年代实用的数据库就没有第二个了，所以他现在是缺少中国市场，同样是全世界第一。</p>
</li>
<li>
<p>SQL Server：微软Windows平台的，这个东西我只能说确实不错，但是和我没有多大关系，因为我又不用Windows，他挺好的就是有点贵，免费的也是可以，我那个时候用的是SQL2008、2012，最大支持cpu4核，等于说你cpu再多他也只有这个性能，所以说你在4核能跑就可以了，他有免费版是挺ok的哈，用C#的话基本上无缝集成，但是现在大家都在用Java，然后用PHP搞互联网嘛，然后现在GO语言也在搞，但是到现在为止，没有听说哪一个大公司哪个大项目会用SQL Server，SQL Server去年已经在Linux下能跑了，我说的是能跑，用不用那是另外回事情了，微软是先把.NET弄成个调.NET core，能够在你Linux下面跑，然后把编程语言跑完了，再把SQL Server移过来，所以那这个地方都挺不错的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个地方Mysql和PostgreSQL在互联网行业是最受欢迎的，Oracle和SQL Server这两没互联网啥事，在互联网的行业是这样的。</p>
</div>
<div class="paragraph">
<p>什么叫互联网行业？你手机用的app，你的网络购物，那么它就是典型的互联网应用，然后这样的话就意味着你的订单量很大，那这种情况下面的话服务器多吧，服务器多用Oracle贼贵，维护也贵，主要是贵不是不好用。</p>
</div>
<div class="paragraph">
<p>所以数据库是什么？那么列出来这三个，所以这个地方我们就按普通人的这种认知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>数据库是保存数据，能用过SQL增删改查的计算机软件。

重点：关系型的、SQL</pre>
</div>
</div>
<div class="paragraph">
<p>Redis是数据库吗？你看他符合定义吗？他能永久保持数据，但他不能通过SQL查，所以我们这个地方指的数据库，通常指的是关系型的，而且是SQL的，这两个很重要，在Redis和Mongodb出现之前，这些数据库全部都是关系型的，极少数可能有那种昙花一现的数据库，所以大家在通常讲数据库的时候，一定指的是关系型的数据库，而且关系型的SQL数据库，所以通常大家指的是这个，所以我们就不会说Redis是一个数据库，Mongodb其实我们也不会认为他是数据库，包括ES，我们也不会认为他这个数据库，他们单独给那种取了个名字叫NoSQL，不是SQL，那就肯定就和这个八杆子打不着一起，所以那这个地方我们通常指的数据库，一定是关系性数据库。，像那种Redis或者Mongodb或者ES，你可以把它叫数据仓库软件， 那这样的话可能更贴切一些。你想嘛ES也不能用SQL查，只能用JSON，Mongodb其实也是有特殊的语法，你看那个Redis用getset搞了半天，也能做，所以那种可能归为纯粹的NoSQL或者是数据仓库，或者叫数据存储软件会更好一些。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_4">18.3. 使用场景</h3>
<div class="paragraph">
<p>那这个地方既然提到使用场景这个地方你要提关键字了，永久保存。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>这个地方补充两点哈，通常说的数据库肯定有它里面的内容，内容组织形式，那么首先你的有数据库，然后第二个是得有表，所以他是这两个形式的组成的。

* 数据库 Database

* 表 Table</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个地方使用场景的话，其实这两个和使用场景也没啥关系，主要是永久保存和SQL，那这样的话使用场景肯定就举例子了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>银行保存余额</p>
</li>
<li>
<p>电商订单</p>
</li>
<li>
<p>病例</p>
</li>
<li>
<p>QQ号（社交类）</p>
</li>
<li>
<p>政务系统</p>
</li>
<li>
<p>游戏装备</p>
</li>
<li>
<p>报警记录</p>
</li>
<li>
<p>违法记录</p>
</li>
<li>
<p>维修记录</p>
</li>
<li>
<p>酒店开房记录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有很多就不写，所以使用场景你发现只要数据不能掉的，通常意义都是用数据库来保存的，这是使用场景。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么保存数据的工作原理">18.4. 怎么保存数据的（工作原理）</h3>
<div class="paragraph">
<p>这地方肯定讲的是How，实际上这个地方问的是工作原理，我们讲编程的时候我们会说怎么去调它，但是我们在讲纯数据库的时候，怎么保存的意思是说，你把数据给了Mysql他怎么保存到硬盘上的，你问的肯定是这个，为什么？我们讨论的是限制了范围的，所以那个地方讲的肯定是数据库的工作原理，那很简单，我们先来复述一遍，我打个比方：</p>
</div>
<div class="paragraph">
<p>你到天猫超市你去买了一瓶水，从你进门开始看发生了什么？你进门的时候挑选商品，挑选了商品过后，你把商品拿到前台结账，然后轮到你过后，那么店员扫二维码扫条形码，系统显示价格，系统显示了价格过后说五块六然后这个时候你要付款，不管你用任何方式付款，就是扣了你的现金扣了你的余额，那么你用银行卡，支付宝，微信现金都可以，然后付款，自从付款那一刻你的交易就结束了，那这样的话就证明就是说你的交易行为就结束了，那这样的话在天猫超市的系统里面有条五块六的购买记录。扫了商品再扫你一下，这个记录我假设他在当前产生了，但是他还没来得及传出去，那这个时候，他这个时候应该形成一条购买记录，购买时间，哪家超市，或者超市的代码，然后商品名称，商品规格，商品单价，商品条形码，如果不存的话，你不觉得那个信息逻辑是不完整的吗？当然有另外一个问题了，他入库的每个都扫了一下条形码，你看现在这就很尴尬了，所以他应该有批次，他条形码应该指的是批次，所以就是相当于批次，批次完了过后就是打不打折，然后这个时候产生这个记录放在这个位置了，他怎么到数据库里面去?</p>
</div>
<div class="paragraph">
<p>数据库肯定是中间过程嘛，那数据库既然是直接写到硬盘上，那为什么你不直接把那条数据保存在硬盘上,这过程当中数据库干了几类事情，第一个数据库通过网络IO接收，这是典型的嘛，3306端口嘛，然后通过端口接收过后接到数据，他肯定要先把它做一个格式化嘛，格式化成自己的格式，你也可以理解为编码，编码成自己的数据库的格式，以特定格式存在硬盘上了过后Mysql才能特定格式去读吧，他为什么这么干，而不直接是写0101乱存就可以了，那是因为他从硬盘上读完了过后，他要做各种分析，缓存，各种加速，各种索引，所以如果你不是特殊格式的话，他很难处理，所以数据库，它第一个职责，这个地方讲的是种典型哈，但是他没有涉及的更多的特性，这个地方第一个，那么它保存肯定是保存自己的格式，所以你要靠他，为什么保存自己的格式呢？是因为他自己有索引功能，他为什么要有索引功能呢？因为他想快，他想查询快，这个查询不管你是单表查询还是多表查询，他就是想快，你为什么不放硬盘上？很慢呀，越访问越慢，你一个人访问都没啥事，你自己都可以hold得住，但是你那个硬盘多读几次就崩了，就这么跟你讲全世界的数据库，不管是谁，他写入的数据永远无限接近，不管是比尔盖茨还是更牛逼的人，你弄的数据库，你写数据的速度永远无限接近，为什么？因为写的速度不是你数据库决定的，是谁决定的？硬盘，硬盘就这么慢，你保存的再快，有啥用，所以说数据库不管你再牛逼，你写数据依赖的是数据库外部的硬盘硬件设施，所以这个时候，都一样慢，我是假设他的整个逻辑已经非常完善了，然后代码0损耗，这样去写数据库，保存硬盘上那个速度一定是无限接近的，那么既然他都是一样的，那他的区别肯定还是有的是什么，查询速度这个说白了通常统称叫性能，所以就第一个用数据库肯定是为了性能，肯定不是为了好看，第一个那肯定是他的使用效率，软件的使用效率，查询效率高，那么你才会用的，为什么你都叫数据库了，你查询慢，谁用你？你还叫数据库吗？你叫的文档算了，第一个，那就是性能好，使用效率高，第二个数据存储方便，抛掉这两个特性，你那个数据库没人用，虽然他也叫数据库，世界上数据库可多了，但是你不会每个都用，因为你要考虑慢不慢，快不快呀，用的方不方便，这两个看起来才是引入数据库的一个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用效率（性能）</p>
</li>
<li>
<p>便利性（SDK？）（API？）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那是怎么让他发挥效率的？说白了你有之所以不用文档的方式去存储，和引入数据库存组一定有区别，而你把这个区别讨论完，你就知道数据库的原理是什么了？首先，我们就先说简单的存一个Text，你可以在里面增加删除修改，增删改查都是可以做的。所以那这个时候它是文档，数据库可以理解成某种意义上的文档，只是那个文档不是你直接编辑的，是数据库编辑的，所以他们的起点和终点是一样的，起点是你输入的数据，终点保存到硬盘上，那中间发生什么，为什么？事物嘛，你拿来这么一对比对比就能看出了他的区别了，而不是孤零零的说，为什么有Linux？Windows不是挺好吗？我都讲过嘛，贝尔实验室的老头子他们想要个多任务系统，那既然有多任务系统，那证明他们以前用的是单任务系统，你登进去了就不能用，为什么？就一套键盘一个显示器当然不能用啦，怎么实现多任务系统的呀，通过网络登上去，用自己电脑登它，然后同时多个用户，是不是这意思嘛？你肯定有单任务系统才有多任务系统嘛，所以事物都不是孤立的，所以回到这个问题，起点是输入数据，终点是保存到硬盘，说白了这个地方就是0101，那中间发生了什么？</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/原理图.png" alt="原理图">
</div>
</div>
<div class="paragraph">
<p>你输入数据，打开了一个编辑器，输入数据点保存，任务就完了，那数据库是什么？你打开了一个Mysql的编辑窗口，把那个数据输入到Mysql窗口，点一下保持它就完了，是这样吗？那肯定不是我们关注的重点，看起来都是一样的，但是我们想关心的是那个数据库的编辑器或者是交互窗口他做了什么，那这个地方输入数据，那么我就假定都是窗口，编辑UI嘛，因为UI就是窗口的意思，那么在编辑窗口编辑数据，那么得保存，第二步嘛，那第3步发生了什么？自从你保存完了过后，就已经脱离你的控制了，要你这个和我们之前讲的结合起来，你数据库肯定有编码，结码，先编码，所以说保存数据这个里面有有东西，那么编码要发网络发送，那么发送完了就是网络接收，比如这个地方就通过3306嘛，那么网络接收后面就要解码，解码完数据就得到他想要的格式了，所以他解码完了是在解析他，数据解析是哪张表哪个数据库的，那么解析完了过后，他应该产生第一个哪一个数据库？第二个哪个表？然后第三个详细数据（记录），他解析完了过后，剩下还是说他要去做后面的事情，那他这样做完了过后，你会发现他已经开始靠近硬盘了，他这个是应该考虑硬盘怎么保存的问题了，所以这个地方他同样有编码。有个东西等一会儿有详细讲，叫数据库存储引擎，按照数据库存储引擎格式编码，编码完了过后，那所以这是一个很典型的过程，你会发现有意思是在这，这是个独立的一个阶段，上面的是不会有中转的，哪里会发现这个地方是最容易的，我发现这叫什么吗？HTTP是这样的吗？Mysql也是这样的呀，我都不说数据库了，包括你的视频也是这样的，包括你的音频，也是这样的，所以这个地方是网络协议的处理的一个流程，就这个是非常典型的，而这个地方他解析数据。你传过来，他要解析，然后这个解析这个数据还是现在还是内存里，他一定要分析完了过后是哪个数据库哪张表，然后记录数据是什么，拿到这些东西过后，带着目的带着这些信息再去问存储引擎说我要存个东西，是什么样的格式？那么去调一些函数过后，他把这个当输入参数传给这个编码函数，怎么样他就会反应串支付串给你编码后的支付串，你再把这串支付串保存到硬盘上。</p>
</div>
<div class="paragraph">
<p>现在有意思就解析这一块，为什么要有存储引擎哈，就拿Mysql举例，Mysql在5.0之前哈，他一直用那个存储已经很老旧的，那个存储引擎只要你更新任何一张表，所有查这张表的人必须排队，锁表意思就是说：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>我在这个房间里面使用的话，比如说，我在用这张房间，外面所有人必须排队，然后我用完了出去了其他人才能进来，慢嘛。然后后面Mysql更新的新版本的存储引擎过后你可以进来，你坐的那个位置，除了那个位置以外其他人都可以用，这样的话，就变成了一个是锁表，一个是锁行，意思就是说一点，很明显，锁一点点的性能更好。</pre>
</div>
</div>
<div class="paragraph">
<p>所以你看出了存储引擎对数据库的影响有多大了，最关键是他以前那个存储引擎还不支持事物，什么叫事物：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>双十一京东上面买东西扣余额扣到第二笔订单的时候，你又下了五个订单，但是你全选完了那个系统扣款可能是一笔一笔的扣，扣到第三笔的时候报错了，请问你的订单交易成功了吗？如果像以前的话，他也不知道。但是你有新的存储引擎过后，第三笔失败了，那么他就会反告诉用户双十一你的订单买失败了，具体哪个地方，我也不清楚自己看日志，然后交易失败了过后他就会把你扣的钱又退给你，这就是事物。</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是说，在那个事物区间里面发生的所有事情都可以回滚，都可以撤销，像极的人生编辑器，在数据库里面，他也有后悔后悔功能，改错了就后悔撤销，你可以主动说我后悔了我撤销，我自己撤销也可以，在报错的时候撤销都是可以的，所以存储引擎对数据库的影响超级的大，然后这是还是一个例子，第二个例子就是快慢的问题，新的存储引擎，它的查询效率更高，为什么？以前存内存里面的时候要查三次才能拿到某条数据，现在有Hash表，效率从以前0n变成了现在01那肯定快了，所以影响很大这地方涉及到的一个事物，主要涉及到的这三块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>事物</p>
</li>
<li>
<p>锁表（查询）</p>
</li>
<li>
<p>索引</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这三块对一个数据库影响很大，我刚刚就简单讲了一下，然后这个过程我们再来套一些实际的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>比如说我们现在做一个简单的查询，那查询的时候你要输入一个SQL，SELECT * FROM Table，然后这样的话就相当于说你指定了表的名字，你在SELECT之前先USE数据库，或者说你的FROM db.表名字，然后这个时候又相当于你又指定了数据库，又指定了数据库的表，甚至你还有 * FROM那个*号也可以换成具体的列，那这样的话这叫元数据嘛，一元两元的元，不是原始的原，这元数据意思就是说最初的未经加工的数据，那你把这个元数据那么编码，这个SQL做编码，把这个SQL做编码，那么编码后的SQL就带了Mysql的报文，报头嘛，报尾，中间就夹着那个SQL，然后通过网络的3300端口发给服务端，经历三次握手，我就不讲了，那太细了，那么上次握手过把数据发过去，那么Mysql服务端说我收到了，收到完了之后，他再把他报文报头东西按照他的规则挨个切开，切完了之后忽悠剩下那串SQL了，然后这个时候，他应该自己写一个SQL解析器，SQL解析器其实以前叫网络协议，SQL这个东西就叫本地协议可不可以吗？就是一个字符串协议，他把那个SQL丢给他的编译解析器，解释器他会把这个SQL里面的哪一列是查询还是怎么了，然后数据库名字表明字包括WHERE条件，它从一个字符串格式化成一段一段的，方便他拿数据嘛，不然的话那么长一个SQL你的那个肉眼倒是能看清楚在哪，但计算机懵的呀，到底是一个 * 号吗？还是那个F吗？他不知道怎么切，所以他现在是也要拿刀子切嘛，把里面重要的元数据切出来，切出来了就放在那嘛，为什么那么复杂还要写SQL，那是因为你笨，你要是能写0101他至于那么恼火吗？</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个时候哈就是之所以用SQL，还要转一次才能让计算机明白是因为人脑没有计算机那么死板，人脑不能理解这种东西，人脑只能理解你形式化的东西，所以他这个地方收到过后他在做解析的时候把SQL解一遍，这个地方有个SQL语法解析器，那么他把那个语法解析完了过去能拿这些东西，然后拿着手上过后那么他就应该去让他的存储引擎去读了，就和刚才不一样了，刚刚是写嘛，他就怎么样，他就问存储引擎这个数据库这张表请你拿出来，那这个时候他肯定就会去读下头，读完了又返回来，然后返回来又绕回去，又把过程倒着来一遍，就出去了，这个时候刚刚进来的时候是一个SQL语句，返回的时候一定是一个结果，那个结果一定是个列表，你的数据库是不是列表吗？你的Excel是不是列表吗？你的编号是不是从一开始的嘛？所以说他的列表一定是从0123456789，所以怎么样到了这个地方。他就倒着来，那这个时候，你反回去的时候是一个列表清单，就是这张表的或者是这个查询的结果清单一行一行返回回去，然后到了这个位置，那么他解码解码完了过后，这个软件就把那个数据按一行行的格式展示出来，刚讲的增加，现现在讲的查询删除更简单，SQL传进去DELECT什么什么东西，到了这个地方，他发现你要删除，就告诉存储引擎请你把这个表的这个数据删了，那么他就找到数据删了，改的话就是更改一个数据将那个地方以前的数据重新覆盖一遍。</p>
</div>
<div class="paragraph">
<p>所以那这个地方就是不管你怎么套，你会发现都能讲通，大致逻辑都是差不多的，我就不用挨个来讲，然后现在问题来了，数据原理就那么简单吗？其实不是的，这个地方少写这个字。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bianchengjiqiao_chapter">19. 编程技巧</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_18">19.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书1.jpg" alt="编程技巧 企业级板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书2.jpg" alt="编程技巧 企业级板书2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书3.jpg" alt="编程技巧 企业级板书3">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书4.jpg" alt="编程技巧 企业级板书4">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书5.jpg" alt="编程技巧 企业级板书5">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是编程技巧what">19.2. 什么是编程技巧？(What)</h3>
<div class="paragraph">
<p>今天讲编程技巧，那首先还是老样子，编程技巧是什么？首先这个技巧指的是什么？这个地方的技巧对于你来说叫技巧，对于我来说叫基础，其实这个东西代表的就是优秀工程师的一个基础技能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_where">19.3. 使用场景 (Where)</h3>
<div class="paragraph">
<p>什么时候该用编程技巧？清晰表达逻辑的时候你就需要用我认为优秀工程师的一些基础技能了，当然你的代码自己都没有逻辑，就谈不上这个东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么用how_2">19.4. 怎么用？(How)</h3>
<div class="paragraph">
<p>怎么用这是今天我们重点讲的。</p>
</div>
<div class="sect3">
<h4 id="_引申">19.4.1. 引申</h4>
<div class="paragraph">
<p>当你没有听我讲这个之前，不管你是工作了半年甚至十年，我讲的这些方法你根本就不会掌握的，另外个层面就是你说这个东西掌握人多不多，多，为什么？在GitHub上面写开源代码的人多多少少都掌握这些，但是在你的生活当中是遇不到这种人的，为什么？GitHub看到的项目也可能就那么几十万个程序员，还是全世界的，不要认为给银行做项目那些就是TOP了，做银行做项目这种人，他是会写业务代码，而编程技巧和业务代码一点关系都没有，为什么？业务抽象到最后，抽象是作为数据抽象，然后最终写到纸面上的时候就是代码抽象了，那么这个过程当中就要依靠编程技巧，但是代码抽象这个不是唯一的方法，就像刚刚说的你可以写IF，也可以写查询表、设计模式，所以有很多种表达方式，甚至你用C语言都可以，就全靠指针，全靠回调函数也是可以做的，所以在银行里面的人，只能说他对那个业务很熟，不一定说他编程技巧是最好的，为什么？编程技巧没有最好，因为编程没有衡量标准，比如说我们同时参加高考，都是同一个地区的，用同一套试卷你能考出来，但是你并没有听说过谁去招聘的时候限制必须要什么软件工程师证书，我没有毕业之前听说大家考那个，然后去看了下那个题还考DOS和一堆上古时代的东西，我直接看都不想看，为什么？首先如果一个证书他学的东西都是过时的，我就认为那个证书没有任何价值，从我的角度来说的软件工程师证书是没有任何用处的，那编程既然没有衡量标准，那你怎么知道你用的是好的或者是合适的？然后这个过程当中编程难就难在这个地方，比如说同样是写一段代码，你写的就和别人写的就是不一样，但是每一年有那个C语言一行代码的比赛，一行代码可以写个游戏，但是写一行代码写游戏的人在公司都被开除了，为什么？因为企业里面要的不是很NB的技巧，要的是协作，所以我讲的东西肯定是企业级的，意思就是说，我们不搞技巧，我们也不钻牛角尖，比如说考个题，问你i和i有什么区别？说实话，放在哪个位置他能加上就可以，然后这个时候，你不在乎我不在乎，你就不会去考虑这个问题了，比如说，有些题是这么说的a = a++-,请问最后他是等于几？你要是敢这么写的话，放心，你的leder会打死你的，为什么？因为只知道你写了一行代码，但我并不知道你这行代码代表了什么意思？</p>
</div>
<hr>
<div class="paragraph">
<p>所以技巧是为了清晰表达自己的逻辑，刚刚逻辑表达不清晰，到后面你怎么去让别人看懂你的代码，所以一般我交出去的代码，代码员是不会重构的，为什么？因为他们重构不了，他们只会在我的基础上面加东西，他不会去改我的，就算改我的，其实也只是改一些，就是后面业务有新增、变动或者是我确实写了Bug，他可能去做这种，但是他不会去改我的逻辑，为什么？他已经想不到更好的逻辑了，但是每一次看到我同事在我的基础上加的逻辑，我就很头痛，为什么？明明我的逻辑很完整，结果你加了东西过后不伦不类的，查数据库在A，然后又用在B，然后C又调了A，然后我就懵了。</p>
</div>
<div class="paragraph">
<p>那么为了清晰的表达逻辑，你就要用这种技巧，所以这是优秀工程师的一个基础技能，它并不是非常非常进阶的东西。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景一">19.5. 使用场景一</h3>
<div class="paragraph">
<p>刚才我问大家一个问题说你接收三个参数，那这三个参数分别是算法的A1，A256和A512，那如果穿个2048进来会怎么样？那么我就从这个入手，讲一下如果是我我会是怎么做。</p>
</div>
<div class="paragraph">
<p>首先我们就假设一个场景，那么这个场景里头，要接收一个URL的URI参数m：</p>
</div>
<div class="paragraph">
<p><code><a href="http://localhost:8080/?m=SHA1" class="bare">http://localhost:8080/?m=SHA1</a></code></p>
</div>
<div class="paragraph">
<p>然后这个m，有三个可选项： <code>SHA1</code>、 <code>SHA256</code>、 <code>SHA512</code></p>
</div>
<div class="paragraph">
<p>那既然叫可选值，在编程领域，你只要看到那个参数啊，它有这三个字可选值，那就意味着一定是枚举，然后现在新的问题来了，枚举是什么？枚举就是把你的可选值列成列，当然你说可以放到数组里头啊，数组也可以，但是你怎么校验数组？你怎么校验字符串数组里面的字符串？就比如说你要校验多没多空格或者你敢打赌某个字符不小心敲成小写的？所以这个时候用数组其实是可以啊，等一会我们再来讲它的用字符串表示的不合理的地方在哪。</p>
</div>
<div class="paragraph">
<p>现在就先讲一种我认为正确的处理方式或者说是比较合理的一种处理方式，那既然这个地方它是枚举，那我就在Java里面写成枚举，然后这个时候我就写个Java Enum(枚举)去表示上面这个的话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Enum

M_SHA1</pre>
</div>
</div>
<div class="paragraph">
<p>就会有个枚举叫M_SHA1，这个变量名是合法的，那既然是合法的，那肯定他也是一个合法的枚举，通常来说，你会这样等于一、二、三，这里我们直接一上来就用一个标准的做法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Enum

M_SHA (1,”SHA1”)</pre>
</div>
</div>
<div class="paragraph">
<p>一般我会把这个枚举类改造一下，我让这个东西变成一个迷你的Class，然后在后面写上SHA，下面套路你就知道了，我这样做的意思就是说普通的枚举，他只能表示数值，但是我想在枚举上做一些字符串、值的比较，这两个我都想用，我不想写在两个地方，所以这里我就先讲我认为标准的方式。</p>
</div>
<div class="paragraph">
<p>那下一个就是把可选值加上去：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Enum

M_SHA (1,”SHA1”);

M_SHA (2,”SHA2”);

M_SHA (3,”SHA3”)</pre>
</div>
</div>
<div class="paragraph">
<p>当然这个地方我肯定省略了这个类的名字，那先取个名字叫Enum Method，这是美举，然后这个时候，你看到没有三个可选项都在这，这些字符串你都认识，是用户输的那个，那前面的1、2、3是什么意思，是因为每一个美举，他一定要对一个数字，这样就很方便编成语言去区分，比如说你没有写1、2、，编程语言他就分不清楚你这个字符串和这个字符串有什么区别，所以每一个语言的枚举，它的基础类型都是数字，不管是长度多长总归它都是数字，所以这个是它的基础特性，就是所有的枚举都是数字，只是Java在数字上加了点东西，方便等一会再用，那这样看起来如果用户传了个这个，那么他就等于1，我要怎么表示这个1呢？首先我肯定不会在那个地方写个1，其实M_SHA1就是表示那个1，那这样的话你在代码里面看到M_SHA1就看到了1和SHA1，用M_SHA1做代号,用它来代替你在到处用字符串、引号，因为你知道的人脑是不可靠的，你到处都用引号手动去打，这样你是能打，但换个同事，他能打对吗？</p>
</div>
<div class="paragraph">
<p>所以这个时候你的同事就变成你的用户，用户的输入是不可靠的，一定要做校验，还有在类型上去限制它，等一会我们来总结，这里我们先把方法讲了。</p>
</div>
<div class="sect3">
<h4 id="_接收参数">19.5.1. 接收参数</h4>
<div class="paragraph">
<p>那既然有枚举了，就要接收参数，假设我现在已经收到了参数m，那就相当于说第一步啊，那么接收的参数参数m，那这个时候m等于字符串，所以现在这个m是等于SHA1，那现在我拿到这个后，要做参数教验，我有几种做法</p>
</div>
<div class="paragraph">
<p>1.IF</p>
</div>
<div class="paragraph">
<p>if m == “SHA1”</p>
</div>
<div class="paragraph">
<p>那既然可以这样写，那也可以往下继续延伸，写多个IF，但问题在于，如果有100个可选值呢？最关键是只有三个没错，确实他只有三个，但是你要是三个都解决不了，你何来解决100个问题，所以我讲过的，从我的这个经验来说的话，我经常是用一种方法解决所有的共性问题，既然这是一种参数的可选择问题，你就应该把这种问题归纳成一种简单明了的方法，以后在你的软系统里面，只要涉及到这种的，通通只用一种方法，就问你个问题，你的同事拿到你代码的时候，逻辑就很简单，这个人我已经看透他了，怎么看透的？他只要是可选值，他都会用枚举，那就变得简单了，只要你变得简单，你的同事就不会在代码里面写Bug，所以你不能一会儿用枚举，一会儿用IF，一会儿再用查询表，你这是在秀你的技巧，但是秀技就很讨厌，你知道吗？俗称装逼，装逼是要有限度的，所以这个是你用IF是确实可以做的，没毛病，但可能看起来没什么好看而且最关键万一以后你老板说要加两个算法，以前是三个，再加两个就是五个，然后你就在后面加，那么参数校验是加了，但是后面在用那个算法的时候，总得有地方判断它是哪种算法？你又得判断，然后你说把这个包装一下，然后写成SDK跟我的同事用，那你同事又是传的字符串进来，你又得校验一下吧，这样不累吗？这等于说你一个相同的逻辑会在出现在不同的地方，要是这个逻辑不完整，不自洽的话，你很容易留下隐患。</p>
</div>
<div class="paragraph">
<p>就像昨天我们公司团建，我跟我同事讲我写代码都是叫防御式编程，我会因为防御式编程花非常多的精力在我的封装、易用性上面，甚至包括我的变量名、使用文档、说明等等，这些东西我会花时间，为什么？因为我宁愿花时间，也不原因出了问题，我帮你找Bug，然后发现是我的问题，那样的话就更花时间，所以从一个内行的角度来看，我是在优雅的编程，我这种优雅体现在：“你能想到我都想到了，你没想到我也我也想到了，我想的始终比你多一步。”这就是工程师和工程师之间的差距，你但凡多想半步，就好非常多，不是好一点点的问题。</p>
</div>
<div class="paragraph">
<p>2.枚举</p>
</div>
<div class="paragraph">
<p>第一种方式肯定是不可靠的，因为你还是用字符串的方式来做的，那么A2的方式是拿了枚举，得把m转成枚举才可以，所以我一定会有这个语法，这里枚举我就用e表示，那就叫me，那么me这个枚举，他肯定是来自于m，所以你可能有一个方法或者强制类型转化，比如说强制转成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>me = (method)m</pre>
</div>
</div>
<div class="paragraph">
<p>我们假设这句话他是合理的，那么强制转换过后me就等于其中一个类型，传进来的是SHA1，那这个m1= M_SHA1，所以这地方就写个注释，那这个地方其实就是等于的M_SHA1，那做了个强制类型转换过后，那他就是me了，然后这个时候me要去调加密算法，要传给下一个Class，就假设我们调的是那个MAC：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mac = Mac (me.getname)</pre>
</div>
</div>
<div class="paragraph">
<p>现在你又开始有槽点了，这地方本来接受的就是字符串，那为什么不把这个M直接传过去？那实际上这个getName实际上又是等于一个字符串，那为什么不直接把m传过来？听说过SQL注入吗？打个比方，这个地方是个查SQL的，要是传一个rm -rf进来传或者Delete，然后你就会发现这语句就不是你预期的，就变成了一个Select里面悄悄带了个inset，那你的数据库表是不是就被改了，所以你对你的代码能控制吗？那就是万用灵活的API接口，就是你的编程啥都不用干，只需要几个注入的接口，前端那边只需要传SQL过来啥都能做，前端那个人直接查表可方便了。</p>
</div>
<div class="paragraph">
<p>所以这样风险贼大，因为用户的输入是不可信的，永远是不可信的，哪怕他是你的同事，为什么？你也解决不了你同事犯傻，所以做了一个类型转换，转过来，转了类型过后至少这个me你是信的过的，为什么？因为me是三个当中其中任何一个，那万一me没有在这个可选值里面呢？那这个代码就要改造，他有一个最终的版本，一般来说我们要去把一个东西转成一个美举，就是强制类型转化是可以的，但是这个地方要写一点代码，那个代码我就不写在黑板上，那在，枚举类里头有几个方法，第一个方法是获得SHA的值，我们就叫他GetName，前面的数字我们就把它叫GetValue：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>String GetName();

Int GetValue();</pre>
</div>
</div>
<div class="paragraph">
<p>然后这个地方除了这两个以外，还要去把Name变成枚举键，所以你应该有一个返回math的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Method toEnum(String)</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是有三个函数，因为我说了他是个Class，他只是刚好和枚举有点关系，其实枚举你一看就知道是基于Class改造出来的，GetName是返回这个字符串的，这个GetValue是返回数字的，还有一个是从字符串变成枚举的，所以我们使用方法是这样的，先传一个字符串，得到一个枚举，拿了这个枚举和Enum过后，然后Enum.getName就得到支付串，然后getvalue得到的Int，主要是方便，没有其他原因，那这个地方的话，me很明显要调枚举类的方法，而这个方法的肯定是一个静态方法，为什么？因为这个里面的东西和内成员是没关系的，因为你传的东西最终是反了一个自己，而你没有使用任何类成员的变量，所以就不管Static的问题，我就直接用了，就掉math的一个静态方法，叫toEnum，然后接收的参数是m</p>
</div>
<div class="listingblock">
<div class="content">
<pre>me=method.toEnum(m)</pre>
</div>
</div>
<div class="paragraph">
<p>这样的话这句话就解决了问题,但是现你们现在还有一个问题没解决，就是如果他输入的参数不是你预期三个当中的其中一个，怎么办？所以这个时候啊，对于我来说，我会悄悄的加一个东西，加个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>M_NONE(-1,”NONE”)</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是无效值，所以我这个地方是先转换，转换完了之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>IF(me == M_NONE){
log_error(...)

retrun

}</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是如果等于NONE的话就ERROR，这个地方就处理ERROR，打个错误消息，然后retrun，至于retrun什么就不管了，那这样他就终止程序运行了，那经历过这一步过后，这个m就是可信的了，所以现在可以把ME去做加密：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mac = Mac(me.GetName())</pre>
</div>
</div>
<div class="paragraph">
<p>那现在得到了这个，而这个地方在使用的时候，你会发现m.GetName又把字符串给还回来了，然后这个时候，你拿出来做一些其他事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mac.dosomething()</pre>
</div>
</div>
<div class="paragraph">
<p>其实代码用的时候其实就这么几行，枚举啥的都不算的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_划分阶段">19.5.2. 划分阶段</h4>
<div class="paragraph">
<p>然后这个时候给代码这边分个阶段从这个地方啊延伸出来的然后，这个地方是属于参数参数的数据接收，啊那数据接收完了过后，这一段
对的这个数据教业吗，</p>
</div>
<div class="paragraph">
<p>那么枚举的代码算行数，刚刚我是说几行就解决了，为什么不算行数？因为这是相当于一个工具，下一次你还会用的，只是你调用他的地方和名字改了，所以这个东西是不算行数的，为什么？你可以复用，除了这个地方可以复用，甚至说你可能项目其他地方也会用到这个，所以在这种场景下，这个方法的就变成了写一次代码，我就可以一直用，如果如果他不满足需求，我就把它改成满足需求，又灵活，比如说我不想去判断那个IF，我就直接在这个方法里面抛出异常，抛了异常，Java就往外面丢，最外层再来个Try Cach把它包裹起来，所以这个是没有抛异常的版本，我不是不抛异常，是因为有些程序员，他不想要异常，所以我的基础代码一般是不喜欢抛异常的，为什么？因为抛异常外面不好处理，他对你的入侵性太强了，一旦抛了异常，所有用你代码的人都要用Try cash，然后1下就多了五行，然后你的代码结构，就成功的被打乱了，为什么？Try Cash其实是没有逻辑的，因为你永远不知道是哪个地方出去的，所以这个是你要根据返回的异常类型，然后里自定义个叫那个枚举异常，那里写1000个累，那你有1000个异常？不然的你怎么区分是哪个代码出错了？</p>
</div>
<div class="paragraph">
<p>所以Try Cash有时候好用，有时候它不好用，要分场景，在你经验不足的时候，要慎用，你每次要想明白为什么，而不是无脑的直接敲出来，这是第一个问题，就是这个异常的问题，然后还有个工具重复使用。</p>
</div>
<div class="paragraph">
<p>第二个就是为什么不用Map？你这个地方用map的话，无非就是说有一个Map，有枚举里的一些东西，是这样的你用Map有一个很致命的问题，你用枚举转成map里面的东西，你还是得校验，代码少不了，你只是把两个Get省了，第一个你少了只是GET然后你下面类型转换你还是得做，就是相对来说插入一条那个Map的元素，哈西表里面插入一条，一个Key对应的Value，你只是少了两个GET这个代码，但是这个转换没少好这是第一个，第二个是当我想在其他地方表示这个SHA1的时候，如果你有Map的话，你要从Map里面把值拿出来，那你怎么保证里面有东西呢？你是不是还要判断一下是不是包含这个值，包含这个Key，再把值拿出来，因为你不判断的话，虽然你假装知道有，那万一哪天你手贱把它给删了呢？数组、哈西表这些东西叫动态容器，什么叫动态容器？就是永远在屁股后面可以加、可以删，特别灵活，灵活到什么程度呢？什么时间删的你都不知道，比如说你明明在最开始初始化有三个Map的元素，结果到中间你老子抽了你从中间rmove了一个Key，然后就剩俩，然后你后面去用的时候，你假装还在，结果你引入了隐患，媒体最大的好处是你只要不删我的代码，你的容器、数量是固定的，等着被别人用，别人只需要用字符串的初始化就可以了，当然这个地方我再精简一下，那这个地方既然可以转成这个枚举，看起来这个枚举是可以写个构造函数直接就代替他了。</p>
</div>
<div class="paragraph">
<p>所以这个地方他的构造函数和他同名，他构造函数接收一个字符串，现在就已经很简单了，所以刚才两个问题啊，第一个为什么不用Map，第二个是封装代码的意义在哪？</p>
</div>
<div class="paragraph">
<p>那么这个地方封装代码的意义就是能重复使用，逻辑固定,然后不用Map是因为要无视动态容器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景二">19.6. 使用场景二</h3>
<div class="paragraph">
<p>和之前同样的例子，换个场景，刚刚的场景很简单，刚才的简单，简单在于那个值，是把它当字符串在用，那个字符串和你的业务逻辑里面没有非常强的耦合性，你会发现刚才是这样的，就有有些参数传进去，就只是用一下值，但是有些参数传进去，就要基于它构造一些东西，所以这个地方我们就开始讲工厂模式，先把这个m换成Car，之所以这么举例，是因为要无限向你靠近，但是做业务的时候就不一定了，那个时候就可以根据需求自己去换，这个地方可以任意换。</p>
</div>
<div class="paragraph">
<p>那这个时候就假设要这个参数的值去创建一个类，然后这个类里面又有自己的一些东西，比如我就看其实不叫car，简单表示这个地方的值就比如是Bus，那就相当于说这个地方如果传进去的是Bus，Bus的话要买车票，那他就有逻辑了，你会发现这个时候就跟你的逻辑强耦合了。</p>
</div>
<div class="paragraph">
<p>所以刚才那种是非常浅显的，而现在是变成很明显的东西，当然你会发现他肯定是枚举，为什么？因为你要做参数教验，只要是参赛校验，他就是可选值，所以刚才那个地方你一定要用上的，只是发生在后面的变化，所以这个地方我就跳过枚举，等会直接写。</p>
</div>
<div class="paragraph">
<p>那车辆的话，除了Bus、Track(货车)还有Bike，那首先我们要接受参数，就接受参数的可选值先列出来，这地方Car的第一个可选值肯定是Bus，第二个是Track，可能第三个就是典型的Car(小型车辆），然后肯定就是用枚举，我们就省略枚举下面的步骤，这里枚举的意义是在于他刚好是可选值，你要用可选择的枚举来做参数校验。</p>
</div>
<div class="sect3">
<h4 id="_补充c语言中的枚举">19.6.1. 补充：C语言中的枚举</h4>
<div class="paragraph">
<p>这里简单提一下在C里面枚举比这个校验更简单，因为有效的值，我们一般是从0、1、2、3，在C语言里面，这个没有刚好是Int，所以我们经常转换完过后，判断那个Car的Int，在0-3这个范围中，如果是无效的枚举的，那么他的Int是在范围之外的，所以写C语言非常非常简单，用Java写了那么大一堆，结果C语言两三行就搞定了，当然简单是要付出代价的，就是可维护性以及对人的要求都很高。</p>
</div>
</div>
<div class="sect3">
<h4 id="_代码逻辑">19.6.2. 代码逻辑</h4>
<div class="paragraph">
<p>既然已经有枚举，那么参数校验肯定也会做，这个地方我就直接这个代码逻辑，就不说那种IF/Eles的情况了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.intputCar = arge[“car”]</pre>
</div>
</div>
<div class="paragraph">
<p>首先接收参数，显然得有个car，去获取用户传进来的参数，现在就假设这个地方是可以通过数组拿出来的，那这样的话你拿到第一个变量。</p>
</div>
<div class="paragraph">
<p>然后现在要做参数教验，做类型强制转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2.CarEnum = Car(inputCar)</pre>
</div>
</div>
<div class="paragraph">
<p>把这幅串传进去这个枚举。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>3.if (carEnum == C_NONE){

retrun;

}</pre>
</div>
</div>
<div class="paragraph">
<p>判断传入的字符串是否在枚举中。</p>
</div>
<div class="paragraph">
<p>那现在得到一个枚举，那我要基于这个枚举去创建一个类，那现在假设这个类的已经提前写好了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Class Bus—&gt;BaseCar

Void do()</pre>
</div>
</div>
<div class="paragraph">
<p>首先继承的肯定是有一个公共基础类，那这个公共基础类就是BaseCar，那Bus里面有一个买票的动作，所以这个地方就假设他没有返回值， 然后有一个Void do()，这个我们等一会再具体说是掉什么动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Class Track—&gt;BaseCar

Void do()</pre>
</div>
</div>
<div class="paragraph">
<p>既然有了Bus，那肯定也还有Class Track，他也继承了BaseCar，Track里面也有Void do()。</p>
</div>
<div class="paragraph">
<p>现在我们讲的不叫设计模式，我们是从参数输入来讨论的，但设计模式是根据设计的角度来讨论，这两个是不一样，所以我们现在讲的使用技巧，但是你并不知道为什么或者你知道什么时间用，所以理解层次不用那么深。</p>
</div>
<div class="paragraph">
<p>现在有个问题：怎么从用户输入这个参数去上面说的一个类？意思就是要基于这个枚举，就比如说是Bus枚举，然后怎么去创建Bus类？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Car = CarFactory.getCar(CarEnum)</pre>
</div>
</div>
<div class="paragraph">
<p>那这个地方肯定要得到这个Car，上面Bus和Track都属于Car，那这个地方肯定是有个Car的工厂(CarFactory)，然后把参数传进去，那么这个getcar里面就去做判断，判断你传的是哪种枚举，然后哪种枚举对应的是东西，现在假设我们不知道里面是怎么具体做的，假设他现在得到对应的一个类，那现在就有一个问题：你得到Get返的东西，你肯定不能在这儿直接写个Bus，为什么吗？如果这样写的话，每次用户用一下你就要重启服务器，重新编译代码，你不觉得这样就变成了ATM取钱的时候，里面有小人数钱吗？所以看起来这里肯定不能直接写Bus，那这地方肯定就要写BaseCar。</p>
</div>
<div class="paragraph">
<p>那这个BaseCar其实应该有相同或者类似的方法，打个比方，比如说公交车有买票，那Track一定得有买票，不然的话，然后这个地方调了过后，就会出现这种语法，Car.Do(买票)，但卡车不用买票，你不可能还判断一下方法的名字，为什么？因为前面都是BaseCar，那你的方法名字必须完全一样，玩犊子了，为什么？我们具体讨论一下，他为什么传那个汽车进来？因为他肯定要坐。</p>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>我们现在这个乘客，首先乘客要选择乘坐哪种车，那么乘坐车的时候，公交车和卡车他都可以坐，说白了从更大的角度来说，你是在使用这辆小轿车，那你使用小轿车和使用卡车没有区别，为什么？你既然都做了，而且都有货物，小轿车有行李箱，可以把货物放在后备箱，卡车，你也可以放后备箱，就是放的多一点点，说白了，就像那个挖掘机，你家里面的玩具挖掘机和外面的挖掘机都叫挖掘机，只是挖的东西不一样，但是他们都是挖掘机，体量不同，但实际上对他们动作是一样的，这个地方首先方法应该是一样的，你要先打车，就是Void Cal()，相应的Track(货车)也有个Call，Call先把车叫过来然后就要使用，这个时候你有货物，但货物是不同的，所以使用的方法名字可能是一样的，但是你的货物不同，但不管怎么不同，它都叫货物，就比如说不管是一个行李箱还是一吨铁，它们都是货物，但是他们的体积和容积是不一样的。</p>
</div>
<div class="paragraph">
<p>这样的话，就变成了第二个方法就就是Void Use()，这个时候你要穿个Size，你就根据你的需要的Size去定义它，比如说Size传进去，然后在Bus里面写If Size&gt;500公斤就拒载，这样它就返回值了，说明返回值了Boolen值，你会发现方法名字是一样的，调这个地方是没问题。</p>
</div>
<div class="paragraph">
<p>那么首先你应该是Car.Call()，先叫车，其实还可以更升华一下，不在这儿叫他，可以提前叫，这里无非就是要选择叫那种车，但是我们现在放到这儿也没关系，只是说从这个地方衍生出来的问题而已，所以这种编程技巧会让你写代码越写越舒服。</p>
</div>
<div class="paragraph">
<p>第二件事情就是，你叫到车了，这个时候你要上车，结果司机一看你拉了那么大一箱东西，给你拒载了，所以说叫完车过后就要用车，然后这个时候你要传你带的货物的Size进来，但你会发现现在的URL没有Size参数啊，加上就可以了，那这个地方把Size传进来了，他有一个返回值，那么我们把这段代码总结一下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>BaseCar car = CarFactory.getCar(carEnmu)

car.cal()

Boolen status = car.user(size)

if (status &gt; 80){

print(“886”);

}else{

car.run();

}</pre>
</div>
</div>
<div class="paragraph">
<p>接着上面的讲，刚刚我们说这个Factory里面其实我们是没有写明的，，包括什么时候拒载、什么时候同意也是没有写明的，那先写Factory，那么就有个Class，叫Car Factory：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class CarFactory</pre>
</div>
</div>
<div class="paragraph">
<p>然后这个类里面有getCar方法，刚刚我们调用的时候直接大写的，并没有实力化对象，证明他是个静态方法，所以这地方就写直接写方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public Static BaseCar getCar(CE){

}</pre>
</div>
</div>
<div class="paragraph">
<p>那接下来就判断CE：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>if (ce == EnumBus){

return new Bus();

}

if (ce == EnumTrack){

return new Track();

}</pre>
</div>
</div>
<div class="paragraph">
<p>像这种情况，如果你的这个工厂类很少，这样写其实是可以的，这是第一种情况</p>
</div>
<div class="paragraph">
<p>那么第二种情况，就是假设类型有很多，那么就要写一个查询表，这个地方我们之前是用的枚举，枚举就类似一个查询表，因为他可以用Map代替其中一部分，那都和Map类似了，肯定也类似于查询表，那现在我们肯定就只需直接需要Map了，所以刚刚讲的就是方法一，现在讲方法二，方法二肯定要先构建查询表，这个查询表还是用Static表示，他就表示只初始化一次，那这样的话就是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Static Map&lt;CarEnmu,BaseCar&gt;map ={

{EnumBus,New Bus()},

{EnumTrack,New Track()}

}</pre>
</div>
</div>
<div class="paragraph">
<p>这样就构造了个查询表，因为现在只有两个，如果有更多的就直接加上去，一般情况下有多少个美举，就会有多少个查询表，大不了反个空，但是这只是一般情况，一般情况下他都是空的，就证明你没用，那你写枚举干嘛？你应该真实有这个美举，还有对应的这个类这样的话就可以不用做异常判断的，因为他肯定是存在的，不存在空指针，直接让代码报严重错误，你就不用去管他了，因为这是你自己引起的，所以一般意义上，我并不会去检查我自己的代码，但是用户输入的就必须要检查，你自己写的代码报错了叫Bug，但是外部传进来的，那就叫安全隐患，这两个级别可不一样，所以一般你自己写的代码，就不要去到处检查，不然代码写的贼丑。</p>
</div>
<div class="paragraph">
<p>那接着刚刚的说，这个地方直接就用Map，然后传了个参数CE进来，这个时候肯定是在Map里面去找CE，那这地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>if (map.equer(accesskeyid)){

retrun map.getce

}

throw net Exception (“...”)</pre>
</div>
</div>
<div class="paragraph">
<p>通过这个方式，你唯一要做的就是每一次新加个Key过后，下面都不用动，只需要加查询表，而刚刚if的方法是每一次有新东西，你就要加两行，其实区别不大，但是很明显这种维护性更高一些，而且这个很不容易写Bug，想象一下，你写IF的时候，可能某个地方可能写错，但查询表你不会写错，为什么？因为它是挨着一起的，而且最关键是Map一个Key只能有一个值，如果有两个重复的Key代码就会报错，但是里写错了IF，他也不知道你想表达什么，他就正常通过了，所以这个Map，一个Key对应一个Value，他帮你保证不会重复。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>switch ce:
case EnumBus:
retrun new
....</pre>
</div>
</div>
<div class="paragraph">
<p>还有一种方法就是用Switch，但是你发现和IF没有什么本子区别，都是一样的，只是说语法上更连贯，但是Switch比IF，Switch会提示你，你的枚举里面有五个，但是你case里面只有四个玩意儿，请问是少了吗？</p>
</div>
<div class="paragraph">
<p>那么判断就有这三个版本，那肯定作为我来说，我常用的是查询表，是这样的，如果只有两三个值，而且预判过程当中不会超过十个的时候，我有可能会用Switch，但是那个地方很明显超过了八、九、十个的时候，那肯定就用查询表。</p>
</div>
<div class="paragraph">
<p>所以就看数量的问题，量少用IF，量再多一点点，就用Switch，量很多的时候就用查询表，查询表就相当于对于我来说就是究极绝招，要是特别特别多，那你的需求就有问题了。</p>
</div>
<div class="paragraph">
<p>那为什么不存在数据库？因为这个叫逻辑，存数据库叫存数据，数据是不带逻辑的，只有你使用的场景不同的时候，他才带逻辑，你放数据库里面，得先查出来，查出来后，再把它初始化成一个Map或者列表，那个时候他才是有逻辑的，所以放到数据库里面是一个很致命的问题，你不用的时候，那个数据库都不知道有啥用，等你要用的时候，你都不能确定是不是你想要的东西，载入进来你还要判断，还要做数据检查，为什么?因为这是从外部输入的，而我写的代码里面的好处就是说编译器包括IDEA，他会警告你，所以从数据库动态加载或者是说从URI动态传入，都有一个问题，就是要校验，你要校验你的Key、Value是不是对的，而我写的代码好处就是我不需要校验，只要错了就异常，那个地方一弄就变成了这个上头你要先载入做校验，然后才是下面这些逻辑，所以基本上我不太可能把这种需要逻辑的可选择值放到数据库里，非常非常少，除非为了保证整个业务系统的逻辑连贯性才会放，但是如果放到这边比数据库好，那肯定选这边，对于你来说，无脑放这就可以了，数据库少用，要是某天数据库宕机了，没东西了，那就是严重的致命错误，Java内部不容易出问题了，但是用数据库就涉及到第三方调用了。</p>
</div>
<div class="paragraph">
<p>那现在你知道这个Getcar怎么来的，就是构建查询表，只是查询表写的时候，选择用哈西表还是用Switch或者IF，你发现他们逻辑都是一样的，就相当于你先构造了一个表，你传了个值进来，然后问这个表然后又出去，这逻辑像不像人工智能？人工智能基本就神经元，进去一个东西，出来个东西，出来是啥，反正你也不关心，现在我们来解决什么时候拒载，什么时候同意的问题</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_拒载同意">19.7. 拒载？同意？</h3>
<div class="sect3">
<h4 id="_bus">19.7.1. BUS</h4>
<div class="paragraph">
<p>这个地方有两种选择，像之前讲的那种情况，可以理解为一个基础类，然后基础类有个好处，它是可以放内成员和内成员函数的，说白了就是可以有属性和函数两种东西，你也可以说，这里不是继承关系，而是是实现关系，就是这个写的是一种接口Interface，Java里面interface永远都是Public的，Interface里是不允许出现成员变量的，那么就意味着如果你要用的类似于变量成员的时候，你就不能用接口了，所以这个地方我一般都会写一Interface，然后如果出现了需要用到内成员的情况，我就会把这Interface换Class，然后写成继承关系，这个以后讲Java基础语法和逻辑会讲，现在只是提一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Interface BaseCar:
void call()
boolean use(size)</pre>
</div>
</div>
<div class="paragraph">
<p>那这个地方我就先写成Interface，这个Interface要有两个接口，一个没有返回值的，就是叫车，然后一个是boolean，就是用车:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class Bus extand BaseCar

class Track extand BaseCar</pre>
</div>
</div>
<div class="paragraph">
<p>然后还有两个类，那个叫车就不写了，没啥意义，反正就是都会到，不到就不到噻，就把这个返回值改成boolean-叫车失败，但那个逻辑没有参考性，但是Use方法是有参考性的，叫车就只占个位置放在那就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class Bus extand BaseCar

void call()

boolean user(size)</pre>
</div>
</div>
<div class="paragraph">
<p>比如说现在是Bus公交车，那个公交车上的乘车乘客守则上写了的一个人就是携带的物体啊按体积算的大概应该是一平方，就比如你背一个箩筐，那肯定是不行的，但拉杆箱是可以的，他是按照体积来算的，这里我们就按公斤数来算，比如说公交车的上限是120公斤，那么这个地方我肯定要写一个静态的最大值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static int maxsize = 120

然后他进的第一件事就是判断：
boolean user(size)

IF(size &gt; maxsize){
retrun false
}

...

....

retrun</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_track">19.7.2. Track</h4>
<div class="listingblock">
<div class="content">
<pre>class Track extand BaseCar

static int maxsize;

void call();

boolean user(size);

IF(size &gt; maxsize){
retrun false
}

...

....

retrun</pre>
</div>
</div>
<div class="paragraph">
<p>这里就是两种逻辑，而且你会发现他两个都用到了Maxsize，那就可以把这两个提到父类哪里，声明一个最大Size，虽然父类不知道Size是多少，但其实都是一样的。</p>
</div>
<div class="paragraph">
<p>这样写是没问题的，就看你的洁癖程度到哪种程度，你的优雅程度越高，你会越往上提，然后你会发现代码就变多了也变复杂了，这样的话，新手能看懂，但是往上一提，新手就看不懂了，所以你发现我这样一个逻辑可以实现无数种分支，然后不管是叫车还是用车，他都可以在一套大逻辑下面，就是经典描述工厂模式意思就是都在造车，然后造车都要经过提炼石油、制造赵轮胎、然后生产线，这样大体步骤都一样，只不过实现细节不同，那在造东西的时候，你就适合用这个，你会发现大体步骤都一样，都是用车，你不管的是货拉拉、滴滴还是T3，你说你得叫车吧，叫了车后，车要找到乘客定位，再到达指定地点等待乘客，然后司机发现这个乘客手上是拿了一只毛笔，还是拿了一吨铁力管它的呢，然后这个时候你都没有看到乘客，肯定没有办法拒载，但是当人数超载或者货物超载了，那么他就有可能拒载，那么就是IF(同意)，那么乘客上车走，IF(不同意)就点拒绝，然后走，只是走的时候乘客在不在上面而已。</p>
</div>
<div class="paragraph">
<p>所以大体逻辑是一样的情况下，你就可以用这种布局或者说是这种套路，任何软件系统、编程语言都是一样的，只是说语法的问题，这就是编程的魅力，只要理解了思路就好了，语法问题真的不是大问题，因为语法你总有一天会学会，但是编程思路错了，那任何编程语言都救不了你。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_代码实现">19.8. 代码实现</h3>
<div class="paragraph">
<p>查询表、工厂模式一用，然后各个地方组合，函数一封装，可能就没有IF else了，所以IF多就是因为没有设计，没有设计的代码就不要给我提多少IF的问题了，为什么？因为你不配，因为你就算把IF解决了，该有问题还是有问题，比如说他放到Map里面，但没有判断Key，然后就直接用，这样就有可能空值，当然反正都是异常报错，那万一那个地方是三数据库结果呢？空的时候也删，不空的时候也删，所以就等于说你的编程是有危害的，会对系统产生危害，产生危害就可能就处于不可控的状态了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设计校验步骤">19.9. 设计校验步骤</h3>
<div class="paragraph">
<p>那这个地方参数校验我们先写个URL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost/greeting?AccessKeyId=123&amp;SignMethod=SHA1&amp;SignNoce=4567&amp;Timestamp=145789&amp;Signture=abcd</pre>
</div>
</div>
<div class="paragraph">
<p>我们先看一下这五个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.AccessKeyId

2.SignMethod

3.SignNoce

4.Timestamp

5.Signture</pre>
</div>
</div>
<div class="sect3">
<h4 id="_accesskeyid">19.9.1. AccessKeyId</h4>
<div class="paragraph">
<p>然后看看这些参数你看要做哪些校验，就先拿AccessKeyId举例：</p>
</div>
<div class="paragraph">
<p>1.要验证他是否存在。</p>
</div>
<div class="paragraph">
<p>2.要验证它的长度。</p>
</div>
<div class="paragraph">
<p>就像这里KeyId一定是固定长度的，固定长度的随机字符串是有限定条件的，所以你要对长度进行教研。
3.格式校验</p>
</div>
<div class="paragraph">
<p>KeyId应该涉及到的是字母、数字、没有下划线，啥都没有。</p>
</div>
<div class="paragraph">
<p>这里长度和格式是两回事，平时表达的时候，你说他的长度多少，但是我们一般会把他两强行分开，格式是格式，长度是长度，这只是对AccessKeyId涉及到的三种情况，可能还有其他的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_signmethod">19.9.2. SignMethod</h4>
<div class="paragraph">
<p>第二个SignMethod肯定是在对枚举进行教验，但是他又涉及到是否存在，长度就不用管了，因为如果没有匹配到枚举就会直接报错，所以就是是否存在，然后转成枚举校验。</p>
</div>
</div>
<div class="sect3">
<h4 id="_signnoce">19.9.3. SignNoce</h4>
<div class="paragraph">
<p>随机数是这样的，首先我们要判断下他如果传个1传个2可不可以？不可以，因为1和2没有足够的复杂度，你本来就是因为安全才加入随机数的，结果就放个1、2、3过来，那谁都能猜，所以说这个时候啊应该要求五位数以上的，说白了就是应该有个取值范围，比如说这个取值范围可以是1000那么到9999，肯定是在某个区间，而且区间直接把简单的排除掉了，所以那这个地方看起来就是：</p>
</div>
<div class="paragraph">
<p>1.存不存在。</p>
</div>
<div class="paragraph">
<p>2.转成INT过后他的取值范围是多少。</p>
</div>
</div>
<div class="sect3">
<h4 id="_timestep">19.9.4. Timestep</h4>
<div class="paragraph">
<p>Timestep肯定的是能转成Java时间对象，转了过后，如果不是一个正确的时间格式，他会报错，比如说他转了后刚好等于1970年1月1号00时00点，那肯定就转失败了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_signtrue">19.9.5. Signtrue</h4>
<div class="paragraph">
<p>那这个Signtrue肯定是有长度的，为什么？你的签名方法是固定的，但是在你穿参数的时候，你并不知道那个256是长度，所以你应该是校验最小长度，SHA1生成的这个Signtrue可能有20位，SHA512生成估计就是30位，所以是校验最小长度和最大长度的区间。</p>
</div>
<div class="paragraph">
<p>所以就光这五个参数的接收，事可多了，这种参数校验纯用IF都能做，但是想一下这样做的话，你的Controller肯定特别特别长，全是IF Else，而且很麻烦，最关键是以后加参数，你还得改，改的时候，指不定会出现问题，人脑是不可靠的，要假设你一定会出问题，所以你就要让你的逻辑统一。</p>
</div>
</div>
<div class="sect3">
<h4 id="_什么叫逻辑统一">19.9.6. 什么叫逻辑统一？</h4>
<div class="paragraph">
<p>就是处理一个参数的时候，用的一个方法，处理十个参数的时候，也是用的那个方法，只是说处理的时候细节不一样，就像我们刚刚用那个轿车里面的用车一样，用车的时候细节是不同的，而参数校验无非就是存不存在、有没有长度要求、有没有范围要求，而长度要求、范围要求是属于校验里面的一个小步骤，所以我们现在就把这个总结出来。</p>
</div>
</div>
<div class="sect3">
<h4 id="_总结_3">19.9.7. 总结</h4>
<div class="paragraph">
<p>1.是否存在参数。</p>
</div>
<div class="paragraph">
<p>2.有无长度要求。</p>
</div>
<div class="paragraph">
<p>3.有无格式要求。</p>
</div>
<div class="paragraph">
<p>4.是否是有效值。
有效值里包括校验类型和取值范围</p>
</div>
<hr>
<div class="paragraph">
<p>参数教验事可多了，你脑子里面是这么想的吗？你脑子里面就想着参数传进去，能用就可以了，同样是写代码，为什么你的质量那么差，我的质量那么高，就是因为我考虑的比你多，我一定会用最坏的情况，脑子里想着假设有人来攻击我，我要怎么做到天衣无缝，至少在不用暴力把我压垮的情况下，数据类型上面是对的，你把服务器攻破了那是服务器的问题，和代码没有关系，只是问题关系不大哈啊，所以那这个地方就看起来，在做参数教验的时候，你要满足这些条件。</p>
</div>
<div class="paragraph">
<p>现在我们挨个走一遍：</p>
</div>
<div class="paragraph">
<p>1.AccessKeyId</p>
</div>
<div class="paragraph">
<p>校验：1.是否存在2.长度要求3.固定长度的4.格式要求</p>
</div>
<div class="paragraph">
<p>AccessKeyId有效值校验是在数据库里。</p>
</div>
<div class="paragraph">
<p>这个地方我们讲的是HTTP接收校验，意思就是说不能查数据库，我们现在的层次是HTTP接收，数据库有没有效我们不管，我们只需要保证前面的。</p>
</div>
<hr>
<div class="paragraph">
<p>2.SignMethod</p>
</div>
<div class="paragraph">
<p>校验：1.是否存在2.长度要求3.校验是否存在奇怪的字符4.取值有效范围就用枚举实现</p>
</div>
<hr>
<div class="paragraph">
<p>3.SignNoce
校验：1.是否存在2.长度要求3.必须由数字组成</p>
</div>
<hr>
<div class="paragraph">
<p>4.TimeStamp
校验：1.是否存在2.不能小于今天3.必须由数字组成4.转换出来是不是有效的Java时间对象，然后判断一下比当前时间是否相差至少15秒。</p>
</div>
<div class="paragraph">
<p>但是这个15秒属于接受校验，因为如果超过了15秒就属于错误的URL
但是上面那个AccessKeyId就不属于接收校验了，因为要查数据库，它属于深度的业务教业，判断用户名是否存在。</p>
</div>
<hr>
<div class="paragraph">
<p>5.Signtrue
校验：1.是否存在2.长度要求3.校验是否存在奇怪的字符4.校验接收的和生成的是否一致</p>
</div>
<hr>
<div class="paragraph">
<p>所以你只要TimeStamp那个能理解,那Signtrue也能理解，但是有个问题:你要验证Signtrue之前你要先验证AccessKeyId，套娃就套起来了，但AccessKeyId要查数据库，所以在做纯接收的时候，你做不了Signtrue的校验。</p>
</div>
<div class="paragraph">
<p>所以校验分两种，包括刚刚说的那个15秒，上面常见的存在/长度/格式/是否有效这些东西叫值校验，意思就是基于字符串本身做校验，那刚刚还提到了一种更深度的校验，就是逻辑校验（业务/功能）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_逻辑校验">19.10. 逻辑校验</h3>
<div class="sect3">
<h4 id="_数据库查询类">19.10.1. 数据库查询类</h4>
<div class="paragraph">
<p>我们这个地方讲的是API，肯定就不是业务，讲的是功能，那刚刚有几个不确定的校验，第一个就是AccessKeyId，那包括的就是第一种数据库查询类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_有效时间校验">19.10.2. 有效时间校验</h4>
<div class="paragraph">
<p>然后第二种是刚刚那个15秒，其实15秒划给值校验也是可以的，因为他也是属于校验URL是否有效，如果把他强行分成值校验和逻辑校验，他肯定是属于逻辑教研，说白了就是自变量：长度/格式/是否存在这些是属于值的，比如说数字，也属于值，因为那是写死固定的，但是动态的，比如这个15秒是你可以改的，因为它和URL没有关系了，所以说15秒的情况可以总结为有效时间校验，属于逻辑校验的一种。</p>
</div>
</div>
<div class="sect3">
<h4 id="_综合判断">19.10.3. 综合判断</h4>
<div class="paragraph">
<p>第三种情况叫综合判断。</p>
</div>
<hr>
<div class="paragraph">
<p>所以参数校验严格意义上分成两类，我在写代码的时候，我也会把它分成两类，但逻辑校验可能隐藏在某些代码里头，和值校验没有关系，逻辑校验是一定要做的，说白了一个再差的程序员都会做其中一部分，反而值校验是优秀的程序员才做的，因为值校验不管做不做都不会对交互产生影响，但是逻辑校验不做的话就会产生很大的错误，而且值校验对系统没有危害，为什么？你看不出来，逻辑校验就直接系统不按预期工作，就是Bug，软件测试都能测出来，但我没有见过几个专业的软件测试测值校验，不要太相信那些测试，他们一天就点来点去，如果你不要求他，是不会测值校验的。</p>
</div>
<div class="paragraph">
<p>那这两个校验怎么实现呢？是这样的，做这个校验，工作量真的很大，你每次加个参数可能要加很多个类，相反比起IF，是个程序员，都会选IF，但是IF有一个致命的问题，就是你的逻辑每次都是散的，为什么？我们刚刚讲了五个参数，他的校验方式都是不一样的，对长度的要求，还有对有效值的判断，那个代码写法是不一样的，这样就会导致什么看起来都是IF/ELSE，代码里面怪怪的，为什么？每个IF东西都不一样，如果全部都是长度判断就贼简单了。</p>
</div>
<div class="paragraph">
<p>那么首先你要从大逻辑上解决这个问题，做参数教验大的逻辑是什么？既然叫参数教验，肯定针对的是参数个体，为什么？你校验的时候是一个一个校验的，所以说肯定是基于参数个体挨个校验，至于这个调教验要分几类，管他的呢，挨个都校验，只是这个校验函数是空的，永远返回true，但是步骤是摆在那的，那这样的话是是所有参数步骤都是一样的，那是不是就可以写成刚才的工厂模式了，这个和刚才叫车是一样的步骤，这里参数校验步骤都统一出来了，但是函数里面细节不同，策略模式以后再说，现在太早了，策略模式和这个不一样，这个地方你要先创建校验的对象，有了校验对象过后剩下的才是其他模式，而工厂模式是专门用来生成对象。</p>
</div>
<div class="paragraph">
<p>所以这个地方的我针对的的重点是：校验参数个体，那既然是个体，就应该每个参数对应一个类，就是那个参数类，那你现在有个疑问：就一个参数，至于搞个类弄他吗？不觉得好麻烦吗？写个代码还要去分析这些。</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>假如你代码写完了，那请问你的代码拿到别人的电脑上能工作吗？那我的代码为什么能拿到你电脑上的工作？那是因为定义Java的版本，Maven的版本/动作所有都的统一了，然后使用方法就在单元测试里面。</p>
</div>
<div class="paragraph">
<p>所以至不至于这么做的目的前提条件是你的软件项目能生存多久，如果软件只跑三天就删了，就不要搞这个，要是你要跑三年，而且你的代码是团队协作的话，请你搞这个，如果你的代码永远只有你一个人用，不要用这个，所以说，现在是在提高你的上限，至于下限多低，看情况。</p>
</div>
<div class="paragraph">
<p>那我先用AccessKeyId来举例，我们现在在写一个叫Accesskidparam这个类就表示参数的意思，然后我的构造参数，接收的是那个支付串，说白了Java帮你接收了总的参数，所以这个东西啊，一定不是只接受一个参数。</p>
</div>
<div class="paragraph">
<p>那这个类的全称就是AccessKeyIdParamChecker，Checker就表示验证器，那参数教验他的初始化参数就应该接收那个字符串，因为那个Java接收的都是的是字符串，当然你也可以接受Int，记住：如果我们要用自己的报错，那个Java接收的对象的所有类型必须是字符串，如果你声明成数字的话，他不仅不传数字还会报400错误，这样用户就看不到你错误了。</p>
</div>
<div class="paragraph">
<p>接着往下走，他的构造函数就写出来了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AccessKeyIdParamChecker(String s)</pre>
</div>
</div>
<div class="paragraph">
<p>具体实现就不管他了，你肯定要去接受一个参数，然后肯定还有个l类成员去把这个参数保存下来，那这个地方就应该有一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>String value;</pre>
</div>
</div>
<div class="paragraph">
<p>默认是这样的。</p>
</div>
<div class="paragraph">
<p>然后把这个代码写完：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>value = s；</pre>
</div>
</div>
<div class="paragraph">
<p>这样就保持下来了。</p>
</div>
<div class="paragraph">
<p>那上面的写完后，还要写方法：</p>
</div>
<div class="paragraph">
<p>1.是否存在
数据库查询类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Void exists（）{

}</pre>
</div>
</div>
<div class="paragraph">
<p>代码里面的逻辑我就不写了，我觉得里面的东西每个都不一样，没法挨个写，就说白了你要判断这个value是不是等于空指针或者空字符串，如果等于那就认为不存在。</p>
</div>
<div class="paragraph">
<p>2.是否长度要求</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Vodi checkLength（）{

}</pre>
</div>
</div>
<div class="paragraph">
<p>3.校验格式</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Void checkFormat（）{

}</pre>
</div>
</div>
<div class="paragraph">
<p>4.校验有效值</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Void checkValue(){

}</pre>
</div>
</div>
<div class="paragraph">
<p>那么不管是校验类型，取值范围都是在这里面做的，那如果你有n个这个类，这个时候你怎么去调它？然后怎么结合起来，现在是用那个Spring Boot接收了一个完整的对象，里面包含了所有的参数列表，就相对来说每一个参数列表都要调用上面那个校验器。</p>
</div>
<div class="paragraph">
<p>我们就先按这个记流水账的方式写，那相当于是说要初始化校验器，简称校验器为Checker：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Checker a = CheckerFactory.setcherk()</pre>
</div>
</div>
<div class="paragraph">
<p>那么传过来过后，你要怎么调呢:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a.exists（）

a.checkLength（）

a.checkFormat（）

a.checkValue（）</pre>
</div>
</div>
<div class="paragraph">
<p>现在有个问题，我没有把那个返回值用起来，因为这个地方，如果全部反布尔值看起来有问题，为什么？因为IF判断布尔值贼麻烦，这个时候就直接抛出异常，然后在外面捕获，这样更简单暴力。</p>
</div>
<div class="paragraph">
<p>然后这个地方我就写一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Catch (Exception e){
    return ....
}</pre>
</div>
</div>
<div class="paragraph">
<p>这里面的message随便写，就是提示用户说你参数少了，其他都是一样的，然后在调用它的地方用Try框起来，然后我就往下写，这是一个参数校验的逻辑，第二个参数检查跟他是一样的，只是在这个地方构造的时候，看起来可以用工厂模式，跟刚才一样，这地方是个Factory返回一个校验器，校验器把提成interface的方法，那调用他的就是个interface，而这个工厂返回interface去包住这段代码，那这个地方应该实现某个接口，有切克的接口嘛继承接切克嘛可不可以啊那这地方就是切克切克a等于什么切克工厂
然后就这个时候，工厂里头有一个get，我就直接写get切克啊括号码参数然后最后你既然这段代码你是解决了一个，但个体那你下面只需要写一个或循环参数列表吗或循环什么lenglish这个历史的就是参数列表上啊，这是个体嘛然后就个体就相当于是说把这个代码写到这里，回来，你哪怕有无数个参数，你只需要加什么加factor里面那个查询表你发现没有这个，这个代码已经不是新手代码了早上我都还是存新手到了现在已经不得不能要了就是看懂一点点啊，参数教练我就讲完了</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_SJKYL2_chapter">20. 数据库原理（二）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_19">20.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/数据库原理(二)板书1.jpg" alt="数据库原理(二)板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数据库原理二">20.2. 数据库原理（二）</h3>
<div class="paragraph">
<p>数据库不是个孤立的东西,之所以为什么数据库在国内至少到现在为止，没有一个大家主流接受的一个公司或者一个人能做出来，是因为数据库跨了存储文件存储系统、网络IO、操作系统甚至有些做得极客的地方还会针对cpu或者操作系统做优化，最关键的是，它里面有非常非常多的算法，什么意思？比如你写一个查询，每次稳定到200秒输出结果，这非常ok，但是你要把200秒提升到0.2毫秒。这个就已经是跨数学了，可能会用到很多数学知识,这完全就不是人干的事了，只有大神才能Hold住，说白了谁发明的操作系统的，谁就能写数据库，是这样的，去看那些做数据库的人，他们很多都是做操作系统出生的，所以数据库不是一个孤立的东西，在你学习的时候，不要想着把MySQL所有东西都学完，就只学你要的那部分，学你关心的那部分，就比如说数据库是怎么解决网络收发的问题，你关心那个干嘛？难道数据库只能用网络收发，就不能用Socket通信了？只不过用Socket就只能在本地，然后再就加一个Nginx基于Socket做个反带，我就问你，我可以给予80端口查数据库吗？那那个网络也不是必须的嘛。</p>
</div>
<div class="paragraph">
<p>那第一点是什么？刚讲了那么多，我们通过举例子来，就不那么文绉绉的，就是由一个问题引发出后面一系列的问题：</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Select * from table;</pre>
</div>
</div>
<div class="paragraph">
<p>执行这个查询后肯定会返回一些东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0.2S
100000 rows</pre>
</div>
</div>
<div class="paragraph">
<p>那这100000行，用了0.2秒，那请问可以把它速度再往上提吗？前提是什么？第一个你要知道你需要查那些列，这个时候你就会优化这个SQL里的*：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Select id from table;</pre>
</div>
</div>
<div class="paragraph">
<p>那假设现在这一个语句从0.2秒变成了0.095秒，可能还是有100000条,那还能继续做优化吗？优化可以限制查询的数量或者加一个索引，那问题来了：为什么限制数量过后它会快？为什么只查和不限制一个慢一个快？我们忽略掉MySQL打印那么多东西要花的时间，就假设在MySQL里面，内部处理时间等于零，那你查询100万条和10万条，为什么10万条快？想过没有？可能会说10万条明显数据少一些，所以这里面就涉及到文件IO了。</p>
</div>
<div class="paragraph">
<p>所以这个地方做优化有两个手段，第一个：索引，第二个：限制数量，其实你会发现这两种优化手段的角度是不一样的，但是我们现在不讨论什么是索引，我们现在就假设你已经知道什么叫索引，那第二个刚刚说的数量其实是解决了一个文件IO的问题，那什么叫i，o啊？全称是Input、Output，这个地方的文件IO指的是FileSystem Input、Output,说白了就是他最终会找导致硬盘去读东西，所以如果孤立出现I、O，我们一般指的是硬盘，但是如果出现在嵌入式中，那个I、O一般指的是串口，就比如显示器后面有个口子，插上去，这就叫I、O，所以I、O出现的位置、场景不一样，对应的含义也是不同的，看起来就是通过减少文件读写或者说是减少文件I、O的消耗。</p>
</div>
<div class="paragraph">
<p>那索引呢？上面是减少数量，最开始读10万条优化后读1万条，就已经影响到结果了，而索引其实不影响结果，可能大家脑子里有这个意思，那我们现在把这个范围扩大一下，你不要限制在你杯子上面，我就问你一个问题，看起来你说的是Hash表结构，那MySQL里面肯定没有HashMap，肯定是没有Java那套，他也不大可能说在内存里面写个Hash表，这一重启索引就失效了，不可能吧？那现在我假设他有一张Hash表，那这张哈西表在哪？我们就来推啊，现在我直接告诉你他在硬盘上，那在硬盘的哪个地方？问你个问题吗？加了索引之后是不是可以通过Show index查出来，我就这么跟你讲如果你不会Linux，那今天这节课我没法上，就是现在我假装大家都会Linux，假装大家都知道文件系统，比如NTFX，Xfs，假装大家都知道，如果这些技术条件你不知道的话，我这个地方没法讲。</p>
</div>
<div class="paragraph">
<p>那我们就开始用推论的方式来推，因为这个我也没有仔细去想过，我只是突发奇想举个例子：首先我刚讲过我用了SQL基本上就能猜到后面，我们现在通过索引也是一样的，索引是create index，数据表来也是create table，查数据表表是select，索引是Show indax，看起来Show index是查的具体索引的内容，那看起应该有个玩意可以把所有索引查出来，不然我Show indax在哪去找的，这样你就会发现那个表的使用跟那个索引，虽然他们亮东西不一样，但是你会发现，他们对于MySQL的操作入口是一样的，可能对用户来说是不一样的，但对MySQL来说看起来是一样，你要是不信就直接监控你的硬盘，你如果查index的时候他肯定消耗I、O。所以你的索引、索引数据就是那个索引的名称、哪两列，它是你保存在MySQL里头，他首先不是保存配置文件，我就直接不卖关子告诉你，索引是保存在他的存储引擎里面的，你的数据库的表在哪，你的行的记录在哪个地方，索引就保存在这个位置，所以要回答什么是索引，只要回答完这个问题，基本上MySQL原理，我们就讲完了，为什么？因为回答这个问题，首先要讲存储引擎，我要讲出自引擎，然后再讲Linux文件I、O，然后还要讲了在存储引擎里面是怎么去存数据的，MySQL的数据是怎么存的，表数据是怎么存的，索引怎么存的，因为你都讲存储引擎了这些能不讲吗？但如果脱离操作系统单独来讲存储引擎，得写100篇论文，毫无疑问，但是今天我们不是论文比武大赛，我们是想搞明白，所以这个过程当中，我们就从多维度来观察同一个东西。</p>
</div>
<div class="paragraph">
<p>所以这个地方索引，他英文叫index，是他创建语句是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Create index ....</pre>
</div>
</div>
<div class="paragraph">
<p>然后查询单个索引的话是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Show index ...</pre>
</div>
</div>
<div class="paragraph">
<p>语法就不具体写了，巧的是，数据表也在用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Create table ....</pre>
</div>
</div>
<div class="paragraph">
<p>查询表也是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Select ......</pre>
</div>
</div>
<div class="paragraph">
<p>这样你会发现在MySQL，他把这个封装成差不多的操作方式，肯定就是为了你方便，那我问你个问题，他用一样的操作方式，很大可能性他的存储的结构是一样的，首先我们在讲索引之前你得先把表是怎么存在讲明白，所以你得先明白什么叫存储引擎，表是存在存储引擎里面的，所以这个就是第一个啊就是二啊。</p>
</div>
</div>
<div class="sect2">
<h3 id="_什么是存储引擎">20.3. 什么是存储引擎</h3>
<div class="paragraph">
<p>首先为了方便，我就把存储引擎简写为EG,那之前我们确定的事情是：1.数据表是存在存储引擎里的，存储引擎相对于文件系统来说是一个“大文件”。那还有什么？，索引和表也是一样存在存储引擎里，那现在就有人问了这个EG是个啥？这个其实很简单：</p>
</div>
<div class="paragraph">
<p><code>存储引擎相对于文件系统来说是一个“大文件”。</code></p>
</div>
<div class="paragraph">
<p>这里的文件系统肯定指的就是说可以是Xfs或者NTFS，相对来说，它是个大文件，大文件平时在Windows最大文件可能是某些电影，4K的可能有40个G，其实这里和大文件和那个电影本质上大致是一样的。</p>
</div>
<div class="sect3">
<h4 id="_视频播放器">20.3.1. 视频播放器</h4>
<div class="paragraph">
<p>这里建立概念了，接下来谁告诉我MP4或者MKV或者是AVI这些文件的播放器干了啥，首先你怎么看电影的？双击视频文件，这时如果你的文件很大，它就会有个读取的过程，那在这个过程中读取的是什么数据?那肯定是读取他自己的内容，为什么举这个例子？因为刚才有人跟我说顺序读写，难不成你还能跳着读？你的播放电影还能跳着播？就你不要说什么顺不顺了，说白了就是用户想看哪个位置拖进度条就行了，那数据库可以拖吗？数据库有进度条吗？但数据库 有记录行数，简单说一下播放器怎么播放电影的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.双击。

2.播放器自动去打开文件。

3.打开过后会调操作系统的Read函数。</pre>
</div>
</div>
<div class="paragraph">
<p>他的open的时候，肯定加了文件参数再加个“R”，意思就是只读嘛，并不是说放一次就坏了，你以为你是dvd，还加了点灰尘啊。</p>
</div>
<div class="paragraph">
<p>如果播放器发现文件很大的话，双击过后那个播放器就会在转，它还在等，等什么？在等你的电影文件从硬盘上加载到浏览器播放器里，看起来这个播放器他肯定不是加载40个G，你的电脑那个内存一共才八个g，要加载40个G是什么概念？，所以播放器绝对不是那么傻，播放器肯定是只加载一部分，比如说他每一次加载的时候加载20秒或30秒的文件就可以了，那他是怎么知道是20秒还是30秒？假设是MP4文件，播放器就知道应该读多少帧，因为MP4是按帧数来的，比如读1000帧，那就是啪啪啪啪啪读了过后播放器就把那第1000帧解码成画面，因为你知道的有些播放器不带解码器，你发现播不了，但你装个MP4、MP3的解码器他就能播了，说白了读文件是先读后面才解码，所以他读的那个固定长度可能是有一个大家约定的这么一个缓冲区，可能是两兆，也可能是二十兆，但是他一定不是按帧来的，因为播放器缺少解码器的时候，播放器其实已经打开文件了，而且你发现他要读文件，他肯定要读一点点，然后再把这东西传给解码器解码，解码器解码了过后解不出东西，挨个试都解不出来，然后就报错。</p>
</div>
<div class="paragraph">
<p>所以播放器其实很简单，那个说明解码器很值钱，所以你要是发明了MP5标准,然后卖给那些人或者开源，你就挣钱了，大家都用你的标准。</p>
</div>
</div>
<div class="sect3">
<h4 id="_存储引擎">20.3.2. 存储引擎</h4>
<div class="paragraph">
<p>播放器搞懂了，我们再回头看存储引擎，既然播放器和存储引擎在保存形式上面都是一个大文件，那这个存储引擎的文件和电影文件有什么区别？刚刚说了电影文件是通过编码器解码器，它有编码，巧了，存储引擎也有编码，这个世界就是这么怪，你只要懂了协议啥都懂了，之前我们说协议就类似一本说明书，那MP4如果没有说明书的话播放器能播吗？不能，所以那个解码器里面实现的是说明书上的功能，翻译，就相对说播放器自己是不带说明书的，他需要有一个人帮他按照说明书把它翻译成他那个播放器能懂的画面，说白了，你在做格式转换，转换成播放器认识的，播放器只认识0101,那为什么要带编码，不直接保存0101呢？因为编码可以压缩，这么做就是为了省空间，要是空间无限大谁还发明MP4格式,直接存，比如说那个相机单反你拍过有raw原始格式，原始格式随便怎么放大，它没有失真的,但是你用JPG导出来一放大,那个像素点就出来了。但是你用png机会好很多，因为PNG太差了，压不了，为什么？因为PNG他说自己是不失真但是又带那么一点点压缩，但是jpg是全损压缩，是真压缩，是对图片做了处理的，而PNG他还要带那个透明图层，他是有很多其他的东西的，说明他做的工作挺少的，协议各有各的特点，你一旦懂了格式这玩意儿,其他就很好理解。</p>
</div>
<div class="paragraph">
<p>同样的，协议也是一种格式，然后这个地方是MP4格式，然后存储引擎也是有格式的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_格式">20.3.3. 格式</h4>
<div class="paragraph">
<p>那讲到格式了，这地方有MP4,MP3，还有AVI，假设不一定是电影嘛，那我现在问那个问题：为什么不讲MKV？因为MKV还可以再压，MKV是在这个外面再压了一层，压缩的压缩，但是AVI是不带压缩的，比较原始，是第一层，但是RMVB那个玩意儿压的也挺厉害的，所以AVI你会发现文件很大，MP4的话大概容量小一半,但是你发现更有意思的同样是MP4格式，有些是用H265压缩的，你会发现本来是1.9个G，用了H265大概就是一半,更夸张，然后你会发现那个MKV在外面在包了一层，你不管MKV做了啥，他包了一层，看起来不仅仅是压缩或者没有压缩的，但是你想为什么他不用MP4要弄成MKV那肯定是有原因的。</p>
</div>
<div class="paragraph">
<p>那既然视频文件有格式，那其实存储引擎也有格式，如果MySQL举例的话，当前大家在用的格式叫innerdb，以前叫myisam，这玩意儿就是个垃圾啊，不支持事物，不支持存储过程，还锁表，然后innerdb肯定是解决了这些问题，所以MySQL被更多人接受，他有两个阶段，没有数据库，能够在PHP里面读，当时PHP那么流行，要个数据库配合，刚好PHP无缝用MySQL，大家用它，最后发现很多问题，没有事物，没有很多东西，这个时候就只能在PHP里面用，但是MySQL自从用了innerdb后，更多的人接受他了，太简单了，有典型的数据库的事物、存储过程、锁行，而且性能肯定也是有提升的，还有索引，说白了就是各种都有提升，那么用Java也可以用MySQL了，相信在那个之前用Java的人还是会说要不用Orcle或者PostgresSQL，MySQL应该就没有那么流行，所以他分成两个阶段，一个是电商流行的时候，然后第二个就是电商热已经过了，Java火的时候，那么MySQL份额应该会更大，但是如果他还是用myisam，我相信会更少人用,也不是说没有人用，会更少。</p>
</div>
<div class="paragraph">
<p>所以在这个地方，电影有格式，那我们的存储引擎也是有格式的，那现在这个存储引擎是什么？我们开始下定义了，存储过程就是：</p>
</div>
<div class="paragraph">
<p>一种用数据库存储格式保存的大文件。</p>
</div>
<div class="paragraph">
<p>这个地方保存的意思就是那个内容里头就是有编码，就非常明确了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_存储格式">20.4. 存储格式</h3>
<div class="paragraph">
<p>刚才电影的存储格式是MP4,存储引擎的存储格式看起来就有inner db。</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>假如我是发明MP4那个人,我们就把那个电影文件展开讲，比如说哈这个地方是一个MP4文件:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/MP4.png" alt="MP4">
</div>
</div>
<div class="paragraph">
<p>在这个前头位置，你要写上我是MP4，然后用的是MP4的h256编码做的，还要告诉别人这个文件的总大小，比如说是100个字节，不然的话，你那个电影文件可能觉得屁股空白后面去了，用这种套路，最终他在后面就会填，比如这里我就用0101表示，有100个字节，之所以它为什么在开头写上这个总字节数，是因为万一这个文件屁股后面多了两字节，他可以说：“对不起，MP4文件播放错误。”好巧，你用BT下载的时候，很多时候都会出这种错误，多了两个字节，少两个字节就放不了，但这个时候你可以用vlc强行放，但是有时候拖进度条会报错，为什么？因为你的字节数不对，你拖的时候，他可能有些地方要按百分比算位置，结果拖两下他就迷路了，为什么？因为你少了两个楼梯。</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>你走楼梯走着走着少两阶，我就问你你摔跟斗吗？你100%摔？都不用讲为什么，因为你的脚已形成条件反射了，找楼梯每次用力要均匀，你一脚跨下去突然少两节，你1000%当场摔地上，还有一种情况就是，和这楼梯相关，和数据库没有关系，走楼梯的那个台阶突然从五厘米变成了七厘米，很多人踢脚背，就撞地上去了，摔在那个地方也是摔,只是一个朝下一个朝上，有个视频怎么样，那个台阶我就不说了，台阶故意高了1节，你说矮了一节就算了，是这样的，你从下面往上走，他高了一节，你是踢到那个地方往前倾，结果你跨下去，他突然高了一节，一样的你从上面往下走，你会发现你踩的时候，踩空，为什么？因为你的预判是五厘米，你的脚用力的时候是用在五厘米那个位置的，结果一脚踩空，而刚好那个人又挺坏的，前面有个限高杆，所有人的撞上去，为什么？因为大家都喜欢看手机，可香了。</p>
</div>
<div class="paragraph">
<p>那又回到这个地方，所以他一定会在头的前一行或者头的固定字节用这个套路，用这个套路地方很多，打个比方有没有人装过Windos系统，装过Windos就有个索引mbr,有时候Windos起不起来，到了黑区区的窗口那个地方,因为在你的硬盘最开始的位置,那个地方就写了mbr大小多少？是什么类型的启动盘？用哪种类型启动，然后Linux比如说有人把Arch给搞崩了，没事弄好就好，为什么？引导重新装一遍，把那个分区文件的头重新覆盖一遍,用Pacman去装那个引导Grub，装完过后他就会把头覆盖一遍就好了。</p>
</div>
<div class="paragraph">
<p>所以各个文件类型都是一样的道理，大家都是，不管是PNG、PDF、word、zip都有，全世界都是这么干的，那这么理解没毛病的，打个比方，你怎么知道抓包的时候是一个HTTP包？很简单，开头是get、post、delect、update除了这些以外的都不是，所以这个地方是一个枚举值，然后这个时候用get开头，屁股后面是/r/n换行的，那肯定是HTTP，当然你要求更详细一点，就是中间怎么割的，必须版本号之类的，那再说,但是开头你是能确定的,像我们公司写代码，两代协议混在一起，混出来的那个东西叫7b，7b就表示是某种数字嘛？然后他转成数字就是比如说195，结果我正常的内容里面有个东西刚好是叫七b，结果就出现了此7b非比7b,然后就报错了，后面一解析，啪啪啪全错了，那个包都不能用，我们现在就是因为这个头痛，所以我们现在的解决办法是先按七b的协议解析一遍，如果报错，我再按另外一个方式解析，但是如果我把数据调过来，你会发现一切全错了，一样的道理。</p>
</div>
<div class="paragraph">
<p>所以你看，他没有那么巧，我刚刚举了那么多例子，全世界都在用着用这些文件头，所以这个地方你可以理解我有个东西叫文件头，我刚刚讲了Windows的启动盘有MBR，然后包括你的DOS分区，包括你的PNG等等基本全世界都有了，那现在有个问题，innerdb格式开头也有这个东西，以此类推嘛，我们可以马上在那个MySQL的上面，打开这个文件的前面去看，一定有特殊的标记，你把不同服务器上MySQL的文件打开都有这种，甚至可能是MySQL的版本号，比如说他是1.0版本还是2.0版本的格式,1.0版本的格式和2.0肯定不能互通,那能互通我升级你干嘛呀？一定是你有缺陷，所以这个时候，那么innerdb也有文件头，我说这个的意思就是说我要画一个出来，而且看起来这个文件，他应该也要写自己的长度，但这个文件，它是一直在变大，但是这个变大很有艺术，我猜测是这样的，因为我有MySQL配置的时候，他的这个你用ll命令去看，不要用du命令哈，因为ll命令去看你会发现这个文件明明只有几k，但是因为ll命令能算出几十个g出来，用ll命令 看是系统分配给他的文件属性里面叫大小，文件属性里面那个大小30个g，但是用du命令查出来的时候叫占用的磁盘空间大小， <code>占用</code>，注意这两个词哈是不一样的，所以我有合理的猜测这个地方的大小是他那个Mysql改了个配置，重启过后立马就创建了Innodb这个文件，那个时候就写死了，这个大小都是不会随便改的，因为改会改错的，你想嘛，每个人都在改一遍，以谁为准？最好的方式就弄在这儿不动了，所以有个参数就那么巧叫innodb filesize，或者叫innodb size，你不觉得那么巧吗？你手动去改这个大小，当然没问题，但是有个问题就是，这个如果文件有人用呢？你要去占用这个文件去改这个文件系统上这个文件的大小，数据库卡死了吧，你都把数据库停了那谁在改啊？你手动改当然也不是不行，手动把这个值改了，改完了过后把这个文件在Linux下面把它改大，我们叫扩容，这就有个问题了，你是简单的在屁股后面加空白吗？加000吗？你怎么保证你不影响这个这个文件的正确格式被解析出来？万一你改完了过后他结格式乱了呢？所以你需要，你需要一个有东西叫innodb-tools，简称扩容工具来做，是官方给你出吗？所以按正常逻辑设计来讲的话，这个值是不会轻易去改它的，相反，他会在创建文件的时候就把这个分配好，就把这个写死，但是呢不占空间，为什么？因为后面全部是0，记住，一个文件里面如果全部是这种空白符的话，它是不占用空间的，但是巧了，你用cp参数默认去拷他去copy他，对不起，他那个0他会重新给你分配一次空间，你会发现原来是那个文件10m你copy出来有30个g，你是不是可以搞别人？懂意思了吗？然后你在U盘上放一个10m文件，对，就是我U盘上那个30个g的，你拷出来他拷出果然30个g没骗我，但是U盘只有2g。然后你又跑去骗记者，我发明了中国独特的有专利的压缩算法，能把30个g压成2g，你看你看了没有，其实我讲了那么久和Mysql半点关系都没有，你发现是这样子，我讲到哪个地方和Mysql有关系？你告诉我，除了这个名字以外哪个地方和Mysql有关系？哪儿和Mysql有关系，你告诉我，你会发现，这个时候我们是上文件系统课，所以我讲过的写Mysql数据库，或者Psql，SQL Server这些人全部都是搞文件系统的，全部搞操作系统的，只有这样的功力，你才hold得住，为什么？就这个东西我都要花一个小时给你讲明白，你不觉得Mysql离你有点远吗？</p>
</div>
<div class="paragraph">
<p>所以这地方他默认填0，后面是这样的，我打个比方是，现在我创建了一张表，你这个文件那么大，是不是有些地方应该用来存表？比如说这个地方用来存表名字，那有些地方应该存数据，然后有的地方好像是用来存索引的吧？现在有个问题了，你咋知道点地方存索引呢？你想过这个问题没有？说白了我们分区间，我们我先全部填充成，我等会来讲，所以我先把它写出来，这个时候哈这个地方我们会分区间我打个比方我直线的地方我假设它存的是table，我比如说打两个直线的这个地方的表示存的index可以吗，我假设我用波浪线的表示表的数据，可不可以？现在有意思了，你咋知道从哪个地方开始是表？你咋知道从哪个地方开始是那个表的名字呢？是不是有这个问题？你想吧，程序员是逻辑非常严谨的一种一种生物，他会做一个这种无厘头的事情吗？不会，所以这个时候存储引擎有两个文件，这个文件叫Data文件，叫数据文件，还有一个文件叫Log文件，日志文件，我就问你个问题吗？我这个地方可不可以用一段一段的表示？什么意思？我打个比方：</p>
</div>
<div class="paragraph">
<p>我创建了一张表，我就用逗号分割，我怎么写？我就假设最后创建一张表嘛，我就写一个table-pos=101可不可以？当然写的是是二进制哈，你翻译完了？翻译成你的英文可以写成这样子吗？在101是啥吗？就Data文件第101位置，这叫起始位置，是不是应该还有个长度？从1开始长度为10就是1+10就是11，那么你起始位置是不是应该有个长度位置？所有还有个长度，长度200，这样的话 你是不是就知道某一张表的位置了？然后那张表叫什么名字呢？要么你在这个地方加点复杂的逻辑，要么你再写个叫table name position，然后至于他们之间的关系，你再去对应一下，这个Log文件是不是可以做很多事？就是这个里面只有数字，位置，长度这些东西，最后这些位置拼在一起。</p>
</div>
<div class="paragraph">
<p>而且我敢打赌，索引的信息应该也在里头，你想吧，你存表的时候，insert的时候，update的时候，delete的时候，那个位置已经改不了了，你想比如说你的电影放到D盘，你能无缝的移到c盘去吗？不能，因为你要用移动命令？那现在改位置？但是你加索引是不是很快。我们倒着推，加很快就意味着没有挪位置，没有挪位置他是怎么加索引的，只加了Log，我就简单一点写嘛，这个地方就写一个叫index，比如说我们的index是叫a，a等于table，101.50个长度，我写的就很简单哈他实际上肯定比这个复杂多了，那这样的话我是不是能算出索引的位置，我知道他是个索引了，然后我都有a了，我能不能有a1、a2?加索引这么一加Hash表就构造出来了嘛，他最终是不是构造个Hash表嘛？只是说他在Hash表的这个数据放在了硬盘上，Mysql启动的时候可能要加载，你看到没有我这么一讲，你会发现我从始之中我就没有讲过Mysql专业知识，所以你发现有个Log文件和Data文件好了。</p>
</div>
<div class="paragraph">
<p>如果你自己要做一个类似于Mysql或者Redis这种东西，Redis也有这个，Redis那个文件里面你不管他是分成了一个文件还是分成两个文件，他一定有这种角色的东西。ES绝对有，你想嘛？我打个比方Mysql他有时候，他会因为硬盘问题宕机?或者断电？那个时候正好在写某条数据，但是你发现不会因为断电就是那种确定保存好的数据，你从来不会掉，为什么？除非那个硬盘刚好坏在了Data文件这个位置，但是你只是宕机停电了你会发现没有丢数据，为什么？因为数据在写之前会保存到Log文件里头，因为这里面有个buffer，放到buffer里面的东西他是不会告诉你保存成功的，只有把buffer里面东西写到Data文件里面，操作系统返回说，我写完了，然后他写完了过后，这个Log里面添加一个ok的记录，然后这个Mysql就会返给你说保存成功，你会发现insert它就ok了，如果刚刚保存到Data这个文件，然后你会发现Log文件还没有来得及返给你断电了，没关系，你启动的时候Mysql提示说有章数据请运行repair自动修复，他就读这个里面章数据，什么叫章数据？就是出正在处理当中的但不是ok的，他把那个数据重新确认一遍，保没保存嘛，但是你把这Log文件一删，我跟你讲，你白搭，为什么？因为你只有Data文件，当然我说这个很绝对哈，我只是假设我把Mysql做了简化，实际上他保存索引的时候你会发现这个Log文件是可以删的，我只是在故意偷换概念，一定还有第三个这种文件，为什么？因为这个刚才的索引呢可以放在前面的位置？约定前第100m，从0-100m全是放索引的，全是放这种东西的，你就固定加在那100m，100m以后的都是Data，你是不是也可以算位置，我刚刚把这Data文件和Log文件故意分开，我现在把它合在一起，你也可以理解这个概念，所以现在的Mysql我告诉你那个Log文件是可以删的，当然你要确定你的数据一定是保存完了的哈，所以你要去造一个数据库，或者这种类似保证那个数据一定保存成功的是不是也要按这种逻辑去做？比如说你是kafka，哎呀，好巧，kafka也有这个东西，那真太巧了，那肯定RabbitMQ也有，但凡说他不丢消息了，能够持久化保存的，都有这个东西，就是这种东西，通常他们就会叫Log File，不会有很特殊的名字，这种Log File叫Data Log File，他就来做这种保证数据不丢，因为你kafka重启过后你发现你消息是没丢的，没有消费的消息是没丢的哦， 但是你没用过，你可能现在不清楚，以后你就明白了，所以你就以后就不要去学kafka为什么不丢消息？你就发现了网上至少用3000字来解释了这个问题，他那种丢是消息本身丢了，都还没进到kafka，就是发出去了没收到。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ORM_chapter">21. ORM原理</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_20">21.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/ORM1.jpg" alt="ORM1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ORM2.jpg" alt="ORM2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是orm框架">21.2. 什么是ORM框架？</h3>
<div class="listingblock">
<div class="content">
<pre>O:Obiect          对象 &lt;-----&gt;类(A)的一个实例
R:Relational      关系 ------&gt;关系型数据库
M:Mapping         映射 ------&gt;表结构的映射类(A)</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方我们讲肯定是讲的ORM框架，我肯定指的不是说一个ORM本身，我肯定是特殊到具体框架，这种框架有JPA、Hibernate、Mybatis，那当然我讲这个东西，我可能就开始讲Mysql driver了，我就拉通了讲，就是从一个数据库，他躺在硬盘上面，你怎么把读出来的，那天其实有讲但是我把这部分故意漏掉，为什么？那天我是忽略的Java语言的。</p>
</div>
<div class="paragraph">
<p>那如果是ORM框架的，肯定先解释什么是ORM，再解释框架，然后现在先忽略框，那这个地方我就比如问你什么是JPA，你把JPA解释明白了这个就解释明白了，那什么是JPA？什么是Hibernate？什么是Mybatis？我记得那个框架的英文是怎么写的？framework。首先，框架你肯定不知道，而框架这个词，在我们的古汉语文言文里头，他一定没有计算机框架这玩意儿？那证明这个是一个舶来词，是个新词汇，出现在60年代过后，2000年也是60年代过后，就是计算机诞生过后，编程语言诞生过后才会这个东西，那这地方会发现就算是外国人发明的计算机，美国人发明的，那框架这个东西看起来也和他们拖不了关系，他们用英文叫什么framework，其实我今天讲之前我也没想过这个框架什么意思，我们就来解释一遍吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>这个frame就有点像HTTP协议里面的请求帧和响应帧，片段，帧，片段或者一堆， 包括那个如果你们用的很老的那些网站后台，它有叫框架类镶，镶嵌。就一个网页里面会塞多个framework，就相当于是说你可以把知乎的那个网页用框架的那个标签，把它塞到你的一部分，成一格一格的就变成一个九宫格嘛就像塞进去。那这样的话，单个拎出来的地方就是一帧一帧一帧，一片段一片段一片段，所以这是片段的意思，片段工作，感觉怪怪的？work嘛？一般我们理解就是job然后拿个锄头在这而挖挖挖然后你这个动作就work，片段工作。</pre>
</div>
</div>
<div class="paragraph">
<p>再来看框架，什么是软件框架呀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>就是你用那个框架过后，你的工作很省事，所以看这个地方就变成了工作片段，代码片段，多个片代码片段堆在一起就变成了framework，你看这么翻译就通畅了，不要直接变成这个词，你要把它给搞明白，多种多样的代码片段合在一起就是框架。</pre>
</div>
</div>
<div class="paragraph">
<p>我们来举个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SpringBoot，他有Controller，然后他有各种RestfulApi的规范，甚至它里面包了JPA，它有各种各样的东西，你会发现JPA和那个Controller完全没有关系，是不是一段一段的片段代码组合在一起就能完成某件事情。</pre>
</div>
</div>
<div class="paragraph">
<p>现在框架知道了，数据库框架你听得懂，ROM框架你就听不懂？比如说有个东西叫HTTP框架，你听得懂不？就是SpringBoot，没毛病吧，然后这个时候他前面换一个，你就不懂了，就像协议一样，有网络协议，有存储协议比如说那个Mysql的innodb存储引擎，他就是存储协议，那在这个地方框架框架前面有XXX框架，你不认识了吗？所以说你看到没有一切都是有来源的，他不会凭空的出现。所以你看到没有那这样的话，ORM框架，我们先解释框架，那么框架是什么，是多种或者一种是代码片段组成的一个软件集合，代码集合，你会发现我们在解释名词的时候用集合特别顺手，仓库也是集合，那你现在看的就是说为了提升软件开发效率出现的一种代码集合，然后具体的解释什么样的代码集合，这个时候先把框架给解释了，解释完框架我们到头了在框架前面做约束，做填空题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>为提升软件开发效率而提炼的代码集合，它就是框架，那么称作框架。</pre>
</div>
</div>
<div class="paragraph">
<p>框架解释明白了，那这个时候我们在用数据库这个ORM框架再套一下，为了提升软件开发效率而提炼的什么样的代码结合？打个问号，什么样的代码集合呀，将数据库的表映射成Java代码或者映射成编程代码，但是你会发现你这样的话前言后语不好接起来，我们就先不管框架，我们先看下怎么提炼，那么关键词肯定是映射，而且还要限制是关系型，所以我们现在把关键词先列出来，对象、关系、映射肯定必须得有，我们就看怎么套哈，那么就是说ORM是一种就是说白了，框架我们先不解释它，我们就说是一种框架，ORM框架是指将关系型对象的表结构映射成编程语言的框架，大概有这意思，但是我感觉还是有一点问题，我们再精简，然后我们看一下ORM映射完了过后有哪些功能，增删改查都有，那么这些是动作，然后动作完了过后能拿出记录数据，所以说明不仅仅是映射的表的结构，他你还能把类容拿出来，甚至你还能做更高级的东西，甚至你还能直接执行SQL，所以那现在看起来ORM能够简化数据库查询相关的操作，看到没有，你看我从这个角度去讲是不是就通了？然后再结合映射看怎么讲？那么就是说ORM框架它的目的是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>就是简化数据库相关的操作，简化关系性数据库相关的操作，简化Java操作数据库相关的操作，就是简化就很重要了。</pre>
</div>
</div>
<div class="paragraph">
<p>你刚刚说映射，你会发现你如果从这个角度去讲的话，是不是讲不明白？因为你还要去解释映射，而这种映射，其实映射是基本原理，映射完了过后才有上层的一些操作，所以其实ORM里面那个映射他是最基础的东西，但是如果你解释只解释了基础，你就导致了他上层SQL操作的就不行了，我们就先从简化这角度来讲，那么ORM框架是一种简化数据库操作的软件框架，他怎么简化的呀？通过将关系型数据库的表结构映射程编程语言对象，基于对象的基础上面在完成后续一系列的什么对象填充等等，那就变得很长了，那不是我们的风格，因为会发现你讲的这这段话过后，任何人看了只要能看明白这句话的人，他都能学会，但是很多人看到前半句后面就不看了，看下怎么总结，我就先写个草稿，等会儿再改哈：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ORM框架是为简化编程语言操作关系型数据库而出现的软件框架。</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方框架我们就没有展开了，因为如果你框架都不明白，你是没办法理解这个东西的，所以刚刚对框架进行那个解释嘛，所以你会发现这个地方前面都是在解释什么是软件框架，什么是我们的ORM软件框架，这句话只是说他的目的，这只是目的，他怎么达成的？而且这个地方还要设计一个就是我没有说是关系性所以你要加上，关系解决了，但是对象和这个映射没有出现在这个位置，现在你要解释，后面就说白了，你后面怎么去解释这个ORM是怎么把这个框架搭起来的，不然的话这个概念你是解释不完，来想一下，首先，连接词肯定是通过嘛，通过什么？就拿Java举例：</p>
</div>
<div class="paragraph">
<p>你Java里面这个地方涉及到数据库对象的只有一个东西，表的一行记录，你想是不是？对象嘛，类的实例化嘛，类的一个实例就是称为对象嘛，你会发现如果我们之前对编程语言没有认知的话，我讲你根本听不懂，所以这个地方有前置条件，这个地方对象指的是什么这个地方对象，因为数据库里面是没有对象的，所以这个地方走的对象有两层意思，关系性数据库，关系数据库表和表之间有联系，但是和对象牵扯起来就很牵强，所以我们就忽略掉第一层意思，只留下关系可以了。第二层意思，在Java里面出现对象的只有一个，就是你的Model，Class实例化过后就变成了十行记录就是十个对象，所以这个地方你可以理解为类的实例，类的一个实例就是对象，他们是相等的，那这个时候你就明白了那个对象是什么，对象的意思就是说我把数据库里面的东西结果查出来，查出来过后你的那个SQL不是返了很多行记录，Java把这这条记录或者很多行记录转成了很多个对象，那就变成那个对象列表，那个列表的元素数量有可能是0个，有可能是1个，有可能是多个，就是一个toList，这地方关系跟你指的是数据库本身，关系性数据库，那映射呢？刚刚不是讲了吗？为什么要映射表和Java之间的这个关系？为什么做这个绑定关系？你的创建表的时候你要创建很多什么，那个表里面除了列以外还有啥东西吗？我说列也肯定包含了他相关的所有东西，一张对象性关系表的那个表里面，他设计了几个方面，表包含了表名，包含了列，列就涉及到列名，列属性还有默认值，还有是否组建这些东西我都认为是一列的东西，表名一个列相关的所有东西，那除了这个以外还有什么？还有外件组件，你可以单独把它拎出来，你可以放到列里面去，但实际上那个组件还是外件其实对于我们来说不是很关键，不是所有的表都有这个东西，但是那个列是必须的，你没有表名你只有列名是没有用的，所以说这个地方的映射是指的首先是这个表，其次是那个你的Class里面的类属性映射就是那个列的名称还有类型，就是列名，所以这个地方映射肯定是指将关系性数据库的表映射成一个Java类，或者是一个编程语言的类。</p>
</div>
<div class="paragraph">
<p>那上面这个地方这个类是指的谁？就是这个两个类是一样的，等于说你映射完的映射类的一个实例，所以那这个地方映射是指的什么关系型，我因为我这个地方有约束嘛，我就不强调关系型的，表结构的映射类，这个地方我就不去解释什么叫映射，这个地方不是我的重点，映射那个东西大家都懂，这个语文都懂，现在你不清楚的是他映射的谁，把谁映射成谁？表结构映射类，而这个类我如果取名字叫a的话，那这个地方a呀，就是先把表结构写成映射类，然后查完数据库所有的记录，就转成了那个类的对象，就表示一行一行的，就像你的Excel，你类的每个实例是一个Excel的一行,类的话是不就是个列，堆在一起就是那个类的总称，所以这个地方如果你要用形象一点表示的话，比如说这是Excel:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/excel表格图.png" alt="excel表格图">
</div>
</div>
<div class="paragraph">
<p>那这个地方是那个你的行数0123456，那这地方比如说是列名，那你可能得个这个东西,你得到这个东西过后你肯定有这样，所以那这个地方谁是类谁是对象，这个地方不是有列名，这是一个Excel的表格，就是列的话我这个地方肯定是a、b、c、b、e、f、g、h，那这样的话用a1、a2、a3、可以表示单个列，所以那这样的话就是你怎么去理解他的关系哈。类是指的整张表，所以那这个地方的话就相当于是说：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类A&#8230;&#8203;..H(所有列)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你想一下就说白了A到H这个地方就是类属性，那类属性和所有列之间是相等的，我是指的这个区间就表示是类，但是你会发现我没有说这个下头，我说的是谁，所以这地方指的是定义，哪怕那个Excel名是空的，类似存在的，但是没有对象，所以如果是一个空的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>空Excel：有类定义，无实例化对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那如果是非空Excel就是有类定义又有实例化对象，那具体类我讲明白了，这个很重要哈,那这个里面谁是对象哈，所以这个地方的对象，总的来说按这个模式了就变成了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A0&#8230;&#8203;..H0(一行)</p>
</li>
<li>
<p>A1&#8230;&#8203;..H1(一行)</p>
</li>
<li>
<p>A5&#8230;&#8203;..H5(一行)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么有a0是不是有a1啊，a1是这个到h1嘛，我可以有很多，这地方是5嘛，这全是对象，所以那这是一行，这是一行，这是一行，那最后这个对象肯定指的是多个，所以有所以单独出现说对象的时候，比如说实例化一个对象，实例化一组对象，所以说我们是有前置约束条件的，所以刚刚说是空的Excel，那如果现在是非空的Excel，就又有这个，又有这个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>空Excel：有类定义，也有实例化对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个地方我们要谈数量，因为是根据你情况来的，所以刚才类的话是指这他的那个表头，所以这个地方定义也称为表头，这个都叫表头了，你那个对象关系数据库的表结构，是不是等于表结构嘛，那对象的话肯定指的是行，所以这个地方对象指的是行，那在数据库里面叫一条记录，英文叫row，一行嘛就是一个w嘛，两行就是rows，那这个地方是列嘛，col嘛，但是他是类全部就是在所有的列s，那这地方行有可能是一个，也有可能是多个。</p>
</div>
<div class="paragraph">
<p>那又回到这边来，我们把这三个词挨个解释了一遍，第二个词已经出现了这个的位置了，类的一个实例或者对象，这地方是没有解释的，说白了你讲完了前一句话，你只讲了他的目的，你没有讲他实现的手段，就是有些时候去解释什么是什么的时候哈，你只是讲出来它是由什么组成的？你并没想到目的，但这个东西太复杂了。这个东西太复杂了，你不能只讲半句话，你讲完半句话你还是懵的，为什么？因为你的目的是最终理解他，然后去用它，结果也没理解到也没用上，所以就是说这个过程当中你要去解释它是怎么实现的，所以那这个地方实现就是这两个手段，肯定有因才有果，通过将表结构映射成编程语言类，再将查询的结果行转换成这个类的实例，最终实现简化操作的目的，所以通了，但是你会发现这个概念，如果不去理解这个对你这个，懵的，但是你解释是很麻烦的，比如说王雪慧找波波问他什么是HTTP，波波讲的可贼溜了，然后王雪慧说只能两句话跟我讲一下，然后这个时候波波就懵了，为什么？我知道是个啥但是我讲不出来，通过将表结构映射成类，映射成编程语言的类，通过将这个中间刚我们讲是个简化版的，映射成类过后有什么好处？就是把表变成Java的类部有什么好处？读取的是方便，便于就是读取表信息，便于读取表信息，括号表明列名，列类型等等，便于在编程时使用表（包括表名，列类型，列名等），这只讲的前半句话，那他查询完了过后呢？因为这个地方是通过将表结构映射成编程语言的类，便于在编程时使用表，表包括什么？这个地方可以用逗号哈，把括号去掉也是可以的，包括表名，列名，列类型等等，最终可以将SQL的查询结果转换成类对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>通过将表结构映射成编程语言的类，便于在编程时使用表，包括表名，列类型，列名等。
最终可以将SQL的查询结果转换的类对象。</pre>
</div>
</div>
<div class="paragraph">
<p>你这光只有这句话，你是没有办法说清楚的，就这句也不行，他有前后因果，这是目的是先给你介绍个总的概念，再跟你说我手段是怎么实现的，是分两步，先有映射才有对象，所以现在可能这一句话羽翼不丰满，但是核心思想已有了，但是我个人觉得就还是太复杂了，但是我如果把它精简一下，我感觉就是讲不清楚，我把他放大又多，所以我们先保持这个样子，我觉得就不是超过了，就最终就这个样子了，所以这个地方解释的框架，这个地方解释的什么是ORM框架，如果你要套的话，你就把这个框架个定义套过去，但是我个人觉得你最好是先告诉别人什么是框架，再说什么是ORM框架，所以把当遇到复杂概念的时候，把它拆分，有前置条件有后置条件，比如说这个时候你连类都没有用过，我就不会跟你讲，因为这个属于高级工程师需要学的内容，但是我们这个地方我们认为都是应该掌握的，不分初级高级中级，就是用到什么，你就应该去了解他，不要刻意给自己画圈圈，说，哎呀，我还是个初级的新人，我不需要学这些，所以这个地方的话就是他的前置条件是你能够理解这些东西，而且其实说白了，我哪怕没有那个，我能基于这个也一样给你讲下去，但是我觉得那个表可能会更形象一些。</p>
</div>
</div>
<div class="sect2">
<h3 id="_orm工作原理">21.3. ORM工作原理</h3>
<div class="paragraph">
<p>在讲ORM这个工作原理之前得先明白是两个东西，那这个地方肯定是Database Driver，数据库驱动，那看起来这地方是两个词，数据库不用解释了吧了，那什么是驱动？比如说显卡驱动，说到关键词了，协议，那我先举个例子嘛显卡驱动，大家都装过，没有显卡驱动你的那个屏幕那个显卡就没用，那么说明这个驱动是承上启下的，那就是操作系统和显卡之间的一个桥梁，显卡驱动让操作系统知道显卡是怎么工作的，能够控制它，使用它，显卡去都明白了那把显卡去掉，换成数据库，那数据库确定是啥，能够让第三方编程语言或者第三方工具与数据库通信的一个软件集合或者一个软件框架，这个驱动肯定是个框架，所有软件都是框架，基本上除了用户能点的，只要是给程序员用的，这是给程序员用的嘛，就是框架，这个地方我打个比方：</p>
</div>
<div class="paragraph">
<p>举的是Mysql的数据库驱动，让Mysql以外的第三方工具或者语言能够与Mysql本身通信的这么一个软件框架，那这样的话就是Mysql驱动，我现在问你个问题，那驱动做了啥，他能够让第三方工具知道查出来的东西是什么，你说是ORM，这是两个层面的东西，ORM更高级，数据库驱动更低级，其实本质上这两个东西是一样的，但是驱动里面没有映射，他也没有对象，为什么？没有映射当然就没有对象了，因为关系这玩意儿讲的是关系数据库，讲的可不是里面查出来的东西，所以这个驱动里头只有什么查询出来的结果集，它只是一个列表，只是一个可能数组指针，他可能只是一个其他东西就是非常非常原始的，ORM在数据库驱动的基础上面去做翻译工作，他就遍历那个数组，他就遍历那个结果集，挨个挨个拿出来，所以你如果很介意ORM的性能的话，你自己也是可以基于数据库驱动做一个的，我们就不要去搞重复发明了，其实一句话，驱动是负责与数据库沟通沟通按照Mysql的通行协议与数据库沟通，说白了他是一个协议的解封包解包器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>驱动是数据库通信协议的编码和解码器。

* 网络层面

* 结果集转换</pre>
</div>
</div>
<div class="paragraph">
<p>我从这个角度跟你讲，一下就明白了，其实刚刚从用户角度讲的发现讲了半天狗屁不是，编码解码器，你都把它解码了，你是不是可以用它了？当然就能沟通了，他当然是个桥梁了，从桥梁的角度讲你听不懂这是什么，为什么？因为涉及到需要了解驱动的人一定是写代码的人，他不需要知道什么是桥梁，你直接告诉我你有啥用，所以我就不去啰嗦，以前我给波波帮他们讲的时候，网络协议那块应该是后讲，所以我没有办法很简单给他讲明白。但是如果先讲的网络协议，而且讲的比较深入，过后你会发现所有东西都是按说明书翻译，翻译来翻译去嘛，翻译过来叫编码，翻译回去叫结码，就很简单了所以他就这个翻译器，翻译两个方向嘛，英文翻译成中文，中文翻译成英文。</p>
</div>
<div class="paragraph">
<p>所以那这个地方驱动明白了吗？很简单，它就是个编码解码器，只是说编码的东西是什么？他肯定要把网络协议里面东西拿过来，因为你想嘛，你用Java去连Mysql你填的时候IP地址和端口，所以说这个东西是一定要连网络的，他连网络就要封包解包，这个是网络的封包解包，那么他网络封包解包做完了过后，他那个里面带的数据还要去识别转换一下呀，他也是在做编码解码，只是一个是网络包封包解包，然后一个是Mysql查询数据集的一个封包解包，所以这个涉及到两方面，一个是网络层面哈，那么还有一个就是结果集转换，一个是网络层面的那个封包解包，一个是结果集的转换，他都是用编码解码去做的，只要能把这个做了驱动就ok了，你再用那个显卡驱动来套一下，显卡驱动那么肯定有串口通信，因为你要接线，你要把那个显卡插在那个pc插槽上头，所以这个时候操作系统主要解决的问题是怎么和pc-1插槽通信，网络有了的，然后这个叉槽有了过后，那这个时候显卡一定要通过那个pc-1插槽传输东西，来来去去来来去去，因为他有带宽嘛比如说40gb每秒，他那个带宽里面携带有数据，你的操作系统你知道的是什么数据吧？有来有去吗？又有一个层面的封包解包，你又发现这东西都是万能公式相通的，所以你看到没有，把协议这玩意弄懂了过后基本是万用语言。</p>
</div>
<div class="paragraph">
<p>比如说你买了个车，你看那个说明书是为什么吗？那是使用协议，当我报滴滴滴的时候，是汽车内存出了问题，然后比如说你的亮什么灯？他们也是一种协议，只是这个协议的转化是通过你的人脑转换的，所以你的人脑里面有编码解码器，但是如果你的编码解码器虽然在，但是如果把说明书抹掉，你能转吗？你转不了，所以我们很多时候不是从哲学层面去解释很多东西，你会发现在是吹牛逼，但是你倒回去套的时候，你发现万用公式随便套，这叫强哥学习法就诞生了。</p>
</div>
<div class="paragraph">
<p>那驱动我们明白了，那这个地方我们就不再解释驱动了，那这个地方的工作原理是什么样的？简单画一个图哈：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/正着来.png" alt="正着来">
</div>
</div>
<div class="paragraph">
<p>图是这样的，我就假设是用Java的那个JPA，比如说你先写过来点，比如说你有一段Java代码，你通过JPA，那么JPA又用了hibernate，然后hibernate一定用的是driver，我们这个地方通常指的driver一定是Mysql driver，其实到这个地方的时候，我提醒你一下，你应该会有印象，你用那个河狸数据库管理器的时候，他要下驱动，他下的东西你会发现下东西的Jar包，然后那么驱动有了过后，那驱动它往下走，他就会连Mysql，当然往下走，你要是具体一点的话，应该是操作系统里面的网口，有了网口就有主板，有主板就有网口那就太细了，我们假设他应该通过网络，然后这个地方他通过网络找到了Mysql的端口，你会发现这里面谁是ORM哈，而这个东西他就是driver，你会发现你只要把driver搞懂了过后，这个图就很清晰了。</p>
</div>
<div class="paragraph">
<p>Java语言里面可能某个地方需要查某个表什么by id查了某一列嘛，那么调的是的语法，JPA他给你封装的很高级，就是基本上他内部是方法名你都是瞎猜的find by id，find by类，find by id and类，他有一定的规则，封装的太好了，封装的太简单了，其实这个JPA是用hibernate改的，你发现hibernate启动的时候是用JPA起的，但是用的是用JPA，所以你可以两个都分称为ORM是没问题的？或者说都称为hibernate都是ok的，那么ORM看起来是在driver上面封装了一层，为什么？其实你可以跳过他，完全没有问题，我之前用c或者c + + 我写代码，我个别时候要查数据库，我用的是Mysql和官方提供的c + + 驱动，你的Java下载下来是个Jar包，用c + + 下载下来是一个.so的文件，然后那个文件里面就有函数嘛，你就现在把它加载进来函数就可以用了，这个你不用担心，具体过程你假设就跟Java一样，那这样的话，我调完了过后我就要用While循环或for循环，或者用if判断去把那个driver的东西挨个读出来,所以为什么我对这些东西那么清楚，所以我写过各种各样的驱动,我写过内核驱动，我写过数据库驱动，甚至我自己还基于Redis包装了一层驱动,我有c语言版的Redis驱动，最开始Redis官方是没有这个东西的，或者很难用，我就基于我自己的方式包装的一层，所以那这样的话就相当于是说driver过了过后通过网络你的数据库，所以说明driver做进行了网络的一个转换，还进行了结果集的一个转换，做了两个层的东西嘛，最后Mysql再返回来就回去回去回去。</p>
</div>
<div class="sect3">
<h4 id="_java和jpa是什么关系">21.3.1. Java和JPA是什么关系？</h4>
<div class="paragraph">
<p>这个过程当中我们再拎过来，看一下有没有需要补充的，那这个地方看起来那么Java和JPA是什么关系？他怎么绑定在一起的？我们讲了工作原理嘛，你得举个例子吗？我们现在没举例子，在我们的举个例子，证明的工作原因是对的，所以那这个地方首先，你既然Java里面用了这个东西，那首先第一个你要连数据库，首先那例子哈2.1，例子，那这个地方的话首先你有一个配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>config——&gt;mysql://localhost:3306/testdb?passwprd=123&amp;user=root&amp;...</pre>
</div>
</div>
<div class="paragraph">
<p>那你一般会写这个，这才是重头戏？一般是ip地址，localhost：3306，我随便写哈，我就假设我写的是对的，那这个时候你肯定先有数据库，比如说我们这个地方叫textdb，那这样写完了过后肯定还要跟你的账号名字，编码，时区，我记得像是这么写的，我就假设先写password满意了嘛，password=123，user=root，那比如还有些其他的东西，这个东西就典型的URL，我可没有说URL必须是HTTP开头的，HTTP：//，哎，巧了，Mysql：//，所以这个地方他有个名字叫连接URL英文叫connection，叫连接字符串连接URL都可以，就讲的是这个，这种分就不用我讲怎么分了，典型的一看就会，一用就废，所以这个明白了，这个后面后面可能会跟时区，或者跟那个编码，utf8等等很多很多东西都都可以跟就是你只要掌握了Mysql，我问你Psql怎么连？所以他顶多是说有一些Mysql特殊的属性，可能身体后面要要取掉，但是大多数情况下面你这个字符串的直接动这个地方，剩下的工作是ORM帮你做的，因为Psql的driver和Mysql的driver不是一个厂家写的，你咋保证他这个位置是一样的呀，他有可能把那个密码放到localhost里头，所以这个字符称转换了一般是ORM给你转换的，那我先用连接字符串连接，然后这个时候ORM做了什么？把这个字符串转换成一个结构化的连接类，那就存在Java里头了比如有个类就叫connection info，他把这个字符串挨个弄出来存到connection info的对象里头去，为什么叫一个类里面一个对象呢？他万一有两个连接字符串，他就可以有两个对象，就组成一个集群的嘛，所以那这个地方这是连接字符串，连接字符串有了过后那么Java里面会去做转换，然后这个地方就转换嘛，就是把上面这个东西哈就是解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>parser——&gt;解析URL，保存连接信息到对象</pre>
</div>
</div>
<div class="paragraph">
<p>URL然后保存连接信息到对象，这个对象我们就不要去深究他是什么，反正随便个对象都可以，再Java里面万物皆对象，连接信息保存了，他要连接，他要把这个信息给driver，他就去调用driver了，所以他就这个地方开始连接conn嘛：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>conn——&gt;ORM调用driver连接</pre>
</div>
</div>
<div class="paragraph">
<p>那这样的话就相当于是说这一块是ORM的基础工作，然后这样的话就相当于说ORM调用driver连接，连接完了才是使用，才有你的find by id，所以这个地方就是Java code：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Cpde——&gt;repo.findById（1）</pre>
</div>
</div>
<div class="paragraph">
<p>就相当是说你有一个类嘛，我们叫repo嘛，repo.findById，然后这地方比如说是(1）,就现在直接调用了，然后这个调用的过程当中，他肯定还要去复制ORM把它转换完了，又是调driver，所以那这个地方的话又涉及到转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>parser——&gt;code——&gt;SQL</pre>
</div>
</div>
<div class="paragraph">
<p>这地方转换把上code转换成一个SQL，那这样的话，就把上面那个code的转化成SQL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>driver——&gt;SQL——&gt;Mysql</pre>
</div>
</div>
<div class="paragraph">
<p>然后最后是driver把SQL发送给Mysql，然后发送给Mysql过后他一定会返回一个查询结果集，最后再反着来嘛，我这地方只写关键的地方哈，你会发现就是可能讲这个地方很多具体可能没讲，但写代码的时候你可以忽略到很多细节，为什么？你根本就不关心，所以这个地方我跳了很多的步骤，但是你知道这个地方可大概对哪个位置，你每做一件数据库相关的事，你要知道这个过程是什么样的，你把这个东西套过来。</p>
</div>
<div class="paragraph">
<p>比如说Java他要先怎么样，先去读那个配置文件，读完配置文件过后，把这个配置连接信息交给JPA，JPA交给hibernate，hibernate把那个连接信息最后调用driver去连，这是连接，连接完了之后Java准备的一个代码，代码是通过JPA的方式findById做的，那么findById通过hibernate转成了SQL，所以这个地方是SQL吧，这个地方是网络包加SQL吧，他返回回去的时候也是一样，就是变成结果集了，那我就不写了我觉得没有必要，那么结果集到这步也是结果集，这是网络加结果集，这就变成了结果集，那结果集再往上结果集就是变成了对象，结果对象，结果对象，结果对象Java就能用了，所以你们到时做笔记的时候，这个反着来，你们要画出来。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/反这来.png" alt="反这来">
</div>
</div>
<div class="paragraph">
<p>&lt;&lt;</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-09-15 19:46:29 +0800
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>