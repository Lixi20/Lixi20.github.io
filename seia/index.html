<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="李喜">
<title>C03课堂随笔</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white; color: rgba(0, 0, 0, 0.8); padding: 0; margin: 0; font-family: "Noto Serif", "DejaVu Serif", serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: #7a2518; font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #2156a5; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Open Sans", "DejaVu Sans", sans-serif; font-weight: 300; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.0125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddddd8; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; font-weight: normal; color: rgba(0, 0, 0, 0.9); }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }

blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #f7f8f7; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }

body { tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; word-spacing: -0.05em; }
h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong { font-weight: 400; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; background-color: #f7f7f8; -webkit-border-radius: 4px; border-radius: 4px; line-height: 1.45; text-rendering: optimizeSpeed; border: 1px dashed #2f6fab;}

pre {border: 1px dashed gray;}

pre, pre > code { line-height: 1.45; color: rgba(0, 0, 0, 0.9); font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace; font-weight: normal; text-rendering: optimizeSpeed;}

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: rgba(0, 0, 0, 0.8); }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: rgba(0, 0, 0, 0.9); }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddddd8; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddddd8; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddddd8; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #ddddd8; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #efefed; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #7a2518; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #efefed; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #efefed; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: rgba(0, 0, 0, 0.8); padding: 1.25em; }

#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #efefed; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1rem; font-style: italic; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: rgba(0, 0, 0, 0.85); }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddddd8; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; text-align: center; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.listingblock pre:not(.highlight) {color: white; background: #002b36; }

.literalblock pre, .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #f7f7f8; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 1em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #f7f7f8; background-color: rgba(0, 0, 0, 0.9); }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock pre.prettyprint { border-width: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.45; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddddd8; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #7a2518; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid rgba(0, 0, 0, 0.6); }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: rgba(0, 0, 0, 0.6); }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.6; background: #f7f8f7; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 1.25em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.05em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

dt, th.tableblock, td.content, div.footnote { text-rendering: optimizeLegibility; }

h1, h2, p, td.content, span.alt { letter-spacing: -0.01em; }

p strong, td.content strong, div.footnote strong { letter-spacing: -0.005em; }

p, blockquote, dt, td.content, span.alt { font-size: 1.0625rem; }

p { margin-bottom: 1.25rem; }

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }

.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }

.print-only { display: none !important; }

@media print { @page { margin: 1.25cm 0.75cm; }
  * { -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
  a { color: inherit !important; text-decoration: underline !important; }
  a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
  a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  pre, blockquote, tr, img, object, svg { page-break-inside: avoid; }
  thead { display: table-header-group; }
  svg { max-width: 100%; }
  p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
  #toc { border-bottom: 1px solid #ddddd8 !important; padding-bottom: 0 !important; }
  .sect1 { padding-bottom: 0 !important; }
  .sect1 + .sect1 { border: 0 !important; }
  #header > h1:first-child { margin-top: 1.25rem; }
  body.book #header { text-align: center; }
  body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
  body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
  body.book #header .details span:first-child { margin-left: 0 !important; }
  body.book #header .details br { display: block; }
  body.book #header .details br + span:before { content: none !important; }
  body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
  body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
  .listingblock code[data-lang]:before { display: block; }
  #footer { background: none !important; padding: 0 0.9375em; }
  #footer-text { color: rgba(0, 0, 0, 0.6) !important; font-size: 0.9em; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }

</style>
<link rel="stylesheet" href="css/font-awesome.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>C03课堂随笔</h1>
<div class="details">
<span id="author" class="author">李喜</span><br>
<span id="email" class="email"><a href="mailto:lixi0506cd@gmail.com">lixi0506cd@gmail.com</a></span><br>
<span id="revdate">何文松 &lt;conscience0915@gmail.com&gt;</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_前言">前言</a>
<ul class="sectlevel2">
<li><a href="#_贡献名单">贡献名单</a></li>
</ul>
</li>
<li><a href="#_BCTS1_chapter">1. 编程通识(一)</a>
<ul class="sectlevel2">
<li><a href="#_板书">1.1. 板书</a></li>
<li><a href="#_三个公式">1.2. 三个公式</a></li>
<li><a href="#_产品软件商业模式">1.3. 产品=软件+商业模式</a>
<ul class="sectlevel3">
<li><a href="#_软件是什么">1.3.1. 软件是什么？</a></li>
<li><a href="#_商业模式是什么">1.3.2. 商业模式是什么？</a></li>
</ul>
</li>
<li><a href="#_软件程序使用场景">1.4. 软件=程序+使用场景</a>
<ul class="sectlevel3">
<li><a href="#_程序">1.4.1. 程序</a></li>
<li><a href="#_使用场景">1.4.2. 使用场景</a></li>
</ul>
</li>
<li><a href="#_程序算法数据结构">1.5. 程序=算法+数据结构</a>
<ul class="sectlevel3">
<li><a href="#_程序是什么">1.5.1. 程序是什么</a></li>
<li><a href="#_算法是什么">1.5.2. 算法是什么</a></li>
<li><a href="#_数据结构是什么">1.5.3. 数据结构是什么</a></li>
</ul>
</li>
<li><a href="#_编程要培养编程直觉">1.6. 编程要培养编程直觉</a></li>
</ul>
</li>
<li><a href="#_BCTS2_chapter">2. 编程通识(二)</a>
<ul class="sectlevel2">
<li><a href="#_板书_2">2.1. 板书</a></li>
<li><a href="#_前言_2">2.2. 前言</a></li>
<li><a href="#_什么是网络">2.3. 什么是网络</a>
<ul class="sectlevel3">
<li><a href="#_互联网与万维网">2.3.1. 互联网与万维网</a></li>
</ul>
</li>
<li><a href="#_补充学习编程到底在学习什么">2.4. 补充：学习编程到底在学习什么？</a>
<ul class="sectlevel3">
<li><a href="#_数学">2.4.1. 数学</a></li>
<li><a href="#_编程">2.4.2. 编程</a></li>
</ul>
</li>
<li><a href="#_什么是协议">2.5. 什么是协议</a>
<ul class="sectlevel3">
<li><a href="#_举个例子">2.5.1. 举个例子</a></li>
</ul>
</li>
<li><a href="#_什么是网络协议">2.6. 什么是网络协议</a>
<ul class="sectlevel3">
<li><a href="#_协议">2.6.1. 协议：</a></li>
<li><a href="#_tcp子集_httpftpudptcpsmtppop3imap">2.6.2. TCP子集 （HTTP、FTP、UDP、TCP、SMTP、POP3、IMAP）</a>
<ul class="sectlevel4">
<li><a href="#_pop3_smtp_imap的区别在哪里">POP3, SMTP, IMAP的区别在哪里？</a></li>
</ul>
</li>
<li><a href="#_ip子集icmparp">2.6.3. IP子集(ICMP\ARP)</a></li>
<li><a href="#_要理解计算机世界是怎么运行的非常重要">2.6.4. 要理解计算机世界是怎么运行的非常重要！！！</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_XMSZ1_chapter">3. 项目实战(一)</a>
<ul class="sectlevel2">
<li><a href="#_板书_3">3.1. 板书</a></li>
<li><a href="#_前言_3">3.2. 前言</a></li>
<li><a href="#_项目背景">3.3. 项目背景</a>
<ul class="sectlevel3">
<li><a href="#_常用监控软件">3.3.1. 常用监控软件</a></li>
<li><a href="#_它们存在的问题">3.3.2. 它们存在的问题</a></li>
<li><a href="#_项目背景_2">3.3.3. 项目背景</a></li>
<li><a href="#_还有哪些领域在用linux">3.3.4. 还有哪些领域在用Linux？</a></li>
<li><a href="#_什么叫头部">3.3.5. 什么叫头部？</a></li>
<li><a href="#_linux存在的问题">3.3.6. Linux存在的问题</a></li>
<li><a href="#_起步阶段">3.3.7. 起步阶段</a></li>
<li><a href="#_补充为什么程序员的工资比传统行业高">3.3.8. 补充：为什么程序员的工资比传统行业高</a></li>
<li><a href="#_起步阶段的会遇见的问题">3.3.9. 起步阶段的会遇见的问题</a></li>
<li><a href="#_项目后期会遇见的问题">3.3.10. 项目后期会遇见的问题</a></li>
</ul>
</li>
<li><a href="#_提出问题技术">3.4. 提出问题(技术)</a>
<ul class="sectlevel3">
<li><a href="#_怎样了解模块间的调用关系">3.4.1. 怎样了解模块间的调用关系？</a></li>
<li><a href="#_模块内的工作状态是怎样的">3.4.2. 模块内的工作状态是怎样的？</a></li>
</ul>
</li>
<li><a href="#_解决问题设计">3.5. 解决问题(设计)</a>
<ul class="sectlevel3">
<li><a href="#_管控模块间的交互">3.5.1. 管控模块间的交互</a></li>
<li><a href="#_模块内的工作时长输入参数输出结果数量等等">3.5.2. 模块内的工作时长（输入参数，输出结果数量等等）</a></li>
</ul>
</li>
<li><a href="#_整体数据逻辑设计">3.6. 整体数据逻辑设计</a>
<ul class="sectlevel3">
<li><a href="#_架构图">3.6.1. 架构图</a></li>
<li><a href="#_怎样收集数据应该收集哪些数据">3.6.2. 怎样收集数据？应该收集哪些数据？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_XMSZ2_chapter">4. 项目实战(二)</a>
<ul class="sectlevel2">
<li><a href="#_板书_4">4.1. 板书</a></li>
<li><a href="#_前言_4">4.2. 前言</a></li>
<li><a href="#_客户端的问题">4.3. 客户端的问题</a></li>
<li><a href="#_扩展性">4.4. 扩展性</a></li>
<li><a href="#_主程序怎么运行的">4.5. 主程序怎么运行的？</a></li>
<li><a href="#_扩充">4.6. 扩充</a></li>
<li><a href="#_新的问题">4.7. 新的问题</a></li>
</ul>
</li>
<li><a href="#_HTTP_chapter">5. HTTP协议</a>
<ul class="sectlevel2">
<li><a href="#_板书_5">5.1. 板书</a></li>
<li><a href="#_什么是http">5.2. 什么是HTTP？</a>
<ul class="sectlevel3">
<li><a href="#_协议_2">5.2.1. 协议</a></li>
<li><a href="#_文本">5.2.2. 文本</a></li>
</ul>
</li>
<li><a href="#_为什么用http">5.3. 为什么用HTTP？</a></li>
<li><a href="#_怎么使用http">5.4. 怎么使用HTTP？</a></li>
</ul>
</li>
<li><a href="#_Linux-systemsprogramming1_chapter">6. Linux系统编程(一、二)</a>
<ul class="sectlevel2">
<li><a href="#_板书_6">6.1. 板书</a></li>
<li><a href="#_linux系统编程是什么">6.2. Linux系统编程是什么？</a></li>
<li><a href="#_what">6.3. What?</a></li>
<li><a href="#_做什么">6.4. 做什么？</a></li>
<li><a href="#_how">6.5. How？</a></li>
<li><a href="#_实战">6.6. 实战</a></li>
</ul>
</li>
<li><a href="#_Linux-systemsprogramming2_chapter">7. Linux系统编程(三、四、五)</a>
<ul class="sectlevel2">
<li><a href="#_板书_7">7.1. 板书</a></li>
<li><a href="#_挂载信息">7.2. 挂载信息</a></li>
<li><a href="#_伪代码">7.3. 伪代码</a></li>
<li><a href="#_约定">7.4. 约定</a></li>
<li><a href="#_拓扑">7.5. 拓扑</a></li>
<li><a href="#_调用配置文件">7.6. 调用配置文件</a></li>
<li><a href="#_agentd设计第一阶段">7.7. Agentd设计（第一阶段）</a></li>
<li><a href="#_server第一阶段">7.8. Server（第一阶段）</a></li>
</ul>
</li>
<li><a href="#_linux系统编程六七">8. Linux系统编程(六、七)</a>
<ul class="sectlevel2">
<li><a href="#_板书_8">8.1. 板书</a></li>
<li><a href="#_前言_5">8.2. 前言</a></li>
<li><a href="#_zabbix的优缺点">8.3. Zabbix的优缺点</a></li>
<li><a href="#_我们需要什么">8.4. 我们需要什么？</a></li>
<li><a href="#_我们为什么要自己造一套">8.5. 我们为什么要自己造一套？</a>
<ul class="sectlevel3">
<li><a href="#_更小的颗粒度">8.5.1. 更小的颗粒度</a></li>
<li><a href="#_更现代更好的生态">8.5.2. 更现代，更好的生态</a></li>
<li><a href="#_视角">8.5.3. 视角</a></li>
</ul>
</li>
<li><a href="#_取名字的作用">8.6. 取名字的作用</a></li>
<li><a href="#_球眼系统qiuyan服务端设计">8.7. 球眼系统（QiuYan）服务端设计</a>
<ul class="sectlevel3">
<li><a href="#_postgresql">8.7.1. PostgreSQL</a></li>
<li><a href="#_springboot">8.7.2. Springboot</a></li>
<li><a href="#_react">8.7.3. React</a></li>
<li><a href="#_only_pc">8.7.4. Only pc</a></li>
<li><a href="#_时间通知回调http">8.7.5. 时间通知，回调（HTTP）</a></li>
<li><a href="#_大致过程">8.7.6. 大致过程</a></li>
<li><a href="#_怎么使用">8.7.7. 怎么使用</a></li>
<li><a href="#_界面概念图">8.7.8. 界面概念图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_QiuYang_chapter">9. 球眼系统设计(八)</a>
<ul class="sectlevel2">
<li><a href="#_板书_9">9.1. 板书</a></li>
<li><a href="#_控制策略">9.2. 控制策略</a>
<ul class="sectlevel3">
<li><a href="#_when">9.2.1. When？</a></li>
</ul>
</li>
<li><a href="#_交互过程">9.3. 交互过程</a>
<ul class="sectlevel3">
<li><a href="#_简单的梳理逻辑">9.3.1. 简单的梳理逻辑</a></li>
<li><a href="#_合理性">9.3.2. 合理性</a></li>
<li><a href="#_怎么同步客户端和服务端的清单">9.3.3. 怎么同步客户端和服务端的清单？</a></li>
</ul>
</li>
<li><a href="#_分发系统">9.4. 分发系统</a></li>
</ul>
</li>
<li><a href="#_QiuYangAPI_chapter">10. 球眼系统设计(API系统)</a>
<ul class="sectlevel2">
<li><a href="#_板书_10">10.1. 板书</a></li>
<li><a href="#_什么是api">10.2. 什么是API</a>
<ul class="sectlevel3">
<li><a href="#_参数校验">10.2.1. 参数校验</a></li>
<li><a href="#_身份认证令牌">10.2.2. 身份认证（令牌）</a></li>
<li><a href="#_整体设计思路">10.2.3. 整体设计思路</a></li>
</ul>
</li>
<li><a href="#_api的特点">10.3. API的特点</a></li>
<li><a href="#_api的标准">10.4. API的标准</a>
<ul class="sectlevel3">
<li><a href="#_参数校验_2">10.4.1. 参数校验</a></li>
<li><a href="#_身份标识token">10.4.2. 身份标识(Token)</a></li>
</ul>
</li>
<li><a href="#_api_逻辑链业务">10.5. API 逻辑链（业务）</a></li>
<li><a href="#_api命名规范">10.6. API命名规范</a></li>
</ul>
</li>
<li><a href="#_DaimaTongshi_chapter">11. 代码设计（通识）</a>
<ul class="sectlevel2">
<li><a href="#_本源">11.1. 本源</a></li>
<li><a href="#_编程的本源">11.2. 编程的本源</a></li>
<li><a href="#_工具的作用">11.3. 工具的作用</a>
<ul class="sectlevel3">
<li><a href="#_程序是怎样提高效率的">11.3.1. 程序是怎样提高效率的？</a></li>
</ul>
</li>
<li><a href="#_怎样设计程序无限贴近工具的特质">11.4. 怎样设计程序无限贴近工具的特质？</a></li>
</ul>
</li>
<li><a href="#_JPA_chapter">12. Spring JPA</a>
<ul class="sectlevel2">
<li><a href="#_板书_11">12.1. 板书</a></li>
<li><a href="#_jpa是什么">12.2. JPA是什么？</a></li>
<li><a href="#_jdbc和jpa">12.3. JDBC和JPA</a></li>
<li><a href="#_jpa为什么方便">12.4. JPA为什么方便？</a>
<ul class="sectlevel3">
<li><a href="#_jdbc是怎么用的">12.4.1. JDBC是怎么用的？</a></li>
<li><a href="#_jpa怎么做的">12.4.2. JPA怎么做的?</a></li>
</ul>
</li>
<li><a href="#_补充list">12.5. 补充：List</a></li>
</ul>
</li>
<li><a href="#_SJKTS_chapter">13. 数据库通识</a>
<ul class="sectlevel2">
<li><a href="#_板书_12">13.1. 板书</a></li>
<li><a href="#_什么是数据库">13.2. 什么是数据库</a>
<ul class="sectlevel3">
<li><a href="#_关键词">13.2.1. 关键词</a></li>
<li><a href="#_网络读写">13.2.2. 网络读写</a></li>
<li><a href="#_总结">13.2.3. 总结</a></li>
</ul>
</li>
<li><a href="#_使用场景_2">13.3. 使用场景？</a></li>
<li><a href="#_怎么用how">13.4. 怎么用？(How)</a></li>
</ul>
</li>
<li><a href="#_HTTPYY_chapter">14. HTTP协议(应用)</a>
<ul class="sectlevel2">
<li><a href="#_板书_13">14.1. 板书</a></li>
<li><a href="#_http是什么">14.2. HTTP是什么？</a></li>
<li><a href="#_http的使用场景">14.3. HTTP的使用场景</a>
<ul class="sectlevel3">
<li><a href="#_浏览器">14.3.1. 浏览器</a></li>
<li><a href="#_web服务器">14.3.2. Web服务器</a></li>
<li><a href="#_客户端与服务端之间的传输媒介">14.3.3. 客户端与服务端之间的传输媒介</a></li>
</ul>
</li>
<li><a href="#_http1_1_vs_http2_0">14.4. HTTP/1.1 VS HTTP/2.0</a></li>
</ul>
</li>
<li><a href="#_HTTP1.1VS2.0_chapter">15. HTTP 1.1 VS 2.0</a>
<ul class="sectlevel2">
<li><a href="#_板书_14">15.1. 板书</a></li>
<li><a href="#_http1_1第二个慢是慢在哪">15.2. HTTP1.1第二个慢是慢在哪？</a></li>
<li><a href="#_为什么有http2_0">15.3. 为什么有HTTP/2.0?</a></li>
<li><a href="#_http2_0是怎么解决以上问题的">15.4. HTTP/2.0是怎么解决以上问题的？</a>
<ul class="sectlevel3">
<li><a href="#_三次握手">15.4.1. 三次握手</a></li>
</ul>
</li>
<li><a href="#_减少http头部的传输量">15.5. 减少HTTP头部的传输量</a>
<ul class="sectlevel3">
<li><a href="#_http头压缩">15.5.1. HTTP头压缩</a></li>
</ul>
</li>
<li><a href="#_延伸">15.6. 延伸</a>
<ul class="sectlevel3">
<li><a href="#_http的body是不是可以压缩">15.6.1. HTTP的Body是不是可以压缩？</a></li>
<li><a href="#_http3_0">15.6.2. HTTP/3.0</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYANMOJO_chapter">16. 智眼设计（采集模块）</a>
<ul class="sectlevel2">
<li><a href="#_板书_15">16.1. 板书</a></li>
<li><a href="#_网络拓扑">16.2. 网络拓扑</a></li>
<li><a href="#_解决问题">16.3. 解决问题</a>
<ul class="sectlevel3">
<li><a href="#_补充为什么要着重程序设计">16.3.1. 补充：为什么要着重程序设计？</a></li>
<li><a href="#_agent获取用户配置逻辑">16.3.2. Agent获取用户配置逻辑</a></li>
</ul>
</li>
<li><a href="#_接口安全">16.4. 接口安全</a>
<ul class="sectlevel3">
<li><a href="#_身份认证">16.4.1. 身份认证</a></li>
<li><a href="#_参数校验_3">16.4.2. 参数校验</a></li>
<li><a href="#_接口的时效性校验">16.4.3. 接口的时效性校验</a></li>
<li><a href="#_校验过程">16.4.4. 校验过程</a></li>
<li><a href="#_回调">16.4.5. 回调</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_apisys_chapter">17. API System</a>
<ul class="sectlevel2">
<li><a href="#_板书_16">17.1. 板书</a></li>
<li><a href="#_what_is_api系统">17.2. What is API系统？</a></li>
<li><a href="#_what_is_系统system">17.3. What is 系统(System)?</a>
<ul class="sectlevel3">
<li><a href="#_软件">17.3.1. 软件</a></li>
<li><a href="#_复杂">17.3.2. 复杂</a></li>
<li><a href="#_体量较大">17.3.3. 体量较大</a></li>
<li><a href="#_功能完善">17.3.4. 功能完善</a></li>
<li><a href="#_总结_2">17.3.5. 总结</a></li>
</ul>
</li>
<li><a href="#_what_is_apiapplication_interface">17.4. What is API(Application Interface)？</a></li>
<li><a href="#_什么是api系统">17.5. 什么是API系统</a></li>
<li><a href="#_使用场景_3">17.6. 使用场景</a></li>
</ul>
</li>
<li><a href="#_SJKYL1_chapter">18. 数据库原理（一）</a>
<ul class="sectlevel2">
<li><a href="#_板书_17">18.1. 板书</a></li>
<li><a href="#_数据库是什么">18.2. 数据库是什么</a></li>
<li><a href="#_使用场景_4">18.3. 使用场景</a></li>
<li><a href="#_怎么保存数据的工作原理">18.4. 怎么保存数据的（工作原理）</a></li>
</ul>
</li>
<li><a href="#_bianchengjiqiao_chapter">19. 编程技巧</a>
<ul class="sectlevel2">
<li><a href="#_板书_18">19.1. 板书</a></li>
<li><a href="#_什么是编程技巧what">19.2. 什么是编程技巧？(What)</a></li>
<li><a href="#_使用场景_where">19.3. 使用场景 (Where)</a></li>
<li><a href="#_怎么用how_2">19.4. 怎么用？(How)</a>
<ul class="sectlevel3">
<li><a href="#_引申">19.4.1. 引申</a></li>
</ul>
</li>
<li><a href="#_使用场景一">19.5. 使用场景一</a>
<ul class="sectlevel3">
<li><a href="#_接收参数">19.5.1. 接收参数</a></li>
<li><a href="#_划分阶段">19.5.2. 划分阶段</a></li>
</ul>
</li>
<li><a href="#_使用场景二">19.6. 使用场景二</a>
<ul class="sectlevel3">
<li><a href="#_补充c语言中的枚举">19.6.1. 补充：C语言中的枚举</a></li>
<li><a href="#_代码逻辑">19.6.2. 代码逻辑</a></li>
</ul>
</li>
<li><a href="#_拒载同意">19.7. 拒载？同意？</a>
<ul class="sectlevel3">
<li><a href="#_bus">19.7.1. BUS</a></li>
<li><a href="#_track">19.7.2. Track</a></li>
</ul>
</li>
<li><a href="#_代码实现">19.8. 代码实现</a></li>
<li><a href="#_设计校验步骤">19.9. 设计校验步骤</a>
<ul class="sectlevel3">
<li><a href="#_accesskeyid">19.9.1. AccessKeyId</a></li>
<li><a href="#_signmethod">19.9.2. SignMethod</a></li>
<li><a href="#_signnoce">19.9.3. SignNoce</a></li>
<li><a href="#_timestep">19.9.4. Timestep</a></li>
<li><a href="#_signtrue">19.9.5. Signtrue</a></li>
<li><a href="#_什么叫逻辑统一">19.9.6. 什么叫逻辑统一？</a></li>
<li><a href="#_总结_3">19.9.7. 总结</a></li>
</ul>
</li>
<li><a href="#_逻辑校验">19.10. 逻辑校验</a>
<ul class="sectlevel3">
<li><a href="#_数据库查询类">19.10.1. 数据库查询类</a></li>
<li><a href="#_有效时间校验">19.10.2. 有效时间校验</a></li>
<li><a href="#_综合判断">19.10.3. 综合判断</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_SJKYL2_chapter">20. 数据库原理（二）</a>
<ul class="sectlevel2">
<li><a href="#_板书_19">20.1. 板书</a></li>
<li><a href="#_数据库原理二">20.2. 数据库原理（二）</a></li>
<li><a href="#_什么是存储引擎">20.3. 什么是存储引擎</a>
<ul class="sectlevel3">
<li><a href="#_视频播放器">20.3.1. 视频播放器</a></li>
<li><a href="#_存储引擎">20.3.2. 存储引擎</a></li>
<li><a href="#_格式">20.3.3. 格式</a></li>
</ul>
</li>
<li><a href="#_存储格式">20.4. 存储格式</a></li>
</ul>
</li>
<li><a href="#_ORM_chapter">21. ORM原理</a>
<ul class="sectlevel2">
<li><a href="#_板书_20">21.1. 板书</a></li>
<li><a href="#_什么是orm框架">21.2. 什么是ORM框架？</a></li>
<li><a href="#_orm工作原理">21.3. ORM工作原理</a>
<ul class="sectlevel3">
<li><a href="#_java和jpa是什么关系">21.3.1. Java和JPA是什么关系？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYJIEM_chapter">22. 智眼系统API和界面设计（一）</a>
<ul class="sectlevel2">
<li><a href="#_板书_21">22.1. 板书</a></li>
<li><a href="#_需要注意的">22.2. 需要注意的</a></li>
<li><a href="#_定位">22.3. 定位</a></li>
<li><a href="#_核心界面">22.4. 核心界面</a>
<ul class="sectlevel3">
<li><a href="#_page_one">22.4.1. Page One</a></li>
<li><a href="#_page102">22.4.2. Page1（02）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYJIEM2-3_chapter">23. 智眼系统API和界面设计（二、三）</a>
<ul class="sectlevel2">
<li><a href="#_板书_22">23.1. 板书</a></li>
<li><a href="#_基础模块">23.2. 基础模块</a>
<ul class="sectlevel3">
<li><a href="#_iops模块">23.2.1. IOPS模块</a></li>
<li><a href="#_文件io">23.2.2. 文件IO</a></li>
<li><a href="#_硬盘">23.2.3. 硬盘</a></li>
<li><a href="#_网络带宽">23.2.4. 网络带宽</a></li>
<li><a href="#_网络tcp">23.2.5. 网络TCP</a></li>
<li><a href="#_进程">23.2.6. 进程</a></li>
</ul>
</li>
<li><a href="#_应用程序">23.3. 应用程序</a>
<ul class="sectlevel3">
<li><a href="#_http">23.3.1. HTTP</a></li>
<li><a href="#_mysql">23.3.2. MySQL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYJIEM4-8_chapter">24. 智眼系统API和界面设计（4~8）</a>
<ul class="sectlevel2">
<li><a href="#_板书_23">24.1. 板书</a></li>
<li><a href="#_界面设计风格">24.2. 界面设计风格</a>
<ul class="sectlevel3">
<li><a href="#_统计图表">24.2.1. 统计图表</a></li>
</ul>
</li>
<li><a href="#_表格">24.3. 表格</a>
<ul class="sectlevel3">
<li><a href="#_按列排序单列">24.3.1. 按列排序（单列）</a></li>
<li><a href="#_多列排序">24.3.2. 多列排序</a></li>
<li><a href="#_筛选">24.3.3. 筛选</a></li>
</ul>
</li>
<li><a href="#_绑定界面">24.4. 绑定界面</a></li>
<li><a href="#_竞品区别产品优势">24.5. 竞品区别（产品优势）</a></li>
<li><a href="#_初衷">24.6. 初衷</a></li>
<li><a href="#_定位_2">24.7. 定位</a></li>
<li><a href="#_详细分析定位">24.8. 详细分析:定位</a></li>
<li><a href="#_详细分析初衷">24.9. 详细分析:初衷</a>
<ul class="sectlevel3">
<li><a href="#_看不见">24.9.1. 看不见</a></li>
<li><a href="#_产品数据">24.9.2. 产品数据</a></li>
<li><a href="#_运行数据">24.9.3. 运行数据</a></li>
<li><a href="#_解决不了">24.9.4. 解决不了</a></li>
</ul>
</li>
<li><a href="#_api">24.10. API</a></li>
<li><a href="#_api系统系统设计">24.11. API系统系统设计</a>
<ul class="sectlevel3">
<li><a href="#_怎么做">24.11.1. 怎么做</a></li>
</ul>
</li>
<li><a href="#_采集程序通信">24.12. 采集程序通信</a>
<ul class="sectlevel3">
<li><a href="#_节点端通信流程">24.12.1. 节点端通信流程</a></li>
<li><a href="#_节点和服务端通信流程">24.12.2. 节点和服务端通信流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYJIEM9_chapter">25. 智眼系统API和界面设计（九）</a>
<ul class="sectlevel2">
<li><a href="#_板书_24">25.1. 板书</a></li>
<li><a href="#_功能分区">25.2. 功能分区</a></li>
<li><a href="#_访问方式">25.3. 访问方式</a></li>
<li><a href="#_特点">25.4. 特点</a>
<ul class="sectlevel3">
<li><a href="#_web_api">25.4.1. Web API</a></li>
<li><a href="#_open_api">25.4.2. Open API</a></li>
</ul>
</li>
<li><a href="#_graphql">25.5. GraphQL</a></li>
<li><a href="#_题外中国程序员和国外程序员写代码有什么区别">25.6. 题外：中国程序员和国外程序员写代码有什么区别？</a>
<ul class="sectlevel3">
<li><a href="#_美国程序员">25.6.1. 美国程序员</a></li>
<li><a href="#_印度程序员">25.6.2. 印度程序员</a></li>
<li><a href="#_中国程序员">25.6.3. 中国程序员</a></li>
</ul>
</li>
<li><a href="#_传统与新型">25.7. 传统与新型</a></li>
</ul>
</li>
<li><a href="#_ZHIYJIEM10_chapter">26. 智眼系统API和界面设计（十）</a>
<ul class="sectlevel2">
<li><a href="#_板书_25">26.1. 板书</a></li>
<li><a href="#_web服务和api">26.2. Web服务和API</a>
<ul class="sectlevel3">
<li><a href="#_api和url的分区">26.2.1. API和URL的分区</a></li>
<li><a href="#_用户层具体分区">26.2.2. 用户层具体分区</a></li>
<li><a href="#_绘图层具体分区">26.2.3. 绘图层具体分区</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYANDatabase_chapter">27. 智眼系统设计之数据库设计</a>
<ul class="sectlevel2">
<li><a href="#_板书_26">27.1. 板书</a></li>
<li><a href="#_axure回顾">27.2. axure回顾</a></li>
<li><a href="#_数据库整体设计">27.3. 数据库整体设计</a>
<ul class="sectlevel3">
<li><a href="#_时序数据">27.3.1. 时序数据</a></li>
<li><a href="#_用户数据">27.3.2. 用户数据</a></li>
<li><a href="#_主机">27.3.3. 主机</a></li>
<li><a href="#_分组">27.3.4. 分组</a></li>
<li><a href="#_标签">27.3.5. 标签</a></li>
</ul>
</li>
<li><a href="#_数据表设计">27.4. 数据表设计</a>
<ul class="sectlevel3">
<li><a href="#_时序数据数据表设计">27.4.1. 时序数据数据表设计</a>
<ul class="sectlevel4">
<li><a href="#_cpu">CPU</a></li>
<li><a href="#_tcp">TCP</a></li>
</ul>
</li>
<li><a href="#_http_2">27.4.2. HTTP</a>
<ul class="sectlevel4">
<li><a href="#_http_request">HTTP_Request</a></li>
<li><a href="#_http_response">HTTP_Response</a></li>
<li><a href="#_请求和响应如何建立关系">请求和响应如何建立关系？</a></li>
<li><a href="#_http报文头">HTTP报文头</a></li>
</ul>
</li>
<li><a href="#_mysql_2">27.4.3. Mysql</a></li>
<li><a href="#_用户表">27.4.4. 用户表</a></li>
<li><a href="#_主机_2">27.4.5. 主机</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ZHIYANAgent_chapter">28. 智眼系统设计之Agent</a>
<ul class="sectlevel2">
<li><a href="#_板书_27">28.1. 板书</a></li>
<li><a href="#_agent">28.2. Agent</a>
<ul class="sectlevel3">
<li><a href="#_模型图">28.2.1. 模型图</a></li>
<li><a href="#_采集节点命名">28.2.2. 采集节点命名</a></li>
</ul>
</li>
<li><a href="#_智眼系统的作用">28.3. 智眼系统的作用</a></li>
<li><a href="#_cu">28.4. CU</a></li>
<li><a href="#_cu程序的作用">28.5. CU程序的作用</a></li>
<li><a href="#_cu语言支持">28.6. CU语言支持</a></li>
<li><a href="#_cu是否提供sdk">28.7. CU是否提供SDK？</a></li>
<li><a href="#_cu和agent的通信方式">28.8. CU和Agent的通信方式</a></li>
<li><a href="#_token来源">28.9. Token来源</a>
<ul class="sectlevel3">
<li><a href="#_agent配置文件">28.9.1. Agent配置文件</a></li>
<li><a href="#_cu_2">28.9.2. CU</a></li>
<li><a href="#_curl">28.9.3. Curl</a></li>
</ul>
</li>
<li><a href="#_采集方式">28.10. 采集方式</a>
<ul class="sectlevel3">
<li><a href="#_cu配置文件">28.10.1. CU配置文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_OS_chapter">29. 操作系统（OS）</a>
<ul class="sectlevel2">
<li><a href="#_板书_28">29.1. 板书</a></li>
<li><a href="#_操作系统os">29.2. 操作系统（OS）</a></li>
<li><a href="#_os能做什么">29.3. OS能做什么？</a></li>
<li><a href="#_os的使用场景">29.4. OS的使用场景</a></li>
<li><a href="#_特点_2">29.5. 特点</a></li>
<li><a href="#_linux历史">29.6. Linux历史</a>
<ul class="sectlevel3">
<li><a href="#_unix渊源">29.6.1. UNIX渊源</a></li>
<li><a href="#_linux的创立">29.6.2. Linux的创立</a></li>
<li><a href="#_linux命名">29.6.3. Linux命名</a></li>
<li><a href="#_发展现状">29.6.4. 发展现状</a></li>
<li><a href="#_linux系统架构">29.6.5. Linux系统架构</a></li>
<li><a href="#_linux发行版">29.6.6. Linux发行版</a></li>
</ul>
</li>
<li><a href="#_windows">29.7. Windows</a>
<ul class="sectlevel3">
<li><a href="#_windows由来">29.7.1. Windows由来</a></li>
<li><a href="#_windows全球使用比例">29.7.2. Windows全球使用比例</a></li>
<li><a href="#_windows历史">29.7.3. Windows历史</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_OS2_chapter">30. 操作系统（二）</a>
<ul class="sectlevel2">
<li><a href="#_板书_29">30.1. 板书</a></li>
<li><a href="#_操作系统通识二">30.2. 操作系统通识（二）</a></li>
<li><a href="#_提出问题什么是进程">30.3. 提出问题：什么是进程？</a></li>
<li><a href="#_操作系统是什么">30.4. 操作系统是什么？</a>
<ul class="sectlevel3">
<li><a href="#_什么是计算机">30.4.1. 什么是计算机？</a></li>
</ul>
</li>
<li><a href="#_什么是进程">30.5. 什么是进程</a>
<ul class="sectlevel3">
<li><a href="#_进程是怎么产生的">30.5.1. 进程是怎么产生的</a></li>
<li><a href="#_linux进程图">30.5.2. Linux进程图</a></li>
<li><a href="#_windows进程图">30.5.3. Windows进程图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_OS3_chapter">31. 操作系统（三）</a>
<ul class="sectlevel2">
<li><a href="#_板书_30">31.1. 板书</a></li>
<li><a href="#_操作系统通识之进程和线程">31.2. 操作系统通识之进程和线程</a></li>
<li><a href="#_和进程相关的应用">31.3. 和进程相关的"应用"</a>
<ul class="sectlevel3">
<li><a href="#_top">31.3.1. TOP</a></li>
<li><a href="#_java程序">31.3.2. Java程序</a></li>
<li><a href="#_chrome多进程">31.3.3. Chrome（多进程）</a></li>
<li><a href="#_ide">31.3.4. IDE</a></li>
<li><a href="#_视频">31.3.5. 视频</a></li>
<li><a href="#_媒体软件">31.3.6. 媒体软件</a></li>
</ul>
</li>
<li><a href="#_进程的工作职责">31.4. 进程的“工作职责”</a></li>
<li><a href="#_进程和软件工程师">31.5. 进程和软件工程师</a>
<ul class="sectlevel3">
<li><a href="#_内存分配">31.5.1. 内存分配</a></li>
<li><a href="#_文件读写">31.5.2. 文件读写</a></li>
<li><a href="#_输入输出">31.5.3. 输入输出</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_前言">前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一本关于软件开发、应用前端、系统运维、产品运营、思维、思考的全能手册。</p>
</div>
<div class="sect2">
<h3 id="_贡献名单">贡献名单</h3>
<div class="paragraph">
<p><strong>不按时间先后</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>李喜</p>
</li>
<li>
<p>何文松</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_BCTS1_chapter">1. 编程通识(一)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书">1.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/1.1编程通识(一)板书.jpg" alt="1.1编程通识(一)板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_三个公式">1.2. 三个公式</h3>
<div class="paragraph">
<p>程序一般有很多种理解，比如我们在Linux命令行里经常输入的命令,它其实就是一个程序，再比如我们常用的微信，它也是一个程序,那么程序到底指的是什么？
讲程序之前我们先了解3个公式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>产品=软件+商务模式

软件=程序+使用场景

程序=算法＋数据结构</pre>
</div>
</div>
<div class="paragraph">
<p>很明显它们 <code>相互关联</code> ，可以说它们能够构成一个 <code>链</code> ，从左到右，逐渐的就开始无限扩大，我们也会发现越到后面越虚，为了更好的理解，从上往下我们一步一步的来</p>
</div>
</div>
<div class="sect2">
<h3 id="_产品软件商业模式">1.3. 产品=软件+商业模式</h3>
<div class="paragraph">
<p>将日常中使用的微信带入到这个公式中，然后 <code>产品=软件+商务模式</code> 将微信带入这个公式就变为了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>微信 = 微信 + 商业模式</pre>
</div>
</div>
<div class="paragraph">
<p>这个公式成立吗?</p>
</div>
<div class="paragraph">
<p>很虚，说不通，所以换一种说法，那这个公式正确写法应该是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>产品 (微信) = 程序(微信) + 商业模式(微信)</pre>
</div>
</div>
<div class="sect3">
<h4 id="_软件是什么">1.3.1. 软件是什么？</h4>
<div class="paragraph">
<p>简单来说软件就代表的是这个产品的App</p>
</div>
</div>
<div class="sect3">
<h4 id="_商业模式是什么">1.3.2. 商业模式是什么？</h4>
<div class="paragraph">
<p>我们先举个例子来说明微信的上商业模式是怎样的，这样就能理解商业模式指的是什么概念。</p>
</div>
<hr>
<div class="paragraph">
<p>在智能手机普及之前，不管动感地带、电信、联通等等运营商，购买了它们的包月套餐，假如当时你在谈恋爱，那个套餐里的短信数量，一个月肯定是不够用的，然后就会想方设法的去免费的发消息，但有个问题，当时并不是所有的手机都是智能机，那么在那个时代充斥着一堆诺基亚或者是一堆老年机的时代里，是没有任何好用并且免费的沟通工具。</p>
</div>
<hr>
<div class="paragraph">
<p>那么在智能手机开始普及后的初期，当时安卓和IOS这两个平台上都没有一个好用的、免费的沟通工具。QQ当时出现了，当时QQ的重心并不是移动端，不过当时QQ也适配了移动端(3G QQ)，可是进去过后各种东西，普通人根本不适用，更适用于懂网络的人，微信和QQ的注册方式也不同，微信只需要用手机号发送一个短信就能注册账号了，这样就更适用于普通用户，而QQ则需要登录网页，可能还要申请邮箱而且有很繁琐的步骤，那么微信的商业模式也可以说解决的问题就是普罗大众利用移动的智能手机，免费的相互发送消息。</p>
</div>
<hr>
<div class="paragraph">
<p>为什么特别强调免费呢，因为在这个之前，有一个叫飞书的那个软件，一天有十条的免费短信，飞书这个软件其实也解决了问题。他就像发短信一样的操作，但是超过十条要另外收费。最开始是不收费的，但后面变成了收费，所以自从他想收费的那一天开始，他就已经和成功远离了。
而这类软件的盈利点是随着你的用户量越多，从而产生其他的盈利点，而不是在发消息本身。假设现在的微信发十条消息过后要收钱一分钱一条，那他就和以前搞那个超级女声投票一样，每投一次一块钱一条没有本质的区别。
那现在微信可不是这么玩了，微信说你要开发小程序，对不起，你要交钱，你的服务器要在我这，然后我还要流量提成，你要和我合作，所以收费的渠道很多，盈利点都是在后期。</p>
</div>
<div class="paragraph">
<p>从上面这个例子来看，微信这个产品就等于微信这个App加上他商业模式，而他的 <code>商业模式</code> 就是免费的移动端，消息互发，交友，解决了移动端通信打电话要钱、发短信要钱的问题，你只需要装个App就可以了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_软件程序使用场景">1.4. 软件=程序+使用场景</h3>
<div class="sect3">
<h4 id="_程序">1.4.1. 程序</h4>
<div class="paragraph">
<p>我们顺着上面的微信来讲，之前讲的软件指的就是App，但是它的定义很笼统，它包含了 <code>所有平台</code> 的App，如： <code>安卓</code> ， <code>IOS</code> ， <code>PC</code> 等等 ,在软件这个公式里，App就具体指的众多平台中其中一个，就比如说安卓的App、IOS的App等等。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用场景">1.4.2. 使用场景</h4>
<div class="paragraph">
<p>刚刚商业模式指的是发送消息这种很笼统的概念，而使用场景是说
<code>你拿出了手机，打开了安卓的App，然后在输入框里面打字</code>
相比于商业模式分化的更加细致。</p>
</div>
<div class="paragraph">
<p>举一些例子</p>
</div>
<hr>
<div class="paragraph">
<p>以前的甲骨文，可以用来传递的消息。甚至甲骨文之前你还可以用藤条打几个结记事情，还有就是图像，比如像型文字，甲骨文那种像型文字都是为了传递信息。那么在文字出现之前呢？像型文字出现之前，可以用声音，在一万年前通信基本靠吼，一个人站在那个山头，另一个人站在这个山头，我们俩就对吼，这也是传递消息的一种方式。</p>
</div>
<hr>
<div class="paragraph">
<p>那在指环王里，刚铎被围攻，甘道夫就对洛翰国的国王说你应该去帮助刚铎，然后国王说“刚铎国王都没有点起烽火，我去干嘛？这样我很没面子。”，不过之后就有一个夏尔人爬到那个烽火上面，故意把油打倒然后点燃了烽火。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>烽火是啥？
烽火，又称烽燧、狼烟、狼燧，是一种用于示警的讯号，通常会在险要处或交通要道上建筑用于传递这种讯号的高台，后方看见讯号便知有战事发生，出兵相助。</pre>
</div>
</div>
<div class="paragraph">
<p>那么这个烽火就是在传递消息，所以视觉也可以传递消息，但是这种传递消息是属于双方提前约好的，就比如说两个人，并没有提前交代生火的意思，对于他们来说，就只是单纯地认为着火了，但是当他们提前告知对方生火所蕴含的意义时，就会认为，一方按规矩生火了，那另一方也要生火，按规则运行，那么他们就是在有效的传递消息。</p>
</div>
<hr>
<div class="paragraph">
<p>再比如说，在大街上看到消防车后，我们就知道肯定某个地方着火了，不过这个消息是没有意义的，因为你并不知道是哪个地方着火了，着火的是不是你家？你需不去救火？但消防员知道，他知道XXX小区X楼着火了，可能因为是烤腊肉或者电灯毯着火的，所以消防员的目的，就是我知道着火了，我要去救火，对于他来说，着火了，他的使命就是救火，而对于我们来说，可能是手足无措看热闹，看热闹的时候你挤进去了，那么你就知道到底发生什么事了。</p>
</div>
<hr>
<div class="paragraph">
<p>综上所述，视觉可以传递消息，通信靠吼也可以传递消息，文字也可以传递信息，手打出的文字，画的画都可以传递消息。
那么使用场景，如果从微信上来说的话，就应该是打字的输入框，还有就是点那个语音然后录音，这两种就是使用场景，
但是这个地方并不涉及到一对一还是一对多，他们的输入方式都是一样的，都是在那个框框里面打字或者使用语音呢。</p>
</div>
<div class="paragraph">
<p>上面举得例子都是为了传递信息，但是都是在不同的场景下使用不同的方式实现的，所以 <code>使用场景</code> 指的就是处于不同的场景下实现不同的功能，回到微信的例子，文字的使用场景就应该是打字的输入框，还有语音的使用场景就是点那个语音按钮过后录音，这些也就是微信的使用场景。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_程序算法数据结构">1.5. 程序=算法+数据结构</h3>
<div class="sect3">
<h4 id="_程序是什么">1.5.1. 程序是什么</h4>
<div class="paragraph">
<p>例：安卓的app</p>
</div>
</div>
<div class="sect3">
<h4 id="_算法是什么">1.5.2. 算法是什么</h4>
<div class="paragraph">
<p>逻辑就是算法</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>输入一个参数要 <code>怎么</code> 去处理、 输入文字要 <code>怎么</code> 发送给对方、我是 <code>怎么</code> 让对方收到我发的消息或者我发的信息，包括语音，包括文字，图片我可以认为他是一种视觉的，是一种文件或者怎么样的，但这些都不是很重要，因为就算我不发图片我光靠打文字我也能讲清楚大部分事情，但是在威信诞生之初，大家是没有想过发图片这么一回事儿，你发短信都没有图片，你搞个微信发图片不是必要的，他只是起到一个丰富的作用，所以怎么让对方收到你的信息。你怎么让他收到，所以`这个怎么就是算法`。</p>
</div>
<div class="paragraph">
<p>内在核心：</p>
</div>
<div class="paragraph">
<p>How to ？      Answer——&gt;处理逻辑</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>函数、代码块、代码设计（关系）——&gt;设计模式</p>
</div>
<div class="paragraph">
<p>我们之前写的课程表的算法就是怎么排课。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数据结构是什么">1.5.3. 数据结构是什么</h4>
<div class="paragraph">
<p>你写函数的作用就是调用它，你调用他过后就产生一系列的行为和动作，那么最终你传输的过程当中你一定会携带某种存储结构，所以这个地方的数据结构指的是：</p>
</div>
<div class="paragraph">
<p>1、存储结构</p>
</div>
<div class="paragraph">
<p>2、怎么展示</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/微信界面.png" alt="微信界面">
</div>
</div>
<div class="paragraph">
<p>比如这是微信的对话框。然后下面这个地方是语音的那个符号啊，这个地方你打了文字。我打个比方，你最开始，你发了一个文字信息X给他。那么是你发的你在左边，然后左边这个是你发的文字，然后他又回了一个文字给你，比如这是y，这个地方数据结构包含两大类，第一类是他在网络上怎么去传输，就是你要配合算法去组合它，存储的一种结构，叫存储结构。存储数据结构，全称就叫这个，但这最前面一定省略了某个东西嘛，他一定是数据结构里面细分的东西嘛，所以他那里面有一种叫存储，就是说你文字怎么让他收到。在你看不见的领域，对吧？在网线上，或者在你的wifi上面流淌着那些数据流，这也有数据结构嘛，然后第二种就是说他收到过后，他怎么把那个信息展示出来让他的用户看见，他是在两大类，所以这个时候他要把用存储结构又转换成一种显示结构，然后最后就显示了屏幕上了，但是你在网线传的时候有可能携带了其他的杂七杂八的东西对吧。</p>
</div>
<div class="paragraph">
<p>内在核心：</p>
</div>
<div class="paragraph">
<p>what is？       Answer——&gt;数据关系（描述物体）</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>结构体、类成员、数据表、List/Map、变量（这一类是做存储的，是程序内可见的）、Json/Xml/Html/Jpg(这一类是做传输的，是人类肉眼可见的)他们都是在描述数据怎么去展示的问题，都是在描述物体是什么。（描述物体本身或物体间的关系）。就比如你的姓名和年龄两个分开没啥问题。合在一起他也没问题，那你为什么合在一起啊？对啊，这个东西是你的。为什么我看到这个表单我就知道这是某某某。又比如说我们就只有一个字段，那个字段叫身份证号码，我就问你那身份证号码是不是能表示你啊。但是我说个性别男，他能表示你某一部分。他是在描述物体，为什么在描述物体，而不是描述事物？什么什么事情。比如说我吃饭这个事情你怎么了。去理解他的关系啊，你很难理解为什么他掺杂了很多东西，你用什么吃？对吧，你送嘴吃还是用。我也不知道用啥吃，对吧。你是用筷子还是用勺子，你用大碗还是小碗，你在哪儿吃？所以这个事情啊就是很麻烦。所以像这种数据结构啊，他通常描述的是客观世界里面具体某个东西，东西和东西之间的关系。</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>微信的数据结构</p>
</div>
<div class="paragraph">
<p>这个地方就是聊回微信这个话题啊，那么刚刚讲了微信的发文字信息和发语音是微信的使用场景，算法就是 <code>怎么</code> 去发送消息？数据结构就是发送 <code>什么</code>（Json、List、Xml、数据表）消息？（具体到某个物件比如说螺丝钉）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_编程要培养编程直觉">1.6. 编程要培养编程直觉</h3>
<div class="paragraph">
<p>同样是写代码，为什么你写的代码就是设计不好？就是因为你对这些理解不好，你对这些理解不好就导致你这个人是没有思维的。就好比在几岁的时候，特别是小孩子身上，特别明显，就是他们的逻辑思维非常好。为什么，他天天会问为什么，他一直在问这个问题。小孩子逻辑这样的，如果我哭就会有东西，我就一直哭，如果我哭不挨打，我就有东西吃，如果我哭又被挨打又没东西吃，然后If爸爸举手了，然后就不哭了。小孩子嘛，你看他们，他逻辑思维非常非常的强，为什么？你可以理解为他就是个状态机，就是看人下菜，看动作下菜，看眼神下菜，所以小孩子特别会看眼神。你长大了就不一样了我就不我偏不我就不干。那叫耍性子，你就已经没有逻辑思维了，要感情用事了。小孩子哪来感情呢？你就是天天喂他东西吃，你当宠物养，那是种食物关系，但是小孩子才出生的时候他一天到晚为什么嘛？对吧，他一天在干这个事情我怎么能拿到吃的。比如说那个医院，我举个例子的，那个孩子都哭的，都饿的呀，都一嘴哇哇大哭。然后奶奶抱起来，哄两下，他走到里面，走到里面走两个小时，饿晕了，当然就不哭啦。对吧，小孩子很简单的。怎么简单，哭了，要么是屎糊的屁股上屁股长红疹了。要么是肚子饿了，要么是哪儿扎着痛了，要么被蚊子咬了，对吧？做梦，他连魔鬼是啥都没见过。他做啥梦啊？对不对？他不可能出生就梦到魔鬼对吧？梦到观音菩萨下凡还是啥的吧，不会吧，对不对，所以你看到没有小孩子的概念真的很简单，他就是一个完全的生物有机体。他在按他的本能在去做这种反馈。比如小孩子被扎了，对吧？穿个衣服不舒服你一直动。关键是他才三个月或者才七天，他身都翻不了，你知道吗？就在那里啊啊啊的哭。然后呢，然后妈妈就说，再哭再哭给你两巴掌。相比真的说的话被扇了一巴掌挺痛的，那哭得更凶了，你放心，他会一直哭的，你打他，他会一直哭的。除非你把他打晕，那就不哭了。所以你看到没有？其实小孩子哈很小，他们他逐渐长长大，其实他逻辑思维是非常非常完整的，他也完整的逻辑念路。他有if else一堆。但随着你长大了过后你不会的。然后你身上我有吃的，我得先挣钱，而挣钱的话我先是卖屁股然后完蛋了。所以你就会把这个事情越想越复杂，其实很简单，没吃的嘛。你跑到商店面抢出来就有吃的了噻。你就被这个社会约定俗成的东西给框住了你的生物本能，你的人类本能就已经被限制住了。因为你有法律，或者有社会的道德约束。所以这个时候已经和他相隔十万八千里了，为什么？因为程序是没有道德的。他没有道德去约束他。他也没有爸爸妈妈，也没有感情，所以他就是个冰冷的机器，那一个冰冷的机器，你要怎么样成为个冰冷机器啊？就回到你还是个小娃娃小婴儿的时候。那个时候你就是冰冷的一个吃饭机器，天天要奶粉喝，你干饭机器就是那种这么养成的嘛。所以如果你要逻辑的话，小朋友的逻辑是更完整的。他更符合程序的直觉，所以你可以理解为你这个东西，最终你产这个东西叫程序直觉啊。程序直觉就是我刚刚举的这种，小朋友这种就是直接反应。没有过多的运算，凡是那种经过大脑社会道德，我该不该做这种运算已经和他不符了，所以你要培养的是程序直接这个东西。所以我刚讲的就是说，一旦你知道这些逻辑过后我打个比方，我以前我去学怎么编程的时候，我考虑的问题是。我点的那个按钮过后面发生了什么？我永远会去想根据那个按钮点了过后往后走，查查查查查。怎么通信的。我就一条链路就拉通了，但是这个需要大量的去写代码，大量的去试验。所以只要不删代码，啥都好办。所以像这个东西的话，就是你要靠去练。</p>
</div>
<div class="paragraph">
<p>但是这个地方你要经过大量的代码去练的话不现实，所以你一开始应该有浅显的认知。浅层次就可以了，你大概知道有那么回事。然后剩下就是你，当有这种直觉过后，你就开始去研究这种直觉。具体对应到现实世界或者你的软件哪一部分你去训练它。你去思考，你思考完了过后，那么你就会去补充你这边的这些理论。然后补充的越来越多，越来越完善，比如说最开始你学会的列表，最开始你学会的变量，A=1嘛，然后第二次，你又看到某个软件可以用，或者某个代码可以调某个demo，你可以研究一下，你研究完了就得到什么就得到list。像不像你某天打游戏的时候研究某个部件，然后他升华了，就变成一个战衣爆装备了。对吧，所以他也是这样一个过程啊，所以程序直觉，其实编程这个事情不是那么非常非常感性的编程它是有迹可循的。但是有迹可循它不是摆在明面上的，它是有一套训练方法，而60年代，70年代应该是linux ，unix，c语言发明出来，那发明除了到现在怎么去开发个软件，在业界都没有个统一的认知。你用a方法可以，你用b方法可以，甚至你不用方法也是可以的，就证明条条大路通罗马，就看你所学的哪一条，所以你培养程序直觉是怎么样？这个直觉的意思就是说，你从一个点到另外一个点，你清楚你的目标，所以第一个重点就是你清楚你的目标，我打个比方，我从成都到北京啊。我想从成都到北京，那是我的目标。我怎么去，所以说这涉及到方式的问题，开飞机还是坐火车还是走路？所以你的程序直接是这样的。你最开始训练出一种a方法，你可以达到这个目的，我觉得有个游戏嘛，就造桥嘛。那个桥你用的那个材料越少越牛逼，最开始你用1000个木头造出了桥，然后这个时候，你的效率就随着这个a方案，然后最后a+吧？然后就变成了a，然后效率更高，你的程序直觉是训练这个方法，而从a到a+这个过程，那么就是你的直觉训练。就直觉训练的过程，你训练完了，那么得到这个方法本身就得这个工具又爆了个装备嘛，那你说明掌握了一种技巧，所以你要不断的训练，反复，你可能这个方法不是最优的，你还要想办法去得到更优的。当然，具体写代码来说的话，你肯定就没有那么简单，你可能为了实现这个方法，你跟他学很多东西，那你清楚你的目标和方式。所以你训练的越多，那么你这个方法工具越多。比如说对于我来说，我的武器库里面就有各种核弹，各种常规战术导弹，各种狙击的子弹我流弹炮牌机炮都有，对于你来说你可能就小米加步枪，所以说你要让你的武器库里面越来越多。你武器库越多，那么你的威力越大，那这样的话你中你要想炸的那个房子是用核弹炸还是榴弹炸随便你挑？比如说我明天写一个javaweb程序，没关系，你用c也是可以写的。反正写个三个月嘛，就像用核弹去做了这个事情一样。然后你用springboot的去写，就像用榴弹炮去写嘛对吧。是不是然后有一天出现那个叫轻量级迷你springboot这就是迫击炮了撒，所以你的直接训练会决定你这个你的武器的多少，最终会达到某种目的，所以说你训练的越好。怎么样你的那个整个技巧，技能，技术栈就越靠近你的目标这个中轴线，你能最终你形成了这个线路啊，如果能够直捣黄龙就是最优解。</p>
</div>
<div class="paragraph">
<p>1、要清楚自己的目标。</p>
</div>
<div class="paragraph">
<p>2、要清楚自己的学习方式。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_BCTS2_chapter">2. 编程通识(二)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_2">2.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/编程通识(二)板书1.jpg" alt="编程通识(二)板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程通识(二)板书2.jpg" alt="编程通识(二)板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_2">2.2. 前言</h3>
<div class="paragraph">
<p>网络协议,如果要了解 <code>网络协议</code> ，首先得知道什么是 <code>网络</code> ，知道什么是网络过后，<code>协议</code> 自然而然就通了，最奇怪的是，还有第三个问题，就是什么是 <code>网络协议</code> 。</p>
</div>
<div class="paragraph">
<p>所以我们有3个问题</p>
</div>
<div class="listingblock">
<div class="content">
<pre> 什么是网络

 什么是协议

 什么是网络协议</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是网络">2.3. 什么是网络</h3>
<div class="paragraph">
<p>90年代有一本叫《TCP/IP网络协议》那本书，上面写的：</p>
</div>
<div class="paragraph">
<p><code>“现在有高达几百万台电脑连接在了一起。”</code></p>
</div>
<div class="paragraph">
<p>最开始计算机两两相连，但是两两相连毕竟是很原始的状态，只能单向通信，而不能让两台计算机相互通信，现在发明出了计算机，但是很早之前并没有交换机的概念，就说白了先有网线才有了交换机，不可能发明一个交换机，发现没有东西连接，然后才发明网线，这么看来就觉得很怪。</p>
</div>
<div class="paragraph">
<p>举个例子</p>
</div>
<hr>
<div class="paragraph">
<p>如果没有电视机，就没有现在的安卓电视，如果说先发明安卓，才有安卓电视，这不可能吧。
所以说不用去查，肯定是先有了网线，才发明了交换机，因为为网线更简单，不过还是只能单向通信，但如果两个计算机想要互联怎么办呢？那这种网络拓扑就不够成熟了，所以我们在聊网络的时候，肯定讲的是 <code>互联网</code> 。</p>
</div>
<div class="paragraph">
<p>讲到了互联网，它的起源是美国国航部，当时美国国航部赞助了一个叫网络网际连接的项目，通过引入一个交换机，大家都连到这个交换机上去，那这样的话就形成了 <code>网络</code> 。美国人把网络取名为 <code>“NetWork”</code> ，那么这个Net就是网的意思。</p>
</div>
<div class="paragraph">
<p>网络，英文是：Network，上面说的互联网是美国国防部发明的，从广义上来讲，网络就是美国人发明的，取名叫Network，其中Net的意思就是网络，蜘蛛网不就是Nat。</p>
</div>
<div class="paragraph">
<p>从纯小白的视角可以这样来理解这个单词，就是一个网，可以理解每台电脑都是walker，那么网上就有很多worker，然后他们最终组成一张网， 最后统称就叫NetWork。</p>
</div>
<div class="paragraph">
<p>以此类推，每台计算机都是矿机,很多台矿机最后组成了矿网，</p>
</div>
<div class="sect3">
<h4 id="_互联网与万维网">2.3.1. 互联网与万维网</h4>
<div class="paragraph">
<p>万维网和是互联网区别在哪，万维网能称为万维网，万维网就只作用于浏览器输入网址或者和网页产生关系的地方，只要和浏览器扯上关系的都是万维网的一部分，但是国防部最开始发明的可不是万维网。最开始发明的是Network，所以万维网属于NetWork的一部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_补充学习编程到底在学习什么">2.4. 补充：学习编程到底在学习什么？</h3>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="listingblock">
<div class="content">
<pre>变量a=1
变量b=3
变量c=a+b
那么C的值是多少</pre>
</div>
</div>
<div class="paragraph">
<p>这道题是一道编程题也是一道数学题，它们没有本质的区别，所以可以说编程和数学是紧密联系在一起的，不过它们有对与世界着不同的理解。</p>
</div>
<div class="sect3">
<h4 id="_数学">2.4.1. 数学</h4>
<div class="paragraph">
<p>举个例子嘛
小时候学的加减法，在生活中可以用来买菜，乘法或者除法也是可以的，到了六年级，就开始学代数，到了初一初二就开始学几何，到了高中，等差数列，还有很多更高级东西，其实它们都是来源于生活。数学家，一代一代传承然后经过几百年的发展，他把自己看的某种现象给总结出来了。甚至前几年，浙江大学有篇论文叫博弈论，这个博弈论就研究石头剪刀布的事儿,还花了国家的钱去研究，但是普遍人都认为：“这个东西都要研究？简直不可思议。”但是研究人员就真的通过总结一系列规律后,总结出石头剪刀布的时候怎样才能提高你的胜率,当某天你和别人石头你看论文过后，你能够达到目的。</p>
</div>
<div class="paragraph">
<p>再比如说， <code>万有引力</code> ，如果苹果有砸到头上，普通人肯定不会想到万有引力，可是牛顿就想到了。</p>
</div>
<div class="paragraph">
<p>现在的数学家甚至黑洞都能计算。</p>
</div>
<div class="paragraph">
<p>从上面的例子就可以看出，数学更多的是总结规律，那么数学就是 <code>对客观世界的规律或者事物的一系列的总结</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_编程">2.4.2. 编程</h4>
<div class="paragraph">
<p>那么编程呢？
编程其实就是我们经常讲到编程编程是某某件事情，并不是指代某个东西。
那么 <code>编程为动词，数学为名词</code> ，和数学对等的叫做程序。</p>
</div>
<div class="paragraph">
<p>上面数学是总结世界的运行规律，程序呢？先偷换个概念，我们先给程序这个东西进行归类，每当我们看新东西，不知道他是啥 ，就会去对他进行归类。那程序，首先他应该是某种工具。 那人类用工具是干啥的呀？
远古时期，原始人第一次发现可以用锋利的石头，给自己做一件大衣，貂皮大衣；用火烤的肉更香，除了肉更香以外，吃了还不会拉肚子，还可以长寿，估计最开始有人吃生的，有人吃熟的，结果发现，吃熟的人到活到了30岁40岁，而不吃熟的拉肚子死掉了 。所以说工具的是和效率挂钩的人类发明工具或者是找到某种工具或者制作工具，一定是为了自己服务的 。那程序也是工具，所以说程序也是用来提高人类的工作效率的，那么，它是怎么提高工作效率的呢？
程序首先是代替人类完成工作的，程序的速度很快，这里的速度就有两层意思，那么第一层更快说是指的 <code>计算速度快</code> ，那第二层意思更快，意思说，下一次程序要做同样的事情的时候，就只是把程序拿出来跑一遍，就像洗碗一样，第二次拿个洗碗的刷子，就指的 <code>重复使用</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是协议">2.5. 什么是协议</h3>
<div class="paragraph">
<p>我们先把上面讲网络的概念放下来，就是很多计算机中间一个交换机的例子，我们将这个例子里面的计算机代换成一个个小人,假设那是atm机里面小人，那里面的小人在干啥？他在里面工作，那么每一台atm机之间或者人之间，他们都有相互联系，这样就组成了一个 <code>人际关系网</code> ，他们之间相互联系，但是我们没有交换机，就把空气当做交换机，人与人之间交流也是靠空气来传播的，那么空气就是人与人“连接”的一条线,连接的主要作用就是传递信息，那要怎么才能把信息传递出去呢？在人与人之间传递信息主要依靠的是语言，所以语言就是传递信息的主要方式，语言之下也有不同的实现方式，比如语音，字等等，但是语言还是要就借助“连接”，连接可以理解为更大层次，它就是一个 <code>工具</code> 的载体，那连接这类 <code>工具</code> ，你要要用说话的方式，要用一种语言的方式让他生效，</p>
</div>
<div class="sect3">
<h4 id="_举个例子">2.5.1. 举个例子</h4>
<div class="paragraph">
<p>一个婴儿在咦呀哇的乱叫的时候，你是听不懂的，你不知道他在叫什么，为什么？因为你不是婴儿，你的语言系统已经成熟了，不知道他的婴语究竟代表什么东西。在07、08年的时候，有个视频超级火，两个光头的外国人小男孩，才学会走路，也就就一岁多一点，两个人穿的小baby的衣服走来走去的，当他们走到厨房的角落，其中一个婴儿把袜子脱下来，闻了一下，就开始哇哇哇哇的叫。而且最关键是视频长达67分钟。叫完过后，其中一个小男孩走过来把冰箱打开，接着就开始咦呀哇的，然后另外小男孩就走过来了，这样证明他们之间是有沟通的，但是你听不懂。 所以这个时候他们之间的婴语，对于他们来说，是生效的，对于我们来就没有办法理解一致，那么这个时候他们的语言对你来说是无效的，所以上面我们在人际网络里面就需要使用共同的语言来通信。</p>
</div>
<div class="paragraph">
<p>语言其实就是 <code>工具</code> ，那么 <code>连接</code> 要承载信息嘛，还要信息要流转，那就是协议咯
在网络上面都有计算机，有计算机过后，就会产生数据，但网络上肯定不止一台计算机，现在假设有两台计算机，就会产生数据A(Data A)和数据B(Data B)两个数据，产生了这两个数据过后，因为数据产生就会传递给对方那么就有起点和终点 ，那么他们之间相互连接的网线就是数据的 <code>载体</code> ，但这时载体发送数据它并不能听懂，所以还差一个东西，就是 <code>协议</code> ,平时也叫通信协议。
那这时候在网络就有几类大的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>计算机、数据空间、协议、网线</pre>
</div>
</div>
<div class="paragraph">
<p>网线就是通信协议流淌的载体，是通信的基础条件，是硬件，计算机也是硬件，而协议则是软件，在下图</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/网线里有什么.png" alt="网线里有什么">
</div>
</div>
<div class="paragraph">
<p>Computer A要向Computer B发送数据，上图就是根网线，网线就相当于高速公路，外面的皮是网线皮，这皮里头有同心线，这个时候呢里面肯定还流淌着协议(网络语言),里面充斥着Data A一直流，发送到Computer B后返回的数据就是Data B，严格意义上来讲的话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>网线就是一条高速公路，上面有两个方向，高速公路你开过去的时候，产生Data A，到达Computer B后产生Data B返回回来，这个时候Data是指数据0101，但是如果要让双方都能听懂，就必须带语言格式(协议)</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是网络协议">2.6. 什么是网络协议</h3>
<div class="paragraph">
<p>网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</p>
</div>
<div class="paragraph">
<p>这里的网络就是指流淌在操作系统内部的东西（OS内）</p>
</div>
<div class="sect3">
<h4 id="_协议">2.6.1. 协议：</h4>
<div class="paragraph">
<p>协议其实跟语言一样，语言有中文、英语、西班牙语等。</p>
</div>
<div class="paragraph">
<p>TCP/IP协议：TCP（传输控制协议）和IP（网际协议）</p>
</div>
<div class="paragraph">
<p>TCP/IP提供了点对点链接的机制，将资料应该如何封装、寻址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，分别归属到这四个层次结构之中[7][8]，常视为是简化的‘七层OSI模型’。</p>
</div>
<div class="paragraph">
<p>七层OSI模型：</p>
</div>
<div class="paragraph">
<p>第7层 应用层
主条目：应用层
应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p>
</div>
<div class="paragraph">
<p>第6层 表示层
主条目：表示层
表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
</div>
<div class="paragraph">
<p>第5层 会话层
主条目：会话层
会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p>
</div>
<div class="paragraph">
<p>第4层 传输层
主条目：传输层
传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>
</div>
<div class="paragraph">
<p>第3层 网络层
主条目：网络层
网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p>
</div>
<div class="paragraph">
<p>第2层 数据链路层
主条目：数据链路层
数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
</div>
<div class="paragraph">
<p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p>
</div>
<div class="paragraph">
<p>第1层 物理层
主条目：物理层
物理层（Physical Layer）在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p>
</div>
</div>
<div class="sect3">
<h4 id="_tcp子集_httpftpudptcpsmtppop3imap">2.6.2. TCP子集 （HTTP、FTP、UDP、TCP、SMTP、POP3、IMAP）</h4>
<div class="paragraph">
<p>HTTP：超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的。</p>
</div>
<div class="paragraph">
<p><a href="http://XXX.com" class="bare">http://XXX.com</a></p>
</div>
<div class="paragraph">
<p>ssh://XXX.com</p>
</div>
<div class="paragraph">
<p>比如说一个连接有两个点:</p>
</div>
<div class="paragraph">
<p>server————————client</p>
</div>
<div class="paragraph">
<p>连接是由client发起的，就有了客户端跟服务端的概念，客户端上用的通信是HTTP协议，里面又包裹了HTML。</p>
</div>
<div class="paragraph">
<p>FTP：文件传输协议（英语：File Transfer Protocol，缩写：FTP）是一个用于在计算机网络上在客户端和服务器之间进行文件传输的应用层协议。文件传送（file transfer）和文件访问（file access）之间的区别在于：前者由FTP提供，后者由如NFS等应用系统提供。</p>
</div>
<div class="paragraph">
<p>UDP：用户数据报协议（英语：User Datagram Protocol，缩写：UDP；又称用户数据包协议）是一个简单的面向数据报的通信协议，位于OSI模型的传输层。在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。UDP适用于不需要或在程序中执行错误检查和纠正的应用，它避免了协议栈中此类处理的开销。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取</p>
</div>
<div class="paragraph">
<p>TCP：传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。用户数据报协议（UDP）是同一层内另一个重要的传输协议。TCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。操作系统将TCP连接抽象为套接字表示的本地端点（local end-point），作为编程接口给程序使用。在TCP连接的生命期内，本地端点要经历一系列的状态改变。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/SMTP,%20POP3,%20IMAP.png" alt="SMTP, POP3, IMAP">
</div>
</div>
<div class="paragraph">
<p>SMTP：简单邮件传输协议（英语：Simple Mail Transfer Protocol，缩写：SMTP）是一个在互联网上传输电子邮件的标准。SMTP是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过telnet程序来测试一个SMTP服务器。SMTP使用TCP端口25。要为一个给定的域名决定一个SMTP服务器，需要使用DNS的MX记录。在八十年代早期SMTP开始被广泛地使用。当时，它只是作为UUCP的补充，UUCP更适合于处理在间歇连接的机器间传送邮件。相反，SMTP在发送和接收的机器在持续连线的网络情况下工作得最好。</p>
</div>
<div class="paragraph">
<p>POP3：邮局协议（英语：Post Office Protocol，缩写：POP）是TCP/IP协议族中的一员，由1996年5月发行之RFC1939 首次定义。此协议主要用于支持使用客户端远程管理在服务器上的电子邮件。最新版本为POP3，全名“Post Office Protocol - Version 3”，而提供了SSL加密的POP3协议被称为POP3S。POP支持离线邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或Mac。一旦邮件下载到PC机或Mac上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。</p>
</div>
<div class="paragraph">
<p>IMAP：因特网信息访问协议（英语：Internet Message Access Protocol，缩写：IMAP；以前称作交互邮件访问协议）是一个应用层协议，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。</p>
</div>
<div class="sect4">
<h5 id="_pop3_smtp_imap的区别在哪里">POP3, SMTP, IMAP的区别在哪里？</h5>
<div class="paragraph">
<p>简单地说，SMTP管‘发’， POP3/IMAP管‘收’。</p>
</div>
<div class="paragraph">
<p>举个例子，你坐在电脑边用mail client写完邮件，点击‘发送’。这时你的mail client会发消息给邮件服务器上的SMTP service。这时有两种情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果邮件的收信人也是处于同一个domain，比如从http://163.com发送给163的邮箱，SMTP service只需要转给local的POP3 Service即可</p>
</li>
<li>
<p>如果邮件收信人是另外的domain，比如http://163.com发送给http://sina.com， SMTP service需要通过询问DNS, 找到属于sina的SMTP service的host。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SMTP service收到邮件后转给负责接收邮件的POP3 service</p>
</div>
<div class="paragraph">
<p>POP3 service和IMAP的区别主要是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POP3是比较老的protocol，主要为了解决本地机器和远程邮件服务器链接的问题，每次邮件会download到本地机器，然后从远程邮件服务器上删掉（当然特殊config除外），然后进行本地编辑。这样的问题是如果从多个终端链接服务器，只有第一个下载的能看到，现在pop4正在讨论中</p>
</li>
<li>
<p>IMAP是比较新的（好吧，好像也是80年代的产物）protocol，可以将邮件分文件夹整理，然后这些信息也存在远程的邮件服务器上，读取邮件后，服务器上不删除。原理上IMAP应该是相当于oneline编辑，但现在的mail client基本都有在本地存copy的功能。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ip子集icmparp">2.6.3. IP子集(ICMP\ARP)</h4>
<div class="paragraph">
<p>ICMP：互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。ICMP [1]依靠IP来完成它的任务，它是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了 ping 和 traceroute 这两个特别的例子。 IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6。</p>
</div>
<div class="paragraph">
<p>ARP：地址解析协议（英语：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。ARP也可能指是在多数操作系统中管理其相关地址的一个进程。ARP是通过网络地址来定位MAC地址。</p>
</div>
<div class="paragraph">
<p>VPN（企业内部协议）:虚拟私人网络（英语：virtual private network，缩写：VPN）是常用于连接中、大型企业或团体间私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到发送端认证、消息保密与准确性等功能.</p>
</div>
<div class="paragraph">
<p>例：一个员工出差想访问公司的局域网，他就要进行拨号，打开软件才行，VPN 就会帮你虚拟一张网卡出来，一旦拨号了之后就会有一个IP地址，如果没拨就是没有IP地址的，没有IP地址就不能上网，就不能上公司的局域网。</p>
</div>
<div class="paragraph">
<p>网络协议就是指的这上面的东西。</p>
</div>
</div>
<div class="sect3">
<h4 id="_要理解计算机世界是怎么运行的非常重要">2.6.4. 要理解计算机世界是怎么运行的非常重要！！！</h4>
<div class="paragraph">
<p>一旦你理解了这个过后，你去学很多其他的东西就ok了，比如说有一天，你遇到企业内部的软件出问题了。你没有见过他，难道你就不知道他是怎么回事吗？</p>
</div>
<div class="paragraph">
<p>举个例子：</p>
</div>
<div class="paragraph">
<p>某一天，公司里面的的出纳小姐姐找到我说帅哥能帮我看看吗？她说电子税务的那个软件打不开。当然我帮他解决打不开这个问题，解决了五花八门，最简单的就是经过我一顿骚操作，我就蹲下去插了下网线好了，结果是因为那个下面线太多，小姐姐踢到了，网线就踢松了，他那个网口不牢就踢松了。但是没有开机这种事情我就不讲了，那他自己能解决。我遇到了我跟他解决过很多次这种他那个软件打不开的问题，为什么因为在她的概念里面，电子税务软件出问题了，问题很严重。对吧，但在我的理解里面，这个计算机出什么问题了？然后才是软件，我要先排除计算机有没有问题？对吧。你连windos网络都不通，一上来。Alt+R 输入 cmd，一个黑色窗口，ping一个qq.com然后回车，网络不通，插一下网线好了。</p>
</div>
<div class="paragraph">
<p>你会发现我其实我不懂那个电子记账系统，我也不清楚，但是别人为了为什么遇到问题老去找我为什么，因为我很清楚计算机出什么问题了？我不会被错误迷失了双眼。所以要理解计算机是怎么工作的，他是怎么运行的，非常非常重要。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_XMSZ1_chapter">3. 项目实战(一)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_3">3.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/项目实战（一）板书1.jpg" alt="项目实战（一）板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/项目实战（一）板书2.jpg" alt="项目实战（一）板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_3">3.2. 前言</h3>
<div class="paragraph">
<p>这篇随笔会穿插很多项目，因为讲太多，不动手的话手会生。</p>
</div>
<div class="paragraph">
<p>C01讲的是 <code>Radis</code> ，是一个很复杂的系统，因为当时所有成员都已经有编程经验了，所以就上了一个看起来高大上的一套框架和组织架构。</p>
</div>
<div class="paragraph">
<p>C02的话做了 <code>GeeShow</code> ，属于一种中型项目，有简单的地方，也有技术挑战，然后他也有就是很复杂的理念，至少在市面上见不到第二个，</p>
</div>
<div class="paragraph">
<p>那这次C03的话，就是做一个Linux监控系统。</p>
</div>
</div>
<div class="sect2">
<h3 id="_项目背景">3.3. 项目背景</h3>
<div class="sect3">
<h4 id="_常用监控软件">3.3.1. 常用监控软件</h4>
<div class="paragraph">
<p>监控系统其实在Linux平台或者服务器里并不少见</p>
</div>
<div class="paragraph">
<p>比如说现在已经有:</p>
</div>
<hr>
<div class="paragraph">
<p><code>Zabbix</code></p>
</div>
<div class="paragraph">
<p>由Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。可用于监视各种网络服务、服务器和网络机器等状态。</p>
</div>
<hr>
<div class="paragraph">
<p><code>Cacti</code></p>
</div>
<div class="paragraph">
<p>一种基于Web的开源网络监视和绘图工具，设计为开源的，行业标准的数据记录工具RRDtool的前端应用程序。</p>
</div>
<hr>
<div class="paragraph">
<p><code>Nagios</code></p>
</div>
<div class="paragraph">
<p>电脑系统和网络监控程序，用于检测主机和服务，当异常发生和解除时能提醒用户；是基于GPLv2开发的开源软件，可免费获得及使用。</p>
</div>
<div class="paragraph">
<p>这些都是比较常见的监控软件，这些软件主要就是把服务器的CPU带宽、硬盘、内存、进程数还有很多其他东西通过统计分析的方式，画成图表展示出来，既然这些软件能生成图表，就意味有数据库，如果没有数据库就无法生成图表。</p>
</div>
<div class="paragraph">
<p>至于数据库，用常见的 <code>关系型数据库</code> 或者存储到文件里面的 <code>纯XML</code> 都没有关系，因为最终都能读出来。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_它们存在的问题">3.3.2. 它们存在的问题</h4>
<div class="paragraph">
<p>上面的软件都集中解决的是一个问题，第一个问题就是它的覆盖面是比较通用领域，那么它们是用来解决通用领域，既然是解决通用领域的问题，那就意味着他们就是 <code>同质化</code>，但同质化解决问题就相对的比较之后。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>同质化：指同一大类中不同品牌的商品在性能、外观甚至营销手段上相互模仿，以至逐渐趋同的现象</pre>
</div>
</div>
<div class="paragraph">
<p><code>举个例子</code></p>
</div>
<div class="paragraph">
<p>公司的服务器老死机，然后工作人员查死机的原因，当他查不出来具体的原因，他就通过监控软件，监控软件可能显示CPU有异常，但是并不清楚具体是哪个地方出了问题，比如说看到CPU占用100%，然后监控软件给你提供一个线索，所以说用这种监控，他可以帮你解决问题，但是从强哥的从业经验来说，我解决这种疑难杂症问题，从来不依赖他们，为什么？因为他们都一样，你比如说像宋波峰，我没有让他搭过监控软件，我也没有让黄臣玉去搭监控软件，我也没有让卢宇去搭，我也没有让李喜去搭，为什么？因为这种东西装着玩儿就可以了，这个东西本来它就不重要，因为他只是给你提供一个 <code>线索</code>，那既然你能提供线索，那么在CPU超温或者僵死的时候，系统日志里面已经提示你cpu冻住、卡住了，那么系统日志里面已经提供了线索，就不需要跑到监控的软件上去看它生成的图形，然后有人就说：“图形很好看，日志不好看。”那既然都去解决问题了，肯定也不在乎友不友好，因为你有那个能力去查日志，日志才是追根溯源最好的东西，相反图形这些东西，他只是起个辅助作用，所以他不是决定性的，是通用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_项目背景_2">3.3.3. 项目背景</h4>
<div class="paragraph">
<p>现在Linux可是 <code>巨量的</code>（都不是说大量的）在使用，他是 <code>服务器领域的事实标准</code>，尽管我们会讨论说CentOS好还是Ubantu好，但是从来没有讨论过Windows和Linux该选谁？</p>
</div>
<div class="paragraph">
<p>在我才开始学习Linux那一段时间还充斥着一种说法：“Unix更稳定，Linux不稳定。”但是我从来没有在任何一台服务器上面去装过Unix，因为最开始我在自己的PC上装Unix，发现要装上它是个艺术活，为什么？因为它里面不带驱动，驱动都要你自己弄，最关键基本市场上的驱动都适配的Linux，Unix由于版本还有各种东西都很老，当然也有新的，不过大部分情况下厂商并没有进行适配，这个时候，你要去解决各种各样非常奇怪的问题，那既然我用操作系统目的就是因为我不能写底层的东西，那现在你都让我介入到你的内核里的驱动层面去了，这样不就和我自己写驱动没有什么本质的区别，所以对于系统优先选择就应该是一个成熟标准的系统，那么Unix和Linux相比，那肯定是Linux，这是其一，其二就是Linux和Windows根本就没可比性。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_还有哪些领域在用linux">3.3.4. 还有哪些领域在用Linux？</h4>
<div class="paragraph">
<p>上面说到“Linux已经成为服务器领域事实上的标准了”</p>
</div>
<div class="paragraph">
<p><code>打个比方</code></p>
</div>
<div class="paragraph">
<p>在手机上随便打开一个软件，哪怕是微软的Office365，他的服务器肯定是跑在 `Nginx`下面的，既然都跑在 `Nginx`下面，那么搭建在Linux上就很香，微软有个语音叫Azure，Azure的平台，最开始只卖微软的云，那就只用于微软的Windows，结果过了几年都没起色，直到微软换了一个印度的CEO，这个人推从开源，上一届是鲍威尔和比尔盖茨他们两个在主事，然后他们两退了，他们退了后那就是印度的CEO在主事，那个CEO是一个财务和市场营销出身的，他就只关心钱，他并不关心技术或者生态层面的东西，所以在很长一段时间里微软在开源领域说Linux是毒瘤，就因为Linux抢占了Windows市场份额了，可以想象微软当时是敌对的态度，之后印度的那个CEO上台了，叫萨提亚·纳德拉，他上台就开始推行政策，让微软全面拥抱开源生态，首当其冲的成为了Linux核心基金会的成员，其实要成为Linux核心基金会会员很简单，拿钱买就行了，告诉他我要做这个事，他就会让你进，当然，微软后面夹带私活要想在内核里面加入他的exFAT文件系统，然后Linux大声说Get out，为什么？因为那个东西和你Linux没有半点关系，都是微软的私货，我给Inte说我的CPU有漏洞，我要为了几个漏洞加第二个补丁，不过这个补丁也是一个漏洞、后门，求求Linux让他加进去，然后你Linu也对他说Get Out。所以想加入Linux生态，给钱就可以了，但是你真正想参与其中，你必须要做对社区和生态有益的事情。那之前说的Azure这个云平台，他后面也支持Linux了，自从发现支持Linux后生意大大的好，微软甚至自己的东西都架在了Linux上面。包括他的官方网站，还有IIS、webserver，结果他自己都不用，他用Nginx做前端负载，后端IIS，这也无所谓。这就证明一个问题啊，在负债均衡和反代领域，Nginx才是绝对的王，绝对的流量入口。那看到Nginx也是跑在Linux下面的，你不可能跑个Windows下面，在Windows下面性能贼差，为什么？Nginx官方说在windows上是实验性的，支持很差的，那就是个玩具，谁用谁知道，那这是一个，那微软后面还做了Open JDK，他也开始支持自己的发行版了。</p>
</div>
<div class="paragraph">
<p>微软的发行版名字贼怪，表面上看起来Windows应该是绝对数量的，但实际上在 <code>重要的领域</code> 和 <code>头部</code>，Linux更占数量。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_什么叫头部">3.3.5. 什么叫头部？</h4>
<div class="paragraph">
<p>在服务器用的最多的那些厂商里头100%的都是Linux，不否认说尾巴后面有时候中小企业，小微企业，他们没有能力去用Linux，就会用windows，比如说像那个万科这种房地产的，没有任何技术含量，跨界他需要有一些服务器来做它内部的云或者软件，那他肯定会装windows，所以Windows是肯定有的，而且数量还不少，但是头部才是决定你找工作的或者是从业人员选择的一个重要因素，尾巴上那些顺带会一下就可以了，在这个行业里面，Linux绝对是服务器领域的事实标准，只是大家都在用发行版吵架，但是不妨碍他是Linux。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_linux存在的问题">3.3.6. Linux存在的问题</h4>
<div class="paragraph">
<p>Linux用的多了后就存在 <code>管理问题</code>，操作系统都是需要维护的，比如说：</p>
</div>
<div class="paragraph">
<p><code>安全补丁</code></p>
</div>
<div class="paragraph">
<p><code>版本升级</code></p>
</div>
<div class="paragraph">
<p><code>发布新版软件去迭代</code></p>
</div>
<div class="paragraph">
<p><code>流量大了过后还要去做各种调整或者策略</code>、</p>
</div>
<div class="paragraph">
<p><code>通过Debug找哪个地方慢</code></p>
</div>
<div class="paragraph">
<p>比如说在中小企业里，他们写的程序很慢，但是慢的问题都是有本质共通性的原因，具体原因也不知道，反正就是各种各样的问题，每个操作系统上都有这种需求，那么Linux也不例外，数量越多，存在管理的问题就越多，比如说华为或者富士康，郑州、东莞的富士康工厂一个就有几十万人，这么多人，就存在各种各样的宿舍管理问题，时不时就跳个楼啥的，就算里拉上了蜘蛛网，你一跳跳到网上能接住几个是几个，没接住就都死翘翘了，至少还有赔偿金，所以这就成为了管理问题，人多了过后要管理人，那么软件多也要管理软件，那操作系统也是软件也需要管理，这种问题一旦出现，无法解决，那么这个时候就提出了管理的要求，那么管理的需求是存在的，那之前在最开始讲过的哪些已经有的监控软件，它们都有一种通用性，并不能解决企业当中的问题，为什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

企业的老板，他已经知道了这个服务器已经死过3次机了，那他现在要解决问题，什么问题？ “服务器为什么会宕机？”这是一种场景，但是如果你连用户都没有，死啥机呀。</pre>
</div>
</div>
<div class="paragraph">
<p>所以在死机之前，还有一个阶段，</p>
</div>
</div>
<div class="sect3">
<h4 id="_起步阶段">3.3.7. 起步阶段</h4>
<div class="paragraph">
<p>这一阶段就是企业从零开始做，企业老板需要了解他的用户数据，而系统管理是一个消耗性岗位或者消耗的事情需要去做的，但这种消耗对于企业的就是投资方或者老板，他并不关心，他最关心的是他能 `收入`多少。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你告诉一个老板说：全中国政府，他们都有各种招标，我写了一个爬虫，我把所有的招标消息通过爬虫爬到了我的平台里，每个月花500块钱订阅我的邮件，我会自动把全国的招标信息发邮件推给你。这样只要去找到你的客户，他绝对会买，因为相比于人情事故、打电话还要请吃饭维护关系来说。你这样的话至少能给他更多的机会，他都不知道，那个地方要招标，那个标就和他没关系。他一订阅了你的平台，他就知道那个地方有标了，比如说：政府强制规定，招标必须向外公布，那比如说你是市长啊。其实那个网站上已经发了，但假设我作为一个土豪，我就会直接问“市长，最近有什么生意可以做呀？”然后市长说“我们最近有个招标”</pre>
</div>
</div>
<div class="paragraph">
<p>那么这种是靠人际关系才知道招标的消息，但是搞技术的人就应该看网站。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

我的老家要拆迁，其实拆迁的消息我早几年前就知道了，但是那个时候我非常清楚他处于规划阶段，为什么？因为当地规划局网站上明确的写着规划是多久到多久，甚至某个地方修机场，我比新闻还提前知道，三天两头去看那个规划网站，因为国家规划局只要定版了就开始是进入后续阶段，要是规划都没做，就不用考虑了。</pre>
</div>
</div>
<div class="paragraph">
<p>我们搞技术的，就要用技术的方法去解决问题，而这个市场上的需求方或者老板，他们只关心收入，他不会关心你帮他节约了多少块钱，他觉得只要挣500块我就不关心那节约的500块，因为挣500块属于流动资金，而节约500那不叫流动资金，和支出是不一样的，流动资金能从一个人的钱包流到另一个人的钱包，那你们两个都有500块钱收入，你们两个加起来收入1000块钱，但是如果这种问题一旦出现，少给一个人发了500块钱，那就叫节约开源截流，看起来，大家都不高兴，为什么？因为一个人少收费500块钱。</p>
</div>
<div class="paragraph">
<p>所以这种暴露出的问题啊有几类，第一个那么当用户在项目的初始阶段或者起步阶段，最重要的是了解自己的发展状态、运营状态，这个地方范围会很大，具体来说我的运营状态里面包括我向市场投了广告，那广告的点击量是多少？我投了电梯广告或者是那个电视广告哈，我的完播率或者是观看量是多少？还有每天客户打进来的电话数量是多少？那么有了数量过后有成交率，就是打了电话里面的人有多少人买了我的东西，这就叫成交率，那我得了解我的成交率是多少？成交率有了过后还有退货率，最近鸿星尔克电话都被打爆了，火了之后销量是直接往上涨，最后自己的工厂实在顶不住那么大的订单量，那么就只能退款一些，所以这些老板都很清楚，这些都是人类社会存在几千年的规则了，不需要你去加工，专业的人比你还专业，但是现在已经步入信息化社会，那就意味着这个过程中肯定会用很多软件，这些软件里面订单量，他可以从后台看到的，所以也不需要你操心，反正那个收钱和你没关系，但是有个问题，你那么多订单量到了你的服务器上面，你服务器什么状态啊？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

如果你是京东的老板，你想知道每天多少人浏览你的网站，怎么解决？</pre>
</div>
</div>
<div class="paragraph">
<p>现在做法就是挂一个百度的JS文件在网页的最下头，每当有人访问你的网页的时候也会访问百度那个JS，那么服务器上就会产生一条Web日志，百度就用那个日志来做分析，不过这个已经技术很成熟了，一二十年了，不过还有个问题，这个只是解决了运营里面比较前端的事情，就是眼睛能看得见的那一部分，而眼睛看不见的那部分是从用户发起请求到服务器上后到底发生多少事情？前端肉眼能看得见的那一部分你都很了解，各种各的地方都可以让你看，但你并不了解服务器上的东西，你非常清楚用户从哪来到哪去，甚至用户的性别，电话号码都有，但你就是不清楚你自己的系统，以及整个运营过程的状态，所以这是个很严重的问题，这个问题在十年前就存在了，十年后的今天还没解决好。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

比如说你买了阿里云，阿里云上面有个东西叫监控面板，成功的代替了这个玩意儿，但是出问题死机还是得死，最离谱的就是在阿里云的服务器里你啥都没干，安安静静的放着，结果某天三更半夜CPU突然跑上去然后服务器死掉了，第二天找到客服沟通，沟通了半天，客服给你回复说“亲，我给你换台服务器好了。”刚换没几天，那个服务器的用户又塞满了结果又死掉了，你又得联系客服换服务器，最后你去投诉了三次，阿里云直接把你迁移到一台稳定的服务器上面，终于不出问题了。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个问题就在于自己对自己所拥有的资产不清楚，到现在为止，大家都没有意识到这个严重的问题，这可不是说CPU跑了多少，那可是用户访问你网页访了多少？他产生了多少个查询？你都不清楚。</p>
</div>
</div>
<div class="sect3">
<h4 id="_补充为什么程序员的工资比传统行业高">3.3.8. 补充：为什么程序员的工资比传统行业高</h4>
<div class="paragraph">
<p>那我们现在要做个东西他并不是一个完整的监控系统，我打个比方，为什么程序员的工资比传统行业高吗？</p>
</div>
<div class="paragraph">
<p>设想一下工人在工地上扎钢筋，每天扎多少个灌水泥的小笼子，还有一根一根的钢筋，一根多少钱？但是老板是不是大概知道一个人一天能扎多少多少根吧，所以他请个小工，给他五块钱，计件，你在服装厂上班，在店富士康上班，也是计件，那么计件就意味着工资低，为什么吗？计件意味着你的工作和你的价值是可以量化的，当一个人的价值可以量化过后，那么资本家可以资本家可以剥削任何人，但是当你的劳动价值是明码标价，那就会被砍价。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

老板就知道行情价五块钱一根，但老板可能出四块五但还是有人做，所以他是可以砍价的，但是找个程序员帮你做个软件，你也不知道他的标价是多少，你就问他，你们一般做这个多少钱的？程序员心想：“正常来说我要花三个月，但是我不能报低了给他砍价，所以他心里面想的是4万但是给老板说的8万，然后老板心想，我得还价，但是老板发现还了价后对方就不理他了，第二次老板学乖了，他就不还价了，他就会说：“你这开发要多久啊”。那么如果老板砍价成功，那么将面临个第二个致命问题，老板砍价是砍爽了但是要求的功能，程序员也砍的可爽了,这就叫“上有政策，下有对策，我看需求”如果老板不砍需求还要原价，程序员就想“老板的给5万又不能砍需求怎么办？”缩水呀！任何异常都不管，</pre>
</div>
</div>
<div class="paragraph">
<p>所以说在计算机领域是生产力说了算，可不是甲方说了算，但凡甲方说了算的计算机项目，他已经被明码标价，已经被定价了。这个钱摆在那你这爱要不要，就比如说政府的项目，但是除了这种甲方强势的项目以外，你到自由市场上，你找个程序员给你开发500块钱的系统，对方骂你是傻子，就是因为不能被定价，所以程序员工资高，创新能力是一方面，它有科技含含量，最重要的原因就是不能定价，一旦程序员的工作能够被定价过后，就能批量的从学校培养，直接进企业上班写代码，对日外包就是怎么回事，但是那种模式有严重的问题，什么问题？创新能力严重低下，他不符合这个行业的价值观和驱动能力，为什么这个行业是一直在创新的？而这种定价和计件的方式，他只能解决已有的问题，但是这个行业已经经过了20年的发展已经有了翻天覆地的变化，日本的那一套已经被严重的抛弃了，理论也过时了，那么这个时候，还要用这种方式去打通其他的方式来做定价这种？也要考虑一个问题：“他多久能够过会过时？”那么 <code>程序员的工资高，很很大一部分是因为它的生产力不能被定价.</code></p>
</div>
<div class="paragraph">
<p>而现在老板面临手的问题就是：“虽然我不不需要定程序员的价格，但是老板要知道程序员做出来的系统到底产生了多少的交货、查询、带宽或者是花费的时间，因为这样就意味着老板可以对系统的算力量进行定价和标定。”</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

服务器上的是一个1Ghz的CPU，那么按我之前监控的数据来看的话，在1Ghz的CPU上，我的系统去跑最高的话大概能够同时跑到100个人，这样的话，他就能大概预估，那么如果我把CPU加到2Ghz ，那现在我的系统至少能够跑100-150个人，具体多少可以去测试，可以再观察一段时间，然后就发现，1Ghz的时候是100个人，2Ghz是120人，4Ghz的时候是150人，</pre>
</div>
</div>
<div class="paragraph">
<p>所以他是能够通过观察得到一个数据，但是这个玩意并不能用数学算，因为太复杂了，里面包括的变量太多了，数学里要做的事情是可控变量，</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子：如果a+b=c，a和b的变量一直在变，请问怎么知道c的值，所以数学里面最重要的一点就是控制变量，要先把其中一个变量控制下来，所以数学里经常看见“假定a=1，那么b=偶数。请问c有多少种可能性？”</pre>
</div>
</div>
<div class="paragraph">
<p>看到没数学它在控制变量，但是在服务器领域或软件领域里，最大的问题就是它不能控制变量，虽然他是不能用数学算的，他太复杂了，可变因素太多了，所以要经过测试。但是有多少人访问，这个是肉眼就可以看出来的，所以在运营里面最大的一个问题就是不能对系统算力进行标定啊。</p>
</div>
<div class="paragraph">
<p>那么还有问题，第一个问题，企业不知道自己究竟可以承担多少访问量，</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方
老板现在知道在50个并发量的时候会出问题，那么要怎样全靠程序员去自觉排查代码，按行话来说，叫走代码，走代码的意思就是打开你的IDEA，然后从程序员个人觉得，举个例子，访问A的登录API时候出了问题，你就会打开IDEA，然后找到Spring Boot的Controller找到登录接口，从登录接口那个代码一直往下看。然后猜哪里出问题了，这个是全凭经验的，比如说你这地方的查询是不是太太慢了？然后你去测试，测试完后，发布个新版，然后你同事在管这个服务器，你就对他说：“发了个新版，我Jar包发给你了，你重新测一下”结果他弄了半天还是对你说：“哎，还是不行。”这样一来一回来个十次，你两个疯了，为什么？效率太低，而且老板这时候直接冒出来说：“什么时候能解决呀？”</pre>
</div>
</div>
<div class="paragraph">
<p>比如说最经典的就是发生在我小伙伴身上的事情，他在一个外企工作，大概是5:30交给他个任务，然后六点就问：“做完没有啊？”这种情况我们一般用智障的眼神看着的leader，刚刚我们才讨论完需求，那么快啊。然后Leader就说：“那辛苦一下你们，今天晚上加个班做完好不好？”然后你心里骂娘都有了，但是一想哎呀，我靠。还是钱香，所以这个时候你就被逼的去996了啊。</p>
</div>
</div>
<div class="sect3">
<h4 id="_起步阶段的会遇见的问题">3.3.9. 起步阶段的会遇见的问题</h4>
<div class="literalblock">
<div class="content">
<pre> `1.程序可以支撑多少并发量的认知`
这种认知是需要时间的教育的，没有时间去真正的承受这种访问，你是不知道的，所以在运营状态里头第一个问题就缺少偏后置的一些阶段，但病发量它是一个很大的概念。</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方：

在京东上买东西需要多少个步骤啊？

1.你首先得打开京东

2.浏览网页浏览商品

3.找到一个想要的商品点的购物车

4.下订单

5.选地址

6.选择送货时间

7.选择支付方式，

8.提交订单

9.去支付。</pre>
</div>
</div>
<div class="paragraph">
<p>可以看到有这么多的过程，那么并发发生在哪一个地方？
下单有下单的并发，访问有访问的并发,这样就存在一个问题，因素太多(软件因素/流通节点)。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`2.流通节点太多`</pre>
</div>
</div>
<div class="paragraph">
<p>流通节点太多就有个致命的问题： <code>知之甚少</code>。</p>
</div>
<div class="paragraph">
<p>如果纯网页浏览的话，Nginx会产生日志，那现在你要想知道 <code>Mybatis到底查了几个东西？</code>  <code>Mybatis哪个地方卡了呀？</code> 你说我在Mysql上打开慢查询就知道了，这样是没问题，但关键是本身就已经是后置了，访问入口在最前面，Mysql在最后面，然后你在最后面那个软件装了个监控器，那中间呢怎么办，当然这样是能解决输入输出的问题，但是后面的数据库不是你能上你就能上的，数据库是一个企业最核心的资产，它不会让随便让你上去弄，一不小心删库怎么办。</p>
</div>
<div class="paragraph">
<p>前段时间抖音一个实习生把那个训练模型给删了，最关键是那个模型还不是试验的还是生产的，更早一点，网易的程序员也不靠谱，把数据库密码传到了网上，而且那个他那个账号密码也是是生产的，不是测试的。</p>
</div>
<div class="paragraph">
<p>所以让不可靠的人进入生产系统过后，会发生一系列安全隐患，根本不可能让不靠谱的人去排查Mysql的慢查询。</p>
</div>
<div class="paragraph">
<p>如果真的让不靠谱的了去排查Mysql，然后他看到Mysql超CPU8%，看起来是Mysql有问题，那他直接先重启下Mysql，结果一重启十个子系统全部宕机，本身就两个子系统宕机，结果一重启Mysql全部系统全宕机，然后在重启期间所有的新发生的请求又一直涌向Mysql卡在那，结果刚刚起来的Mysql还没热身呢，又挂了，CPU堵车的时候是真堵车，不是慢慢堵车，会发生一系列很可怕的事情。</p>
</div>
<div class="paragraph">
<p>起步阶段会存在很多数据流通节点，一旦软件数据流通节点太多，就存在管理问题，这就是起步阶段会遇到的问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_项目后期会遇见的问题">3.3.10. 项目后期会遇见的问题</h4>
<div class="paragraph">
<p>到了后期，主要是对软件进行优化，怎么优化？ <code>提升并发</code>,但是企业并不会主动去提升并发的，因为没有出问题，企业就认为不出问题的机器就是好机器，他也就不会管，所以这个时候企业不主动优化，那就意味的所有优化暴露出来的问题都是Bug，就是 <code>性能方面的Bug</code>,一旦出现性能方面的Bug,一般企业是没有能力解决的，不要说现在云技术那么发达，人才那么多，你放心，他连人都找不到。</p>
</div>
<div class="paragraph">
<p>曾经我有一个同事的一个下属，他们公司以前的项目就是因为性能太差，被政府给踢出来了，他们开发了一个林业的管理系统， 就是森林防火的那种系统，结果三天两头系统打不开，为什么打不开，因为访问的人有点多，有多少呢，大概十个，搞了一年多，搞不定然后甲方终止合作，公司就垮了，后面又花了一天时间，成功支持11个了，老板欢心鼓舞，但关键是到第十个时候还是死机。</p>
</div>
<div class="paragraph">
<p>所以在项目后期还存在个问题：优化性能Bug，这个问题可以很快很好的解决，不过要花很大的代价，比如说程序员告诉老板：“这个2万的服务器不行，我们要买20万的服务器。”那确实优化好了，钱不是问题就能很好的解决，但是我们作为一个高薪行业，要有自己的职业素养，能花2万解决的问题最多花3万，花20万就离谱了，当然不说老板不老板的问题，光从社会效益上来说，程序员是尽量少花钱，大家心里都有一个认知的，就是 <code>在有限的场景下面去解决问题</code>，这样程序员是非常有成就感的，但是并不妨碍这个行业里还是有落后者，那落后者就说：“我只要够富裕，加钱就可以了。”加钱能解决的问题还要你，淘宝如果花510亿能买，你买一个淘宝多好啊，你能买到淘宝吗？你买不到，关键出性能Bug的时候，你可能买了新的服务器可还是一样的慢，这是最离谱的，所以说钱不一定能解决问题，因为你根本就不清楚问题出在哪，可能问题就是电信机房给你现在十兆带宽，你带宽跑满了，有这种可能对吧，所以存在诸多的问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_提出问题技术">3.4. 提出问题(技术)</h3>
<div class="sect3">
<h4 id="_怎样了解模块间的调用关系">3.4.1. 怎样了解模块间的调用关系？</h4>
<div class="paragraph">
<p>并发量是对软件系统整体效率的度量标准。（结果，颗粒度更细）</p>
</div>
<div class="paragraph">
<p>软件数据流通节点太多，管理存在问题。</p>
</div>
<div class="paragraph">
<p>如：用户登录，在登录界面上，用户输入用户名和密码，再点击登录（这个时候都是在人机交互界面发生关系），点完登录过后服务器去查询你的用户名是否存在，用户名如果存在会去判断这个用户预设的密码和你填写的密码是不是相等的，如果相等，提示，返回，返回一个ture，提示登录成功，如果不相等，提示返回密码错误，那就有以下几个节点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>点登录发送了一个POST请求，POST请求到了服务器上面。</p>
</li>
<li>
<p>你的Java代码收到了之后要做协议的解包，解码，然后协议就把用户的帐号跟密码拿出来，拿出来过后要通过数据库去查询这个用户名对应的密码。</p>
</li>
<li>
<p>查询完了之后要进行对比。</p>
</li>
<li>
<p>对比完了之后要输出结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就一个登录放到数据流通节点那里就会发生很多次这种事情，但是最重要的几个点就是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户发送请求。</p>
</li>
<li>
<p>发起请求到最后密码对比结果结束，对比结束之后的结果ture或者false。</p>
</li>
<li>
<p>查询语句</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>发起请求跟结果对比是同一个层次的，查询语句是一个层次，都很重要。</p>
</div>
<div class="paragraph">
<p>（模块间交互）
项目后期优化（被动），性能Bug。</p>
</div>
</div>
<div class="sect3">
<h4 id="_模块内的工作状态是怎样的">3.4.2. 模块内的工作状态是怎样的？</h4>
<div class="paragraph">
<p>如：查Mysql，正常来说，在本机上查询只需要1毫秒，但是上了生产过后一开始是1毫秒然后是5毫秒最后变成4秒，这个秒就需要管控，这是第一个问题，第二个问题：查询这个东西很细，有可能是有很多个查询组合的最终你要想客户端反映一个登录结果，你点了登录，卡了五分钟，那就要对请求响应时间做管控，要记录响应时间，记录响应时间是基于一个点来记录的，要么那个响应时间在nginx内部，你监控nginx日志，他请求和响应是有个日志可以打出来的，还有个方式就是在Controller进来的时候getting start，那么出去的时候end，这个时候就可以有个计时器记录时间，在你代码的开始入口和出口之间写个计时器去监控他，所以可以对响应时间做控制，更精细一点，你可以查每一个查询的返回时间。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解决问题设计">3.5. 解决问题(设计)</h3>
<div class="sect3">
<h4 id="_管控模块间的交互">3.5.1. 管控模块间的交互</h4>

</div>
<div class="sect3">
<h4 id="_模块内的工作时长输入参数输出结果数量等等">3.5.2. 模块内的工作时长（输入参数，输出结果数量等等）</h4>
<div class="paragraph">
<p>如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SQL查询时间</p>
</li>
<li>
<p>HTTP的响应时间</p>
</li>
<li>
<p>调用地图API的时间</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用户：程序员，System admin（系统管理员）</p>
</div>
<div class="paragraph">
<p>使用：通过 yaml包或者pacman装一个软件，先把我们这个软件跑起来，装完了会有一个Web界面，比如说zabbix,这个东西装完了过后会有个网页，网页有CTO的使用率，有内存，还有网络和其他的东西，但是这个解决不了模块间交互的关系，还有一个东西Istio就是Googel给k8s开发的，这个东西是用在k8s领域的，k8s里面有很多模块，那模块内怎么通信，怎么死掉的或者状态怎么样是通过一些监控去监控k8s死没死掉，如果死掉了他会有一个记录，然后你可以自定义一下策略，当他死掉之后做拉起或者重新新建一个镜像让他启动起来，这个样子之后当你的app服务器死掉之后经过几秒钟检测之后再给你启动一个，就又活了，除了这个他还有一些收集信息的能力，还有一类就是定制，给自己开发一个，一般写的时候是根自己有关系，在英文里面，在linux领域我们一般吧调优这种东西叫profile，这个东西很多时候会在代码里面镶嵌很多东西，镶嵌完了过后会把你的调用堆栈，就比如说你调用了有一个进程，进程有依赖了什么东西，他把那个函数的调用关系全部打印出来了，最后就点那个加号减号就行了（点了加号就会把下面都展开，它可能就会有很多调用），这一类就是linux上面有现成的命令，在你运行这个命令的前面先运行profile，运行完了就会生成一个分析文件，那个分析文件里面就会有函数的调用关系，每个函数花了多少时间，我们优化c或者c + + 程序就是这么干的，这种优化已经是从操作系统的调用层面叫System call，这个叫系统调用，就是通过系统内核和你产生交互，然后把你的规则跟数据收集出来，最终你就能看到某个函数在那里转圈圈，一直在调用，每一次占0.1秒，运行了一万次，你是能看出来的，但是有个问题，如果按这种方式首先你的程序必须是c或者c + + 写的，java就不要想了，因为你去看java的话就只能看到jvm的东西，看不到 user层的，因为jvm和系统发生关系，而你和java发生关系，中间隔了一层，所以只有纯静态语言才能调这个，比如说Rust。
这是三种我认知里面的方式，那么第一种zabbix就是通用领域里面收集系统信息， 而且收集信息是很有限的，当然你可以写插件去监控某些特殊的东西。然后第二类Istio他是集中在k8s这个生态里面的，这个非常非常有限，因为我可以完全不用k8s,虽然k8s对你来说这几年有用，但是你咋知道五年过k8s他不过时呢。第三类profile就是太底层了，1w个程序员里面顶多一个人在用这个，我都是高估了这个，所以在成都市，在对面那么多栋大楼里面找到一个都是不大可能的事情，凤毛麟角的，这个也不是因为它没用，而是因为它太底层了,太底层就意味着现在的程序员大多叫Web程序员，他们是搞不清次这个东西的，但是按常理来说，你如果是一个计算机工程师，我认为这种程序调优是必备的技能，但是你如果只是为了吃饭，只是为了生存你肯定不会在意这些东西，虽然我不知道怎么去设计，但是我知道市面上有这么几种东西，我个人觉得我们做的东西可能和第二类Istio差不多， 和第三类profile相比起来，如果你要通过编码去控制他的交互，我个人觉得那样对代码的侵入太大了，我打个比方：</p>
</div>
<div class="paragraph">
<p>某个公司用java开发了一套东西。然后后面发现老宕机，你告诉他你也用我这个东西，在你代码里面加入某些东西就可以怎么样了。但是用户他就不愿意动，为什么？我代码通过了安全审计，好不容易甲方认可上线呢？你这么一改，我要用要跑的用户去发版本，还要经过代码审计一系列复杂的事情，侵入太大了。那这种轻松的话万一你是个病毒呢？万一你又坏心思了，所以这种侵入性太大了，当然他的运行方式是在命令前面加一个东西，但是java，这种你是没有办法通过这种纯调用，所以你必须=侵入代码里面去统计它的函数使用对吧？那就很麻烦了，你这样侵入代码里面统计你为啥不开发个jvm的统计工具，直接统计都完了完事对吧。层次太低了，就和profile一样的，你统计到jvm里面去有几个人搞得懂啊。就是我们有一个广度，就是你的适应性要广，而且侵入还要小，所以看起来纯profile这种方式不行的。所以看起来的话首先总结特点:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>普遍性（适应性）：我们这东西不是很特殊，不能只能用了某一个细分的领域。我们用到应该是感受和程序相关的，至少都能有一些作用。（普遍性第一个是指的人，第二个指的是物）</p>
</li>
<li>
<p>无侵入性：这个无就是少的意思嘛，最好是无，就是更可能少的侵入性。</p>
</li>
<li>
<p>更灵活、扩展性：要适应变化，要能写插件，应该是一个平台，一个数据容器。</p>
</li>
<li>
<p>覆盖关键路径：在关键领域把握要点。</p>
</li>
<li>
<p>性能热点：性能热点就比如一个系统一共花了5秒钟去响应用户的某个动作，在这个动作5秒里面有个查询占了3秒就是性能热点。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上五点是最重要的！</p>
</div>
<div class="paragraph">
<p>因为你的程序卡顿，不管你是走代码还是你去测试也好，你就不能一眼看出问题在那里，就术语盲人摸象，然后这个时候程序员需要一个东西去辅助他解这种问题，不是还有一个大的嘛，就是企业里面，你应该对你系统的运行状态去了解，他应该是先有状态的本身的收集。收集完了过后在某些地方他看到有异常的数据，他应该是这样就发现的，所以最终程序员装了我们的的东西过后，把数据收集上来过后能看到异常，现在就有两个问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>怎么把数据收集上来？</p>
</li>
<li>
<p>收集什么样的数据？</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_整体数据逻辑设计">3.6. 整体数据逻辑设计</h3>
<div class="sect3">
<h4 id="_架构图">3.6.1. 架构图</h4>
<div class="imageblock">
<div class="content">
<img src="images/项目设计.jpg" alt="项目设计">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_怎样收集数据应该收集哪些数据">3.6.2. 怎样收集数据？应该收集哪些数据？</h4>
<div class="paragraph">
<p>在不侵入的情况下哪些数据应该是收集的？我们就先写出数据特征，一项项列出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>传统的东西比如：

CPU

内存

硬盘

UpTime（系统运行时间）</pre>
</div>
</div>
<div class="paragraph">
<p>除了这些以外，还有最重要的一点：网络，网络是很笼统的概念，那就得区分，那网络区分那就有：  <code>HTTP的请求,MySQL、Redis、Kafaka</code>，还有文件IO，但他不属于网络，本来他应该属于常见的硬盘里面，但是那里的硬盘是负责硬盘的大小，所以这个地方应该还有 <code>FileSystem(文件系统)</code>，那么FileSystem里应该有 <code>R/W IO</code>，IOPS应该是属于上面硬盘的，因为IOPS是硬盘里面的，而R/W IO是涉及到 <code>文件读写`的，文件读写和机械是不一样的， `IOPS是机械的限制，R/W IO则是软件层面的限制</code>，因为FileSystem这个地方涉及到NTFS和ext4。</p>
</div>
<div class="paragraph">
<p>那现在假设个场景，假设查询慢，那么有几种方法能够采集到MySQL查询？写一个Mybetis PlusPlus，然后在里面加一个代码，那个代码就是我写的Class，凡是用我的框架，就能自动把那个数据采集上来，那这就是意味着我对代码具有侵入性了，用户必须用我的代码，用户不把我的软件包的代码引入到项目里面，就采集不了MySQL，还有Redis，你也写一个Jdis PlusPlus，那工作量就可大了，然后Kafaka，他是通过用Zookeper请求的。</p>
</div>
<div class="paragraph">
<p>再假设一个场景，用户他不懂任何Linux的操作，那他只需要根据我们的软件，去看每一个SQL的执行效率，然后我们按SQL的响应时长排序，时间越长的排的越靠前，那用户是不是能很快就能查出问题，还有连接池，这样的话用户就能看到同时有多少个连接。</p>
</div>
<div class="paragraph">
<p>那像 `文件读写`呢,Linux内核提供的接口，是可以去读写的，就是监控某个指定的目录，Linux就是这么高级，Windows其实也有，但是是靠技巧去做的，但是在Linux内核就自带了，你可以用info这个命令,带上参数 -w指定Watch模式，加上目录，就能监听目录的读写、删除、修改，比如说木马，他是要创建文件的，我有段时间那个服务器老是被改文件，但是我又不知道什么时候上来的，日志太多，然后就把那个网站目录做成监听模式，只要Create文件，I Know，所以说就去把木马立项到日志文件里面，第二天只要看到有那个文件就翻日志，就可以看到是什么时候创建的，而且还能看到是什么时间访问的。</p>
</div>
<div class="paragraph">
<p>除了这些以外，内存的分配不需要考虑，因为内存一般指大小就可以了，cpu通用时长也不重要，那么一般出问题就是NetWork那一块，因为一般取数据、文件IO一般都是和应用直接挂钩的，那么现在他是延伸一下，提出一个问题：HTTPS怎么办？</p>
</div>
<div class="paragraph">
<p>首先，假设要加密的数据，如果要让我监控的话，就应该在平台上面把MySQL或者Radies配的证书给我，你把你配的证书给我过后我对的，或者我们最开始就不考虑那些问题？要知道我们的软件是有延展性的</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

用户发起了一个高德地图的请求，那在NetWokr这个地方除了常见的以外，可能还要针对TCP连接单独去处理，因为加密的不都是TCP连接，那你就知道项目里是谁发起的连接，哪个连接耗时多久，又等于说这些就是PCB下面应用层，等于说TCP应该是大的层次，而左边一般都是小的，所以整个连接中，你应该是一个连接管理的地方，连接耗时了多久？应该把它列出来，然后HTTPS加密的话，可以把证书配给我，证书配给我的话，你通信过程当中。我就可以解，MySQL也是配证书，Readish好像也是，他们基本上都是差不多的，只要解了一个，剩下都可以，说白了：

“你加了密的我就监控不了吗？”</pre>
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre>再打个比方

用户让我监听某个端口的TCP通信，那肯定得告诉我端口，不可能把所有网卡全部监听一遍，那数量得多大呀？所以这个时候比如用户的8080都出问题了，你应该让我看8080那个没有加密的，不应该让我看Nginx之外的，只要在Nginx后面的就不存在加密的问题，而且大多数MySQL大家都不会用加密的，你本地都要调用，所以很少有人去加密，所以加密问题应该不是最优先的，因为总可以看不加密的，然后还有TCP那个，可以看它连接的时长，你能统计出来的，就是一个连接过来直到连接断开？从端口开始到结束一共花了多长时间你给记下来，然后写个MySQL协议解析器，Redis也要写，HTTP好弄,现成的有很多，然后MySQL也有，所以就看我们把他们怎么结合在一起，但是MySQL个有个问题：不同的版本，协议形式不一样。所以我们可能支持常用的5.7,8.0,那么这就是版本支持问题，那个最老的5.5，你可能想都不想支持，Redis相对比较简单，因为它的协议就简单，然后Kafaka的话，也不难，所以说白了，你做完这些过后，你比那个Kafaka官方的人还了解Kafaka。</pre>
</div>
</div>
<div class="paragraph">
<p>所以我们的工作量应该主要在NetWork那一块，难度和工作量在那块非常集中。所以这个地方很明显就是插件，肯定优先支持HTTP，然后就是文件IO，文件IO有现成的内核模块，直接用，因为这个东西肯定和性能有关系，肯定不会用Python来做，那文件IO这块是调用内核模块，内核模块里面有各种标志。可以用C/C++，如果rust可以的话，尽量用Rust，因为我希望这个项目有后来者参加，用C的话可能没有人维护，所以我们大概清楚要怎么做了。</p>
</div>
<div class="paragraph">
<p>那么这样做的话，首先：</p>
</div>
<div class="paragraph">
<p>1.对人的要求就很低，只需要在网页上配置一下。</p>
</div>
<div class="paragraph">
<p>2.普遍性：都已经做成这个样子了，已经关心网络还有底层的基础设施，那么物体肯定也是适配的。</p>
</div>
<div class="paragraph">
<p>3.无侵入性：我们做的就相当于把你网络流量Copy了一份，这样看起来像把罗番那个科来公司的事情全部重新干了一遍。</p>
</div>
<div class="paragraph">
<p>4.灵活和扩展性：我们因为扩展的是协议嘛，这就是一个模块嘛，一个Mojo，那么就相当于是一个个做扩展。</p>
</div>
<div class="paragraph">
<p>5.关键路径：网卡，性能热点可以通过观察它的时长。</p>
</div>
<div class="paragraph">
<p>当然，如果一个应用，全部东西写在一起，没有前后端分离，你只存在查数据库这种，那你就只和外界查数据库有交互，那这种我们就帮不上了，为什么？因为你所有东西耦合在一起，你都没有模块，我想一下那种我们能覆盖到哪种范围，首先查数据库或者Redis都是可以的，还有我们的客户应该是现代的，不会出现前后端耦合，都是前后端分离，至少分成模块了，还有微服务，差不多覆盖住这一个就行了。</p>
</div>
<div class="paragraph">
<p>那现在回过头来想这个项目有没有意义。</p>
</div>
<div class="paragraph">
<p>因为我们最开始肯定先考虑的项目背景、可行性，虽然之前简单聊了一下，那现在我们要确定一个事情： `“这个事情做下来到底能不能解决客户的问题，或者他的问题值不值得解决？”`如果客户的系统不出问题的时候，通过我们的软件能不能让更有意义一些，比如说用户没有问题的时候用这个东西，他可以看到，每一次SQL要花多长时间，如果时间过长的话就可以针对他进行一个优化，还有比如说软件测试的同事啊，他要去做测试。他虽然看不懂代码，但他可以看有没有发起请求，这是一个对于软件测试的，对程序员来说的话就是刚刚说的MySQL开发、请求，比如说可以排查哪哪会不会出问题，对系统管理员来说呢？那这个地方能不能解决客户要知道有多少并发的问题？那也是可以的，就直接看流量入口进来的数量，然后对于运维，我们可以做插件的话，类似于刚才说百度？？的统计页面，比如说是哪个IP来的、用的什么浏览器、哪个端口、哪个URL，对老板来说，老板肯定是让下面的人去做；对项目经理来说，他从代码层面来说，他是不懂这个项目的，但他看了这个我们的页面之后，他知道哪里可能花的时间很久，从Team leader来说的话，他就可以让程序员的工作量化了，对运营来说，就和老板差不多，运营关心的是指标，他就看那个承载量，这些看起来都是ok的，目的达到了。</p>
</div>
<div class="paragraph">
<p>那现在是采集的类别收集到了。那现在考虑个问题，我采集过后看起来这个地方应该运行个程序，那么这个程序我们一般叫Agent，你可以翻译成代理(客户端代理)，他就运行在每一个用户的操作系统上面的，比如阿里云，他就是在他的机器上装的这个玩意儿，不然他怎么控制你重启的,他可以断电重启，但是用户说我要温柔的重启，他就必须通过Agent控制你的系统,那上面讲的就是Agent，那么肯定这些数据有需要一个接收的服务器。</p>
</div>
<div class="paragraph">
<p>那从Agent到Server肯定是基于tcp的，但是为了让软件更具扩展性，我们应该知道TCP下面有哪种协议？假如我们自己造了套协议在TCP上面，现在要考虑个问题：为什么？要通过协议去造一个通信协议。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

造了个通信协议，让别人去维护，那他肯定不会。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个肯定更加倾向于HTTP+JSON，它们更通用更快，说白了界面酷炫。然后Agent里的东西都看起来现代，所以就有人会去用，哪怕是为了装酷，那我们就会用基于HTTP+JSON的方式来传输数据，但是地方有个问题：传输的速度可能会非常快，想一下嘛，Agent一定会要把协议分析一下，把数据分析出来，再传出去的，运计算量肯定不会放到服务端去计算的，所以你肯定是在每台机器上做边缘计算，所以这个地方肯定丢的是SQL本身，还有他的响应时间，看起来通信协议是靠HTTP+JSON，传输平次就是Agent只要有变化就会去推，比如说Agent里HTTP的包很多，那就会一直产生单独的HTTP的包往外面推，性能不是现在要考虑的问题，这个地方实际上是对性能不敏感，因为服务器你大不了一边100E 次嘛。这也是100E次,实在不行的话，你可以把Agent缓存一会再打包丢吗，你是可以通过策略降频的，你不一定来一个就推一个，可以一分钟推一下嘛，但是要存到内存里面，那么Server既然是接收服务器，它是HTTP的，那这样看起来要接收HTTP，而且要和Agent配合，先讲下一个和数据库发生关系的模块，我们这些数据，它首先量不大等于说存储这边我们用Post，还需要统计就是ELK，用来做简单的统计分析，他启动起来，其实你数据越多也大吧，但是我们Agent已经统计完了，相对来说，它是数量是固定的；所以说暂时就是一个纯持久化存储的，然后一个用ELK，为什么用PSQL？因为它有很多非常非常好的特性，比如说，可以做实时数据，MySQL都不行，因为那个MySQL是学院派开发的，就是那些典型的大学开发的。至于是用对象关系性存储，还是用持续存储，这个看需求，到时大不了把特性打开就可以了，然后ES主要是用来做复杂的分析，判断，排序，那差不多就这些，然后Server接收啊，Store存储，那应该还有个WebServer，那么Web的话肯定就用Spring Boot，前端的话我建议用react，你写。为什么用React？因为它复杂，Vue就是简单，那简单的东西，我们都会，就要玩一会复杂的，因为Vue和React他们在里面都差不多，你会React了，看Vue就一天的时间。</p>
</div>
<div class="paragraph">
<p>从Web—Store—Server—Agent都有各种控制策略，所以分开是可以的。先确定建设设计方案，首先Agent，肯定不能用Java，因为性能太差了，而且内存消耗贼多，我们希望控制住内存，为什么？因为用户的的客户机可能内存只有几百兆，比如说，你要求用户内存至少512MB以上，然后自己就占了人家一半的内存，所以这个地方偏向于Rust或者是C++都可以，这是没问题的。然后Agent和Server之间，是用HTTP出来的，出来过后到Server有些策略控制，那这种策略控制有哪些？</p>
</div>
<div class="paragraph">
<p>补充之前PSQL和ELK中还需要有消息队列RabbitMQ，那首先这个地方消息对列那这个地方的话。因为他是rust，总是为了内存，这个server和他是跑在一起的，那么Server和Web都可以使用Java。</p>
</div>
<div class="paragraph">
<p>现在我们就设计出了就是大致的逻辑，那我们再复述一遍。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>首先这个软件

1.要对人的要求要低，他最好用可视界面，能够做设置、查看，以及对监听目标的适应性更广，比如说只要Linux都可以。

2.无侵入性，我们是通过监听基础设施，然后就实现了无侵入性。

3.灵活扩展性，说白了，基础之外实现的功能都是加工的模块。

4.关键路径覆盖，主要因为都是基础设施，所以已经覆盖了。

5.性能热点，统计状态然后进行了排序，然后如果客户真的要找热点，可以让他去做个设置，就比如说设置个预值，SQL超过三秒就标红。</pre>
</div>
</div>
<div class="paragraph">
<p>现在看来通用领域的监控我们都得有，那么Agent你的NetWork块是有挑战难度的，比如说MySQL，要去写一个协议解析，官方有，但是官方他是有版本支持还要各种裁剪，所以有适配问题，他有各种各样的版本，那我们可能要最低支持5.7,8.0再说,然后Redis相对比较简单一些，然后Kafaka的报文也比较简单；然后文件IO这个地方是比较固定，是内核的东西，几百年都没有变过的。</p>
</div>
<div class="paragraph">
<p>那么技术难度主要就是MySQL，HTTP很多现成的，没什么大难度，把报文拿出来解析个报文，就算手写都把它写出来；那么Agent我们就采用rust或者C + ，要知道，做这个东西要有延展性，C+用户越来越少，越来越贵；Rust虽然也贵啊，但是他相对来说没有那么多糟心的事，也就语法严格，要在safe模式下面去工作。那这样的话如果有新人来维护的时候，那么肯定他维护的是这样的，新增了一个功能点，报上Server，Server内部应该不用大动，为什么？因为你新增功能点应该是加了Compent的结构，那么Server和Web都是Java，所以的话难度应该在Agent下的NetWork，所以对开发者的要求来说，难度会大一些。</p>
</div>
<div class="paragraph">
<p>现在在说大的这样做到底有没有意义？这样会不会是重复造轮子？
现在市场上没有这种东西，因为我们是针对企业的问题来提的，老板或者Leeder他们要的是一个完整的解决方案，他要的不是说我知道某个工具能解决。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_XMSZ2_chapter">4. 项目实战(二)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_4">4.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/项目实战(二)板书.jpg" alt="项目实战(二)板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_4">4.2. 前言</h3>
<div class="paragraph">
<p>上面我们讲到解决方案，我们当时涉及到说有Web界面，上报数据的服务器，Agent客户端，大概是三种，然后Agent客户端的话，当时心想的可能用Rust/C++/C/Python，就是还没有确定，那么Web端或者服务端，因为是Web程序，所以说用Java写是ok的。</p>
</div>
<div class="paragraph">
<p>那今天的话我们就先考虑一个问题：客户端的问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_客户端的问题">4.3. 客户端的问题</h3>
<div class="paragraph">
<p>客户端肯定是用来上报数据的，如果网络托普是这样的话：</p>
</div>
<div class="paragraph">
<p>客户端收集信息，收集完了后通过网络协议报给服务器。</p>
</div>
<div class="paragraph">
<p>那现在我们讨论客户端里面的东西，首先常见的客户端，像Zabbix、Cacti或者是Nagios，他们都有不同的方式，比如：阿里云，大家都用过，但可能没有注意，它客户机里面有个叫Aliyun.service，那个东西就是客户端。</p>
</div>
<div class="paragraph">
<p>那客户端他干了什么？</p>
</div>
<div class="paragraph">
<p>收集cpu、内存，执行重启、关机、睡眠等等操作，除了以外，他还要检测你系统上有没有安全隐患，像那天我尝试把Aliyun.service给删了，马上就在控制台上显示说的“有人试图删除我自己，”请你注意，后面我就奇为什么删不掉，然后我就花了接近半个多小时去分析他具体是怎么防删除的，后面发现它是supersuper管理员，然而你就是一个普通用户，那你就删不掉他的系统，也不能干掉它,这个就很国情，要是放在亚马逊上，你这么做会被别人吐口水淹死了，为什么？ `因为你侵犯了我的隐私。`在国外这一点最重要就是你产品可以不，就算你体验不、使用很难，但我可以学，你写个教程给我学，学完了过后我自己弄，但是请你不能干涉我的系统，而国内是这样的：哎呀，我害怕你出错，害怕你删掉了什么东西，就像防傻瓜一样防，这个应该在以前我讲过国情的问题，像国外的话，他们发明了互联网，所以所有的与计算机相关的，都是外国人发明的，就说英语那帮，那么他们的基础素养是很高的，为什么？因为他们素养低的都在那个大街上当流浪汉的，但是总体来说，只要办公室里面穿着得体的人，他们整个综合素质是非常高的，为什么？人少嘛，可以搞精英教育，如果让他变成14亿人，他来搞他还不指定搞成啥样呢，再加上那会儿从清朝抢走那么多白银黄金，那不发展的更，所以你得承认这个差距。</p>
</div>
<div class="paragraph">
<p>那么典型的客户端，肯定在机器上会有一个程序在运行，首先我们得有 <code>守护进程</code>，那么这个进程其实是从Agent过去的，所以说Agent是出口，那么现在有个问题，Agent是出口，我们采集cpu、内存等等应该怎么做？常见的做法是在这个Agent里面写代码，写一个cpu函数，写一个内存函数，然后再写个网络函数，那我问你个问题：做是可以做，但做完了过后系统扩展性在那？在我们的特性中，有一条非常非常关键的特性就是扩展性，因为你不可能把全世界所有用户的需求都囊括在里面，那么就要借助整个社区给你的反馈。</p>
</div>
<div class="paragraph">
<p>那这个时候你就应该留出编程接口让别人来帮你完善，那这时候你说：“强哥，Web界面他不可能帮你完善”，但是改这个东西并不影响Web，Web界面那边完全可以动态呀，那这样看起来Web一点都不重要，其实重要的是客户端，然后这个时候就涉及到一个问题：我可以用rush的一种语言完成所有的事情，但是为什么不选c呀？因为写c的话，内存管理很麻烦。那为什么用Python？</p>
</div>
<div class="paragraph">
<p>其实每一种语言有它的 <code>优劣势</code>，那这个时候就根据用户需求，他愿意怎么弄他就弄，但是你不要把他 `限制`死，比如说有一次我想去改RabbitMQ的这个东西，我觉得他那个整个机制没有解决我的问题，我不知道是我用错了，还是怎么样，那我就尝试去看Agent的代码，结果拉下来一堆C，想去改东西的话，还没文档，还要自己琢磨，然后就放弃了，之后我自己又花了一个月写了个ZSR，才解决我的问题。因为当时有台服务器老被黑，是用户的服务器，但是我也抓不到是谁，我就写了ZSR，把所有的东西都监控起来，每秒钟把整个系统快照一遍，产生的日志文件一天的话大概有两个G，但是他颗粒度非常细，每秒钟，如果想更快的话也可以，但是没有必要，所以我用编程的方式解决我自己最核心的问题，之后我写完了就放在那，不需要去管了，为什么？对于我来说经常是要用到什么我就写什么，但是这样会有个问题，就是说整个技术栈很散，知道的东西也很散，以后想解决更多的问题的时候，要把它们合在一起就很麻烦。</p>
</div>
<div class="paragraph">
<p>所以这个平台也是作为我个人技能的补充，就把我以前理念全部合在一起，做过的，没做过的都可以用上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩展性">4.4. 扩展性</h3>
<div class="paragraph">
<p>所以在Agent里，首要的是考虑扩展性，性能是才是第二位，为什么说性能是第二位？你连数据都采集不上来，你咋知道性能有问题。</p>
</div>
<div class="paragraph">
<p>举个例子</p>
</div>
<div class="paragraph">
<p>今天吃晚饭的时候还在和跟同事讨论那个南瓜尖，他说那个南瓜尖很吃，我说那个有毛刺，他说没有，很吃，我说是如果在你家里面，去掐的话，你会掐那个很短很嫩的那个芽，但是你咋知道菜市场的大妈，她掐的那么长的，然后买回来吵着碗里，你不咬一口你咋知道他很老？，这个很实际的例子。
所以我自己不喜欢吃是因为我不确定他老不老，就像我每次问我妈，我说：“那个鸡的屁股你洗干净了吗？”然后我妈说：“吸干净了，没得问题”然后一咬下去，呕，这辈子都都不会再碰那个东西，为什么？心理阴影，你不咬一下，你咋知道他洗干净没有？。</p>
</div>
<div class="paragraph">
<p>所以扩展性是第一位，那我东西都没有装上去，跑起来，就是说都没有见过猪跑，怎么去吃猪肉呢？要吃的明明白白？比如猪的后腿肯定吃，为什么？它天天都在的锻炼，所以扩展性尤为重要，因为你要让他先跑起来。</p>
</div>
<div class="paragraph">
<p>那什么是性能？就是你运行起来的时候不能耗太多的CPU、内存，那如果是客户自己写的，CPU和内存消耗的高，那就和我们没关系，但是我们写的对性能是有要求的，所以说如果你搞不定的话，可以让我们帮你定制。</p>
</div>
<div class="paragraph">
<p>那我们先讨论扩展性的问题，你想你要让客户甚至用JS来写，都能收集东西。你想之前说不限制语言嘛？他用任何语言都可以把这个数据报上去，但是扩展性里还有个隐藏条件，就是要简单，就是我们整个系统能够做的事情，你不能让用户去做，那要做的扩展性，先画个拓扑:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/扩展性拓扑.jpg" alt="扩展性拓扑">
</div>
</div>
<div class="paragraph">
<p>比如说这个是一个cpu的程序啊，这个cpu的程序是用Pyhone写的。还有有个负责内存的，用Shell写的，最后还有一个报文件IO的东西，用Java写的。那这三种他最终应该有统一的行为，那么他们一定会和某个模块发生关系。然后这个模块发生关系过后统一行为再抛出去，但这个时候都还没有脱离本机，还是在自己本机上面，还没有通过网线再出去，所以中间的模块他的职责是什么？Agentd职责又是什么？那Agentd肯定是整个系统的核心，为什么？因为他的任务很重要，为什么前面那么多东西过来过后对于他来说，他要整理、调度，然后再发出去，所以这个时候对于他来说有很多任务啊，但是中间的模块是什么？这个叫动态客户端模块支持，简称DAMS，这个灵感来源是来自内核里面一个概念，叫DKMS，他们两之间A和K他们两个的行为都差不多。那么DAMS的作用是什么？他提供统一的行为接口，这个是编程的编程关系哈，是在模块代码层面，模块之间的关系，并不是运行时的关系。</p>
</div>
</div>
<div class="sect2">
<h3 id="_主程序怎么运行的">4.5. 主程序怎么运行的？</h3>
<div class="paragraph">
<p>举个例子</p>
</div>
<div class="paragraph">
<p>假如有一个cpu模块，首先，你开机肯定要先跑Agentd，因为他是入口，那么在跑他的时候，他会去读配置文件，那么我就把那个运行的时候，整个启动的过程写下来。</p>
</div>
<div class="paragraph">
<p>1.启动Agentd</p>
</div>
<div class="paragraph">
<p>2.检查目录Conf.d下面的配置文件</p>
</div>
<div class="paragraph">
<p>比如说Conf.d下面很多个*.ini配置文件。那么他会去扫描所有的配置文件当他扫描过后，他会把配置文件加载进去。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`那么ini配置文件里应该有什么?`</pre>
</div>
</div>
<div class="paragraph">
<p>首先里面应该有模块的名字，然后他有一个exec可执行程序，这个地方你可以写成什么，比如说top命令，就应该是exec=/sbin/top，就是命令的路径，然后在下面写个type，那么type是什么？就等于每一次运行几次？比如说运行一次，就叫oneshot。那么这就是配置文件里面的东西。</p>
</div>
<div class="paragraph">
<p>3.dans -m cpu start</p>
</div>
<div class="paragraph">
<p>那么他读了配置文件过后，就要在内部就要dans -m cpu start ，因为它在加载的时候，要启动一个线程，启动线程过后，那么这个c我后面就用cpu代替这个模块那第四个。cpu这个模块，他在启动的时候，他要执行top下命令。</p>
</div>
<div class="paragraph">
<p>4.resect</p>
</div>
<div class="paragraph">
<p>就像像你调用mkdir一样，会返回结果，所以他在启动的时候，执行完了会把比如说那个东西叫result(结果)，</p>
</div>
<div class="paragraph">
<p>5.Agentd&#8212;&#8203;JSON A&#8212;&#8203;JSON B&#8212;&#8203;Server</p>
</div>
<div class="paragraph">
<p>然后会把这个结果通过HTTP/JSON上报给DAMS，比如说他的端口是8080，那报给他过后，这个地方是JSON A，那上报给Agentd后应该去做一些整理，那么他把那个JSON A转成JSON B发给Server。</p>
</div>
<hr>
<div class="paragraph">
<p>这个时候，因为我们有几个模块，这地方有三个例子，那么这个动作会发生几次？三次，等于说他就是个循环，那第三点就很重要，如果有几个模块的就应该起几个线层，每一个线程去运行每个模块的命令，比如说第一个运行的是CPU和top命令，第二个可以用free命令看内存，然后再用某个命令去IO，那么看完了都有返回结果，那返回结果经过程序，因为程序是给他自己处理的。</p>
</div>
<div class="paragraph">
<p>可以自己通过命令把比如说CPU的数据，就只要那个90%筛出来，我们先忽略掉一部分细节啊，逻辑的话就是，在你开机的时候，首先被拉起来的是你的agent这个主程序，主程序启动的时候，它就扫描某一个模块文件夹下面所有的模块配置文件，等于说模块不是写死的，不是代码里面写死的是什么？，所有的都是这么做的，比如说你用PHP加模块，也是这样加的。那这样的话就相当于是说比如说有三个模块，那这个第二步就应该起三个线程，每一个线程和线之间是没有关系的，但是线程和主程序之间是通过HTTP通信的，这就解决了资源的问题，编程的难度陡然降低，为什么？无非就是请求个网址，这个网址是自己的还是别人的，无所谓，启动主程序的时候启动个8080端口，然后程序报给8080过后8080再去请求他的网址，把最终结果丢给Server，但是如果难度太高，就导致了没有人愿意用，维护成本太高了，所以这个Agentd有个职责，他叫代理，叫Broker，你大家看英文的框架的时候，你经常遇到这个东西。比如消息队列里头，经常你看到，翻译成砖块，他其实和persis代理还是有本质的区别的吧，代理一般是指很复杂的东西。比如说你说Nginx就是个反带，他是一个完整的代理，但是这个地方，你不能把它叫代理，为什么？他既不是反向代理，也不是正向代理，他就是简单的把东西封装一下，朝外面丢，那为什么要这个东西，而不直接把数据丢给Server？因为，现在有几个连接呀？有三个连接，那都连到Server上去，那我一台机器上面就也不止三个模块吧，那么通过这种汇总的行为，来降低服务器的连接数，让总体性能更好一些。</p>
</div>
<div class="paragraph">
<p>因为你最终从DAMS出来的时候，是模块自己的信息。但Agentd，应该告诉他是哪台机器的，是那个IP地址的。</p>
</div>
<div class="paragraph">
<p>现在问题来了，如果你打的标准输出或者文件日志里的，请问你打的时候，你怎么能够及时的通知Agentd去处理？因为你如果用标准输出打到屏幕上或者日上都差不多的，文件IO你异步处理是有问题的，为什么?因为你写了过后，那服务器咋知道有新东西了，所以这样的话就必须两边同时打开，就相当于说Agentd要打开那个日志文件，就只读嘛。DAMS是又写又读嘛，然后两边就一直都有个关系了，那这就意味着两边状态要同步，如果我不小心把文件删了，Agent就要重新打开，这样你还要管理，很麻烦，所以你设计的时候考虑的问题就是用起来方便。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩充">4.6. 扩充</h3>
<div class="paragraph">
<p>然后现在开始做扩充，刚刚有些细节省掉了啊，从8080端口开始，那这个地方看起来是要启动Web server，webserver启动了过后，那么就应该运行在他的一个线程，当然你也可以运行在进程里头，但是我们是假设哈。不过进程太多也可以，比如说他一个子进程专门用来处理Web请求，处理完了过后顺手丢出去。假设有一个主进程和一个Web的进程，然后在启动的时候，拿个进程专门取Web端口，另外一个继续做下面的事情，因为下面的才是主流程，Web端口是有消息发上来才会被触发，叫事件驱动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>事件驱动：等着别人来请求我的时候，我才返给你，就比如说支付宝的服务器也没莫名其妙给我发余额呀，那么就证明他也是被动的，为什么？要有存款的行为才有余额的变动呀，如果某一天突然打钱进来了，一定是幻觉，就像某个银行账号，突然存款一个亿，你敢用吗？你不敢动啊，因为你如果今天用了1000万，第二天就被抓了贪污国家公款罪，为什么？钱也不是你打你就开始用了。</pre>
</div>
</div>
<div class="paragraph">
<p>所以整体来说，首先你要起个子进程，放在那，然后你的主进程就一直接往下走，就开始去扫描配置目录里面的那个模块配置，模块不止一个，所以你应该用一个命令去扫描那个目录下所有匹配规则的名字，然后用列表列出来，列出来了过后你就应该有个清单，然后挨个读，先读它的名字，读了名字过后，应该有个class或者列表把名字保存，然后就是对象的执行执行路径，还有一个是执行的类型，这三个凑成的一个子对象。然后再把对象放在对象列表里面就存下来了嘛。我们之前讲的程序等于算法加数据结构。这地方就在讲数据结构，还没涉及到算法的地方，为什么？那时候他还在加载，就像从MySQL读东西读完了，准备好了，必要的条件数据都有了，这样算法才能运行起来，为什么？算法是需要输入参数的，比如说人工智能的推荐算法，推荐算法是不是有输入嘛，再比如说用户说100块钱到200块钱以内，男性用品，然后这个时候算法有输入，算法才能运行，所以现在还在为算法准备东西 ，最后得到一个对象列表，过后你是不是该写个for循环，挨个把列表里面的对象读出来，怎么读啊？object取出来，object.name放到第3步的CPU那个位置上，至于是这样执行还是在函数里面直接调函数，无所谓，所以应该是这样的，简单一点，你应该调object.exec直接启动，那如果有三个模块的话就写三个，而且启动的时候你要先把他传给一个线程，让他在线程里面去跑，不管那个东西是执行一次还是一直执行不退出来，都用一样的逻辑处理，为什么不用进程？哇，你机器20个接口。你的20个进程，那就太拥堵了，因为进程的消耗很大，进程是要分配内存的，分配各种各样继承出来的内存，就很麻烦，而线程是操作系统调度的最小单位，在面试的时候，很可能有些人会问这个问题，但是你不用担心，一般人不会问你，为什么？因为他也不懂，所以进程是操作系统分配资源的最小单位，内存，cpu，怎么打开文件就是这种东西。</p>
</div>
<div class="paragraph">
<p>线程是依附于进程的，但是线程又可以跑东西，所以线程是跑东西的最小单位，没毛病。所以你用线程跑就是为了节约资源，就是为了省内存，把内存省掉的一点，能抠一点是一点，就这么抠出来的，不像那个微软，你的电脑一共才8G的内存，结果他一次性给你用完了6G，剩下两个g自由发挥,以前Windows Xp 512内存用的好好的，突然来个Vista要求1.5G的内存，装上开个机啥都不干他就自己卡死了，微软和Intel总会想方设法用各种Flash东西给你塞满，但是作为优秀的开发者来讲，我们不要去干那个事情，所以在设计的时候要考虑各种各样的细节，所以那这个地方肯定是用线程。至于线程，我是单纯用一个命令启动，还是用个模块，都一样的。</p>
</div>
<div class="paragraph">
<p>所以第三点是一个线程，那么他可能调函数或者命令，然后把线程跑起来，你现在不要关心他。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

这个线程运行的是top命令，那么运行的过后，他会马上返东西出来，那这个县城里头，那么肯定不仅是一个简单的线程，那线程里面应该包装了这模块里面的一些行为。刚刚波波说的嘛，有SaaS服务，但你不可能让用户去写，比如说CPU模块到DAMS是有行为的，打个比方，整个主程序执行完了的结果是一个屏幕上的整个东西，你要把这个东西塞在JSON里面然后丢给服务器吗？所以你在写cpu这个模块的时候，里面应该预备一些函数，把那个数据得到过后，用预备的一些函数，把它清理一遍，然后往Agent丢，但朝这丢的时候一定是标准接口，就是你清理完后的东西，通过标准的这个接口又出去，这个接口是我们自己预备的。用户只需要解决那个选数据的问题，所以这个程序不是一个简单的命令，第二步里应该是用户自己写的。
这个程序里头，他要负责处理获取数据的数据的清洗，清洗完了过后，把清洗完的东西打到标准输出上面，打到屏幕上面，然后线程把屏幕的东西捕获了，再通过标准的HTTP接口封装成JSON，接着丢出去，所以用户只需要处理配置文件的逻辑，但是有个前提，你打出来的标准输出或者你的这种格式，必须统一，为什么？因为我是统一的，所以我去拿东西的时候，一定也是统一的，所以这个地方是是统一的接口。用户的程序里面就应该去处理这些逻辑，这个地方虽然例子是一个拓扑，但是你要自己写一个Shell把拓扑给处理掉。</pre>
</div>
</div>
<div class="paragraph">
<p>所以等一会我们就把这个黑板上擦掉，重新去写个例子去完善它，这个里面有统一的逻辑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

比如说写个插件，那个ZSR我里面写用C写了个插件系统，就是插件或者是模块，你要注册，模块你要注册，你还要注销，就相当加载和卸载吗，除这个以外，模块输出至少有三个接口，首先你应该又有加载，慢慢加载完了过后你应该有获取，这个获取里面应该包括命令拓扑的结果，拿到结果过后再做一些简单的筛选，所以说数据的获取1就是输出的东西，应该是处理完的，然后处理完后，应该还有一个output的东西，为什么？他应该输出到屏幕上，应该告诉对高统一的格式告诉DAMS我是哪个模块，要把名称、采集时间、命令输出结果放上去，然后把这几个结果转成JSON，往上一报ok，所以DASM就是刚刚说的统一格式，Agentd就是他封装完的HTTP  JSON包，然后丢出去，这样的话，对于用户来说，如果有想开发自己的扩展的话，你只需要加一个配置文件，然后在配置文件中的exec下写一句Shell或者一个简单的程序，只要那个格式是我们统一的格式，我们就能处理。那这样的话基本常用的语言都可以实现，扩散性就ok了。然后性能的问题，客户自己写的程序的性能问题又和我们没有关系。</pre>
</div>
</div>
<div class="paragraph">
<p>整个设计里没有进程和线程的关系，他们只有一个启动就完了，那这样的话，就形成一个完整的闭环，而不用关心各种细节的问题，关系太多很容易把这个开发难度给提升提升，提升完就不友好了，所以应该把更多的精力放在优秀的设计上面。而不是放在技术的细节上，为什么？因为技术是挣不了钱的，比如说知乎上经常有个问题：大公司怎么保护他代码的。
是这样的，微软美国公司，他把他的Windows 10的原代码给了中国政府。那中国政府搞了个Windows 10出来吗？为什么？他要让中国政府相信他，Windows 10里面没有放木马，让政府办公可以信任他？所以这个是原代码，它不值钱，为什么？政府买他单给他单子，单子才值钱，原代码啥都不是，比如说华为交换机的原代码，欧盟有，英国有，美国也有，因为华为任正非早就给他们，让他们随便审核，找出问题算我输，然后美国说，不是这个样子的，我不是想看你代码，我是想加点进去，任正非又说不敢干，那不然美国怎么监控全世界嘛，这个话不能公开场合说白了，说白了就没意思了，只要智商正常都能看懂，所以整个主程序的设计逻辑，你要解决是什么？要解决是优秀的设计，优秀的框架，不要在意太多技术细节，因为技术细节处处都是陷阱，你想嘛？你到处都用Socket或者C，我没说这个东西不能写，但是他会让别人望而却步，就没有人愿意参与你的项目了，所以这个时候你要考虑的是什么，通过这种扩展性和优秀的设计解决生态问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方
今天你你能干，你拿到1万的薪水做这个事情，那明天比如说有个5000的小伙子，他敢不敢动？他不敢动，为什么？因为难度摆在那，但是他用Python是这样的，我一般让别人写Python，我才不提前一个星期了，你今天下午用拍上把这个写一下。有啥难度吗？没有难度，因为你只要是从事这个行业的，你多多少少都会写一点，除非你是文职，你凡是技术岗的都没有问题，甚至我之前讲过，上家公司的一个人，我让他用Python，他死活不用，后面我强行让他们用，三天给我写出了个花里胡哨的Python还写成了Java，反正我是没看懂，就真的写了三天，三天过后，他的代码我已经看不懂了，为什么？各种封装？Java有注解Python也有了，然后他那个函数，他说：打日志的时候不方便，用注解来打日志，然后把整个代码传给那个注解。注解里头123封装，反正一出问题一调试，结果到处乱跳，也不知道跳哪去了，用Python的目的是因为它简单快吗，结果里写成了Java，那为什么你直接用Java呢？</pre>
</div>
</div>
<div class="paragraph">
<p>顺着刚才讲，那么你写for循环，你循环完了过后起n个线程，线程把数据采集完了，过后，输出一个标准的123名称、采集时间、输出结果，然后把它弄在一起丢出去，就从模块丢到DASM，DASM是认识的，如果不认识那么就是你的格式不对，然后用HTTP封装一下包成JSON，往外面丢就ok了，至少数据传上去了。</p>
</div>
<div class="paragraph">
<p>现在还有个很复杂的问题：就是配置文件中的One Shot，这个命令现在显示的是执行一次，但是有的东西你是不能间断的，我打个比方，监听HTTP的包。总不能间隔采集，只要断一秒钟，下次来的时候，前面数据都丢掉了，所以像这种监听HTTP的或采集cpu的这两个东西很特别。因为采cpu，一旦你停下来你再采集的时候，每次采的第一次，他永远都是0。因为CPU的使用率是靠占用时间来算的，所以时间有个起点，那这样的话就面临的就是像cpu、HTT这种的采集程序，用HTTP举例，你不能停掉，得一直运行的。所以在配置文件里就有一个问题，你的输出会源源不断的往外面丢了，如果用刚才把数据都合并在一起的那种方式，是不是有问题？消息发不出来，因为他永远堵在那儿了，源源不断的就变成了那个阻塞，就像堵车一样，你前面的没有过红绿灯，后面的全部排在那排着队的。就导致了越发越多，越压越多，后面那个内存就爆炸了，所以这个地方你要考虑个问题：像HTTP那种，刚刚说模块和DAMS之间用打在屏幕上的方式，但屏幕是不能异步的，就算能异步，你也是用函数来实现的，但这样难度就太大了，所以真正在去做设计的时候。真正在去做设计的时候，各个模块和DAMS是一个整块，比如说cpu是cpu的、内存是内存的、IO是IO的。所以这这两个不是单独的两个模块，他们是一体的，是DAMS去调的，那么他要去调用那些东西该怎么掉？所以他应该有个自己的策略，比如说他发现这个地方如果是OneShot的，他就只调用一次，有东西过后，他就把那个程序stop了，当然你可以在配置文件里加个间隔多少秒再调用，那这样就比如监控内存，每一分钟采集一次，这样的话，你有几种实现方式？</p>
</div>
<div class="paragraph">
<p>第一种：到1分钟的时候，启动一下，采集完了，STOP。</p>
</div>
<div class="paragraph">
<p>第二种：启动过后永远不退出。</p>
</div>
<div class="paragraph">
<p>但是第二种就有个问题了，你等那一分钟，你要让用户自己去写空白，刚刚才推了东西，然后应该等59秒，空白空白空白空白空白。所以用户的程序应该不考虑这个问题。那么调度的事情啊，应该让DAMS来做，采数据，用户说了算。</p>
</div>
<div class="paragraph">
<p>那么刚刚说这个内存就应该是这样的：</p>
</div>
<div class="paragraph">
<p>启动第一次，运行一下，程序就会有输出，当你拿到想要的过后，计数器设为1，这个时候就退出，退出完了过后，他那个线程肯定是不会退出的，他就Sleep 60秒，那线程会一直放在那儿，所以这个地方，他相当于说Sleep 60秒，60秒后下次再来，但是线程是不会退出去的，因为什么？因为他OneShot下面还有一个配置，就是间隔时间60秒嘛，这是一种方式，还有一种方式，就像HTTP那种，不能间隔，你必须一直采，那一直采就一直朝外面报，那现在怎么解决输出的问题啊？当然你输出到DAMS那肯定是JSON，当然有点抽象哈，不懂我们就解释到懂为止。</p>
</div>
</div>
<div class="sect2">
<h3 id="_新的问题">4.7. 新的问题</h3>
<div class="paragraph">
<p>那么在配置文件中Type里HTTP这种东西怎么去采？采了过后，你又不能阻塞，因为只有一个线程，说白了你采完了报给谁？然后怎么怎么样，首先才肯定是用户自己写的程序采集，那要怎么解决gdp的问题、采集的问题。
首先分析一下采集HTTP的时候你要怎么用？</p>
</div>
<div class="paragraph">
<p>那个东西一定一直卡在那儿的，因为他不退出来，所以采集到的时候就一直卡在那，当然我们不讨论用户程序里头怎么写的，我不关心他。我们就只做什么，这边是用户的，这边是给我们的，我们就只知道他会每秒钟输出一条数据，然后这个数据你要怎么去搜？他每秒钟打一条，比如说你，你们两个，都不能断开，就等于说是这样的。你接收到一条数据，数据你收到过后马上处理，处理完了过后就应该到后面的逻辑，这个时候你处理完了，你应该又处于一个什么？他们之间数据给出来到这个地方，要怎么去处理？我不限制方式，头脑风暴，HTTP它每一秒钟那个程序每一秒钟就像will shock一样，每一秒钟朝指定的地方丢一条数据，我们不讨论之前的，你就相当于说你那个软件上头一直在新增东西对吧？新增一行一行一行，你说你每次处理的是新增的那一行，老的你肯定是不管的，那新的那一行怎么处理？</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_HTTP_chapter">5. HTTP协议</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_5">5.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/HTTP协议板书1.jpg" alt="HTTP协议板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP协议板书2.jpg" alt="HTTP协议板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是http">5.2. 什么是HTTP？</h3>
<div class="paragraph">
<p>HTTP：超文本传输协议</p>
</div>
<div class="paragraph">
<p>H：Hyper（超）</p>
</div>
<div class="paragraph">
<p>T：Text（文本）</p>
</div>
<div class="paragraph">
<p>T：Transfer （传输）</p>
</div>
<div class="paragraph">
<p>P：Protocol（协议）</p>
</div>
<div class="paragraph">
<p>之所以讲HTTP是因为所有人天天都会和他打交道，浏览器，app。甚至你的支付宝，他很多地方都用到这个东西。当然你刷抖音也很有可能为什么他的视频分段嘛， 像哔哩哔哩我之前上课的时候直播，我就把哔哩哔哩爬出来了，他出来发现他的URL都是什么HTTP打头的 ，而且他可能一个十分钟的视频，他分成了四段。</p>
</div>
<div class="sect3">
<h4 id="_协议_2">5.2.1. 协议</h4>
<div class="paragraph">
<p>网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</p>
</div>
</div>
<div class="sect3">
<h4 id="_文本">5.2.2. 文本</h4>
<div class="paragraph">
<p>很多文字组成在一起的就叫文本。</p>
</div>
<div class="paragraph">
<p>写一个超过文本的文本：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/文本.png" alt="文本">
</div>
</div>
<div class="paragraph">
<p>&lt;h1&gt;是经过渲染之后的文本</p>
</div>
<div class="paragraph">
<p>&lt;p&gt;就是文本哦</p>
</div>
<div class="paragraph">
<p>这个地方你可以看出区别，这个两个大小一样，他其实就是把一个文字打印到了屏幕和浏览器上面，没有做任何的改变，那这个地方我加了个h1过后就表示是标题1,就是你的word里头那个标题12345还有这个字体就越来越大，1最大嘛，2小3更小，然后正文是最小的。</p>
</div>
<div class="paragraph">
<p>所以这个地方指的超文本是靠这种东西这种东西来渲染的，用英文来讲的话叫tag,叫标记，英文来讲叫tag，那么tag翻译成中文就是标记，也经常有有人把这个东西叫什么标记语言，所以我们经常会把这个这种语法称作HTML ，HTML你就理解为这个协议里面的文字，HTTP是存在的协议嘛，你协议里面要有一种表现协议数据的形式。0101是计算机的表示，然后比如说我说话，说普通话，说汉字是我的表示，是我们两个能够理解普通话的，这个字典里面的表示 ，汉字是表示的 ，比如说你是英国人，你说英语，然后你写英文的文字，这个时候你的表现形式就是那个英文，那这个时候你既然说的是HTTP语言，那HTTP语言就应该有一个自己的文字和语言，那这样的话就是HTML。</p>
</div>
<div class="paragraph">
<p>HTTP=语言</p>
</div>
<div class="paragraph">
<p>HTML=HTTP的文字</p>
</div>
<div class="paragraph">
<p>H：Hyper（超）</p>
</div>
<div class="paragraph">
<p>T：Text （文本）</p>
</div>
<div class="paragraph">
<p>M：Markup （标记）</p>
</div>
<div class="paragraph">
<p>L：Language（语言）</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_为什么用http">5.3. 为什么用HTTP？</h3>
<div class="ulist">
<ul>
<li>
<p>简单好用：HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。</p>
</li>
<li>
<p>可扩展的：在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。</p>
</li>
<li>
<p>无状态，有会话的：HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p>
</div>
<div class="paragraph">
<p>使用场景：app、网页、物联网</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>摩拜单车要将他的位置报上服务器，就是用没有界面的HTTP；电梯里面的广告机在服务器上下发广告的时候也用的HTTP；投一块钱或者扫码拍照的，拍完数据传输也是HTTP。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么使用http">5.4. 怎么使用HTTP？</h3>
<div class="paragraph">
<p>例：</p>
</div>
<div class="paragraph">
<p>你用一个裸的python，你怎么使用http协议传东西啊？你最开始应该是准备一个什么？你要写个库，那个库能够正常的封包解包http协议。有了这个作为基础，你才能在封装更上层的class。</p>
</div>
<div class="paragraph">
<p>java本身它和http是有关系的，java语言他自带了一套去访问网页的一套库啊或者一些基础功能，或者叫内置功能啊，它里面有servlet，这个东西是干了个啥？那么这个地方servlet，他是做了一个封包解包，他在构造请求和解析请求，解析什么请求，现在看要是手写一个报文:</p>
</div>
<div class="paragraph">
<p>请求报文：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/请求报文.png" alt="请求报文">
</div>
</div>
<div class="paragraph">
<p>响应报文：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/响应报文.png" alt="响应报文">
</div>
</div>
<div class="paragraph">
<p>这个报文很简单，servlet干了个什么事情啊？servlet他收到数据的时候，收到的是Accept，他判断这个里头那些东西，他把他单独的拎出来，他封装了一堆class，就叫HTTP Request，
HTTP Request它会产生这个对象哈。然后这个时候，因为你是程序员，你要控制他你要回答，你要回答的话，你又需要构造HTTP Response对象，所以我现在我就决定他的对象那个中间的，Body等于body，标题等于title，最后，他就会构造上面一堆，他构造这一堆过后就把它丢给访问者，就相当说你在浏览器里面敲qq.com，浏览器会生成这个报文，什么叫报文呢？就是上面这堆东西就是给也程序看的数据，在网络上流淌的数据可以叫报文，所以这个时候，针对网络请求，我们一般都会说叫报文，上面这两个东西都叫报文，第一个叫请求报文，第二个个叫响应报文，所以请求报文是什么？是浏览器帮你构造的，那这个地方是浏览器帮你构造的，他发给了java，java在调他的servlet，servlet收到这个报文过后，把它转换成request这个对象，小写就是对象的，那么这个上面是java帮你转的，然后这个地方是程序员转的。程序员自己收到这个东西过后他要做什么处理哈？我就写到伪代码：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/伪代码.png" alt="伪代码">
</div>
</div>
<div class="paragraph">
<p>我打个比方我有个函数，这个函数的返回值是一个Response的对象，然后函数名字比如说我就叫doGet（），函数名字叫doGet就调用get，意思就是说get的时候调这个函数吗？至于怎么跑到这来的，你就先不要去管他，然后这个地方我写一段代码，HTTP Request这个东西就是servlet处理好的，他已经帮你生成了，就是把那个报文转成了Request对象，然后现在你就调一下，我就假设那边传了参数进来的，比如说这个时候我假设有个参数叫名称，那就是我就假设有个叫getName的方法，有这个方法过后，那么这个时候我就怎么样啊？我就构造一个对象 ，比如说直接reture，我就直接传类，反正最终能够返回这个对象就可以了，HTTP Ｒesponse（name）就是返回值嘛，所以你看到没有这个request的是java帮你生成好的，但是response要你自己调，要你自己初始化，最后你初始化完了过后就会得到响应报文，浏览器就会收到响应报文，最终这个response会回到user这个的地方，就通过http。
通过http七协议最终传给chrome吗？ 然后库中最后中间看那个网页上所以这个地方他怎么发生关系的？哈这个东西叫解码器decoder，当然解码器的话就是decoder，然后这个东西叫encoder，编码器。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Linux-systemsprogramming1_chapter">6. Linux系统编程(一、二)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_6">6.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程板书1.jpg" alt="Linux系统编程板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linux系统编程是什么">6.2. Linux系统编程是什么？</h3>
<div class="paragraph">
<p>Linux系统编程。系统编程是什么？分词嘛，以前比如说你有Java的编程经验或者有前端的编程经验，那你是在哪编程的，你那叫Web编程，是在HTTP协议上面给浏览器写网页，所以那个经常叫Web程序员，那Web程序员做的事情就是Web编程，那系统程序员就是系统编程，所以这个地方要分开来讲，首先，什么是编程？我就肯定不讲了，那么系统编程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what">6.3. What?</h3>
<div class="paragraph">
<p>老规矩：首先是What？这个地方应该有两个概念，把系统编程拆开，拆开后得了两个东西，第一个是 <code>系统</code>，第二个是 <code>编程</code>，当然这个地方的系统指的就是Linux，那肯定首先如果从范围上来讲的话，编程范围最大，任何东西都可以编程，系统编程是在缩小他的范围，就局限在特定的系统，比如windows，Linux、Unix，那Linux系统肯定就是在限定系统编程的范围，在一步步缩小，那么</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`Linux&lt;系统&lt;编程`</pre>
</div>
</div>
<div class="paragraph">
<p>从范围上是这样的，那就很简单了，编程我们不讲，那系统就是Linux，所以这个地方实际上说的就是在Linux系统上面编程。比如说，以前一个人虽然写 浏览器，Web程序，也是在Linux上面编程，但是那问了一个非常非常简单的区别。你去写HTTP的GET、POST，查了各种数据库，请问一个问题：你关心你是在什么系统上面吗？你想一下你关心吗？你用java加spring boot加MySQL。那他在Windows之下可不可以跑？在Linux下面也是可以跑的，所以就算你是用c++写的，它的区别也是非常非常小，为什么？因为你的编程语言跟你的操作系统之间，你没有让他们之间发生交互。比如说JVM我肯定知道自己在Linux下头，但是和你没关系，你是编程语言的用户，你没有和操作系统发生关系，你没有让你的Java代码去干点啥，所以这个时候就算你写十年的Java，你也成不了系统开发工程师，因为系统开发工程师要求的是：对操作系统非常熟悉。要求的难度直线上升，比如现在市面上有些岗位叫算法工程师，其实啥都不是，就是打杂的，为什么？各种各样的逻辑嘛？他不就高效嘛，他去理逻辑嘛，就是涉及到各个方方面面，那么系统工程师是非常老派的叫法，但老派不意味着落后，这是非常典型的叫法，他是按使用场景来分的。比如Web开发工程师是开发Web相关的，那么系统开发工程是开发系统相关的，现在出现的算法工程师或者全栈，他的意思就是说你是样样通样样温，你说那个算法工程要求很高的，是，他只是对学历要求很高，那他造过自己的一个框架？他没有，他只有用他有限的数学知识，然后去怎么怎么样，但是他绝无可能从头自己搭一套东西，为什么？算法工程师不是干那个事的。算法工程师是在已经有的数据上面去做一些逻辑的处理，让这个逻辑处理更快，更简单，去简化企业里面产品的一些地方，这才是算法工程师应该去做的事情，比如说有个岗位叫数据推荐算法工程师，干啥的嘛？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方
你刚刚在外面说话的时候你说我要买个录音机，结果打开知乎推荐第一个就是录音机，他们就是干那个的。</pre>
</div>
</div>
<div class="paragraph">
<p>所以以前我们的程序员或者我们开发的东西是根据它的使用场景来定义的，但随着现在的岗位越来越多，除了传统的岗位以外，还有很多新兴的岗位，它就是混合概念的，那这个地方说的系统编程是非常非常基础的，你都不能成为一个系统开发工程师，你成为不了一个优秀的全栈，因为一个优秀的全栈离不开系统，所以说这个是基础当中的基础，只有你成为一个合格的系统工程师，你才有可能成为一个优秀的Web开发工程师，你觉得这个没有关系啊，以后你会慢慢理解到的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你写的Java那个Spring Boot出问题了，前后端跨域嘛，反正你说我配了的，照着CSDN上面配了的，配完了后，你要知道生没生效，然后打开浏览器测一下，就是因为浏览器打开有问题，我才问你生没生效，对不对？你看这个时候，你就忙着摸下，就全靠瞎猜，但是如果你是一个优秀的系统工程师，你会怎么样？你会首当其冲：抓包，抓包看报文，请求报文一看，跨域头发过来了，但是你反东西的时候不对，你的响应报文有问题，或者是说不抓包，我浏览器F12也是抓包嘛，也能看到报文。</pre>
</div>
</div>
<div class="paragraph">
<p>所以它很重要，它很基础，我讲过的警惕一件事情：用技术论高地，键盘大侠就是这么来的，就是你虽然可能主修Java？但这是现在主修Java，等两年你咋知道你主修啥？你根本不清楚，等两年你主修收钱那就更好了，所以不要用技术论高低，他只是你当前所处的阶段，这个东西和你的阶段匹配，仅此而已。比如说：给你6000块钱用C++，给你8000块钱用Java，给你2万的时候对不起了，除了Java，你还得干点其他的，这个时候你的重心已经开始偏移了，发生了变化。</p>
</div>
<div class="paragraph">
<p>刚刚主要讲的是系统编程啊，在Linux上面编程啊，笼统的讲就是在某种平台上编程，比如说在手机上编程，我叫安卓程序员，我在iphone上编程，我就叫IOS开发工程师，我在单片机就叫嵌入式开发工程师，？然后那个嵌入式里面又用的Linux，所以又叫Linux嵌入式开发工程师，在浏览器上面就是Web开发工程师，所以这些都是在某种场景下面去做编程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_做什么">6.4. 做什么？</h3>
<div class="paragraph">
<p>系统编程解决了什么样的问题？怎么解决的？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

常见的MySQL、Nginx、Redis他们都是什么软件？他们是典型的系统软件，就运行在操作系统系统上面做某种事情，为什么不写qq？因为qq是纯用户端的，和个人也有关系，而上面举例的都是提供服务的就是Server就你可以理解为Service，就是服务，这些都是提供服务的，它们都要和操作系统打交道，而且非常密切，也可以把他们叫服务端软件，这样更具体一些，所以操作系统编程，系统开发工程师要做什么事情？就是调用操作系统的各种API和各种资源去编程。</pre>
</div>
</div>
<div class="paragraph">
<p>API的英文：Application programming interface，AP指的是Application就是应用程序接口，那接口是啥？其实就是那个USB充电那个口，这个地方的接口就是说操作系统留了个USB给你，只要拿USB，按那个USB的规则比如说：那个电压是多少？接口的形状是什么样的？插进去对不对？你唯一要做的事情就是自己用Java写一个USB接口，所以这个地方是调用超出性的接口开发或资源开发程序，举个最简单的例子的：ls，天天用是不是，他也是个程序，他在操作系统API，这个就很典型，它会调命令，这会调操作系统的函数叫：dir( )打了个括号，就表示是函数，Linux内核里面有个函数叫dir，你只要调这个函数，他就会把目录的列表还给你，然后ls再把这个列表的结果处理一下，弄成各种格式发给你。</p>
</div>
<div class="paragraph">
<p>ls调了操作系统的函数。刚才你说强哥；“我调Java的时候，我也调了read和write，”他肯定和他这种打交道，我知道，但是调用操作系统那个东西不是你本意，但ls是，你必须要直接调查这种系统的接口，比如说如果在Window下，你可以写个windows程序，然后把那个注册表的目录数、节点全部遍历出来，Windows就提供了comm接口出来，但是难用，相比Linux编程贼爽，Windows编程脑壳大，各种历史包袱，导致丑陋无比，Linux是直接：对不起，函数没有了，Windows为了兼容，他付出很多的代价啊，所以对程序员来说有的时候有些人可能适应。</p>
</div>
<div class="paragraph">
<p>上面讲到ls是调了dir，而上面MySQL、Nginx、Redis肯定是调了网络接口的，因为他要监听端口，所以他们一定会调个Listen，还有except，Listen是监听端口，比如说你MySQL默认端口是3306，那他一定会调这个代码的，MySQL官方自己调的，说白了，如果你写的一个程序直接和操作系统打交道。就是像这个样子，调用它的内核里面的各种函数，各种代码，你就可以叫系统软件。当然，ERP系统就指的是企业服务，比如说物流ERP，那种就和企业服务打交道了，这个地方全称是操作系统软件，意思就是说他是所有上层软件的基础，比如说我把MySQL一炸，所有人就瘫痪了，MySQL只要有Bug基本上挂掉百分之七八十都是很正常的。所以操作系统软件非常的重要，它不能有bug，他不能比如说圣诞节一个彩蛋挑出来，不是哪个UI框架，圣诞节的时候在政府的微系统上跳了个彩蛋出来，好像是阿里的程序员干的，就贼奇怪，在全世界，吐口水都把你淹死，所以在这个领域哈，是绝对不允许出现这种情况的。</p>
</div>
<div class="paragraph">
<p>那ls他做了什么？</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`1.调用OS的函数（直接）`</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>`2.直接调用操作系统的资源（内核）`</pre>
</div>
</div>
<div class="paragraph">
<p>在Linux场景下面的话，一切皆文件，鼠标是文件，显示器是文件，刚才他的显卡有问题，他的显卡也是文件，你的显卡在/dev/video card下，你把那个文件一删你会发现电脑就出问题了，而且就算重启了他也可能会有问题，那是因为你在装显卡那个包或者驱动的时候，他创建那个文件，你删了过后重启它就没有了，你只能重新把那个安装程序安装一遍。但是Windows如果是这种情况的话必须重装系统，但Linux就简单，只要把那个显卡驱动重新弄来，在命令行下头直接重装一遍，它就会恢复正常了。
这就叫一切皆文件，什么叫文件？刚刚讲了你的键盘、内存、cpu都是文件啊，所以这个时候你直接朝那个文件里面写点啥就有可能出问题，要是你要想搞坏一个人的电脑，贼简单，随便打开个文件槽里面乱写点啥，如果你要想搞一个Windows电脑，很简单，把目录一删就好了，Linux至少可以修复，但windows你想多了啊，你可以把比如说的两台电脑都是CentOS8，其中一台出问题，直接把另外那台电脑上目录东西拷过来后十有八九就好了，都不用重装。</p>
</div>
<div class="paragraph">
<p>所以，做什么具体就是两大类方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_how">6.5. How？</h3>
<div class="paragraph">
<p>怎么做？很简单。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

要统计内存信息。就是那个free命令，这个地方API调动函数的话，就类似刚刚讲的dir，当然还有很多比如删除。是一个叫unlink函数，你调它就可以删的东西，比如说修改权限chmod，这个命令，对不起，恰巧刚好有一样的函数，直接调这个函数也可以改权限啊，那既然可以改文件权限，那用户组也可以chown，能举很多很多例子，而且你都听过，所以你会发现那些命令都传参数给内核函数，他根据你的参数调这个内核函数的，把参数拼成他想要的样子，然后最后丢给系统执行就完了，好简单，就是这么直接了当，这是一类，就是刚刚说这个，那文件怎么办？文件大部分都在/proc这个目录，这个目录下面有所有的进程信息，还有一个比如说你要想知道你有多少个硬盘，你扫描/dev下面sd开头的，当然现在有的硬盘现在已经不是SATA的了，M.2的，你会发现还要支持n开头的，但是这个下面有所有设备的硬件信息，显卡呀、硬盘啊、usb、各种串口、sd卡槽都在这个下面，然后分区多大、分了几个区、分区信息、分区的头、分区的尾全有，有一个文件很重要，很常见的，比如说要看那个发行版的信息，它就在/etc/os-release，所有的Linux都有这个文件，这个文件里头，如果你是ubant 12.04，把这个文件的内容打到屏幕上面，它里面就12.04，完整的发行版的信息都在里面，个别发行版，他可能不遵从这个约定，有可能是其他的，但是红帽是很标准的，他除了这个以外，他还有个东西叫redhead-release就表示红帽发行版信息，这个叫系统发行版信息，但是红帽这两个都是一样的，ubantu有细微的区别，所以你会发现他的发型版信息就在这里头，如果把这个文件删了，你会发现有些软件，工作会崩溃，他凡是读那个系统信息都会崩溃，但是Windows你要拿信息就很麻烦你得调查的函数，Windows把所有的东西都封装到了它的函数里面，这些导致个问题，万一哪天他的函数参数变了呢，而且要维护那么多版本，你调的函数他还会乱码，但这个乱码是你不会处理，因为你不知道他用的什么编码，我就想拿个信息而已，所以Linux真的很简单，因为它的行为非常的一致，进程信息在/proc，设备信息在/dev，操作系统在/etc/os-release。</pre>
</div>
</div>
<div class="paragraph">
<p>所以Linux简单，是因为它的哲学：一切皆文件，他的行为也非常的一致，不会有特殊的东西，所以Windows下面那个注册表就是个毒瘤，那个玩意儿吐槽一万次都吐槽不干净啊，完全没用，还是累赘，搞注册表之前，我都要先把注册表完整备付，也不知道会不会出问题，Linux很简单，文件就两个行为，就读和写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

打开一个文件

1.打开一个文件

打开的时候，指定它是只读、只写、可读可写，一般只读可以了，然后指定文件名。

2.close

比如说打开是写就可以往里面写东西，写完了过后就直接close。</pre>
</div>
</div>
<div class="paragraph">
<p>全世界甚至全宇宙所有读写问题都是这么干的，没有例外，就很简单，没有特例，都是这么干的。当然一般搞系统编程的，涉及到内核文件的时候，一般都是只读，写的情况非常非常少，除非真的有特殊的需求，当然，除了这些文件，你可能还会写自己的文件，比如说Linux下面经常看到/run/nginx.pid这个东西,各种各种pid,特别是管服务器的时候，那个MySQL的pid意外失败了，那个pid一直放在那，然后你第二次重启起不起来，因为那个pd已经存在了，他提示你把pid删了就好了，而那个pid打开，你就会发现这个数字，那个数字就是进程号，所以一个很重要的文件，他居然就是写了个数字放在里头。所以就不要随意去改这些文件，你改了过后，你就发现起不起来了，放心，那个报错你是不会看的，然后你就会直接网络上求助。昨天前天我在网上乱逛的时候，发现有一个人提了个问题，他用Spring Boot读P SQL报错，请问大家怎么处理啊？我打开了他那个问题，有截图，是个好习惯，打开第一眼我就看到了问题在哪，我就找了旁边的同事，我说：你信不信，你是个天才。他说，我不行。那来看一个图，这个正在读P SQL，我给手指指给你看，你看这报错是不是报的MySQL，看到没有他就是不了解，他不会看报错信息，但是但凡你的多看一眼，你也不至于犯这种错误，所以这个地方他就很简单，就是往里面写了个数字。</p>
</div>
<div class="paragraph">
<p>所以搞操作系统编程，Linux操作系统编程，只需要了解上面两个，剩下的就简单了，真的，甚至写的Linux内核也不是不可能，内核模块，也很简单，只是有个问题：如果你写内核模块，你的程序出问题了，整个机器直接当机，因为你把内核搞崩了，但是你写用户态的信息啊，叫userspace啊，你随便怎么死，反正不会有事，但是你写内核态的程序的时候，他就很重要，为什么？因为内核态的东西是没有保护的，你在里面加个Bug，就像你往核反应堆里吐口水都可能出事，不过可能你打开盖子那瞬间已经出事了，就像打开你的天灵盖一样啊，剩下的就全靠天了。所以用户态的程序啊，影响不大。如果你能写这个，你就能写内核态的东西，什么叫内核态？就是更原始，用户态是在操作系统层面，那内核都不叫操作系统了，为什么？那叫操作系统的内核在最下面，这个时候，你要去写程序，你就应该更严谨，但是整体一样的没有区别。像我们以前给那个四川网监写防火墙，当时我们在运营商级别是有关键字扫描的，比如说你要席叉叉，将叉叉这种，你在百度上乱搜，你会被我们屏蔽的，你放心，不会抓你的，就只是是打不开网页，你会发现你的网页莫名其妙打不开，而且你怎么查都查不出问题，你只要搜特定关键字你就打不开，为什么？因为我们在Linux内核里，因为你要发现网络请求，那我们就在网络请求连接的过程当中，我们在中间加了个钩子，一旦你的钩子检查到你搜的是关键字列表里头的，就直接把你的链接强行关掉，然后刚好那么巧Linux是整个运营商的网关，你所以的流量都会在我那过，等于说我们再监控里，所以那个程序你能写这个，我刚刚说那个程序你也是可以写的，那个程序加起来不到200行，一共写了三个月。</p>
</div>
</div>
<div class="sect2">
<h3 id="_实战">6.6. 实战</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程板书2.jpg" alt="Linux系统编程板书2">
</div>
</div>
<div class="paragraph">
<p>我们监控系统里面最基础的功能就是监控cpu，监控内存，监控硬盘 ，监控cpu，线程和进程数量 ，开机时间，负载。</p>
</div>
<div class="paragraph">
<p>讲个最简单的uptime，看这个名字就知道，就叫开机时间，linux下面有这个命令 ，你在linux敲下回车，他会告诉你当前本机已经已经登录有多少个用户，就是桌面用户，或者远程登上去的，他会告诉你我有多少个用户，然后我开机时间是多少，开机了几天几年几月几分几秒 。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Linux-systemsprogramming2_chapter">7. Linux系统编程(三、四、五)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_7">7.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(三、四、五)板书1.jpg" alt="Linux系统编程(三、四、五)板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(三、四、五)板书2.jpg" alt="Linux系统编程(三、四、五)板书2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(三、四、五)板书3.jpg" alt="Linux系统编程(三、四、五)板书3">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_挂载信息">7.2. 挂载信息</h3>
<div class="paragraph">
<p>上次讲实战就只是泛泛的提了一下，今天我们就写挂载磁盘的监控，比如说平时我们在Linux服务器上面会用df -h命令，那么你会看到下面几个东西：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/dfh.png" alt="dfh">
</div>
</div>
<div class="paragraph">
<p>上面就是df -h命令输出的东西，但是如果要去做监控系统的话，不可能去靠这个命令得到这些东西，为什么？因为会出现下面几种情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一个情况：命令可能会升级。

第二个情况：命令有可能执行的时候没权限。

第三个情况：命令有格式，他有格式意味着要去解析格式，这样就对格式产生了依赖，哪怕多一个空格都会影响最后的结果，无法保证他没有，那么就要考虑各种格式的问题。</pre>
</div>
</div>
<div class="paragraph">
<p>所以在获取信息的时候，对方最好给你接口，有接口就可以调函数，就不用去解析格式，比如说刚才有一个人说他要查微博的信息，如果微博SDK都给你输出了一个列表一个for循环就弄出来了，你不用去爬了呀，那是爬方便还是API方便，那肯定是API方便。</p>
</div>
<div class="paragraph">
<p>所以这种方式它是有缺点的，但是现在我们要实现一样的效果，要在我们的网页上面能看到一个表格，表格有这么多多列，然后这个时候，你肯定不会把这个直接输出过去，在Linux下面，是有函数的，但是Linux不是所有的东西都会提供函数给你，为什么？因为这东西太简单了，所以他有一个东西叫/etc/mtab,当然他在proc目录下面也有类似的东西，比如说就叫mont,这两个效果是一样的。但是在那个文件里头，他就不是上面图片上的样子了，在那个文件里面，他不是一个命令的输出，他就是个文件内容，那个东西内核只要不变，比如说Linux大神，他们在开发的时候，如果不去故意地改变他，你或许是ok的，但是这个命令结果你获取就有问题，所以一般我们是从源头拿，而不是用命令知道，为什么？因为你读它，你要靠命令去帮你读，这就意味着中间包了一层，包了一层是有风险的，所以现在你要去读源头文件，那这个文件里面是怎么写的？这个文件里面很简单了</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/procmounts.png" alt="procmounts">
</div>
</div>
<div class="paragraph">
<p>由图可见这个地方和上面用命令出来的东西是不一样的，有多余的东西是列不出来的，就看你到底要不要那个多余的东西，所以这个时候就相当于是说用你的编程语言打开这个文件，文件有这些东西，然后挨个读。</p>
</div>
</div>
<div class="sect2">
<h3 id="_伪代码">7.3. 伪代码</h3>
<div class="paragraph">
<p>现在就写个伪代码：</p>
</div>
<div class="paragraph">
<p>首先应该就是打开文件，比如说打开/etc/mtab:</p>
</div>
<div class="paragraph">
<p><code>f = open(“/etc/mtab”,”r”)</code></p>
</div>
<div class="paragraph">
<p>这个时候是不需要去判断那个文件存不存在的，为什么？因为这个文件都不存在了，那你Linux都没启动起来，属于那种什么超级恢复模式，当然不能正常运行了，放心，就算是在那个模式，这个文件也是在的啊，除非到了崩溃模式，grub那个启动界面都进不去，所以哪怕是微内核的，甚至你的手机里面，都有这个东西，只是你看不见而已，所以这个地方就不需要判断文件在不在。</p>
</div>
<div class="paragraph">
<p>现在得到f了，那应该怎样一行一行的取呢？是不是所以我要调个Get一行，所以第二步是这样写的：</p>
</div>
<div class="paragraph">
<p><code>while (line = getline(f))</code></p>
</div>
<div class="paragraph">
<p>调了这个函数过后会得到这个变量，但是不理解为什么这个地方要合在一起写，那是因为偷懒的办法，如果这个地方，如果这个Line变量最终是一个空，是一个 <code>null</code> ，指向一个空地址，那这个while就会变成FALSE，一旦是空值他肯定就不会走下面了，所以这个地方那如果我得到的line有东西，那就得到的是第一行，那么第二行，第三行，第四行，然后如果在第四行过后，他又会转回来，又到了这个地方，直到第五行的时候是空的，那这个函数就会跳出去，其实写这个程序只需要几行，所以系统编程有好高级吗？你不懂的并不是这个地方，你不懂的是这个有什么用，然后他又怎么去呈现到用户那边去。</p>
</div>
<div class="paragraph">
<p>但是就算这个那么简单，到现在为止，100个人里面也没有一个人会写，为什么？因为基本上你可以忽略不计这种人，因为要对操作系统有了解，多少人装一个linux，装个Docker，把东西一拉一跑完事剩下的什么也不知道啊，然后我就拿K8S把它跑起来嘛，就解决你的宕机问题，这个用法没有问题，但是终归你会遇到，万一对方没有K8S，你就两眼一抹黑，而大多数公司出问题都是重启，在我这个地方可没有重启这个说法，为什么？只要你能连上去，就能够给解决，不要跟我讲重启这回事，为什么？因为重启是既不治标也不治本，为什么？你影响了业务啊。重启也是在影响业务，这边不就是本吗？所以最后两头都不站，只是解决了当前的死机的问题，但是你并没有解决他出问题，他为什么出问题？然后明天必定还会出问题，有可能是在你睡觉的时候，有可能是在你下班的路上，有可能是大家都睡觉了，用户在用的时候，这个时候你只能通宵值班，你看他啥时候出问题吗？</p>
</div>
<div class="paragraph">
<p>那这个地方我得到第一行，我得到第一行过后，我下一步是不是要做这个分割？所以我要得到第一列，第二列，第三列，第四列，第五列，那现在我要分裂，要把它分开，所以假设有个函数叫分割函数，比如说我有这个函数，那把这个行传进来，告诉他用空格分割，但是我的结果没有保存，那是不是该用个列表把它存下来，那么我有一个列表等于它，然后剩下就好办了，我列表等于他，而这个列表的总列数一定是固定的,为什么?他不可能说这个地方有5列，然后下面就只有4列吧，在操作系统领域不可能有这种行为的，就算没有，他都会给你放个none，会放一个标识符，表示站着位的，但是很多时候不会这么写的，他一定有某一个东西，所以它的总列数一定是固定的，就假设有五列：</p>
</div>
<div class="paragraph">
<p><code>if(line size()!=5)</code></p>
</div>
<div class="paragraph">
<p><code>break</code></p>
</div>
<div class="paragraph">
<p>只要循环不满足就立刻跳出嘛，所以说写程序嘛，你要处理异常，70%代码都是在做异常处理，因为我完全可以不写它，我直接会拿值，加起来不到五行，所以那判断等于五接下来就可以放心大胆的用了。</p>
</div>
<div class="paragraph">
<p>所以那这个地方得到第一列，那第一列，比如说，你要给他取个名字，这个地方叫分区，分区的英文怎么说的？Prtition：分区，然后第二列文件系统第三列是总大小，第四列是可用空间，第五个就是mount挂载点，我也讲过的：<code>程序等于算法加数据结构</code>，这个就是数据结构，这也就是算法，这也就是程序，完了，当然这个数据结构太简单了我可以给它拼成JSON，现在是叫数据结构噻，只是太简单了嘛。你不看这边，你就看上头的list的，它也是数据结构，只不过是放到数组里面的，放的变量就不是List？就不是数据结构了吗？它是有逻辑的，我现在是不是可以把它转成JSON？我是不是可以给它转成XML？还可以把他转成HTML，我可不可以存到数据库里面？所以你刚刚我说那些所有的东西就叫数据结构，而什么叫算法？得到那些数据结构的整个过程就叫算法，他的算法严格意义上说是这个While循环，在循环里面这一部分是不是，如果你要说整个程序的算法应该是这个包含While，严格意义上的话，那么整个While里面的list和if语句就叫算法，然后下面这部分就是数据结构，当然我这个地方数据结构很简单，那整个加起来呢？我这个地方可以把它拼成一个SQL，然后连接数据库、插入，然后你这个时候发现，其实按最精简的模式，连接数据库根本就不是程序核心的一部分，真正核心的部分只有你构造出等待插入到MySQL里面的那一部分，比如说insert、into、table那一句话里面屁股后面你有value吗？那个东西才是真正有价值的？为什么？万一某一天我不插MySQL，可能我要插P SQL，然后P SQL也不想用，我就想放到Redis里头，你会发Values里面那个东西啊，他始终是不会变的，就这一堆东西，变的是它前面的一部分语法，或者是你把这个值用到哪个地方去，等于说你构造了一个数据包，而这个包要怎么用？那是根据你的场景或者你需要的东西去演化、变化了，所以在这个过程当中，连接MySQL，然后检查连接是否成功、处理错误代码，这一堆东西，虽然它是程序的一部分，但是它严格意义上来说的话，它属于异常处理的代码，而不在这个公式里头，所以你在做技术调研的时候，你就做这两个，第一行都不重要，你一定会拿到那一行的，为什么？如果你用C写的话，你要去做那个切割的话，这个地方要用一个特殊的函数。sscnf去做列的切割。如果你用Python的话就更简单了，Python自动能够帮你分，你要用Java就麻烦一点，人生苦短我用Python，Java可能写个五行六行才能解决，Python一行就解决了，那么这都是根据你的语言不同。</p>
</div>
<div class="paragraph">
<p>所以我说这个东西叫伪代码，伪代码的意思就是说他和真正的编程语言没有关系，只表达你的意思就可以了，一般Python是最简洁的，所以你在做技术调研的时候，就是你要去验证你的思路是不是可行，或者是说，某种方案是不是可靠的时候，你就要做算法和数据结果的设计了，这件设计你能说通，你能说给你的同事或者能说服你自己，剩下事情就简单了。</p>
</div>
<div class="paragraph">
<p>第一个问题，你要在IDE里面去建一个工程，和他有关系吗？没关系，有没有问题？有问题，但问题不大，所以这个地方，你要自信一点，就是你只要把这个过程做了，剩下都简单了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_约定">7.4. 约定</h3>
<div class="paragraph">
<p>那么这个是一个挂载信息的获取，现在拿了这个东西，我剩下就只需要按照和对方的 <code>约定</code>，比如对方约定用JSON我就用JSON把它包一下，然后丢出去。如果对方说你打到屏幕上就可以了，格式是什么什么，照做就行了。如果对方要HTTP，就封个报文给他，至于我是用Spring Boot，还是用我自己写的，你管得着吗？只要按那个报文丢给你就可以了，就是说按我们两个约定，我们接口之间是要有约定的，为什么？因为你会调我给你的接口或者说我会调你准备好的借口，那这个时候我们两个是提前有约定的，叫规范(API规范)，JSON也是一种规范，为什么？因为我们两个提前会约定好，用花过号表示什么，用冒号表示什么，key叫什么名字的时候表示什么意思等等，那这个时候你们是提前有约定的，你说我们两个传JSON，他不叫约定，为什么传JSON传一对空的花括号，他也叫JSON，为什么？空JSON嘛，空JSON也是JSON啊，那所以这个时候你又要考虑清楚具体要怎么用它，但是这个一定不是在你调研的时候需要去考虑的，为什么？我如果打屏幕上print12345直接打，但是如果你Print打他就有问题了，为什么？因为你没有算法，但这个算法有可能有五行十行100行1000行，他都叫算法，所以程序多或者很大的时候，不要受干扰，程序里面70%的代码都是为了解决异常、平台兼容、错误处理、日志，只有20%到30%的代码才是真正的核心代码，而且可能比这个还低，有可能有的人你经常看到那个JS里面有人说，你见过最差的代码是什么样的？他能if 100层，到后面格式挺好看的，这种里面，我能用三行，把它的那个核心算法说白了，把它程序给写完，为什么？因为他无非就是一个查询表，查询表我在做可行性研究的时候，我那个表写一行。他也是有元素的，元素数量为一，然后顺利把唯一的那个元素拿出来，然后做一个加减乘除完了，你看就是不是大多数都是三行吗？对不对，所以说你跟别人去沟通，最开始做初步沟通的时候，你是跟别人沟通算法和数据结果的设计，但是你去写代码的时候一定要比他多，为什么？你要写各种错误处理：文件在不在？有没有权限？比如说这个地方f报错的时候，他一定有返回值，这个f就可能是空子针，然后这个空子针你要判断if f=空子针，就报什么什么错，然后这个时候本身原计划数据结构是这样的，然后结果报错的时候，你肯定还要对方约一个当出错的时候我们的数据结构是怎么样的？看到没有，无非就是这个链路走通了，你开始做完善了。就是那天我发到群里面的图一样。我发给你们过后我又改了2版，我发现：有的地方可以精简或者可以画的更好，我就开始做叠带了，有这个东西，你就可以做叠带，没有这个东西的时候你啥都不是，为什么？就停留在脑子里，脑子里面的东西是不值钱的，就像我脑子里面有很多东西一样，他一文不值，为什么？你又看不见，摸不着，也不能换钱啊。所以说这个时候，你要把它千方百计的落在你的纸面上，落在你的代码层面。</p>
</div>
<div class="paragraph">
<p>然后现在我们开始慢慢往上走了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拓扑">7.5. 拓扑</h3>
<div class="paragraph">
<p>接着上面的讲，先画个拓扑图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tuopu.jpg" alt="tuopu">
</div>
</div>
<div class="paragraph">
<p>一个机器上面可能有不同的监控程序负责收集数据，那么这些数据收集完了过后，他会通过假定现在是HTTP报给他Agentd，那么Agentd的守护进程收到过后，他又会把这些东西完整的收集一遍，然后统一报给他的上层，所以解释一下为什么要用HTTP，上次我们讲过，就是当前这个编程生态用HTTP是一种行业共识，因为它简单，而且很多框架的支持它，如果你自己要造一套TCP上的应用层协议，就有个问题：你的维护者可能看不懂，就会导致参与度很低，那么这个时候我们在没有遇到明显瓶颈的时候，就假设就用的就是HTTP，这个地方之所以让Agentd打包而不是直接发上去的原因是因为直接报上他，如果没有这一层Agentd直接往上报的话，那如果有50个模块，那就连接太多了，所以这个地方我们就假设他每秒钟，等于说每隔n秒他都会往上报一次，这个主要是为了解决服务端的压力的问题。</p>
</div>
<div class="paragraph">
<p>然后回到刚刚的这个程序这一边，那我们现在写的这个程序啊，就属于这个User的，那现在很明显用HTTP朝外面报，当时我们不是考虑了个问题嘛，就是说如果他是一个Shell怎么办？用Shell没有办法调别人的代码库，但是他完全可以用curl、pust往上报，可行性是有的？那这样的话，对于用户来说是，它可以用我们的编程，我们提供好的SDK。他也可以自己用HTTP往上报，这就像极了ES这种东西，你可以用它的JavaSDK，他帮你封装HTTP的请求，或者你觉得你自己要求简单，你也直接可以请求他的app往上面报就可以了，所以这样的话支持就非常广泛了，对我们的用户端程序就没有非常具体的要求，你都可以，当然Socket的好处就是他的性能很好，但现在是这个东西都没跑起来，求啥性能啊，我们又不是一个性能程序，如果真的要求性能程序，比如说我是一个监控MySQL查询的一个程序，所以这个时候对性能的要求应该是在User里头，就相当于是说我每监控一段时间，我就会朝外面报一下我的状态，我就像他这样的转圈圈，报出去，然后继续转圈圈再报出去，他上报的动作和他监控的动作其实是两个线程，这样的话就不影响了嘛，就非阻塞了。</p>
</div>
<div class="paragraph">
<p>所以网络托普就这样的，每一个人在写程序的时候，你肯定要画各种各样的图。算法和数据结构他解决的是单个点的问题，当然这种点可能有n个，但拓扑图一定你要有那么一张，因为它能让你的程序怎么运行，怎么用，一目了然，很明显吗？你都Agentd的这个程序了，好简单嘛。你系统上是不是装这个东西啊，看到没有，那运行怎么运行啊？是用c还是用Java就有很具体的要求了，我们之前讲过，这地方对内存很敏感，为什么？你运行这个东西跑个Java最低的要求一两百兆的内存，那别人一共在256内存，起都起不起来啊，就有一点过分，可能用户就很敏感，所以这个地方要么用rust要么用C，但是我们为了练手，就这个地方就是rust的，那这个地方用rush的，那么User，我仔细想了一下，你要调系统的函数，用rust调系统函数中间还是隔一层，所以用rush的地方一定是非常纯粹的，什么意思？他和别人不打交道，就是纯代码层面，别人不调他，他也不调别人，那我们就用rush的来写，但这个地方既要调操作系统，又要朝外面报东西，那操作系统都是C写的？windows是C吗？Linux可是纯C写的，Unix可也是纯C写的，所以这个地方监控cpu这种非常非常基础的，那就纯C，像那种要监控HTTP的你肯定首选C++或者rust了，为什么？因为这个时候他的分析量上来了，你要考虑你编写和维护的性价比的问题。所以这个是你要考虑，比如说像有些东西能够一个行就是弄出来了，还用啥编程语呀，一句Shell就搞定的事情，你要让你的程序快速的能够工作是一件非常非常好的事情，如果你写了一年你的程序，他跑不起来，我劝你早点放弃。</p>
</div>
<div class="paragraph">
<p>所以野生程序员就会经常犯一个错误，什么错误？</p>
</div>
<div class="paragraph">
<p><code>为了追求局部的先进性，忽略了总体设计的稳定性.</code></p>
</div>
<div class="paragraph">
<p>这句话是钱学森说的，讲的非常非常有道理，他是什么人？美国的喷气式实验室就是他和他的导师冯大牛一起搞的，钱学森是冯大神的学生，冯大神同时还搞了土星五全世界200吨推力的火箭，美国人的，当时和苏联竞争嘛？钱学森是美国空间实验室的缔造者，我们都先不说他是中国人，他为人类做了很大一部分事情，所以这个人非常非常厉害，你们要仔细去研究一下，也是可以的。</p>
</div>
<div class="paragraph">
<p>那现在我们通过简易的设计，然后让总体处于稳定状态就可以了，所以你不要为了追求先进性，搞得非常非常复杂，程序一定是越简单越好。</p>
</div>
<div class="paragraph">
<p>今天我跟我的同事在商量，我们有两套系统，这两套系统是通过网线或者wifi连在一起的，我就问他：“以前你们做这个这种需求的时候，你们是怎么去交换数据的？”就是说白了下面负责收集数据，上面负责接收数据，然后再丢出去，从这个层面就是这样的，这个是数据的收集者，这个是透传出去。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>我就问他一个问题：“以前你们是怎么把这个数据下面这个数据，发给上面做数据交换的？”

他说：“以前我们是直接用裸的TCP报文。”

对的，就是在TCP内层自己加一些简单的应用协议，就传个数据，对性能啥都没有要求你，他们居然要自己搞一个报文，自己造一套协议？

我说：“你们累不累啊？有没有什么可用的开源库？”

他说：“没有，啥的没有，一穷二白。”

然后我就推荐他，

我说：“你用HTTP绝对能解决。”

他说：“HTTP一传几百个字节，好麻烦。”

这时候我说：“什么？来我手写个报文给你看一下。”</pre>
</div>
</div>
<div class="paragraph">
<p>然后他看到，那么简单，对呀，就这么简单，为什么？我都能手写了，你程序员不能写啊，懂我意思了吗？我手写这个事情已经说明了HTTP很简单，然后他还有一些疑虑，怕掌握不够，我说，没关系，我花20分钟我跟你讲一下，20分钟我都觉得要不到，为什么？他以前也自己写过，但是我看了一下他们以前拼那个HTTP的报文可复杂了，拼JS，还加了很多没有用的头，那肯定复杂呀，我搞了那么久的研究，我觉得这个事情很简单，要用Python的话，五分钟的就解决了，你要用c的话，估计一天，为什么？真的很麻烦，各种各样的编译环境，很麻烦，但是相比他以前来说真的很简单，为什么？以前如果你写的TCP报文，然后你离职了，另一个人来维护，玩犊子了，为什么？没文档，就是写Bug，所以为什么？这个就是我追求的稳定性，而他追求的是能完成任务就可以了，没有任何考虑，也不先进，也不稳定，我说的稳定，不是说他写的代码不稳定，而是由于在改动过程当中很容易引入bug，为什么？因为他用纯c去操作TCP报文和用c操作HTTP来，我小朋友问你个问题：这两个哪个简单？为什么？因为HTTP是人尽皆知的，所以简单，但是非常底层的裸TCP，自己写的报文，他不简单，为什么？因为他是闭缘，他是不开放的，很少人去了解他，所以问题在于没人了解，TCP那么难，还那么多人学，为什么？因为大家都用啊跑不掉，所以如果可以的话没有人愿意去学的，但是你天天要接触他，你必须得学，看到没有TCP就很难懂，我上学的时候TCP/IP卷一卷二卷三，我可是全部都看了一遍，反正我看了几遍我都没感觉中间有些东西没看懂，为什么？哇，那个报文，他发了个表格，他说第几位，第几位是什么？为什么那么搞啊？我说这帮老头子在干嘛？我永远都看不懂，但是我工作过后接触到这东西，我再回来看，嗯，有道理。所以那个书不是给新手看的。</p>
</div>
<div class="paragraph">
<p>所以这个地方交换数据选的是HTTP是因为要让我们的维护更方便，然后让我们的使用性更高，你看我们通过这个配置的方式模块画的方式已经不限制我们的用户用哪种方式收集数据了，然后再加上又可以用HTTP接口往上报，进一步放宽了，甚至说Docker，他机器上做了五个Docker镜像里头朝这个地方报可不可以啊？但是你用说Socket可以吗？纯Socket的文件是不能跨机器的，不能跨机器意味着你的Docker和你的宿主机是隔离的，然后这个是，你必须当成两台机器，你看到没有，我没有限制可能性，只要不限制可能性，他任何事情都可以满足。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>比如说我的老板经常问我：

老板：你这个程序架构又得改

我：为什么？

老板：你看吧，需求变了，你要调。

我：老大，你放心，这个问题你不要再想了，你不用去担心了。</pre>
</div>
</div>
<div class="paragraph">
<p>为什么？我的意思就说你不要再瞎想了，听我的，为什么？因为从做出来到现在过了一年多的时间，我们接入了那么多需求，我们的架构可一点都没有调过。因为我们的设计架构的时候，我从来没有考虑过谁用这个系统，我考虑的是说：这个用户会产生什么样的数据？这个数据本身有什么样的特点？这两个人他产生的数据特点有可能是重合的，重合了过后我是不是只要支持这两种就可以了？但是如果要支持那个人就有问题了，为什么？人的行为多种多样，我最终得到一面红色的五星红旗，管他是捡的、买的、还是偷的，我最终是不是都有面五星红旗，对于我来说我就管红旗嘛，我管你是坑蒙拐骗，所以这个时候我没有去限制用户，我也没有限制进来的数据必须是什么样的，所以我在做系统设计的时候我在用最简单的方式实现了看起来巨大无比巨复杂的一个系统。我最近5、6年一直都在搞系统设计，我以前一直编码，编码的过程再去学捣鼓捣鼓反复的重构，那么我重构到了一定阶段，我就积累足够的经验，我就开始搞专门的设计了，所以我觉得设计非常非常有意思，为什么？我觉得很多时候把最简单的东西合在一起，它能产生无穷的力量，为什么？刚才我说的这个结构，对面可是拿年薪的，我跟他两个沟通的时候都在讲这个事，而且他都不掌握，那你掌握了是不是也可以拿年薪了？两个拿年薪的人都在沟通这个事情，但这个事情你都听得懂，这就说明你发现编程的本质实际上并不复杂，而复杂是他包裹着很多迷惑人的外衣。第一个，这次业务你不懂，你的资历浅，你说了没人听，然后还一个你不敢说，这个时候你会受到很多外在的因素，所以编程的本质其实非常简单，你掌握了一个个轮子往那一拼，完事。</p>
</div>
<div class="paragraph">
<p>就像刚刚讲的火药，几千年前发明的火药到现在还是硝酸啊？什么甘油啊？以前造了火药，到现在你还是靠冲击力迸发出去然后产生个惯性嘛？然后打出去，炮弹也是靠这个原理，你看，都是非常非常基础的东西，你掌握了几千年都不用变。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调用配置文件">7.6. 调用配置文件</h3>
<div class="ulist">
<ul>
<li>
<p>PUT方法</p>
</li>
<li>
<p>URL：http：//localhost：8080/model/disk，这个我们一般在URL里面我们会用过动词来表示这是个什么动作，但是这个地方我们也没用的post，因为说白了，我这个机器上头就只有模块才用这个url，所以我们就标准的restful api接口就有什么就用这个post的表示提交意思，这个地方我就不加动词了。通常来说，如果你是一个阿里云，你要向用户提供sdk，你的URL有超多，这个时候千万不要用这种标准的这种Restful Api规范,就用get表示获取，POST的表示提交更新，PUT的是增加，DELETE是删除，所以这个地方要用PUT。</p>
</li>
<li>
<p>接下里就是我收集到数据我要向上面报，拿着个时候我打个比方，我用命令行，curl-x PUT http：//localhost：8080/model/disk -d‘,引号后面就可以跟内容了。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>拼成一个json：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
   “name”：“disk”，
   “time”：“20121/8/16 09:00”，
   “timezone”:"Aisa/shanghai",
       "data ":{
            "filesystem":"ext4",
            "mount":"/",
             ....
           }
     }</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_agentd设计第一阶段">7.7. Agentd设计（第一阶段）</h3>
<div class="ulist">
<ul>
<li>
<p>Web Server（通信用的是HTTP）</p>
</li>
<li>
<p>Web Client（相当于User程序来说）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个程序在系统上面，你把它启动起来，那启动起来过后，他会默认监听一个8080端口,那监听的端口过后，那么他就相当于是说等待别人的连，等待别人往上报数据，那这个时候就相当于是说，我打个比方，就刚刚那个Put那么报上来的时候，那这个地方他应该每次报数据的时候他处理应该不影响后面数据接收，他应该是异步的。如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Agentd.png" alt="Agentd">
</div>
</div>
<div class="paragraph">
<p>就是他应该是多线程的，这是最基本的要求，当然你用现在的框架基本上都是这样的，你不用去担心这个异步的问题，但是你得知道，就算框架帮你封装了，你也知道，你不能说前面那个没有处理没有接收处理完的后面全卡住。他收到用户程序往上报的这个结果过后，他应该把多个模块的数据组合一下，再定时的报出去，什么叫定时报出去，比如说每一秒钟，这是一种策略。还有一种策略就是说，如果我这次报的数据和上次数据没有变化，我就不报，当然这种这种策略是因为在物联网上比较值钱，为什么？因为它可以省流量，但是现在我们用的都是网络，我们并不关心流量，如果我真的关心流量，我就相当于就是在上面往上报的时候这个地方加个GZIP压缩就可以，这压缩在Nginx上面开就可以了，你程序一行代码都不用写，这样的话能节约分之30以上的空间，浏览器或者你的服务端收到他自动会解压的，所以这个地方我们就不考虑带宽了，就相当于是说我们这个8080，他是第一个起个端口嘛，做异步接收，那么第二个他收到数据过后，那么要汇总（如上图），就像第二个大的逻辑，他要汇总所有的模块数据，那么汇总完了过后也要形成一个Json。如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
     "HOST":"..."
     "Name":"..."
     "Time":"..."
     "Zone":"..."
     "Modles":[
          {   “name”：“disk”，
              “time”：“20121/8/16 09:00”，
              “timezone”:"Aisa/shanghai",
              "data ":{
                  "filesystem":"ext4",
                   "mount":"/",
                    ....
               }
            }
         ]
      }</pre>
</div>
</div>
<div class="paragraph">
<p>所以说服务端会传上面做个Json到 Server，这个传就是Web Client，User报数据报给80端口，80端口收到过后，做一些处理，实际上这个Client指的不是一个模块，因为他是汇总所有模块嘛。是这个地方都是基于Json的一个客户端，所以他收集数据应该是等到某一个时间段，比如说每隔一秒钟把自己缓冲的数据组成这样丢出去，所以说他在他自己这个里面一定有最后一条这个数据的缓存第二次把它覆盖掉，比如说第一次disk传的一个数据上来，然后这个时候，他就如果你不主动删了，他一直放在你的那个静态变量放在那里，你第二次disk刷新了，你传数据给我，我是不是重新写一遍，然后当我到了那个一秒钟间隔的时候，我要把这个数据转成这个Json丢出去，你把这个用户端和这个服务端结偶了，就是说Server和user没有关系，你不要强行的说等到这个报的时候一起直接报上去，那你要汇总Modle数据干嘛呀，所以这地方，实际上是有cache的，是有缓存的，你缓存的时候最后一次上报的状态，所以说他什么时候缓存失效啊，等下一次覆盖嘛，他要是那个程序一直出错，他一直不覆盖怎么办？出错就出错嘛，你去解决出错的问题啊和我缓存没关系嘛，然后到后面就发现一个bug是吗？你们这个模块死了，这个缓存还在往上报。然后你要写一个东西去检测这个问题了，比如说你发现这个User请求不上去，他都通知不了，所以说你那个cache加个过期时间，你看系统是不是设计出来了，缓存加个过去时间，比如说过期五秒钟，五秒钟以内没报，我就直接把你删了，那这地方我就不会报你的数据了，因为我是基于缓存构造这个嘛，缓存是什么？缓存是这个modles里面的东西，你有三那个模块，我们就应该有三个缓存，所以这个地方我们自己构造一个缓存机制就好了，其实很简单的，因为Redis他是相对于没有技术的人，于我们的这种人来说，如果那个场景下，Redis不合适自己造一个嘛，也不是不可以真的很简单，就你想嘛，cache嘛，就一个静态变量嘛，静态变量生效是在整个所有线程里面都生效，所以你去肯定就有一更新，你肯定就有增删改查嘛，然后这个时候，你肯定还要起个线程定时器嘛，去循环检查这个cache。
当你循环了五轮过后，那个cache没有被更新，直接干掉它为什么？因为你cache每次插入进去那时不是一个时间戳嘛，so easy。</p>
</div>
</div>
<div class="sect2">
<h3 id="_server第一阶段">7.8. Server（第一阶段）</h3>
<div class="ulist">
<ul>
<li>
<p>Web Server</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_linux系统编程六七">8. Linux系统编程(六、七)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_8">8.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(六、七)板书1.jpg" alt="Linux系统编程(六、七)板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Linux系统编程(六、七)板书2.jpg" alt="Linux系统编程(六、七)板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_前言_5">8.2. 前言</h3>
<div class="paragraph">
<p>是时候给我们的项目取个名字了，我们之前说我们叫Linux监控系统，然后现在开源领域常见的比如：Zabbix、Cacti、Nagios后面两个都很老了，这个里面Zabbix份额是最大的，主要是因为它现代，Nagios是大概20年前用perl写的，然后Cacti是PHP写的，他只能绘图，功能很弱，基本上没有数据库，所有的图形是放在类似于XML或者是那种图片文件里面的，你要读的时候，他就会读磁盘上的文件，还要配功能很麻烦，所以这两个基本上都不是首选。</p>
</div>
</div>
<div class="sect2">
<h3 id="_zabbix的优缺点">8.3. Zabbix的优缺点</h3>
<div class="paragraph">
<p>那么们自己做的东西和Zabbix不同的点在于Zabbix是专注于cpu曲线、硬盘使用率、你的进程数，它的重点是在于绘制图形，它的重点是在于图形上面，那对于我们来说：我们应该更偏重于管理，Zabbix说白了都不用登他，可能每个月或者每个星期，你登上去看一下，或者出了问题，他发封邮件给你，他说进程数超过500了，这样你会发现他的颗粒度，就是说整体来说比较粗线条，怎么理解啊？</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>不管你有没有Zabbix，他对你的系统管理其实是没有多大影响的，你可能为了向外行做报告的时候，在PPT里你需要那些图，但是现在没东西，你就先把Zabbix装在那运行一年，然后当你需要图的时候，把它截下来就行了，但是对于System admin来说没用的，所以说我除了看这个以外，它有一些功能就是你可以设置它的cpu超过，比如说百分之百的时候，它会发封邮件给你啊，你进程数超过多少，他可以发邮件给你，可以设置阈值，Zabbix偏重于对阈值的一个配置来实现你的一些辅助管理，除了这个以外没有其他的，然后Zabbix特点是什么？刚刚讲的优点就是有图形，然后根据阈值来辅助你的管理，那Zabbix使用简单，可以管很多的机器，每个机器给你编组就像上体育课一样，男生站左边，女生站右边，其他站中间，他可以分组进行管理，最后编组过后，他可以按组来看这些图形，最后你会发现Zabbix其实他对于你管理上并没有帮助，你会发现他的重点其实是在于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一个:图形

第二个:编组（多机器）

第三个:阈值</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方第二个点 <code>多机器</code> 就很有意思，如果你只是想用Zabbix来管理一台单独的机器的话，它其实是没什么价值的，一般机器多的时候用它可能会用，比如说有的公司，它就两个机器，要看那个CPU曲线用top命令就看到了，也不存在做报告啥的，你想吗？我做报告我给谁做报告啊？我给我的Team Leader，就俩人，我给你做报告，我还给你写个Word，不觉得这个公司的组织架构有严重的问题吗？，为什么？一共就两个人，为什么不扁平管理，反而要这种树状管理，那这样的话就意味着：当你的体量小的时候，其实你是不需要这种炫酷的图形辅助你去做报告的，那你应该是直接登录机器去查看有没有问题，没问题就算了，有问题再说，所以其实你在机器少的时候，你是不会用Zabbix的，但是你想一下，如果公司一共有八个运维，出问题了，总得有个高手解决吧是吧，那如果你们公司半个运维或者一个运维，而且那个人又是兼职，现在问题来了，出问题了，所以在运维多或者人力资源充足的时候，Zabbix首当其冲拿来做报告的，做一种事后的辅助，写报告、查cpu什么时候异常、带宽用了多少等等，做这种统计性质的事，为什么我知道他们是这么做的？因为我用它也是这么干的。
高级点的就可以配阈值，配完了过后各种监控，各种报警短信、推送它都能报。</p>
</div>
<div class="paragraph">
<p>现在大家去监控网站有没有问题的方式是是叫什么？</p>
</div>
<div class="paragraph">
<p><code>“360免费网站监控”</code></p>
</div>
<div class="paragraph">
<p>这个就是360那个蜘蛛一直疯狂的爬你的网站，反正爬到你服务器崩了，他就报警了，叮叮叮，官方发短信来了：“你的网址不能访问了”然后问题就是说：他只是告诉你结果，打个比方说什么网站不能访问，网址访问异常，可能是域名解析出了问题，可能是CDN出了问题，也可能是内存死机了，或干脆就是阿里云宕机了。</p>
</div>
<div class="paragraph">
<p>是这样的，出问题我不用你，我知道我出问题了，为什么？宕机五分钟和宕机一晚上没啥区别，你想一下：反正晚上睡觉的时候人也少，宕机就宕机，只是一堆爬虫就挠头了，这个网页咋访问不了了嘞？半夜两三点钟你会发现那个WEN日志量都没少，我跟你讲：如果白天那个Nginx的Web日志如果有一百兆的话，可能晚上就有二十兆，就奇了怪了，那个清晨5、6点钟，那些人都要访问你的网站，你真的是91吗？那么大访问量？，所以这个时候半夜三更宕机其实对你来说是没什么影响的，所以你看Zabbix也是偏向事后，这个偏向事后其实就是用来做事后统计，做一些异常点：比如说半夜三更某个点跑高了，超过了你的一百兆的临界值，然后报警，他解决了什么问题？他只是解决了一种结果性的问题，所以说第三点也就是临界值，就是基于临界值去做各种的辅助，仅此而已。</p>
</div>
<div class="paragraph">
<p>还有个原因就是多机器，但是出问题一般是单机出问题，因为你只有一台一台单机出问题了，你才导致了多机出问题，比如说数据库那台服务器崩了，然后你是通过网络调用那台服务器B的，那么服务器A跟着卡，你访问服务器A上的网站卡着不动，因为SQL查不完，所以他的点就是单台引起的故障，所以这个地方偏向的是这种，所以做系统管理这么多年靠他真没帮我干到啥，这个也是为什么这一次我们要做一个自己的一个Zabbix，就是因为他解决不了我的问题，那为什么不参与他去重购？他本来就是开源的，是这样的，他整个特点都不是面向问题，就说白了，他出发点和我的立足点是不一样的，我的立足点是要保证我的服务器是稳定的，我的系统是稳定的，但它的立足点就是说：我只需要收集，只收集也就罢了，但是你要去自定义他收集的数据的时候，你就真的非常非常的麻烦，你要装各种插件，然后这种插件装了过后处有没有问题？反正除了作者以外，你也不清楚。
他也有我们这套逻辑，但是他整个出发点用的时候，User这个地方没法自定义或者可以自定义，但是一定不是我们这种新手去自定义的，然后中间一出问题，你根本搞不清楚到底是哪出问题了？当然我很熟了，他出问题也就那几个点，但是真的不友好，再加上他是国外的，经常中文乱码，为什么？因为他的server端的界面是用PHP写的，又没有自带中文字体，装了这个东西过后，第一件事情就要用中文字体覆盖到它PHP指定的目录下面去。</p>
</div>
<div class="paragraph">
<p>说白了，Zabbix不符合我们发展这么快，发展这么朝气的行业以及向上的这种趋势，它太保守了，它这种保守体在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一：语言隔离。

第二：社区运营有问题。</pre>
</div>
</div>
<div class="paragraph">
<p>什么叫社区运营，就是用户能参与其中，能提出自己的观点，当然你会说有键盘侠，但是那毕竟是少数，他可能会干扰你，但是你只要运营得当，是能够大大的得到更多的需求和反馈，用户会告诉你他需要什么，那么就会促进你的迭代，但Zabbix是一家商业公司，是商业公司开发的，那么他相对偏保守，而且他的社区到现在为止我没听说他有啥社区，当然他装了个论坛，那个算不算社区，我不清楚。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们需要什么">8.4. 我们需要什么？</h3>
<div class="paragraph">
<p>那么在监控系统领域，我们自己要一套什么东西？</p>
</div>
<div class="paragraph">
<p>当然Zabbix里面的这些东西肯定是必备的，为什么？</p>
</div>
<div class="paragraph">
<p>就算我们做了过后，图形我们肯定也是有的，至于分组，个人觉得分不分组好像也没啥关系，为什么？总不会你的服务器多到自己都不知道ip地址了，就是如果你都那么大量了，说白了，你这种属于特殊需求，可能1000个人里面就那么1、2个，再说了，你是腾讯，你有一千台服务器，你给我钱，我直接帮你定制嘛，所以我认为分组不是必须的，像这种临界值预警的可以考虑，但是，我个人认为，说白了你平时都不在电脑旁边工作，就算我通知你了有啥用？那么不需要做判断，也不需要发短信，你给我回调，我通知你，我一不用发邮件，二不用发短信，你让我回调你，你回调调不了我也没办法，所以我们是可以通过回调的，为什么？回调比邮件方便，我发邮件万一你说我是垃圾邮件把我给干了，我发短信我还得给钱，真的，你要申请一个发短信的平台，你得先有个公司，公司人人都有吗？但是如果你给我一个回调，随便你怎么玩，所以现在我们除了这那些以外还要要解决的问题就是说：我们为什么要自己造一套？</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们为什么要自己造一套">8.5. 我们为什么要自己造一套？</h3>
<div class="paragraph">
<p>如果这个问题回答不好，再往上走，我们就可能会出现偏差，今天很明显我们要设计Server，这个地方是核心，User是边缘，这个起手就可以做，没有啥设不设计的，但Server就不一样了，我们要怎么实现下面的点：</p>
</div>
<div class="paragraph">
<p>1.更小的颗粒度</p>
</div>
<div class="paragraph">
<p>2.更好的生态更现代</p>
</div>
<div class="paragraph">
<p>什么叫更现代？ <code>Reset For</code> 就是更现代，不要再用Socket了，然后前端是时候与时俱进了，大家都这么做了，你这样做了过后至少能让别人参与进来，为什么前后端分离吗？最根本的原因就是因为人力不足，人力不足不是因为没有人，人力不足是因为你花不起那么多钱请一个全栈把它做完，前后端分离的根本目的就是这个样的，为什么？你要是腾讯有一个亿，那还分啥前后端，每个端都是全栈，公司随便拎一个人啥都可以写，你还分啥前后端呢？</p>
</div>
<div class="paragraph">
<p>那么先解释完这两个，看后面还没有问要补充的</p>
</div>
<div class="sect3">
<h4 id="_更小的颗粒度">8.5.1. 更小的颗粒度</h4>
<div class="paragraph">
<p>第一个：更小的颗粒度，最直观的体现就是时间和 模块。</p>
</div>
<div class="paragraph">
<p>时间是指的采集上报的时间，是可控的，反正Agent负责收数据，那你想报多快就报多快，假设100毫秒报一次是可能的，这个地方是不限制的，你有数据就使劲往上报就行了，看到没有这个地方我是不限制的，那这个第一个是时间。</p>
</div>
<div class="paragraph">
<p>模块意思就是很多，那模块多了过后，你的系统，是否还稳定？因为是那样的，首先，一个系统它是固定的，打个比方，这个笔记本是我们的观测目标，我为了多维度的观察它，我应该要更多的模块，模块越多，我观察的越仔细，我观察的越仔细，意味着我可能更了解他，但是如果我只了解三个点，我可能就更少的了解他，就没有那么了解，所以这个时候你的模块应该是多维度的去观测你的目标，这样你才能找到更小颗粒度的问题，比如说有的时候出问题，就是那么100毫秒的个地方，啪一下，起来了，然后又变正常了，这时候你观测的时候，生成的曲线会很直观的展示出来问题的所在。</p>
</div>
<div class="paragraph">
<p>所以用我们这个系统更大的目的是为了什么？</p>
</div>
<div class="paragraph">
<p>提升你的系统或者应用程序的性能，你可以从每一个可能点去观测你的应用程序，而且不侵入你的应用程序，提供一种客观的数据能够让你提升你的性能，能够帮你找到你想解决的问题。</p>
</div>
<div class="paragraph">
<p>比如说那天一个朋友微信上说他有问题，然后帮他解决了，就重启一下啊，你懂的，反正没给钱嘛，就义务重启一下重启完了，他说那个移动端的网站打不开，结果我一打开，这个不是打不开，域名解析正常、数据包也进到了那个系统上面，但是他访问他访问的时候就在转圈圈，然后我就跟踪PHP的进程，然后就发现他唯一访问那个移动端，他就跑去请求一个ip地址啊，巧了那个ip地址这么写的：api.wechat.com，公众号他解析出了一个ip地址，他就请向他发请求，半天没回来，我就告诉他：你那个移动端的网站，是在请求微信的接口，或者回调，报错或者超时了一直卡在那，他就给我发了个红包，我友情重启，他不给我发红包，我把他这个解决了，他发红包，说白了我也没解决，我就看这个花了大概十秒钟，然后他那个红包我24小时没收，超时了，哎呀，亏了，但其实我更觉得没有必要去收那个红包，因为顺手嘛。</p>
</div>
<div class="paragraph">
<p>你看到没有，我只是从我认为的一个点，但是那个经验是我的经验，是在我脑子里，他没有办法辅助你，所以说我就应该把这种经验变成模块，你可以解决你的问题，不一定所有模块都要随时随地启用，你想解决这种问题的时候，再把这个相关的模块启用，然后这个时候，数量啪啪啪就上去了，没关系，你反正是为了解决问题，然后等访问两次那个移动端的网站，再把这个模块禁用，剩下的再去分析日志，你看，就应该这个样子，所以说更小的时间，更多的维度，更多的模块，帮助去解决问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_更现代更好的生态">8.5.2. 更现代，更好的生态</h4>
<div class="paragraph">
<p>我们刚刚讲的我们除了有现代的API以外，我们还有回调，有回调就可以通知用户，因为那个回调的网址是用户的，我会向他定时的推，至于他用回调来发短信还是啥？和我们没有关系，也不需要改我们的代码，只需要提供这一个口子就可以了，而Zabbix很全：短信、邮件，好像就是没回调，因为在国外邮件用的多，然后短信好像他默认是不支持，要装插件，邮件的好处是他有个邮箱就可以了，不过邮箱不是所有人都要用的，但是起一个app server可是每个人都会的，邮件肯定简单一些，但是你都在解决性能问题了，你是个新手吗？再说了实在你不会写回调我再给你开发一个小Demo，你啥都不会，就把Demo跑起来，刚好也是pgp的，或者是Python的，你把那个东西跑起来，至少回调会发到你的服务器上，你看到没有，这就相当于是两件事情。</p>
</div>
</div>
<div class="sect3">
<h4 id="_视角">8.5.3. 视角</h4>
<div class="paragraph">
<p>然后第三个视角的问题，就刚刚更小的颗粒度这些东西就是总结出一个视角的问题，我们的视角是：第一个提升性能，其实提升性能的过程就是解决问题的过程，所以我只是把它单独拎出来了，第二个应该是解决问题。</p>
</div>
<div class="paragraph">
<p>比如说，你可以在我们的系统上面把那个系统的SSH登录日志，可以写个插件把那个日志整理一下推到我们这个Web端去，然后就知道有谁登过吗，某个ip地址、什么时间登录的、用户名是什么、端口是多久，还有个注销，你不用说持续多久，就一个登录一个注销，用户自己看那个时间，你不要去帮他算了，当然也可以上服务器友情赠送嘛？因为在我这个地方，所有数据都有了，不用挨个去查，就是有种可能性，你查是查不到的，为什么？有些工具人，他用他那个工具登到你的服务器上过后，他干完事情就会把日志给删了，然后等你去看日志的时候，黄瓜菜都凉了，但是我这个一秒钟一次，他都还没来得及删，我都已经传走了，相对来说就更可靠一些。</p>
</div>
<div class="paragraph">
<p>比如说以前我不是发过一个网站被入侵，它里面那个ps命令都被替换成了工具人自己的ps，他那个ps里面有个排除挖矿程序，所以说你用Top命令或者ps命令去看的时候，永远看不到异常进程，你很奇怪，但是我们收集这些信息不是通过top命令，他不可能把/proc下面给改了吧,他这么一改，他就得一直改，那个难度就有点大，所以这样的话，对于我们来说，有助于解决我们的问题。</p>
</div>
<div class="paragraph">
<p>用户为什么要装我们的软件？很简单嘛，一定是稍不注意把数据给删了，但是也不知道是谁干的，就可以装这个，或者是说你从程序层面来看的话，程序不可靠，那么运维说我要自己想解决找这个问题或者线索，那么也可以装我们的软件，但是你用Zabbix，对不起，装上去啥都不能用，就一个cpu带宽、网络，你告诉我除了好看外这些东西有啥用？</p>
</div>
<div class="paragraph">
<p>所以我们就是基本上就是三大类啊，然后视角里面还有一个，我们着重强调的是单机管理，只能说1.0，万一2.0我有钱了，加个集群功能、分组也不是不行，但是我们强调的应该是实时管理，而这个实时管理，相对以前来说，以前可能是一个月对一次，你现在可能是你一直挂在上头，这个时候，对于你来说，要解决问题，肯定是这一天都在这上的混，不可能说问题没解决，把软件一装就完事，不会的，因为数据按正常来说，只要你把这个系统搭起来，跑起来几秒钟以后就有数据了，Zabbix的数据是随缘的，因为你不知道哪个地方出错，当然这个Reset For其实你也不知道，但是好歹你能排错，Zabbix是排不了错的，为什么？我到处都是模块化，他能不能工作，你拿出来运行一下就知道了，再说了，强哥是日志工程师，作为日志工程师来说，我会有完整的日志。</p>
</div>
<div class="paragraph">
<p>所以这是主要的几个区别，好了讲了这个那么基本上给我们服务端这边东西定性了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_取名字的作用">8.6. 取名字的作用</h3>
<div class="paragraph">
<p>谁知道为什么：名字取不好代码就写不好？</p>
</div>
<div class="paragraph">
<p>名字取不好就证明你不清楚你的娃，你想让他成为什么样的人才？你对他的希望就属于随便一个都可以，然后换成写代码这件事来说的话，好像这个功能也可以加，然后写到中途就加了五个需求，好像分组也要，好像那个阈值也要，好像短期推送也要，都加上，然后到后面了，似像非像，到时候变成了不像个日子管理系统，也不像Zabbix，你也不像你自己，我就不一样了，我这种人就是一根筋，我要做的事情我想着法说服你，你必须要这么做，你不这么做，我就来，我带着你做，如果你反抗这么做，我换人，要么是我把你开了，要不是老板把我开了。</p>
</div>
<div class="paragraph">
<p>所以名字取不好就意味着你对你的程序功能不清楚，如果名字不好，就意味着需求或者是功能不明确，需求或者是功能不明确的话，你代码一定写不好。</p>
</div>
<div class="paragraph">
<p>刚刚讲的为什么要造轮子就相当于是明确需求，说白了就是项目背景，只是现在我们还没有到整理项目文档的时候，为什么？写程序写代码永远是从代码和技术出发，不要一来就给我整项目文档说明书啥的，那个东西是用来做企业管理的，作为一个普通人，你不应该去考虑那个东西，你应该考虑你的用户怎么用，就算你不写文档，你那么做了，用户也买账。</p>
</div>
<div class="paragraph">
<p>所以文档是用来做沟通的，是用来做团队配合和管理的，所以现在知道为什么名字取不好代码就写不好了，因为你的需求会无限膨胀，我以前给波波讲过一句话叫什么？</p>
</div>
<div class="paragraph">
<p><code>你写代码的过程实际上是一个收敛的过程。</code></p>
</div>
<div class="paragraph">
<p>它在聚拢，需求在聚拢，你的重点也在慢慢的聚拢，为什么？你写完了你的代码应该有几个重点，凡事和重点无关的都是次要的，到现在为止我们都没有讲接口访问需要验证，因为他现在不重要，你的内部还是α版本时候，他是不重要的，但是一旦你发不出去，那个时候就重要了。</p>
</div>
<div class="paragraph">
<p>所以这个时候，我们在这个阶段，你要聚焦，你要收敛你的重点、收敛你的需求、收敛你的思维、收敛你的精力，把它们聚焦在特定的某些重点上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_球眼系统qiuyan服务端设计">8.7. 球眼系统（QiuYan）服务端设计</h3>
<div class="sect3">
<h4 id="_postgresql">8.7.1. PostgreSQL</h4>
<div class="paragraph">
<p>就是为什么不用Mysql，Mysql其实是很廉价，其实也就很普通，一个关系性服务器，PostgreSQL的话，相对来说它的代码包括它的理念都是非常非常好，Mysql那会儿没事务，那么PostgreSQL很早以前就有事务了，两个相差多久了？大概4-5年，所以你知道他们两个带差了，基本上差一代到两代，所以第一个就是持久化存储，选择用PostgreSQL。</p>
</div>
<div class="paragraph">
<p>这里面有几块数据：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>统计：我们有统计类的，但是我们没有用ES也是意味着我们在写代码的时候，你要考虑不要跟我写慢查询了，要合理的设计，规避复杂的查询，当然我没有说加索引解决不了，他能解决，但是他一定是一种被动措施，那个一定是没办法的时候加，正常来说你写代码肯定是要加索引的，但是你不能全靠所索引，为什么？因为所以像like 关键字，很多东西是没有办法生效的，然后这个时候，你不要和他违背，随着你写代码的时候一定要通过良好的设计，避免去做复杂的查询，什么叫复杂查询，一次性查五个表，你那有问题，你知道吗？你既然一次性查五个表了，你为什么不考虑一下第一个？为什么你要查五个表，你查五个表正确的选择？你需求拆分出了问题？如果需求有问题拆需求，如果表有问题拆表，如果都没有问题，请你自己提高你的技术水平。</p>
</li>
<li>
<p>持久化：持久化是将程序数据在持久状态和瞬时状态间转换的机制。 通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）。</p>
</li>
<li>
<p>缓存：通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP缓存，变得更加响应性。</p>
</li>
<li>
<p>时序（集群）：打个比方，你手机里面你要监听控他的cpu，那你应该是只有一个cpu的使用率。再加上个时间戳,上一秒90%，下一秒100%，下一秒10%，你看到没有它的列一共就两列，而且是随着时间一直在不同的变化，那这样的话，这种数据非常非常容易绘图，这种非常容易绘图的数据就是时序数据，为什么？因为他不会随着业务，其他的变化你也都发生变化了，不会的。它使用就是这个cpu，那个字段一直在不停的变化，你是服务器嘛，无非是多了几列嘛，你现在是每次收集一次基础信息，那就是一行，比如说你要把cpu内存单独放，也不是不行，他也是随着时间变化的变化，所以理解什么是时序数据库。这是时序本身也支持集群。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以有统计类的数据就是这种是要保存的数据，还有一种缓存，然后这地方涉及到一些时序数据，所以选PostgreSQL是非常非常正确的选择，Mysql没有办法兼顾那么多，这个是大的技术点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_springboot">8.7.2. Springboot</h4>
<div class="paragraph">
<p>选的是Springboot，选Springboot是这样的，服务端嘛你给我两三百兆内存，让我跑一下那是可以的，就一个嘛他又不多，为什么选他？其实你除了Java以外，你就只有PHP可选的，但是你写PHP的话，你以后接手的维护的时候很麻烦，因为人太少了，你的生态不好弄，你用PHP就会把你的页面的展示还有你的整个逻辑全部用PHP代码合在一起，然后这个时候你就没有办法分开，那这样的会导致在维护的时候，你可能那个人又要懂界面，又要懂PHP，而且调试的时候很麻烦，因为PHP调试的话，虽然他有方法，但是他始终没有Java成熟，打个断点就调了，这个是一个，然后另外就是虽然Web编程PHP更快，但是Java能够写更少的bug，这个也是选择他的原因哈，所以服务端我们都不叫他Java应该叫Springboot。你装个PostgreSQL装个Springboot，啥都不用干，你只要装了Springboot你连Nginx都不用配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_react">8.7.3. React</h4>
<div class="paragraph">
<p>我们当时说是用React，为什么用它，主要是因为它复杂，他要是简单我才不用他呢，为什么不用简单Vue要用React，之所以他复杂是因为他有设计，还有各种设计模式，还有各种编程的抽象，那么你写他的过程当中，你会体会到这种设计带来的好处。还有你要付出的代价，设计的越好意味着使用成本越高。界面用React，然后至于，CSS平铺这些东西就bootstrap就可以了，那个React里面在那个界面布局没有，就用bootstrap做布局哈，扁平布局。</p>
</div>
</div>
<div class="sect3">
<h4 id="_only_pc">8.7.4. Only pc</h4>
<div class="paragraph">
<p>只有pc端没有移动端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_时间通知回调http">8.7.5. 时间通知，回调（HTTP）</h4>
<div class="paragraph">
<p>事件通知嘛，我们直接用回调，肯定用HTTP。</p>
</div>
</div>
<div class="sect3">
<h4 id="_大致过程">8.7.6. 大致过程</h4>
<div class="paragraph">
<p>用户代码调用我们的sdk，构造了一个URL向Agentd上报数据，比如说每隔一秒钟向Agentd报一次cpu的数据，报到Agentd，那么他要做汇总，他汇总完了过后再把那个Json统一报到Server，等于说他汇总，比如说这个地方是一秒一次，那一秒他如果收到数据他就报没收到都就算了，那等于说他每一秒钟都会报，空的也不是不可能是可能的，那空的你报啥呀？空的请你直接跳过，谢谢。这样报到Server，这个地方首先是Springboot收到了，收到了过后，他要把那个Json转成Java对象，那么做一些简单的业务处理，该保存保存，该怎么怎么样，然后最后就落地嘛，就保存到数据库里面做持久化，然后这个时候做完持久化有一些东西要做缓存的，他加到缓存里面有效保存到时序，比如那监控数据，你可能就放到时序（集群），统计数据是什么时候用的，是用户来访问网页。这个是技术点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_怎么使用">8.7.7. 怎么使用</h4>
<div class="paragraph">
<p>我打个比方，你肯定有登录界面，我这个时候就从用户出发了，用户来请求，那用户来用的话，首先肯定是怎么登录？那肯定就是典型的账号密码咯，典型的账号密码登录那登录进来，登录进来过后，那么你有首页，首页虽然我现在不知道长什么样，那肯定有，有什么目录菜单之类的东西嘛，Zabbix他是把他的菜单放在中间就是顶部的，他是放在一排他不是竖着放的，还是横着放的，但是那个感觉不符合中国人的习惯，我们都叫球眼呢，都用拼音的，自信一点，我喜欢竖着排的，那所以这个地方大大概的布局应该是这样的，这个地方应该有logo，然后这个地方是菜单，然后这个地方是应该一些登录的注销，然后这个地方是应该是一些，当然可能有些文字，大概是这种布局噻。</p>
</div>
<div class="paragraph">
<p>那这个数据里头肯定有一类是这个样子的就是这图形里头肯定有一类数据是这样的。如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/折线图.png" alt="折线图">
</div>
</div>
<div class="paragraph">
<p>这个就是统计类的。</p>
</div>
<div class="paragraph">
<p>另一类是这个样子的。如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/表格图.png" alt="表格图">
</div>
</div>
<div class="paragraph">
<p>这个就是展示类的，去浏览信息的原始数据。</p>
</div>
<div class="paragraph">
<p>当然有柱状图折线图，我只是说有图，有图有表，你肯定还有某些表单嘛，那是表单那种是涉及的编辑的，现在对于我们来说，我们先管上报的，上报出来有一类统计类嘛，而表格是展示，就是让你浏览，去浏览那个信息本是原始数据嘛，那这样的话你倒过来，你登录，登录到了这个界面，然后点某个菜单你可能浏览某些一条一条的数据，然后你可能还在首页上面有些图形简单的，比如说你有几台机器，你可能在这个地方，你两台，然后这个地方就是当前有些是异常的数据或者是说你能判断的东西也会概要嘛，那除了这个以外，这种是浏览性质的，然后你浏览完了后面不是有操作按钮，然后什么增加删除啥的，总的就那么两类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_界面概念图">8.7.8. 界面概念图</h4>
<div class="imageblock">
<div class="content">
<img src="images/登陆概念图.png" alt="登陆概念图">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/界面概念图.png" alt="界面概念图">
</div>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_QiuYang_chapter">9. 球眼系统设计(八)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_9">9.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/球眼系统设计(八)板书1.jpg" alt="球眼系统设计(八)板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_控制策略">9.2. 控制策略</h3>
<div class="paragraph">
<p>之前我们一直讲的是说我们的用户程序直接往上报，服务端是不需要管任何就是情况的，但这个地方有一块必须得讲的，就是说服务端一定会去下发某些策略去控。</p>
</div>
<div class="paragraph">
<p>打个比方，我们昨天简单地提到一个启用、禁用的问题，首先禁用那个程序本身就是User程序本身不应该让用户去修改配置文件，因为那个东西太原始了，如果这么玩的话，那不得把人给累死，所以在这个时候，用户是不需要去修改配置文件，由他在Web服务器的网页上，点一个启用、禁用后，插件就不应该停止工作，所以涉及到启用、禁用的问题，我们之前有讲一个就是命令，当时我们是这么写的</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`agentd -m cpu start`</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方有start，那就应该有一个stop。</p>
</div>
<div class="sect3">
<h4 id="_when">9.2.1. When？</h4>
<div class="paragraph">
<p>那现在就应该是说什么时候启用、停止？</p>
</div>
<div class="paragraph">
<p>就是说我默认情况下面Agent启动的时候它首先应该扫描，然后扫描到有那个配置文件，然后，就把对应的模块自动启起来，但这个是基于我们的默认控制策略，那一定还有用户端的配置策略，所以在启动的时候，Agent应该问一下服务器，扫描到的这些插件，默认我要启动了，那服务端应该告诉客户端，给客户端个清单，启用清单或者禁用清单，首先你要把扫描到的配置报给服务器，服务器收到过后，告诉你这些配置里面哪些是禁用的，就相当于把那个清单先发上去，他就回你，因为是这样的，比如说这个机器上面启用了哪些模块，就是默认能找到哪些配置文件，一定是他去扫描过后才会得这个清单吗？所以服务端的这些模块、配置也好，应该是来自于客户端的扫描，扫描过后上报给服务器，然后用户基于上报的清单，把它拿来做编辑，编辑完了再下发给客户端。
那这个过程当中有没有必要去做一些存储的东西？比如说你的，服务端记一下有哪些模块是客户端的，有哪些模块怎么怎么样&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>那有个问题：</p>
</div>
<div class="paragraph">
<p>要是你在数据库里面去记录了这个模块的清单，那啥时候更新？</p>
</div>
<div class="paragraph">
<p>这里从我的直觉来说，客户端他在启动的时候，每次启动都报一次，或者每次Reload的时候，意思就是他只要重载了配置文件，他就报一次,那关键是还是有个问题，服务端用户，他肯定有启用，禁用，启用肯定不用说。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_交互过程">9.3. 交互过程</h3>
<div class="sect3">
<h4 id="_简单的梳理逻辑">9.3.1. 简单的梳理逻辑</h4>
<div class="paragraph">
<p>所以说就要讨论这个交互过程啊，首先，我把这个逻辑简单梳理一遍：</p>
</div>
<div class="paragraph">
<p>1.agent启动的时候要做扫描Config文件，然后得到一个Mod的清单，包括一些配置。</p>
</div>
<div class="paragraph">
<p>2.配置完了过后Agent把这些数据ConfigA直接报给服务端。</p>
</div>
<div class="paragraph">
<p>3.不管他中间发生了什么，服务端又把这个ConfigB下发他</p>
</div>
<div class="paragraph">
<p>4.Agent收到ConfigB的时候就Reload</p>
</div>
</div>
<div class="sect3">
<h4 id="_合理性">9.3.2. 合理性</h4>
<div class="paragraph">
<p>这是我最简单的一个直觉啊，就是我觉得应该这样做，所以我们现在讨论它的合理性或者说这过程当中有什么东西没有考虑到的，你肯定自己的配置文件里面要配服务端的ip地址啊，要长链接吗？他既然能上报他，第二次再来请求一下处理结果吗？上报的时候服务端自动就下发了，打个比方，我们先讨论大的逻辑，波波提了个很好的问题，因为HTTP是没有状态的连接，他请求完了，就会断掉，然后这个时候，服务端是不能向客户端发送数据的，所以以前的Zabbix是长连接，是用的Socket，就可以一直保持在那个地方，但对于我们来说，我们应该没有动机去做一个那么长的连接，顶多是在这个业务的发送期间，一秒一次那个连接数，我觉得它不是个问题，要是你有那么多机器，你直接把那个HTTP的keep live打开，其实性能是没有问题的，但是在业务上面，其实就是断掉的，因为HTTP是没有状态的，上次我们在讲报文的时候没有提这个是因为HTTP的行为，还不是现在考虑的一个因素，所以现在整个逻辑当中还是有问题的，就是用户在什么时候去配置那个东西？打个比方，你之前报了个清单上去，然后用户改了还往下丢，那么在丢的过程中，客户端怎么来拿？比如说是客户端下一次来请求的时候。</p>
</div>
<div class="paragraph">
<p>这个地方先提个概念：</p>
</div>
<div class="paragraph">
<p>pull和push，在git中用push的时候就是你作为客户端向服务端推，这就是Push，然后pull的话就相当是说你作为客户端把服务器上的东西拉过来。</p>
</div>
<div class="paragraph">
<p>这个地方也有这个概念，以你自己为基点，你向服务器推还是向服务器拉都是用的HTTP，都是客户端主动发起的，就像你的浏览器一样，你不点他，他不会有自己请求的，但是聊天室就不一样了，为什么？聊天室随时随地都在发消息，收消息，他是一直有交互的，所以这个和典型的聊天室是不一样的，是基于C/S结构，基于C/S结构的时候普遍意义上都是这种状态，当然如果是典型的Socket连接，他是可以做的长链接的，但是他也是有推和拉这两个动作，只是说那个连接断不断的问题，但是我们这个地方连接是断的，那直觉讨论的话，这个里面还是有些细节问题，我们就不管这个。</p>
</div>
<div class="paragraph">
<p>首先默认情况下面我们默认的模块，它是不能禁用的，禁用他没有意义，我们就假设默认模块是不禁用的，但是像那种HTTP监控它很耗资源的，用户就可能考虑要不要用的问题，所以这个时候相当于是说系统一定是先跑起来，有了HTTP整个监控，然后他不需要这个东西，把它禁用了，这是一种，还有一种就是说那个东西本来就非常非常耗内存比如说就TCP监控，HTTP比较还是少数，但是tcp包含了很多的东西，那这个时候你的监控啥的，东西就很多，这样的话就更耗性能的，所以TCP监控默认情况下应该是禁用的，因为越耗资源的东西就是不应该启用，这种时候，用户禁用有几种办法？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>第一张情况：登录那个客户机上面，把配置改一下，改完了过后把Agent Reload。

第二种情况：在网页上点。</pre>
</div>
</div>
<div class="paragraph">
<p>既然我们之前说的你用我们这个系统，就基本上可以脱离人工管服务器，简单的意思就是说，你要在服务器上那个网页上去实现启用和禁用的问题，所以这个地方就应该有同步，什么意思？你的机器上面有一份配置清单，那在服务器上看起来应该也有，不然他编辑页面出不来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方：

这次我禁用了，等一会你把Agent重启一下，可能又启用了。</pre>
</div>
</div>
<div class="paragraph">
<p>那这样反反复复的对用户体验不是很好，所以我就理解为这个过程当中应该是这样的：首先客户机有个注册的过程，这个注册就比如说你的ip地址是A，那么你把这个A告诉服务器说A上线了，请接收一下，那么服务器说ok，服务器清单里面有这台ip地址，那服务器就信任你了，开始接受你的数据，所以机器应该有一个注册的过程，这个地方控制策略其实涉及到一些基础的交互策略，我没有把它单独拎出来讲，是因为它属于很多业务功能里面必须的东西，是逃不掉的，所以到时候我们遇到的时候，单个单个来讲，那现在看起来是这样的，就是这个Agent上线的时候，他应该向服务器有一个注册的过程，注册过程发起过后，服务器应该有个白名单，总不能谁的都收，那就解决了安全隐患。</p>
</div>
<div class="paragraph">
<p>所以服务器上应该有个白名单或者是说注册的时候带秘钥或者Token，然后Token是服务器颁发到你填到配置文件里面，不管是服务器白名单或者带Token都可以验证身份，但是这个不是我们现在要考虑的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_怎么同步客户端和服务端的清单">9.3.3. 怎么同步客户端和服务端的清单？</h4>
<div class="paragraph">
<p>现在我们要考虑的就是：注册完过后，什么时候服务器要刷新那个清单？</p>
</div>
<div class="paragraph">
<p>这是一个问题，我的理解是要刷新的话，就是Agent要向服务器报，首先启动的时候要报，Reload的时候，要报，还有加载配置的时候，也要报，但是这个报的话，他报的这个东西如果用户编辑过怎么办？那Agent要把这个东西记下来，但是我觉得这个好麻烦，有没有更简单的方式，就是能不能让Agent不去记录这些东西或者是说只有一个人有这个清单就可以了，我打个比方用户编辑清单的时候服务器上不保存。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

用户打开插件列表的时候，应该是Agent上一次报过来的清单，那这个清单，就是在服务端上是个缓存，用户编辑过后，下一次Agent再来报的时候，服务器就把最新结果返给他，因为请求嘛，我要发给你东西。</pre>
</div>
</div>
<div class="paragraph">
<p>所以现在看起来这个是Agent应该有一个定时的心跳，比如说每隔几秒钟有一个心跳，问一下服务器你有没有东西要发给我，然后这个时候，你把你要控制的东西发给他，因为HTTP没状态，就是这个样吧，要不停的问，然后这个机器多的话会不会有问题？</p>
</div>
<div class="paragraph">
<p>比如说，假设有1000台机器吗？1000台机，每五秒钟问一下，或者每十秒钟问一下，相当于一秒钟就有100台，每一秒钟就有100个并发，还是有点吓人，那这个并发有点多，1000台有100个连接，不对，我们之前是每隔一秒钟，客户机就会向服务器报，那1000台，肯定最少都有100个兵法，用长链接也会有这个问题，但长链接的好处是这100个病发不用三次握手，但是如果100个app的话，就把keep live打开，他也不用握手，其实性能没有问题，那这样本质上是一样的，性能没有问题，就假设你这种配置你一定不需要马上生效，30秒生效都是可以的，所以我把它降成30秒，因为禁用这个东西又不是啥重要的，但是用户启用的时候可能就很着急，之前规划Agent本来就有个端口，那就直接把它作为服务端，让服务器来请求他，那这样的话就没有定时轮循的问题了，客户端每隔n秒向服务端发一次，叫定时轮询，那Agent本来就有一个端口，因为你的用户程序向客户端上报吗？那个端口也可以让服务器用，所以相当于是说Agent又是服务端，也是客户端，那这样的话才能保证，因为如果用TCP的话，那个维护难度对人员的要求太高了。</p>
</div>
<div class="paragraph">
<p>内网必须要公网ip，有没有那种内网？我觉得这个应该不是我们关心的，打个比方，你的服务器都有一堡垒机，你把那个服务器部到外面客户端里面，我觉得你是吃饱了撑的，然后如果你服务器在云端，然后你说客户机吗就自己用Frp内网穿透吗？关我啥事啊？我才不考虑这个问题呢，因为这种问题毕竟是少数，甚至你用ip tables都可以解决，你无非就是个端口转发，相当是用Nginx加个反代，因为我本来就是HTTP，我用它的目的就是为了维护方便，你就反代嘛，你加个反代有啥问题？但是你像Zabbix用Socket连接来反代，肯定麻烦，你还搞不来，但是HTTP是个人都可以。</p>
</div>
<div class="paragraph">
<p>看起来这个地方讨论出来了，就是相当于是说Agent，他有一个8080的端口，我们的服务端在注册的时候顺便把自己的回调的URL告诉了服务器，然后服务器有事通知他就回调，所以他在启动的时候哈，他要做几件事情他要去注册，注册的时候包含了什么？包含了自己的ip地址端口，那么还有回调就是用于更新配置，所以他的启动是要去注册嘛，注册的话就相当是有这几个，当然你说有注册肯定有注销，那服务器把你删了就可以了嘛，我觉得这个讨论清楚就是他的行为就是更新配置就用回调，然后用户改了某个插件然后回调，然后Agentd收到过后，看起来Agentd应该有数据库要存储，那客户端我肯定不会装PSQL的，我看一下，那就用那个SQLite等于说Agentd这边就有数据持久化，但那直接给配置文件呢，我就相当于是说我不关心存在，那我存在文件里面也是可以的，那持久化配置啊，直接用文件去做这个处理，我一个数据库我都不想用，因为你能配置东西其实很少，就刚刚涉及到的嘛启用禁用插件，涉及到要配置的东西就是启用禁用，更新插件，用户说他改了东西，要重启下，插件要重启嘛，在服务端上上传插件分发，等于你要去管理他了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_分发系统">9.4. 分发系统</h3>
<div class="paragraph">
<p>上面说我们不想用数据库还有为了方便用户，我们是时候写个yum，因为我一点都不想去做分发，我想的是调那个yum命令然后那个命令自动自动把这些东西装好，包括配置文件都配好，所以这个地方看起来涉及到插件的启动，因为插件的启动有可能你更新的过后你不要不想手动去启动，就这个地方类似于Reload，那这个地方看起来有一个插件的升级和分发，是时候写个yum了，然后yum根据规则我们定义好，我就告诉这个客户端执行这个程序分发，有什么情况下他需要去更新那个东西？首先，他有几种情况嘛？他是命令都换了，他重新注册插件，所以这个地方有升级还有插件的注册，我觉得这个才是我们想要的目的嘛。我们先不要考虑他的复杂性，用户点的越多我们越复杂，有多少人就有多少智能，那所以这地方看起来有注册嘛，有升级嘛，肯定还有删除这些去管理操作嘛，所以这个地方插件启用禁用，还有一个开启和关闭，其实可以这样做，就是Agentd就是把所有的东西全都装上了的，只是全部是禁用状态的，然后他就是想要什么点开的时候只把要才能启起来，不过他自定义的时候呢？都能自定义了，自己上去摸一下，当然就是你的意思就说都是我们写嘛但是我们得为长远做打算你刚说的是1.0版本，我们可能1.2的时候就支持用户他用我们的sdk自己写一个插件啊，自己写个插件过后怎么去注册呢？相当于是说我们的服务端是一个源，然后他用yum命令去调这个源上的数据，首先东西的分发绝对不可能通过这种我们这种HTTP来完成因为他是个单独的逻辑，就像极了你在你的电脑上用pacman装PSQL但是我们比那个PSQL更高级一些，因为配置啥的都没改，他只是装上，我们相对是带了一个我的大脑，然后你调我们的那个yum的时候，他会把这些配置啊或者你想要的密码全部都给你配好，所以分发绝对不会和主系统合在一起，他应该是两套子系统，分发只是触发了这个动作，他触发了那个Agentd去调用一样，我们先不讨论那个HTTP请求，你那样就把这个分发搞复杂了你的pacman /yum是怎么样的，我们写的东西也是怎么样的，没有没有区别啊？就相当于是说Agentd去调那个yum，比如说yum install  cpu模块，然后这个时候yum就会去请求他的原地址，他原地址上就有一个URL，然后他就把它下来装到电脑上然后比如说刚好我们那个规则里面有一个东西是写配置文件，写到他的目录下面去，就等下一次Relaod，当我们发现有更新的时候就Relaod的，Relaod他装完了，因为就像yum命令执行结束嘛执行的过程，我们的这个监控系统是球眼是不关注你的执行过程的，但是你的yum执行成功嘛，然后他就会自动执行Relaod，因为是他触发的这个调用yum嘛，所以说一旦上一条命令执行成功就Relaod，如果执行失败就不Relaod就报错嘛，就返给服务端，主动告诉他说有错，所以那这个地方就相对是我们有自己的一个分发系统。</p>
</div>
<div class="paragraph">
<p>那分发系统有了，然后Agentd他调他调完了触发安装过程，安装过程他不管，他只管上条命令执行成功，现在问题来了，分发系统啥时候装啊？是装Agentd的时候顺带就装了吗？所以刚刚说的我们应该有一个分发系统，这个分发系统一定是独立的，而且一定是通用的，不仅是应用在我们这个项目上面，他应该是把我的运维经验， 用配置规则的方式把我的经验纸面化，形式化，那这样的话就是你不用再担心装了Mysql下一步应该干嘛，你一般你装的Mysql你要先去start，start过后发现没有用户的去建用户一堆乱七八糟的事情，所以要把这些过程按照我的经验，我的经验不行，你再把你的经验文件传上去嘛，然后这个时候名字不一样噻。你肯定是安装的时候你要跟个fifilu/Mysql，这是表示我的仓库嘛，那这样的话就用我的经验，然后用Lixi/Mysql就用了李喜的。用户至至少自己可选，就把他的经验重复了，一旦重复，那个剩下的人就没有价值了，工具人连工具都不是了，所以那这个地方分发系统之前我还没想过这个，但是想到这点跑不掉。因为因为什么啊？因为我可以完全可以写一个李喜/球眼—model—cpu嘛，所以这个地方受到插件管理，还有分发的应该就这些，就这些具体去管Agentd的应该是没有的，为什么？因为这个东西是一个中控。他的中间要去调度控制或者接受控制，所以对于他应本身应该没有什么管理，主要是对他下面User这一层。你要启用禁用分发新增删除，删除很简单嘛，remove，如果他真的要删的话，但是一般最好禁用，但是他是强迫症他想删，你让他删，但在默认的cpu内存硬盘这种就不要删了，为什么那种东西在proc下面的文件又不耗内存又不耗性能啥的删他的干嘛，删的一定是那种他自定义只有自定义的才能删，我们自定义的他只能禁用，不然用户会把你系统搞坏的啊。所以又回到最初那个问题就是服务器怎么去完成这个动作。就之前想不通Agentd怎么交互的，回调，用回调就解决了，因为有回调啥事都可以做了。至于刚波波说的内网的问题啊，这个地方回调涉及到一个内网穿透的问题。这个问题就是我们不处理，他作为专业的人，他应该清楚，所以我们以后在我们的这个球眼的官网上要注明，服务端和客户端如果不在一个局域网，请内网穿透，详情请见frp文档，就是你都搞得那么复杂了。你一定是个专业的人。我相信你。你能搞定的，如果你搞不定，请你把它挪到一个局域网去，当然他说他要加速VPN更牛逼了,企业级内网穿透。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_QiuYangAPI_chapter">10. 球眼系统设计(API系统)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_10">10.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/API系统板书1.jpg" alt="API系统板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是api">10.2. 什么是API</h3>
<div class="paragraph">
<p>API（Application Interface）就是应用程序接口</p>
</div>
<div class="paragraph">
<p>我们之前在做设计时Rest For规范，当然这个东西肯定是基于HTTP的，存在一层递一层的关系，那API有什么东西需要我们特别关注，单独拎出来讲，而不在我们设计的过程当中讲？因为所有基于浏览器前后端分离的项目，它都有API，它是一个很重要的子系统。</p>
</div>
<div class="paragraph">
<p>API系统设计，里面掺杂着很多的点，打个比方</p>
</div>
<div class="sect3">
<h4 id="_参数校验">10.2.1. 参数校验</h4>
<div class="paragraph">
<p>第一个，要用API通信，你的后端是Spring Boot，那这个时候你有Controller，上面就有url的映射，那里面应该还有参数的解析，因为他要把HTTP报文解包，解包完过后，你的Controller就收到一个参数对象，然后拿到参数对象过后，要在里面做逻辑，这个逻辑，拿了参数过后，第一件事情要判断参数是否符合你的预期。</p>
</div>
<div class="paragraph">
<p>在行内，有一句话叫： <code>“用户的输入永远都是不可信的。”</code></p>
</div>
<div class="paragraph">
<p>那这个时候你要对参数进行校验，校验完了过后才是怎么去用参数，比如说你用那个参数去拼SQL或者用参数去构造对象或者各种数据结构，然后传给下一个Service，这个时候逻辑才是通的，这个过程当中，还只是讲了参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_身份认证令牌">10.2.2. 身份认证（令牌）</h4>
<div class="paragraph">
<p>那第二个问题就是：谁都可以访问这个API？这个时候你就要对身份进行验证，你是预期的那个用户吗？像以前我们做身份验证就很简单嘛，一个账号一个密码，但账号密码有个问题，你在网络上传输账号密码那个是不安全的，虽然你可能用了HTTPS，但是你也不敢堵定他机器上没有木马，这样的话，一旦密码被泄露了，你就要登录到网站上去修改密码，这是个很复杂的过程，所以后面大家在做API通信的时候，就倾向于使用Token，意思就是说我发给你了一个东场的令牌，你可以畅通无阻的进入到这个系统里面，不管是你出关或进关，都ok，为什么？亮出你的令牌就可以了，这个令牌中文叫令牌，英文叫Token，所以Token就是一个叫身份标识的东西，用账号密码其实都是可以组成Token的，但是账号密码太重量级了，什么意思？比如说一个人今天登录一下我的服务器，我就心想：我要给他密码的话，我的网银也是这个密码，万一他知道我密码连蒙带猜的话，他就能猜到我的银行卡的密码了，那这个时候我肯定不会给他我服务器的密码，那怎么办呢？给他一个证书嘛，给他一个令牌，这个令牌就是身份标识某种介质，这种介质证书里面就包含令牌，也可以用字符串，那个字符串内容就是令牌，或者给你个U盾，你U盾不插到电脑上，你付不起款，为什么？你不能访问银行的付款系统，看到没有，这个是令牌。</p>
</div>
</div>
<div class="sect3">
<h4 id="_整体设计思路">10.2.3. 整体设计思路</h4>
<div class="paragraph">
<p>API系统除了这两大块还有第三块，就是他的整个设计思路，一般来说，一个前后端分离的项目会面临一个问题，如果你是团队协作的话，经常会出现一个人的问题：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`“听前端还是听后端的？”`</pre>
</div>
</div>
<div class="paragraph">
<p>这是一个老生常谈的问题啊，听前端就意味着前端要什么格式，给什么格式，但是你不要忘了一件事情，如果前端要什么，给什么，这就意味着你的代码是非常非常凌乱的，最后就变成了祖传代码，谁也不想去动，为什么逻辑是乱的？因为动一下就有Bug，最后就不敢动了，所以像我的代码，我十年前写的代码，现在我GitHub上的代码很多都是十年前的，就算十年前的我相信到现在你都是能看懂的，为什么？因为我有自己的代码规范，然后我的函数命名也是ok的，整个逻辑是清晰的，所以为什么把API提成系统？是因为你这个API里的各种接口，它要组成整个球眼系统的后端逻辑，就是除了Web界面以外，所有的逻辑的蕴含在你的Agent层面上面，为什么？你的Agent是给其他子系统模块做交互的，我之前讲过的，其实你在内部写的再丑没关系，但是你的接口给出去如果很难用就麻烦了，打个比方，你是阿里云的程序员，你写了个接口，用户可以获取你的云服务器的信息，但是你设计的接口，他可以获得整个大服务器的ip地址列表，然后用户拿到那个列表过后，自己在里面找哪个是你的？我相信我都不用再讲下去，你就知道这个设计是有问题的，都先不管他安全的问题，明明我只需要一条数据，你给了我1000条这是有问题的，这是过量的。</p>
</div>
<div class="paragraph">
<p>所以在这个情况下的API系统涉及到第一个那么就是说，他是整个业务的入口，那么你要做基础的校验这些东西，那么你就需要把它提到一个子系统的高度，在参数校验的时候应该有统一的逻辑，统一的处理方式，比如说要解决SQL注入的问题，别人乱输入一个参数，比如说输出个rm -rf就把文件给删了那是不应该的，这种就叫参数安全，还有一种安全叫身份认证，你要知道这个用户是谁？他有什么权限？你必须要有个用户标识，以前我们做登录系统的时候，就是说我可能有一个用户名和一个密码，我登录完了过后我在数据库里面查一下，我就得到个user id，我就在我Java代码里到处用那个，以前是这样做的，然后现在你拿到Token后，就只需要从那个Token里面把User ID解出来就行了，那个字符串里面是有藏着秘密的，这个等一会我们再提。</p>
</div>
<div class="paragraph">
<p>那么第三个就是：API系统是整个系统的核心，它必须有完整的，严谨的设计，所以在这个地方什么是API，或者是说API的作用，这个你是不需要过多解释的，你想的应该是API怎么用？那么我就把两个问题合成一个问题。</p>
</div>
<div class="paragraph">
<p>API就是模块间交换数据的手段，但并不是唯一手段，你可以有很多种，SQL可以FTP可以，纯HTTP也是可以的，甚至你可以用图片，比如说那个在图片上藏了密码，你带上个特殊眼镜，你就能看到那个上面的密码，看到没有这个也是在交换数据，只不过他的媒介是很特殊的东西。</p>
</div>
<div class="paragraph">
<p>所以总结下来：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`API是模块间交换数据的手段，我们是通过Rest For API接口实现。`</pre>
</div>
</div>
<div class="paragraph">
<p>这样就可以了，不要去解释什么是数据，那是不应该的.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_api的特点">10.3. API的特点</h3>
<div class="paragraph">
<p>那API有什么特点?它有什么？</p>
</div>
<div class="paragraph">
<p>这个时候我们讲的肯定不仅仅是我们的系统，我们设计了这个球眼系统，它是标准的前后端分离，可能没做之前，大家会认为一个监控系统能有多难，但我相信现在设计完了，你知道你一个人绝对做不完而且给你一年的时间你也做不完，为什么？因为它有难度，你可能能够做其中一部分，但是你做不了一个完整的系统,为什么？</p>
</div>
<div class="paragraph">
<p>因为没有任何一个软件系统是简单的</p>
</div>
<div class="paragraph">
<p>如果一个人软件简单，那一定是幻觉，为什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

比如说波波，他的业务，他说两个星期就做完了，真的吗？真的是两个星期吗？还是说你是限定需求，我只是实现某些需求，或者是我把需求的范围给限定，然后这各种卡，最后你做出了一个迷你的软件系统。</pre>
</div>
</div>
<div class="paragraph">
<p>所以它是相对简单，他也不简单为什么？要是那么简单，你的老板咋不自己做呢？五点钟跟你确定了需求，5:30就问你做完没？那这个时候你恨不得对老板说：“来你来，你做完我给你发工资。”</p>
</div>
<div class="paragraph">
<p>这个时候一个标准的API系统，我这个地方强调的标准是我认为的标准，我肯定是最严格的标准,但是当我看到业界这些程序写的代码的时候，参数校验是啥？不知道，为什么？我就这么跟你讲：十个程序员中的九个，校验他只做一件事情，那个密码的长度最长20位，完了，至于里面是啥，不管，甚至很多时候如果你不强调这个校验长度的话，那九个人就连那个长度都不想验证，我都的高估他们了，他们之所以去写这个校验，是因为是别人提的需求，但是如果大家都不提的话，你放心，参数校验没有一个人做，所以参数教练看起来是一个大家都知道的事情，但是大家不愿意做，为什么？因为他没有效果？那什么时候有效果？你被黑的时候就有效果了，然后这个时候，你花了一个通宵把你公司被黑的问题解决了，发个邮件煞有介事的说我们修复了一个安全漏洞，那个漏洞可能就是你自己留下的把柄，自己给自己擦屁股可爽了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_api的标准">10.4. API的标准</h3>
<div class="paragraph">
<p>那么我说的这个标准，肯定是最严格的，就是他应该是什么啊？我们有自己极客营的标准。</p>
</div>
<div class="sect3">
<h4 id="_参数校验_2">10.4.1. 参数校验</h4>
<div class="paragraph">
<p>第一个，那肯定是参数教验，参数教验包括什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

一个用户注册，他肯定有用户名，那么这个时候，校验你可以分几类？</pre>
</div>
</div>
<div class="paragraph">
<p>第一个：用户名应该由纯英文组成或者下划线，这个时候你肯定是对他的格式，英文数字，字母，数字下发线组成，这叫格式，格式以外就是长度啊，比如说我们以前写域名系统的时候，就是qq.com这个域名，然后我们当时有一个最奇葩的问题，我们程序员因为那个问题改了三天，为什么啊？他是这么注册那个域名的，就是：妈妈说google百度不能抓取这么长的域名，是用拼音组成的，大概刚好128位，然后那个域名注册了过后来，我们后台要显示嘛，他的长度就把我们后台那个页面给撑破了，出现了排版混乱，每一次到了他域名那一页就要乱，但是他这个域名是合法的，因为他的域名是合法的，他没有超过那么长的位数，所以这个时候就是你程序写的时候，你就不应该展示完，你可以等他点进去嘛，所以说，你要对这些事情心里有数，当时我们那个程序员没遇到过这种情况，他就没有去多想啊，当然这个只是一个个例，但是你注册用户名那个地方我写个SQL可以吧？inset into usertable然后你成功被注入了，那他里面写的是scrptjs代码，每一次打开公司的首页，正中间弹个弹窗，对的，就是查数据库的时候把那个介词从数据库查出来了。</p>
</div>
<div class="paragraph">
<p>这就是参数教验啊，分两个步骤，第一个对格式进行校验，第二个是对长度进行校验，但我认为的格式不包括长度，长度是另外一种东西，为什么？因为长度是最简单的一种校验，他的格式是很复杂的，比如说你注册用户名的时候，哔哩哔哩他不允许你正中间出现下划线，他说：你可以当做开头，但是不能以下划线结尾，所以这个时候他的那个校验是很复杂的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_身份标识token">10.4.2. 身份标识(Token)</h4>
<div class="paragraph">
<p>身份标识这个地方通常意义上指的就是Token，你会受到几个概念？Token，cookie，session大概是这几个，其实他们从本质上讲都是一个玩意儿，这个以后再讲，但是它们的使用场景是不一样的，比如说，我是你的教练，我是你的Leder，但回到家，我是我妈的儿子，那难道在家里我就不说我了吗？，所以Token，cookie，session就是这个意思，那现在我们这个地方讲的Token，那Token是什么？你知道用他来做身份标识，但是你并不知道他是怎么组成，我刚刚讲的，他就是一个字符串，通常意义上来说，Token里面包含了几类信息？为什么？看到那个字符串，程序咋知道那个字符串标志的是谁呀？不觉得好奇吗？那个U盾插上去他居然知道是你，那就说明他里面有东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>那Token里面有几个东西组成？

第一个一般是用户编号（UserID）这是基本上必备的，表示是谁。

第二个就是Token生成时间，表示这个Token是什么时候生成的。

第三个是Token的有效时间。</pre>
</div>
</div>
<div class="paragraph">
<p>基本上就是这三类，生成时间和有效时间肯定是相对的，如果没有生存时间你咋知道什么时候过期，为什么要过期？比如说那个U盾每五年要换一下，身份证到过期你也要换，那么何况是这个身份证标识，他也要过期，但是现在有个问题，他不像身份证，花几块钱，还要做张卡，你没有那个东西？那怎么办呢？这个东西是虚拟的，你会生成一个字符串，大概是什么样子：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`ef87562c5768...`</pre>
</div>
</div>
<div class="paragraph">
<p>它就是个哈希，这个哈希要看你怎么理解了，当然有的公司为了图方便，因为哈西是不可逆的，这个时候可能为了携带这些信息，会选择另外一种方式，就是AES/DES，它是对称的，这个地方涉及到一个概念了：对称和不对称，没关系，密码学的问题，我们以后再补，现在你就只需要知道哈希是推不出字符串所隐藏的信息的，你只知道他是有效的，为什么？比如说你要把123转成哈希，但是他有没有是固定的，除了这个有啥用呢？你不可能挨个123567去去试吧，或者是拿着信息去拼，比如说你用AES/DES，它是对称的，对称的，什么意思？就是你的钥匙插进去，它能打开，如果用的错误的钥匙，他就打不开，你可以这么想嘛那钥匙是谁？谁有钥匙？肯定不是用户有钥匙，你的用户都知道你的钥匙了，那所有人都知道了？那你就加密加了个寂寞。</p>
</div>
<div class="paragraph">
<p>所以说这个是钥匙是在服务器上面的，这个Token是你的服务器生成的，用户第一次用这个接口，你生成给他的，像你用阿里云的时候，他有个地方叫access key管理，那个地方，有个生成功能，他就是生成Token，所以这个东西是服务器生成给你的，只有服务器有钥匙，比如说我，我是服务器，我生成好了一个串，然后告诉你请保存好这个串，不要遗失了哟，然后你就剩下拿了个串，现在你就可以去访问阿里云的接口、短信什么的、各种API服务，各种监控都是可以的，所以自己的Token不要泄露了，要是把你的Token发到你的微信群里面，你就等着被黑吧，为什么？因为系统只认Token不认人，钥匙也是嘛，我把钥匙拿给别人，他能开门不？他能开。</p>
</div>
<div class="paragraph">
<p>所以服务器上会有一把钥匙，然后他根据这个钥匙加上这个算法就生成了一个加密结果就叫Token，看到没有，这个地方叫加密结果，拿到API上做传输，就叫Token。</p>
</div>
<div class="paragraph">
<p>那么根据这个算法加上一个密码，我就可以跟把这些东西拼成一个原始字符串，然后把这个字符串给这个算法，他就会生成一个结果，所以如果服务器下次收到这个Token，我能用那个钥匙把它解开，解开是双向的，只要解开是不是就得到了服务器要的校验信息？这样服务器就判断这个用户在不在，是不是有效的UserID，万一用户都不在注销了呢，虽然你可能遇不到这种情况，但是你要判断另外个情况，他生存时间，你要拿出来然后基于这个生成时间加上这个有效期，你算一下是否过期，如果过期的话就提醒用户Token已经失效，请重新申请，为什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

我今天不小心把我Token发到微信群里面？好歹微信能撤回，但如果Token已经被人复制走了，不管是哪个地方泄露的，那就应该登录阿里云那个网页上头把以前的脱坑删掉，然后重新生成一个，那这个泄露的托克既然你删掉了，那服务器上做对比，那么哪个拿到你泄露的Token准备干坏事的人就没什么办法了。</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_api_逻辑链业务">10.5. API 逻辑链（业务）</h3>
<div class="paragraph">
<p>你的API之间有关系嘛，你的整个核心都是这个东西，你的上一个API是登录，下个API是注销，那都是有关系的，所以你可以简称为逻辑链嘛，就业务层面的东西，他这个地方就涉及到业务了。</p>
</div>
<div class="paragraph">
<p>然后这地方逻辑链，逻辑链是什么意思？比如说我刚才讲的，你肯定首先有获取的Token，我们刚刚讲的，我们使用的是标准的restful API，是靠PUT、POST、DELETE来处理的，所以这个时候你的URL肯定是一样的，那么这个地方肯定是这样的：/Token，Token是一个名词，没有意义，为什么作为接口应该是动词，所以获取Token是这样的，肯定要get获取Token，那么有获取Token你就有什么，就有删除Token，或者是失效，或者列表，如果你要列表的话肯定就不仅是那么简单了，应该是也写个List，我这地方是获取吗？那么获取列出来了，然后比如说有个列表的东西哈，那这个地方就可以是这样。列表的话就/list get。然后这个时候，你肯定还有方法让他失效嘛， 所以这个地方你肯定还有个delete。Token是不需要修改的，因为你颁发出去，就不应该改他，所以说是没有POST的，也没有PUT，因为PUT的话是用户把Token传给你，但现在是你给用户，所以那这个时候看到没有/token get/delete和token/list get他们俩是有关系的，API之间是有就是之间是有各种逻辑关系。</p>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>你的用户程序朝上面报的时候，你的Agentd层里面应该加上Token呢？那问题来了，Token什么时候拿到的？你肯定有个get方法去获取从服务端获取Token，而且那个Token看起来应该是一旦颁发过后就不应该让他失效，除非重新获取，所以这个时候应该是怎么样？应该是他去注册的时候怎么样返给他的，他先注册嘛，然后返那个200ok，这个注册只是一个请求注册，叫请求注册，但实际上服务端没批准呢？然后一旦服务端批准，那么就反就调用那个Agentd的回调，把Token下发给他是不是可以。</p>
</div>
<div class="paragraph">
<p>我都不用做严格的设计，就是理论上这是可行的，我在服务端上接收注册嘛，我只要接受他ok，那这个时候自动发一个Token给他，他就寄到他的配置文件里面去，下一次别人来调的时候直接从文件获取，那这个时候用户程序通过SDK上传上来到了Agentd里面，在他服务器报的时候，那就应该有Token。</p>
</div>
<div class="paragraph">
<p>第二个问题，Agentd下面有用户程序，那用户程序报cpu监控数据的时候需不需要有Token？如果在公网上访问需要，但是他都是本地所以不需要，因为他没有跨网络，说白了你多报点数据有啥危害？危害在哪个地方？当然他要出发，一堆东西往上报，看起来这个还是有问题的，所以可能还是要教研一下，就用一个Token就可以了，就解决了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_api命名规范">10.6. API命名规范</h3>
<div class="paragraph">
<p>因为这个API会给很多人用，如果看到你的名字就见字不见人的话，那就是有问题的，比如说:</p>
</div>
<div class="paragraph">
<p>你取了个API的名字，叫getList，请问啥List呀？哪种List呀？你这个时候你就肯定很蒙逼了，比如说:</p>
</div>
<div class="paragraph">
<p>/Data1、/List1</p>
</div>
<div class="paragraph">
<p>这种就不要来哈。API命名规范跟参数校验这两个东西。百分之百的软件系统都没有人写，如果有人写的，一定是发生了什么意外。为什么因为他是随缘取名字的。</p>
</div>
<div class="paragraph">
<p>举个例子：</p>
</div>
<div class="paragraph">
<p>我们前人的代码，一个数据库有一共有6个字段，其中四个字段的拼写是错的，还有三个是拼音的缩写，然后第四个错的是什么？是他用英文把单词写错了,单词就像那天那个line一样，他写成lien了，我真的看了好久，虽然我才疏学浅，但是我非常确定的告诉你这不是一个英文单词，所以他真的就写错了，我看了好久，我至少那张表我看了半个小时我才理解他什么意思，我怎么知道的？我看了一下他那个表里面的那个内容，刚好有中文呢，有些东西我是瞎猜，当时那个表里面有个这个东西，dtxx，这就是一个拼音缩写，后面那个xx你不用管，你猜这dt是什么，dt是电梯，这个是我第一个猜中的，但是后面那个dtxs，请问xs是什么？你就瞎猜了，对不起，我也不知道是啥。</p>
</div>
<div class="paragraph">
<p>所以这个地方在API这个层面命名规范尤为重要，数据库表还好的用户看不见，但这个东西可是大家都会看见，为什么？因为你咋知道哪天你的API会被谁调用？每次别人调用一次就吐槽一次。所以这个时候在和别人产生交互的时候，你的名称，你的命名尤为重要，不仅仅是说那个API本身那个名字包括它的内容。
&lt;&lt;&lt;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_DaimaTongshi_chapter">11. 代码设计（通识）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_本源">11.1. 本源</h3>
<div class="paragraph">
<p>本源是什么？我们拆开一个字一个字地看。</p>
</div>
<div class="paragraph">
<p>首先本字就代表着：本来、本质（目的）字面意思就是指的：</p>
</div>
<div class="paragraph">
<p>事物本身所固有的根本属性，它对事物的性质、状况和发展起决定作用。</p>
</div>
<div class="paragraph">
<p>而源字代表着：源头，比喻事物的开始部分。</p>
</div>
<div class="paragraph">
<p>看得出来，本和源存在着因果关系，当你有了源才会得到最后本，也就是有人源头才会得到最后的结果，这个结果也可以说是本质。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编程的本源">11.2. 编程的本源</h3>
<div class="paragraph">
<p>那么编程的本源是什么呢？</p>
</div>
<div class="paragraph">
<p>上面说的本代表着本质、目的，它们对应到程序这里简单来说就是结果。</p>
</div>
<div class="paragraph">
<p>而源代表的是源头，在编程方面就是起因。</p>
</div>
<div class="paragraph">
<p>之前讲过编程是个动词，而动词一般形容的是人或事物的动作，动作都会带上工具，那么这样可以说程序就是工具。</p>
</div>
</div>
<div class="sect2">
<h3 id="_工具的作用">11.3. 工具的作用</h3>
<div class="paragraph">
<p>首先工具是指能够方便人们完成工作的器具，它的好处可以是机械性，也可以是智能性的，但这是字面上的意思，在日常生活中，我们使用工具，比如说：用斧头砍柴、用水桶提水、用通道传递东西，在这些例子里面，斧头、水桶、通达都是工具，它们都能方便人们完成工作，这也是工具的主要作用之一，那么还有一点是啥？</p>
</div>
<div class="paragraph">
<p>上面说的用斧头砍柴、用水桶提水等等都是靠得工具，那要是这些工具没发明之前人们是怎么生活的？为什么要发明这些？</p>
</div>
<div class="paragraph">
<p>在很早之前，人们需要取火，用来保暖和加工食物，这时候的火源就来源于地上拾取的木头或者树叶，但是那时候没有斧头，木头都是特别粗的，然后发现在火烧完后，那根特别粗的木头不会烧到中心不分，可能外面都化成灰了，但是中间还是完好的摸样，所以人们就想怎么才能把木头分成一小根一小根的，这样能更方便燃烧，这时候不能可能用手直接掰开呀，为什么？第一没有足够的力气，第二强行掰开的话，手会磨损、受伤，这时人们就想有什么有什么东西能代替手，而且要比手更锋利。</p>
</div>
<div class="paragraph">
<p>最初的斧头就出现了，人们发现地上的石头有一些是扁平形状的，如果把石头的一端磨的很锋利，就能基本的割开一些东西，也包括木头。</p>
</div>
<div class="paragraph">
<p>所以得出的结论就是斧头、水桶等等这些工具都是为了服务人类而发明的，而且还能帮助人类提高劳动的效率，那么偷换概念，程序也是工具，那么程序的诞生一定也是为人类服务而且提高人类做事的效率。</p>
</div>
<div class="sect3">
<h4 id="_程序是怎样提高效率的">11.3.1. 程序是怎样提高效率的？</h4>
<div class="paragraph">
<p>那么程序是怎么提高人类做事的效率呢？</p>
</div>
<div class="paragraph">
<p>1.重复（算法）</p>
</div>
<div class="paragraph">
<p>在编程中，算法占据了很重要的部分，而某些结构里，如果有两个点的功能目标相同，编程可以让算法成为一个函数，从而达到重复使用，而不是遇见一次就重新写一次。</p>
</div>
<div class="paragraph">
<p>2.速度快</p>
</div>
<div class="paragraph">
<p>速度快顾名思义程序是部署在计算机上的，而计算机的速度是很快的，强大的CPU能够让它做出每秒几亿次运算。</p>
</div>
<div class="paragraph">
<p>3.稳定、可靠</p>
</div>
<div class="paragraph">
<p>编程相比人来说，它的整个运行规律，逻辑都是人类编写的，它不会像人类做事情做到一半，然后突然冒出什么事来打扰到它工作，从而产生很不好的结果，而且它们能做到这些功能之前都是经过测试的，很大程度上减少了出错的概率。</p>
</div>
<div class="paragraph">
<p>4.模块化</p>
</div>
<div class="paragraph">
<p>这里指的是编程将整个程序的代码分成更小的结构，从而促进大型软件和系统的建构，这样会大大的节约成本，以及避免重复创造。</p>
</div>
<div class="paragraph">
<p>5.持续输出</p>
</div>
<div class="paragraph">
<p>程序相比于人类来说，他不需要睡眠、不需要吃东西补充体力，也不知道什么是睡眠，他就能每天24小时不间断的运行，如果人类不停的思考计算，身体肯定撑不住，不允许这么超负载的运行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_怎样设计程序无限贴近工具的特质">11.4. 怎样设计程序无限贴近工具的特质？</h3>
<div class="ulist">
<ul>
<li>
<p>算法高效：简单，复用，逻辑清晰。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>举例子：</p>
</div>
<div class="paragraph">
<p>SQL慢的原因：相关性弱，复杂(逻辑)、查询多、行多，结果集数量多。</p>
</div>
<div class="paragraph">
<p>API————迟（网络延迟）：域名（错误的DNS会使请求的时候绕大半个地球才请求到服务器），响应慢。</p>
</div>
<div class="paragraph">
<p>代码慢：一个程序里面的代码全是Static Class，一点运行要跑半天才能运行起来。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理异常无bug：处理好代码中的异常问题，最后运行的时候不能有bug出现。</p>
</li>
<li>
<p>运行更快：高效的算法逻辑写出来无异常无bug的程序能够很快的跑起来，而且会持续输出。</p>
</li>
<li>
<p>更合适的模块封装：将每个模块的拆分的很细，就能很清楚的知道每个模块怎么做，该做什么，再进行封装，达到代码复用的地步。</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_JPA_chapter">12. Spring JPA</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_11">12.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/SpringJPA板书.jpg" alt="SpringJPA板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jpa是什么">12.2. JPA是什么？</h3>
<div class="paragraph">
<p>刚刚讲了JPA的英文是 <code>Java persistence API</code>，翻译成中文就是J <code>ava持久化API</code>，那JPA具体来说他支持什么？JPA支持常见的关系型，比如说：MySQL、P SQL，甚至在官网里看到还H2，当然肯定还有SQLite等等，你会发现，这些都是可以写SQL的，但凡能用Select * from XXX查找数据库数据的，JPA都能支持，不过像Radies，MongoDB、ES那种就不一样了，JPA中的P叫持久化嘛，所以这个地方直接就理解为只支持 <code>关系型数据库</code>，其他都是不支持的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jdbc和jpa">12.3. JDBC和JPA</h3>
<div class="paragraph">
<p>大家都知道Java要去查数据库的话，必须要用个东西，那个东西叫JDBC，那这个JDBC是什么？JDBC的英文是： <code>Java Databas Connectivity</code>，翻译过来就是 <code>Java数据库连接</code>，是Java語言中用來規範客戶端程式如何來存取資料庫的應用程式介面，提供了諸如查詢和更新資料庫中資料的方法，那JDBC和JPA是什么关系？</p>
</div>
<div class="paragraph">
<p>首先JDBC是Java提供的一个驱动层数据，这之前先了解一个概念：ORM</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ORM全程是Object Relational Mapping，翻译过来就是对象关系映射，简单来说就是在编程中，把面向对象的概念跟数据库中表的概念对应起来，这个以后会仔细讲，现在只简单提一下。</pre>
</div>
</div>
<div class="paragraph">
<p>那么这个JDBC，它对应的直接是数据库，因为MySQL官方的下载页面，它里面有直接下载JDBC Jar包的链接，这些MySQL收口提供了JDBC的驱动，正常来说这个时候，如果我是那个Spring Boot的开发者，我会把JDBC和JPA持相同的层面，其实这两个是一个层面的东西，而数据库只和JDBC发生关系，因为这个官方就支持这个东西，官方他不可能因为JPA而重新开发，JDBC用起来太麻烦了，JDBC就像以前的Spring，而JPA就像现在的Spring boot，那Spring和Spring Boot谁方便？那肯定是Spring Boot啊，所以从这个层面的时候说JPA只是一个操作器，让你更方便，写更少的代码，封装程度更高，但是他并没有和数据库直接发生关系，而是JDBC和他发生关系，为什么我知道呢？MySQL都没给JPA写驱动，那肯定是这样的。</p>
</div>
<div class="paragraph">
<p>所以理解一下这一层的关系，比如说你写的跟属于里的DB，然后你要让Java能够调你的，那这个时候你的DB应该有请求报文，为什么？因为他是一个用TCP通过端口连过去的，那这样的话就相当是用Java先连一个端口，连上那个端口后，Java拼一个报文，SQL就是要报文里头，报文里就有是哪个数据库，哪个表，什么编码，SQL是什么，然后把这些拼成一个报文丢给你的，Java把丢报文丢给数据库，数据库收到报文过后解析报文，报文解完就把那个SQL拿出来，然后数据库查完了，再反结果给你，通过响应报文传给Java，Java的拿到响应报文后解析格式啊？你解析完了或者写完了这个东西，那他就叫JDBC驱动，这个东西和HTTP没啥区别，就是报文不一样，这样你甚至可以给Rust的写一个。</p>
</div>
<div class="paragraph">
<p>所以这个地方官方会给他提供Driver，就是驱动的意思，就像那显卡驱动一样，只是说层次不一样，但是他们都是驱动。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jpa为什么方便">12.4. JPA为什么方便？</h3>
<div class="paragraph">
<p>我们先将JDBC和JPA作对比。</p>
</div>
<div class="sect3">
<h4 id="_jdbc是怎么用的">12.4.1. JDBC是怎么用的？</h4>
<div class="paragraph">
<p>以前我们要写JDBC的话，</p>
</div>
<div class="paragraph">
<p>1.首先你要连接connectivity db，就是你要先连上数据库，连上去后，假设我连的是MySQL，你就要这么写</p>
</div>
<div class="listingblock">
<div class="content">
<pre> mysql://localhost:3306</pre>
</div>
</div>
<div class="paragraph">
<p>当然，你可能会跟一些数据库名字或者用户名字之类的。</p>
</div>
<div class="paragraph">
<p>2.连上数据了过后，第二个就要切换数据库，你要告诉他你的那个数据库上面，当然，这个地方他默认就会有一个，但你也可以手动切换，现在我们假设你已经进人数据库里头了，那现在要查SQL，在JDBC里，你要查SQL，你要怎么准备呢？</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="listingblock">
<div class="content">
<pre> sql = Statment.preare(“select * from ...)</pre>
</div>
</div>
<div class="paragraph">
<p>你要有个准备一个preare，然后再加上一个SQL字符串。</p>
</div>
<div class="paragraph">
<p>3.第三步就是你要有一个结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre> result = Statment.execute(sql)</pre>
</div>
</div>
<div class="paragraph">
<p>这个执行SQL过后，得到的是查询的结果，然后你要把结果拿出来，但是现在你并不知道这个结果有多少行或者说你能够得到多少行，所以你要写个For循环。</p>
</div>
<div class="paragraph">
<p>4.写个for循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>for (i=0,....&gt;result.row,i++)

....

....
....

row = result[i]</pre>
</div>
</div>
<div class="paragraph">
<p>这个过程当中，你可能能得到单行，单行你是能拿到的.</p>
</div>
<div class="paragraph">
<p>然后设一个变量，就是：row = result[i]，然后就得到了一行，但现在是这一行里还有有五列，那还要循环这一行，把列拿出来，最后得到一列的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>for (row...)</pre>
</div>
</div>
<div class="paragraph">
<p>那么得到数据后，肯定要把数据保存下来，那么你肯定要创建个class，挨个挨个把数据填充到你自己Class的属性里面去。那么这个过程当中你最终输出的是有一个Class。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>row_class.cod[j] = result[j]
...
...</pre>
</div>
</div>
<div class="paragraph">
<p>那么假设是一个数组来保存的，慢慢填充填完了，这样的话就把先一行一列全部都填充到对象里面去，填充完了那个对象就可以用了，所以这个是程序的算法，完了过后就要把他关掉，上面的就相当是清理这些东西了，最后就要关闭连接，好了，你终于搞完了一张数据表了，那我问你个问题，万一这个地方查出来很多行很多列，那你不得把它写死，而且最关键是你会发现这个地方他运算的时候无非就是行和列，和表没有关系。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

如果这个表所有的列都是Char，那这个地方是可以写死类型的，但是他如果是JSON或者INT格式，这个地方还要判断一下他的格式，累不累？</pre>
</div>
</div>
<div class="paragraph">
<p>所以这就是以前我们最开始没有hi，没有JPA，没有Mybatis的时候我们干的事情，就全靠自己去搞，虽然也不是不能写，因为我们写c和c+ + 的时候就这么搞的，逻辑一模一样，用C+ + 连MySQL也是这么弄的，只是语法更复杂一些。</p>
</div>
</div>
<div class="sect3">
<h4 id="_jpa怎么做的">12.4.2. JPA怎么做的?</h4>
<div class="paragraph">
<p>然后JPA是怎么弄的啊？如果是JPA的话，你要的第一件事情就是假如现在你有一张表，你要把这张表映射映射成一个Java的class，就是你表有几列，对应的Class就有几个属性，巧了，这个东西在MVC里面叫Model，当然层次不一样你也可以叫JavaClas都是可以的，然后有的人他喜欢叫DAO。</p>
</div>
<div class="paragraph">
<p>什么是DAO？就是Data Access Object（数据访问对象），是为某种类型的数据库或其他持久性机制提供一个抽象接口的对象，但是不管叫什么都是一样的。</p>
</div>
<div class="paragraph">
<p>那这个地方就相当是表有几列，他就有几个属性，这个做完了过后第二件事情无非就是把行和列的关系绑上了，因为你要去做各种运算和查询，所以他把这个封装成了一个统一的逻辑，我们就把它叫数据仓库，这个数据仓库干啥呢？你去看他那个源代码，你点进去他会有个那叫CUDR增删改查，然后把它封装了一下，然后这个R他又给你们封装好了，就是quray，平时查询是怎么查ID的，所以他就给你封装成这种方法翻译成findByID，当然他可有另外一种写法，比如findNameAndAge，巧了，这两个也是你的列名，这都有And了，那就应该还有All，那么有时候你所有的数据都要查翻译那就是findAll，但是和之前的不一样，层次不一样，上面查的时候，你并不清楚你要查出几个数据，一般情况下，我们查出的是一个，当然All这个地方可能是个列表，返回值不一样，所以findAll，他指的是说查出所有，所以你会发现这个时候时候，他后面不是有括号吗？你会发现的括号是空的，里面是没条件的，所以他返回的是整张表的所有数据，那么代By的可能返的是一条，也可能是三条五条，但是你会发现他都是find开头，无非是后面的词不一样，那么它们就会有不一样的行为，但是这样解决不了一个问题：连表查询，你想嘛，这样只能在单张表里面找那个列名，那如果你要查两张表呢？那就是比较高级的技巧了，现在不讨论。</p>
</div>
<div class="paragraph">
<p>所以你会发现这个东西，这个仓库他给你封装CUDR增删改查，但是他那个叫save比如SAVE命令，那么意思就是repo.sava()，括号的中间是一个对象，等于说你把那个对象先查出来，然后掉他的set把值给改了，然后再传给数据库，save可以做新增也可以做更新，比如说这个地方你不是查出来的，你是自己new了一个不一样的逻辑，但只要能掉save就能保存进去。</p>
</div>
<div class="paragraph">
<p>相比JDBC来说的话，JPA有了算法，还有了数据结构，而且层次非常清晰，你要改表的话，就改最上面的映射，如果你有相关查询你就改函数，如果你新增一列，你根本就不查，那这个地方都不用去改，反正查出来默认在里面放着的。</p>
</div>
<div class="paragraph">
<p>JDBC你只要加了一列其他全都得改，累死你，而且还容易出错，但是JPA也有个问题，他封装太好了，你可能不清楚这个规则，默认情况下，那个findById肯定是在，甚至说那个仓库代码里面啥都不写，你只把那个内继承一下，空的放在那，这些方法都可以的，只是他没有语法提示，但是他在运行的时候，他就会分析你的那个表里有几列，所以说JPA里头，你甚至可以不写函数，你都是可以用的，因为他是自动帮你拼装的，他都帮你拼了，你还写啥。</p>
</div>
<div class="paragraph">
<p>所以经常你会看到类里面是空的啥都没有，但是他又能用，你就很奇怪，作为一个新手就很恼火，为什么？凡事都靠懵，搜索文档都搜不到，所以JPA更简单但是他封装太好，对新手一点都不友好，然后我学习是连蒙带猜，就猜他会怎么做，然后看了几个例子，看到有人用了，我就知道大概怎么回事。</p>
</div>
<div class="paragraph">
<p>当然，有种情况就是：你可能只能拼这种语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SQL(“select * from t where id = 2 “)</pre>
</div>
</div>
<div class="paragraph">
<p>你可能只能拼这种，但是如果你有更复杂的怎么办呢？那个时候你就可以自己写一个find的方法，在find方法上面把那个SQL填进去，比如说</p>
</div>
<div class="listingblock">
<div class="content">
<pre>T=findByXXX(......){

}</pre>
</div>
</div>
<div class="paragraph">
<p>这个就返回了一行，所以你可以写个SQL，然后他掉这个SQL，最后查出来帮你转换成T，就是你可以自己写，当然不一定要叫find什么，就自定义查询嘛，这个地方你也可能是几个连表，那你会发现写着写着还是Mybatis香，因为他就是专门搞复杂SQL的，而JPA只能做简单的，那为什么还要JPA呢？SQL是简单还是复杂是根据你的设计定的，要是啥设计没有，当然复杂了，但是大多数情况你是可以构造成简单的SQL。</p>
</div>
<div class="paragraph">
<p>所以Mybatis适合外包，就是那种业务系统，非常非常复杂，然后设计又结不了藕的，不能做简单查询的，你可能Mybatis合适一些，然后剩下就是JPA，JPA他不是自己写的，他是基于Hibernate的，JPA是简单的把Hibernate封装了一下，这中间有别人的劳动成果，运行的时候都打了Hibernate的，Hibernate跟他其实就是孪生兄弟，Hibernate肯定是更偏JDBC，只是步骤可能少了一两步，当然也是可以写SQL的，就看你怎么弄。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_补充list">12.5. 补充：List</h3>
<div class="paragraph">
<p>然后刚才提到一个说语法看不懂，比如说是这个函数：</p>
</div>
<div class="paragraph">
<p>List&lt;User&gt;  findById()</p>
</div>
<div class="paragraph">
<p>findById是函数名字，括号里面是函数的参数，List&lt;User&gt;这地方是函数的返回值,返回值里面意思是说这个函数会返回多个user,然后你要调的时候，比如说你调了这个函数，那调他过后怎么去用呢？</p>
</div>
<div class="paragraph">
<p>u = result[0]</p>
</div>
<div class="paragraph">
<p>就是result这玩意儿调用数组下标。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_SJKTS_chapter">13. 数据库通识</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_12">13.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/数据库通识.jpg" alt="数据库通识">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是数据库">13.2. 什么是数据库</h3>
<div class="paragraph">
<p>数据库简单理解的话，它就是一个存数据的地方啊，有人说书上写的是存放数据的仓库，这个就要看你怎么去理解这个仓库了，比如像SQLlite或H2，他们就非常非常迷你，你要说他们是仓库吧，我觉得这两个更像个盒子，所以仓库可能是迷你仓库，反正只要是仓库都可以。</p>
</div>
<div class="paragraph">
<p>那我们能不能换一个通俗点的看法？首先，数据库的英文是Database，那么把这两个词拆开，Data是数据的意思，那这个Base是不是就是打游戏里面不是：“我们的基地被攻击”那个里面的Base好像就是基地的意思，因为我看到这个词的时候，第一印象的就是基地，当时那个数据库原理书上面，我刚看了第一眼就是想打游戏，所以这里的Base就相当于数据库，那既然你要解释什么是数据库，你会发现Databa是一个合成词，数据是一个名词，库也是一个名词，但是两个拆开是单独都有自己的意思，所以他是不管是中文还是英文都是个合成词。</p>
</div>
<div class="paragraph">
<p>那这个地方的话解释一下，那么数据这个没得解释，就是字面意思，那库怎么解释？他因为原意有基地的意思，看起来是这样的数据的基地，或者数据大本营，那你说是放数据的地方或者说存数据的地方也是可以的，刚刚不是有人讲：数据存储的仓库啊，这个仓库就很难去理解，因为如果我是一个新手，你说仓库，新手好不容易搞懂了什么叫数据库，然后一听数据仓库就懵了，我们就尽量不要用仓库这个说法。</p>
</div>
<div class="paragraph">
<p>所以你该怎么讲？</p>
</div>
<div class="paragraph">
<p>首先，基地它就是库吗，也可以说是大本营，那到大本营肯定就是要集合呀，所以这个地方其实是这样的，数据库，你听不懂，但是集合这两个词你是听的懂的，因为从小学、初中、高中，集合两个字已经出现过无数次，那数据库有集合的意思，但肯定不是全部，我们把它拆开，首先数据肯定在一个大本营里面，那一堆数据放在一起那就是集合。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

我把一堆纸上面打印上东西，然后把那一堆纸压在一起，它就是一本书，书从广义上也是数据的集合，但是它能叫数据库吗？书不能叫数据库吧，那我问你一个问题，你怎么区分MySQL和P SQL的？</pre>
</div>
</div>
<div class="paragraph">
<p>首先我刚刚讲的，一本书，知识也是一种数据，那么书就是知识的集合，脑子里面叫知识放在书里面就叫数据了，为什么？你要去读他，在你读的时候就像读数据一样，所以你看书你不叫数据库，但是可以叫数据集合，那肯定是除了数据集合以外什么东西他能称得上数据库，那我就问那个问题：为什么你要选不同的数据库？用一个数据库不就够了？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你买的书，他是不是都有固定的排版格式？不管哪种书，现在全世界通行的书都是从左往右，然后从上到下，但不排除比如说像台湾，现在保持着民国的作风，写信的时候他们就像我们小学写信，小学的时候，我们可是学了写信的，这辈子我都没有写过信，除了情书，看到没有对我们来说已经过时了，但是你看民国那个时候，他是这么竖着弄的，那现在他可能也是竖着，有的地方是保持这种格式，就假设有竖着的，有从左到右的，从上到下的，看到没有，特定格式的才叫书，那如果把它打乱放在一起，那叫天书，天书也叫书，只是难看，但不表示你看不懂。</pre>
</div>
</div>
<div class="paragraph">
<p>所以要怎么去定义一本书？因为书也是一种数据集合，那这个时候那定义一本书或者什么叫书？书就是很多很多的文字，把它们组合在一起，就是一个文字的组合，那么一篇文章，它也可以叫书，为什么？只是这本书比较薄，只有一页，但是这个时候我们有个简称，就把它叫文章，仅此而已，因为文章，其实也是个集合，广义上它也是一种书，那这个时候你可能就对书有更具体的要求，你说书的有目录啊，书的有前沿，我文章我也可以加目录，就那种超长篇的文章嘛，比如微信上面划了20下，那个文章都没划完的那种，你可以说他是书。</p>
</div>
<div class="paragraph">
<p>所以从广义上的图书来看，你要去定义它的话，就是：很多文字的一个组合，一个集合，然后把它排列在一起，可以用人类可读的文字或者语言编写的，你会发现这里面文字、编写什么的，格式我都不提他，因为你文字肯定能阅读，至于怎么阅读，从上到下还是从左到右我都无所谓了，只要阅读都可以，那么就对格式有要求了，文字要印在纸上，但是现在有电子书，就是用电子设备打印的纸张，所以说这个叫电子书，他也是一个集合，他不叫数据库。</p>
</div>
<div class="sect3">
<h4 id="_关键词">13.2.1. 关键词</h4>
<div class="paragraph">
<p>那为什么你的书不能叫数据库？</p>
</div>
<div class="paragraph">
<p>那是因为数据库它整个存储格式都是0101，所以我得限定一个范围，限定什么范围？我们就打关键词：</p>
</div>
<div class="paragraph">
<p>第一个：计算机领域。</p>
</div>
<div class="paragraph">
<p>第二个：数据集合。</p>
</div>
<div class="paragraph">
<p>这个数据，我可没有指定具体是什么数据，你看，在计算机以外，文字他算一种数据，语言其实也算数据，图片你看那个照相机，他不是电脑呀，以前那个照一下还要弄闪光灯，还冒烟的，但是和计算机一点关系都没有，甚至和电子都没有关系，他纯靠那种火药燃烧，只要我曝光足够强，人的影子就被打到背后面去，这是纯物理层面，所以这个时候，照片他也可以称为数据，语音也是可以的，那么视频这种眼睛看到的东西也可以称为数据，所以数据的范围很大。</p>
</div>
<div class="paragraph">
<p>这里我们第一点就限定范围，然后第二个就是告诉他是一种什么类型的东西，我们刚刚讲图书嘛，因为我的认知里面数据库就是MySQL，但是我从来没想过怎么去解释他，所以我也其实不知道，那现在我们就挨着挨着推嘛，我们刚刚讲到书是文字的集合，但文字是要按规则排列的，说白了文字是有格式的，比如说你的新华字典或者新华词典上面的那些东西，它的排列都是有规矩的，再比如说电子，你不能说子电吧，这个词还没发明出来，所以你会发现你的文字排列是有要求的，特定的文字，要出现在特定的地方，电子的电一般出现在前面，但是台积电哈的电是在后面去了，为什么？这是个名字，是不一样的，但是它也是有规则的。</p>
</div>
<div class="paragraph">
<p>所以书，是可以称为排列，那如果是计算机领域的这个数据集合，那我们就应该叫数据格式，什么格式？MySQL是有MySQL的格式，比如说MySQL的配置文件里面写了个默认的存储格式，叫innodb，在这个之前有另外一个很老的引擎叫myisam，但他不支持事物，比如说你你更新的时候，他要锁表，意思就是说，有一个人Update，所有读这张表的人必须等到Update完了过后，才能使用，但是不妨碍他简单，他就是因为简单大家才用它，不是因为好，要论好的话，好的数据库多了去了，比如像那个美国的有一家收费数据库叫sybase，那家公司是商业数据库，既然叫商业数据库，那么就要花钱，那肯定好了，oracle也不差，但是你为什么不用？我都不说他安装的问题了，就光他那稀奇古怪的特性，你用的也难受，本来我用PSQL就是图快，结果用个oracle就把机器内存吃了2/3，还要学特殊的语法就非常难受，所以你不会去用orcle的，那这个地方P SQL肯定有他的格式，那SQL server也有的，它装到windows上面，有个两个文件，一个叫mdf文件，一个叫ldf文件，mdf文件就是他的一些原数据，说白了，里面有数据，ldf是日志文件，里面有他的一些操作的信息，你如果把其中一个弄丢了，对不起，数据就会缺失，但是如果你有mdf的话大概率能够恢复的，只能说大概率，为什么？你咋知道数据是第一个版本还是第二个版本的，他有可能这个里面包含了很多版本的数据，你不知道用哪一个，可能包含了一些读写的信息，看到没有，你会发现数据库好像都是这样的。</p>
</div>
<div class="paragraph">
<p>SQLlite最简单的数据库，是单机的，这个数据库通常浏览器什么的，它里面一般都是用的这个，还有很多那种特殊的软件，他就想单机，比如嵌入式用的很多，因为嵌入式里面不可能得起个MySQL，这个数据库它没有进程，它就是个文件，你甚至都不用启动他，他根本就不是个程序，他只有格式，但是不妨碍他叫数据库，而且下的人还挺多的，很多那种用windows下，你装的软件过后，有些作者他为了操作数据方便，他不想用配置文件他就用SQLlite，然后再给你加个密码完事，但这个东西加个密码形同虚死，我直接把你那个二进制未替换了就可以了，你总有地方替换嘛，为什么？太简单了，他只有一个文件，比如说像Redis，也叫数据库，Redis也有db文件，看到没有，我能举一万个数据库，他们每一个都有自己的数据格式，这就像了Windows，Windows叫操作系统，有几个操作系统嘛？Windows，Linux，Unix还有比如说VX那种航空飞机上用的实时数据系统，那种系统就是以毫秒来计算它的运行速度，那操作系统你会发现各种不同，多样的，那为什么不一样？Windows的格式能在Linux运行？不能，为什么？它们的内核是不一样，执行程序的格式是不一样的，数据库也是一样的。</p>
</div>
<div class="paragraph">
<p>所以我们现在知道，计算机领域，一个数据集合，那么这个数据集合是有格式的，那基本上这三点看谁符合，SQLlite符合，但是MySQL比他多，为什么？因为MySQL有端口。</p>
</div>
</div>
<div class="sect3">
<h4 id="_网络读写">13.2.2. 网络读写</h4>
<div class="paragraph">
<p>所以我们加一条，这条是可选的，就是有自己的叫程序进程，比如说像MySQL，他进程是用来做什么的？</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>如果卖MySQL把网络访问这一块砍掉，他也可以像SQLlite一样，所有的数据库，把那个网络通信都砍掉，都可以在本地读写这些格式。</p>
</div>
<div class="paragraph">
<p>所以这个地方严格意义上来说，他不应该叫程序进程，他应该叫网络读写，这是一个可选项，因为它不是必须的，理论上每一种数据库就是一个文件系统，就像你的电脑上的NTFS一样,他就是一个文件系统，不用怀疑，一模一样的，只是你的文件系统是用来存那种图片、pdf、影片的，然后这个时候你的这种存储是属于一种通用存储，什么意思？可以放任何类型的东西，但在数据库里：</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>你要传东西进数据库，你首先要创建数据库，然后创建表，这里创建表像极了建个目录，创建表相对于的目录里面有一个EXcel，然后INSET操作像极了在excel里面加一行。</p>
</div>
<div class="paragraph">
<p>那么我这么比喻你应该就知道，这玩意儿就是个迷你的文件系统，虽然我们可能现在没告诉你什么叫操作系统、文件系统，但是你知道NTFS，Linux下面有Ext4、XFS就跟那个东西是一样的，所以做操作系统和做数据库这块的大牛啊，他们是重叠的，都是那帮人，就是那帮老头子，所以你不用怀疑，就是这么回事，然后我就问你个问题嘛，我通过远程去操作windows和我通过远程操作MySQL是不是一个道理啊？无非就是我让你本地产生读写，所以这地方是网络读写，所以你现在会发现：“我靠，我更不懂数据库了。”</p>
</div>
</div>
<div class="sect3">
<h4 id="_总结">13.2.3. 总结</h4>
<div class="paragraph">
<p>那我们现在总结到底什么是数据库，总结这个我们花半个小时，为什么？你之前都搞不明白它是什么，就算你把“存储数据的仓库”这句话背下来了，也没用，为什么？你根本就不知道什么叫数据仓库，因为数据仓库的描述是不准确的，为什么他没有描述他的全部？因为仓库这个词，是可以剥离出很多很多的概念的，所以这种概念是给高级的人士理解的，对于你来说你不配。</p>
</div>
<div class="paragraph">
<p>所以这个地方我们要总结出一句话，看看能不能把上面的连起来，那数据库就是：“计算机领域的一个数据集合，这种集合有自己特殊的格式，能够通过网络读写。”</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_2">13.3. 使用场景？</h3>
<div class="paragraph">
<p>所以这个地方讲的是where，那这个地方就是使用场景，你使用场景是非常非常具体的，你想一下嘛？这个是从脑子里面总结出来的，但这总结一定是事后才总结的，他发明Mysql的时候，他一定不叫Mysql，你想嘛？那Mysql的雏形还是个小鸡的时候，他肯定可能不叫Mysql，叫municode，那是有可能的，所以那这地方使用场景的话，我们就现在来总结一下嘛，就是我们平时用Mysq是怎么用的？</p>
</div>
<div class="paragraph">
<p>我们有量比较多的数据，类型也多就是量大，我指的量大不是两条，不是五条，有可能是200条，这个量已经很大了，再加到2万条叫巨大，因为一个是要打开2万行很容易崩的，这不是我吹牛，20万你的机器卡五分钟能打开，那是没问题的，你可以想象一下，你每次读数据库要花五分钟，打开一下你的数据库，你不敢想吧，所以这个时候一定是以量为基础，第一个量大，第二个类型多，Excel他只能解决一个问题，就是一个Excel的shift。他只能保存某种格式的数据，你想象一下，你如果那个表格不一样，你能放在一个shift里面打印出来吗？很难，而且会发现是个缝合怪，所以通常我们一个工作表里头，我们只会放一种逻辑的数据，比如财务的阅读统计，我们可能会放到那儿，然后第二个shift可能是年度的，然后第三张可能是明细，你看到没有你会有意识的去分，那数据库其实也是一样的，所以用数据库的场景作为我用的话，第一个数据的量大，第二个，数据的类型多，这种多可能不是三个，你可以想象想你打开一个Excel下面那个工作表那个那个列表列出20个我没见过，你见过你截图给我看。我相信你的做的那个份上的一个Excel跟那个Access  db更适合你，为什么？你都做的那么大量了，那个Excel的管理怕是个问题哦你现在改了个数据，等一会你关掉，然后你重新打开，刚才我改了啥来着？瞬间失忆，量太多人脑是记不住的，所以我见过工作表哈最多的也就5、6个，算顶天了，十个的我有，但是那十个是我自己的，而且不咋改，那你看到没有excel适合去做一些简单轻量的。</p>
</div>
<div class="paragraph">
<p>举个例子：</p>
</div>
<div class="paragraph">
<p>曾经有一个我忘了他们叫什么家具我就假设是八一家具的，那个美女她是那家具的老板，他说有一个人向他们推ERP，他说3万块钱套值不值得，他当时问我，我就问了他一个问题，我说你为什么要去考虑用这个ERP？他说其实我没有考虑，但是那个人上门推销了，他说我觉得还可以，然后我就开始问了他几个问题，我说在没有那个ERP的时候你是怎么一个工作状态？说白了你用ERP为了记某些财务的，表单的，你记的过程当中一定有问题急待解决，那这个时候可能日常的Office满足不了你，你可能才会考虑ERP嘛？什么叫ERP叫企业管理流程之类的。就类似的企业管理的流程管理，财务管理都会都可以叫ERP叫财务ERP叫OA ERP，他只是有分类吗？然后这个时候，我问的过，他说以前我没有这个东西的时候，我是用Excel，他说那Excel，大概有十兆，二十兆的样子也不大。但是呢他每次打开就很慢很卡，他说那个人刚好推销，就换一个，我说是这样的，首先呢那个ERP买要3万而且你还配一台电脑，那台电脑你估计5000块钱搞不定，而且你还要维护，你可能有维护年费一年5000，那么电脑的购买费用我就给你假设是1万块钱，ERP的初始购买价格是3万他肯定还有服务年费，那可能那5000块钱再加个5000就相当1万人工加上管理费，然后就是每年1万的续费的费用再加上初始建设的3万，就4万加上买那个电脑的估计要花钱我觉得算便宜点45000，我说是这样的，1万块钱你能买一台很好的电脑，你觉得我说的在理吧，就是我这么讲的过后的，然后他买台电脑就解决了所有的问题，为什么只要他企业的业务不是翻翻，这种买台电脑还能撑两年，2万块钱撑两年还不用请人，还不用改造自己的企业的管理流程，很棒的一个建议嘛，你看到没有这个时候其实我就问了一个问题，我说没有一些ERP的时候你是怎么做的？说白了ERP相对更智能一些，以及重复性的工作，他可以帮你解决，但是你现在量没那么大，我看起来不是必须的，那就是随这个情况下面我那个建议就应该值1万，他应该可以把佣金，你看到就是装路由器的，顺带他就问了一下，我就讲了一下，你看以后我再也不讲了，这个太血亏了，亏两倍。</p>
</div>
<div class="paragraph">
<p>所以那这个地方使用场景我们刚想到数据量大，那么数据类型多，刚才我举例子那个老板那个事情，你会发现他的量不多，他属于类型很单一就是一些财务数据，你用任何东西都可以记的，那么这个时候量大类型多还有什么，
还有个原因就是读写频繁，我指的频繁是什么意思？你等会儿要读，等会儿要改，Excel可是满足不了的，Excel在改的时候他有文件锁？你其他人就不能改了。</p>
</div>
<div class="paragraph">
<p>所以Excel他在频繁读写的时候是有问题的，什么问题？他是一个文件，如果一个人写的时候，另外一个人必须等，然后这个等的过程那怎么样？就是一个新的损耗，这是一个读，也是一个问题，为什么他每一次读都是从硬盘上硬读，就硬读，没有一点缓存可言，操作系统是对热点文件是有缓存的，但那种缓存是一种通用的策略，他不是针对数据库的，所以一定没有专门的数据库来得快，所以量大，类型多，读写频繁，那个数据库是真的读写频繁，如果你想一下嘛100个人读你的Excel你不崩，绝对崩哈，大家都知道就不用我再举更具体的例子，那除了这个以外刚刚说的吗？我想网络读写，我不想单机，还有什么？刚波波说嘛，关系。这种关系已经超越了Excel里面简单的透视图这种关系，那种关系一定是少，我就问你个问题，比如说你有十张表，十张表，表和表之间如果一一对应的话，就相当是说这个样子的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Excel.png" alt="Excel">
</div>
</div>
<div class="paragraph">
<p>这是第一张表，这第二张表，第三张表等于说，你有三张表的话，你总数是n减一，那我问你如果有十张表来就是10-1嘛，好简单，等于九，但是你错了，数据库的关系可是这样：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/数据库.png" alt="数据库">
</div>
</div>
<div class="paragraph">
<p>他和他有关系，他和他还有关系，他可能查这个地方，然后这个时候数学公式已经失效了，为什么？因为数学公式解决的问题是一种通用或者是叫广泛意义上的规则的一个总结。你设计的数据库和我设计数据库，你能用数据公式总结出来？你只能总监用微积分简单算一算，范围落在哪个地方，但是已经没有办法明确了？为什么？因为关系处于交叉，这种交叉你只能算最少有多少个关系，就像这种嘛？那比如三张表嘛最少的关系就是没关系，最多的关系就是两两之间有关系，他只能算这个区间范围，他没有办法算出准确的？所以这个时候，数学在这个时候也失去了意义了，数学不是干这个事情的。</p>
</div>
<div class="paragraph">
<p>总结：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据量大</p>
</li>
<li>
<p>类型多</p>
</li>
<li>
<p>读写频繁</p>
</li>
<li>
<p>关系（巨）多</p>
</li>
<li>
<p>统一的读写方式（SQL）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>我相信没有SQL让你去读那个二进制你是不愿意的，你想象一下，我就是给你弄个单机的那个Access db，你每一次读Access db的时候，你要想读Excel，先定位到A1这一列，定位到了，在定位到E2这一行，然后你就查出了一条数据。然后如果你要取区间的话就是E1&#8212;&#8203;Z1,然后这一个时候你就很多，所以你看这个时候你就不再是说以前能解决这个问题了。</p>
</div>
<div class="paragraph">
<p>所以这个地方有个统一的读写方式，那这个时候它才是最重要的，其他都不重要，你想一下，读写文件，你是按行读的，这玩意儿你都不知道在第几行，所以说这个方式才最重要的，没有这个东西，前面的都没用，所以我用数据库最简单的原因就是统一的读写方式，这也是最重要的，想象一下嘛，其他的一个你都可以忍，硬件方面提升只要钱够都不是问题，但是没有这个玩意儿他就不是一个我们认为专业的数据库软件了，我认为就这些，当然还有一个网络，网络也很重要的，这个地方指的肯定是普通意义上的数据库，他要有网络读写，说白了，就是要做网络交换数据。</p>
</div>
<div class="paragraph">
<p>那还有没有后面的特点？就你为什么要用数据库？首先，让你自己去解释，那个MySQL的报文，你肯定是不会愿意做的，所以那这个时候你用数据库最重要的一个原因肯定不仅仅是说他能网络读写、交换数据还有个很重要的原因，就是数据库提供了驱动层，也就是JDBC之前的那一层，所以这个地方就是数据库他提供了什么？提供了SDK，封装了他的读写行为，然后这个时候能他上能对接语言下能对接他的操作系统和文件系统，所以就处于这个位置，如果要画一个拓扑，应该是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tuopu.jpg" alt="tuopu">
</div>
</div>
<div class="paragraph">
<p>下面是OS操作系统，具体到他那个FireSystem文件系统这一层，然后上面的话就是属于语言，比如说Java，然后这个时候，打个比方，比如说最上面是Java，那下面这个地方就应该是JDBC，那JDBC下面一层应该是MySQL的Driver，这个以后我们讲原理的那一块，我们会具体讲啊，涉及到ORM和数据库原理内存，然后Driver下一层就应该就是MySQL，然后下面才是OS，里面肯定有内核、文件系统。</p>
</div>
<div class="paragraph">
<p>上面的Driver怎么理解？换一个解释的方式：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tuopu2.jpg" alt="tuopu2">
</div>
</div>
<div class="paragraph">
<p>OS还是OS，MySQL换成Nginx，Driver换成HTTP，然后JDBC换成Restful API，最后Java还是Java，然后你会发现这两个概念就是一模一样的，所以这个地方的Driver，他做了一件事情，就是解析报文，他把报文的封包、解包行为全部囊括在里头了，而另外一个的语言JDBC，只需要把报文的那个decoder和incoder调用一下，他就能把报文拿出来，那剩下的就简单了，我都能把包文解析出来，如果我能自己写，我都不需要你这个Driver，所以这个东西纯粹就是解析报文，然后JDBC是语言里面的规范吗，这种规范是Java官方强制要求的，你按规范做，就可以去对接上层，所以JDBC这个东西实际上没有任何意义，如果只是说叫JDBC的话。</p>
</div>
<div class="paragraph">
<p>我们一般用JDBC的时候是这样的，JDBC加MySQL，然后这个时候你才能写代码，如果你仅有个JDBC放在哪里，请问你启动起来连谁，所以JDBC是不能单独存在的，是一种规范，所以这么一对比，你会发现，如果没有Driver层是没有任何作用的，所以说MySQL的官方，他要提供编程的API接口。</p>
</div>
<div class="paragraph">
<p>现在我们再回过头看Excel，你为什么在Java写的时候，你用Excel去保存你数据库？他也有编程接口，但是我们要的编程接口可是易用的，微软，他用com组件，CVM，用串口的方式实现的Excel的读写，但是特别难用，我跟你讲，我用完一次，就不想用第二次，所以微软那个接口相当于没有，它是一种统一的接口，Excel只是囊括在里面，通过中间一层驱动层实现的，那个驱动叫ODBC，以后会接触，既然有JDBC，那微软搞了属于自己的叫ODBC。</p>
</div>
<div class="paragraph">
<p>所以编程接口是非常非常关键的，如果按顺序的话，最重要的是哪几个？有SQL，有接口，然后网络读写，如果你没有接口，但是没有网络读写，没关系，网络读写我能自己写，大不了用Spring Boot封装一个Conterllor，所以说除了这三个剩下的其实就不是很重要。</p>
</div>
<div class="paragraph">
<p>那么你会发现，这并不是我强行总结出来，这是因为我有需求，如果数据量不大，这些东西都白搭，为什么？我要是数据量不大我就不会搞这个了，我一定是有数据量大，有基础我才搞，虽然前面不是重点，但前面是我的基础需求，这种需求延续下来，他不一定要选MySQL，所以说一定是有各种条件需求，对应需要的条件需求做一个筛选才选出来的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么用how">13.4. 怎么用？(How)</h3>
<div class="paragraph">
<p>这个地方是怎么理解?首先，刚才讲的What，那肯定对应会有一种数据库固定的使用套路，首先，我们说广义上的数据库，它其实是有网络读写的，你既然是通过网络读写数据库，那肯定是有连接的。</p>
</div>
<div class="paragraph">
<p>所以第一步应该是：</p>
</div>
<div class="paragraph">
<p>1.连接数据库。
当然，这个连接数据库肯定是根据语言不同，就有不同的方式，但是你知道的，就算你用Py或者Java，它们其实连接MySQL的时候，甚至那个查询，那个连接串都是差不多的，实际上，你掌握了一种，第二种就没有问题了，所以你第一个就是考虑的连接数据库。</p>
</div>
<div class="paragraph">
<p>2.切换数据库</p>
</div>
<div class="paragraph">
<p>一般连接数据库过后，你应该切换，就是白了，要进入数据库，你切换完了过后，现在开始就可以正常用了。</p>
</div>
<div class="paragraph">
<p>3.读取结果</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>我用的时候，正进行一个表的读写，那我切换数据库，下一个应该是查询，所以这个时候我应该用SQL，然后现在SQL查询其实是有很多小步骤的，我肯定是通过前面讲的使用场景的某个东西，但是又发现在这个地方其实根本就不重要，为什么？因为你SQL查询，不管你是哪种语言，步骤都差不多，打个比方，你用非常原始的JDBC，你要先用pre去加一个satement，先把这个SQL预编译放在那，因为他做语法检查，然后你要用什么accq去调用这个SQL做执行，把它发送给MySQL服务端，然后他收到过后，要响应你一个结果及result，说白了，你不管哪一种数据库，他的行为都差不多，你不管哪种语言，他都差不多，没有本质上的区别。</p>
</div>
<div class="paragraph">
<p>然后你说我用JPA的时候，或者Mybatis等等的时候可不是这样的，它们只是把这个行为帮你做了，所以这个地方我们就忽略掉那些细节，因为现在我们不关心，那这个时候我查询完了，有个读取结果，当然，这个地方我有意忽略掉了网络的传输，因为那个东西不该我管，为什么？他的Driver层已经实现了，和我没有关系。</p>
</div>
<div class="paragraph">
<p>4.释放资源</p>
</div>
<div class="paragraph">
<p>取出结果后吗，我也使用完了后，它是需要释放的，这个和语言有关系，但是我还是把它写上，就是这个地方应该是释放资源，分配可能是前面，你看我前面没有说分配，那为什么释放呢？所以我说这个是广泛的一种型，释放资源不是每一种编程语言都要做的，是根据你语言不同导致的，比如你有Java，他有gc，有gc你是不需要什么释放的，如果你用GO语言，你如果不是写GO语言的runtime的话，他是没有gc的，为什么？runtime的意思就是说是内核的那一部分，GO的内核的一部分是不需要做gc的，但是GO的runtime以外的代码你是可以让他的gc帮你托管，所以说，在GO的runtime里面，说白了他自己实现自己，他肯定没有GC，所以他自己的内核里面是不会有提示的，是手动处理的。</p>
</div>
<div class="paragraph">
<p>那么用GO是可以写个操作系统的，但要看你怎么去用，那么C++就要手动释放了，C也是，Py看起来不用，但是你会发现Py有时候要掉个close，其实也是干这个事情的，所以这个地这一步不是必须的。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_HTTPYY_chapter">14. HTTP协议(应用)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_13">14.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/HTTP应用板书1.jpg" alt="HTTP应用板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP应用板书2.jpg" alt="HTTP应用板书2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP应用板书3.jpg" alt="HTTP应用板书3">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http是什么">14.2. HTTP是什么？</h3>
<div class="paragraph">
<p>今天我们讲一下HTTP协议，我们之前讲过HTTP报文，还有HTTP和Java的一些结合，那今天我们讲应用，首先老规矩啊，他是什么？他能干嘛？</p>
</div>
<div class="paragraph">
<p>首先我们把HTTP一个字一个字拆开：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>H-----&gt;超（Hyper）

T-----&gt;文本（Text）

T-----&gt;传输（Transfer）

P-----&gt;协议（Protocol）</pre>
</div>
</div>
<div class="paragraph">
<p>这个HTTP就是超文本传输协议，上一次我们在讲HTTP报文之前简单提过，今天我们讲的肯定就不是着重讲他的封包和解包，我们现在讲的是他的应用，也就是他应用在哪些方面，用来干什么，用完了过后看着是什么效果？然后讲完这些过后，我们再讲一下HTTP/1.1和HTTP/2.0甚至还有HTTP/3.0，它最终是一种什么形态，为什么需要它？</p>
</div>
<div class="paragraph">
<p>首先，那么超文本我们还是接着上次就是的讲，上次我们讲的超文本是什么意思？超越文本，所以他是超越文本的传输协议，那什么叫超越文本？首先在回答这个问题之前我们要搞明白一个问题：“什么是文本？”首先你要搞清楚文本，比如说文本的话，你可能会见到:</p>
</div>
<div class="paragraph">
<p><code>ABCD测试</code></p>
</div>
<div class="paragraph">
<p>这可能是你某个文件里面一段文本，他只是字数少或者字数多的问题，那么超文本。</p>
</div>
<div class="paragraph">
<p>打个比方，这里我们有下面的文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;html&gt;
    &lt;H1&gt;
      Hello,World!
   &lt;/h1&gt;
&lt;/html&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>这段他也叫文本，你用英文，要是我这个地方写两个中文就是中英文混合，那它也是文本，这两段同样是文本看起来是不是现在这个有点特殊。</p>
</div>
<div class="paragraph">
<p>那么第一段“ABCD测试”，如果把这段文本放到计算机里头，计算机认识他吗？或者说计算机能轻易知道他的内容吗？</p>
</div>
<div class="paragraph">
<p>比如说你是科大讯飞的，你拿着这个文本啥都不干，我就问你科大讯飞的输入法或者是你的识别程序能识别它吗？能识别到哪种程度啊？它能理解吗？</p>
</div>
<div class="paragraph">
<p>那再问你个问题：我随便写个程序能识别第二段文本吗？</p>
</div>
<div class="paragraph">
<p>这一段文本有个特殊的点就在于它是对齐的，成对出现的，这就意味着什么？首先他是文本，那这是文本里面的哪一种？它是一种结构化的文本，那什么是结构化吗？他有结构，那什么是结构呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>举个例子

修房子，你没有图纸，但你得有顶梁住，图在心中嘛，不然怎么修的房子呢？修房子有图纸，你把图纸画出来，它是什么样的？和这里的结构化文本区别在哪？工人拿到图纸知道怎么去施工，因为你房屋修建，房屋建设这种，他是有一定的行规，所以你刷图纸的时候，大家都知道你画的是什么，就算工人不认识图纸，他都不可能把你这个房顶弄到地基下面去。</pre>
</div>
</div>
<div class="paragraph">
<p>所以那这个时候，这种东西叫结构化文本，首先你要看他当中的一些潜在规律，html和/html是对齐的，意思就是说，在他和他之间的内容一定有特殊的意义，然后中间这个h1和/h1也是这样的，就算是学过简单HTML的人都知道他是这个是一个标题，这个就是结构化的好处，为什么？因为它有规律，还有规则，只是这种规则可能你现在不了解，但是你知道它是结构化的，那我把第一段话改造成结构化，怎么改？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方：

&lt;B&gt;abcd&lt;/B&gt; &lt;Test&gt;测试&lt;/Test&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>这样是不是就改成结构化的了？然后再换一种写法：</p>
</div>
<div class="paragraph">
<p><code>#ABCD#测试[Http://qq.com]</code></p>
</div>
<div class="paragraph">
<p>改造前它是一段文本，改造后它也是一段文本，但改造前的文本拿给程序没有任何意义，他顶多就是说当一个工具人啊，你输入什么，他输入什么，但改造后就已经是智能的人了，带智慧的人了，为什么？因为他会把#ABCD#这个标黄，在那个SC里面，还可能加粗，后面的可能是链接，那为什么能实现这种效果？首先为什么讲这个，我的意思就是说超文本传输协议，说白了，这句话要怎么看：</p>
</div>
<div class="paragraph">
<p>“ <code>超越文本</code> 的 <code>传输协议</code> ”</p>
</div>
<div class="paragraph">
<p>HTTP是传输协议，没有问题，那你会发现这个超越文本是可以省略的，那么HTTP就是传输协议的一种，我们要挨个解释，怎么解释啊？这里面肯定有几个东西：</p>
</div>
<div class="paragraph">
<p>1.文本</p>
</div>
<div class="paragraph">
<p>文本就是所看到的文字，比如：英文、中文、法文、日文、印度文、马来文他们都是文本，甚至说，你自己随便乱画，写玛雅人的文字，虽然不认识，但是他也是文本，反正你的眼睛看得见的，反正只要不是图片，统一归纳成文本是没毛病的，甲骨文也是文本，但是你并不认识甲骨文，所以我们讲文本的时候，一般是指的广泛意义上的文字，至于我们认不认识这个文字，我觉得没有关系，比如说像法文，我就不认识，但是你能说法文不是文本吗？所以这个地方的文本肯定是指的是什么，那么它通常意义指的是计算机领域的，因为你在计算机以外，这个文本可能叫书、报纸、说明书，甚至是墓碑的碑文，比如说那个中国古代有些古墓，他就会立个墓碑说这里面是谁谁谁，记录上他的生平事迹，你看，文字有各种各样的名称，为什么？只是因为每个文字对应的载体不一样。</p>
</div>
<div class="paragraph">
<p>就比如：看书载体是纸张，然后你说你在干嘛，你说我在看kindle，那难道kindle上就不是书，不是文本了？他也是，然后别人问你干嘛，你说我看报纸，那你看报纸不也是看的文字，但是你不会说我看文本你说我看报纸。</p>
</div>
<div class="paragraph">
<p>所以你会根据你的载体不同，就可能会看到不同的东西，但在计算机领域这些东西都可以统一称作文本，为什么？因为在计算机的眼睛里头，不管你的载体是哪一种，最终传递的都是信息，信息很可能就是用我用文本的来传递的，程序写代码，他用JSON传给你，或者是我在qq上文字传给你，通常也都是通过文本来传递的，当然0101它广义上也是文本，只是你不懂，但是计算机是懂的。</p>
</div>
<div class="paragraph">
<p>所以这个地方：</p>
</div>
<div class="paragraph">
<p><code>文字：-&#8594;计算机-&#8594;文字</code></p>
</div>
<div class="paragraph">
<p>文本是载体，那么只要载体是计算机，然后再加上文字，至于这个文字是认识不认识的都没有关系，说白了，你可以理解为Data，任何东西都是Data，甚至图片也可以Base64传，pdf也是可以的，把pdf弄成Base64，他也可以传，当然我如果不转成Base64，把那个mp4直接播放给你看，你看的是流媒体，它也是文本啊，只是说这种文本非常特殊，你专门给他取了个名字，叫视频流，那超人不是人吗？但是你会把他叫超人。</p>
</div>
<div class="paragraph">
<p>所以说凡是在计算机领域，我们指的文本一般是指的文字，这种文字有英文、法文、还有一些符号，这些我们都会认为他叫文本，你理解为文字是没毛病的，但是一定不是新华字典上那个范围啊，新华字典那个范围太窄了，我们讲的是那么很大的字典，凡是手能写的都是。</p>
</div>
<div class="paragraph">
<p>2.传输
传输怎么理解，计算机在没有互联网之前，大家都是拿软盘拷来拷去的，我们那个时候不叫传输，我们那叫copy。</p>
</div>
<div class="paragraph">
<p>讲个冷笑话：以前我们合作公司有一个美女叫张燕，他那天跟我讲那个冷笑话，我也不知道是故意逗我玩了，还是真的发生了，她千里迢迢跑到隔壁公司，把我叫过去，她说她遇到个问题，什么问题?然后她说：我在家里面Ctrl+C，然后到公司Ctrl+V可是没有东西，当时我楞了一下，好像是有道理，然后看到她表情很严肃，这时候我也不能笑场，我就给她说这个不能这么拷，你要在同一台电脑上做，我不能直接说。</p>
</div>
<div class="paragraph">
<p>所以传输它完成的是一种Copy动作，那什么叫传输？就是网络Copy，那怎么理解网络Copy呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

在以前Copy的时候，是拿那个软盘，你把它Copy那个软盘上面，然后你要让很远的人来Copy资料，那么你去拷贝这个过程当中，是不是还要买机票？比如说女朋友在海南，你在北京，这个时候你就要买机票，所以怎么样，贵，还不方便。

那这个时候大家想的能不能通过网线直接把这个数据传过去传说，这也是在做Copy，那么这个传输你可以理解为通过网络Copy数据，因为这个地方讲的是传输这个词，那肯定是用数据嘛，数据比文字的信息范围更大，所以传输的话就是通过网络复制数据，从A点到B点，他完成是这种动作。</pre>
</div>
</div>
<div class="paragraph">
<p>3.协议</p>
</div>
<div class="paragraph">
<p>什么是协议？可以理解为字典、说明书，字典说明书是什么意思？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

你不会说普通话的外国人，你随时带一本新华词典，就以前没有app的时候，然后你走到一个人前面用蹩脚的发育说：“你好”然后不知道吃饭怎么说，你就打开字典，在对那个人说：“我要去吃饭。”那这个时候一个不会说普通话的外国人，他能通过一本词典和你搭上线，那么搭上线过后，剩下就好办了。</pre>
</div>
</div>
<div class="paragraph">
<p>就是我我经常在网上看到有些人就是出国玩，跟的一个旅行团，里面全世界的人都有，然后有一对英国夫妇，然后还有一对日本人，然后他们是中国人，他们6个人坐在那个地方看世界杯聊天，怎么聊的呢？中国人先把自己想说的翻译成英语，然后给英国人讲了一遍，他们就用那个翻译机之类的，然后他们聊完了英语，再翻译成日文再跟那一对日本人聊，虽然这样聊天很累，但是他们坐在那地方聊了整整六个小时，他们聊的过程当中还会嘻嘻哈哈的，为什么？如果那个事情不有趣，我相信你不会在那做一天的，不过有可能是外面下雨，所以通过一个词典或者一个翻译app，你就能做到和别人沟通，所以那个的词典就叫协议，只是那本词典是给人用的协议，而协议是给计算机用的，肯定不是人和人之间的，你想想我跟你一起说话的时候用HTML语言说，一个一个字的念，人肯定觉得很烦而且听不懂，所以协议一定不是人和人之间的。</p>
</div>
<div class="paragraph">
<p>所以那个的词典就叫协议，只是那本词典是给人用的协议，而协议是给计算机用的，所以这个地方指的协议首先类似于人和人之间的词典，那要去解释他的话，表示的是用于计算机和浏览器之间的，为什么是浏览器？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

刚刚举了计算机给你讲HTML语言的例子，人会去嫌他啰嗦，而且你还听不懂，所以这个时候计算机和浏览器讲呢？它们能听懂的，这个地方的传输是指用于计算机之间传输数据的载体。</pre>
</div>
</div>
<div class="paragraph">
<p>那载体是什么？我们第一点讲的文本，它就是内容的载体，这个地方协议也是用文字写的，很巧吧，为什么那么巧？你的协议，就像我刚刚念给你听的HTML语言，他也是文本，所以这个地方传输数据的载体，而这种载体你可以理解为传输数据的一种格式，那么这个载体的话就是相当于一种特殊格式的文本集合，当然这个地方为了表达清楚我的意思，我可能用了几种不同的方式去表达，但是你得知道这个地方，最终他肯定是某种规范或者说明书，总的来说就是：“相当于一种特殊格式文本集合的说明书。”</p>
</div>
<div class="paragraph">
<p>这里说明书你可以理解为一种规范，而计算机和计算机这个地方就表示是在限制范围，后面两句话才是真正的解释，你想嘛，我们讲协议的时候，肯定是讲了一本说明书，所以这个地方其实载体意思就是说，传输数据你得有说明书，那个说明书里有说数据是怎么用的。</p>
</div>
<div class="paragraph">
<p>我们以后我再整理一个更完整的表达，但是现在我先表达清楚我的意思啊，就是可能你没有办法讲得非常通俗或者是一句话讲明白，但是你知道，协议就是词典，就是类似于说明书。</p>
</div>
<div class="paragraph">
<p>现在撒回过头来反过来看这句话：</p>
</div>
<div class="paragraph">
<p><code>超越文本的传书协议</code></p>
</div>
<div class="paragraph">
<p>这个地方协议，就是本说明书，传输协议就是用于通过网络复制数据的说明书，然后加上超越文本就是：超越文本的传输说明书，所以前面是在限定他这个说明书的范围，这地方的超越文本很重要，说白了，这个地方的意思就是说HTTP是一个文本的传输说明书，然后加一个更具体的词：“超越”，那就是超越结构化文本的说明书，所以这个地方HTTP真正要有个更完整的解释的话，它是一个：</p>
</div>
<div class="paragraph">
<p><code>结构化文本</code> 传输协议</p>
</div>
<div class="paragraph">
<p>其实前面用的的话，其实都不是很正确，因为他们没有所属关系，是平等的，然后我把这个词再换一下：</p>
</div>
<div class="paragraph">
<p>结构化文本 <code>网络复制</code> 协议</p>
</div>
<div class="paragraph">
<p>如果是新手的话，网络复制比传输好理解一些，但是这里没解释协议，在补充一下：</p>
</div>
<div class="paragraph">
<p>结构化文本网络数据复制 <code>标准</code></p>
</div>
<div class="paragraph">
<p>这就是我们通过一层层偷换概念，做等式替换，最后得出的一个结论。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http的使用场景">14.3. HTTP的使用场景</h3>
<div class="paragraph">
<p>我们之前讲过的，像这种总结，不要去总结他的特点或者他的优点或者劣势，为什么？你把使用场景讲明白了，用在那个场景下面，他肯定就简单噻，所以特点优点那些东西都是什么强行总结出来的,所以我们直接讲这玩意儿用在哪儿?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>浏览器</p>
</li>
<li>
<p>Web服务器</p>
</li>
<li>
<p>手机APP（mini浏览器）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我把这个浏览器装在那种电梯里面的广告大屏里头，也是可以的。那我装的摩拜在单车里面呢？你会发现，如果我们以工具来讲这个事情的话，你会发现世界万物都有他的身影，但是你要用特殊场景的约束的话，其实和他没关系，为什么？因为什么什么都可以，所以我们这地方讲的时候，迷你浏览器，这个地方就有意思了，那么使用场景，这是其实就是规的一类，就是浏览器，那么现在解释浏览器，浏览器有什么作用哈？</p>
</div>
<div class="sect3">
<h4 id="_浏览器">14.3.1. 浏览器</h4>
<div class="paragraph">
<p>就是你用浏览器的时候，首先它有个漂亮的网页。他你输入域名过后能看到网页，然后他看起来能和Web服务器通信，现在我们来解释一下浏览器的作用。浏览器在这个时候，其实它是什么，我们之前讲过的，一个叫服务端，一个叫客户端？但是我们要回避这个概念，为什么？因为这个概念在第一阶段讲得过多人会晕，因为太专业了，所以现在我们只讲浏览器。</p>
</div>
<div class="paragraph">
<p>浏览器可一点都不不比操作系统简单哈，上一次我看他们讨论这个问题，浏览器的代码量好像突破3000万行了，Chrome浏览器的3000万行，所以浏览器它很复杂，但对于我们来说用起来简单，我讲过的，你使用越简单的东西，实际上实现代码越复杂。</p>
</div>
<div class="paragraph">
<p>所以那浏览器第一个作用展示网页，那第一个它能展示网页，那下一个它有什么用？你都要展示网页，你的网页哪来的呀？传输数据不准确，为什么？浏览器现在它是个孤零零的，他一个人是不能传输数据的，你可以讲接收数据，或者发送数据，你不能讲传输数据，你要讲传输数据，一定是说a和b之间传输数据，而你从你自己出发，你应该这样的，要么你发送数据，要么你接受数据，这个才是和你相对的。两人你可以说传输，一人你只能说发送或者传收到，所以第一个肯定是展示网页是最重要的功能，但是在有网页之前，你要先输入一个网址，然后这样的话应该请求网页呀，你肯定要去请求网页嘛，请求嘛然后怎么样嘛？收到撒，那我们按顺序来写吧，没有顺序的话可能理解起来很麻烦，讲HTTP一定要讲这个，如果你不理解他，你理解不了整个HTTP，为什么？和你的生活八杆子远。</p>
</div>
<div class="paragraph">
<p>谁知道为什么我要讲这个，为什么我要用这个角度跟你讲，知道为什么吗？一样事物你在两句话以内你让别人听不懂，你就是不理解他，我指的这个理解说你和程序员沟通你肯定不用给他讲什么是HTTP，为什么？你默认他是知道的，如果他不知道他自己去补课，但是你和你的同事老板沟通，可能有时候的同事是个销售，所以你为了你自己沟通怎么样？你要沟通这个问题的话，你要先去理解，而不同的讲话对象，你的沟通方式是不一样的，写代码其实相比你说话来说写代码容易多了。</p>
</div>
<div class="paragraph">
<p>所以浏览器的作用就是先 请求网页请求网页，那么我请求肯定就收到噻，就像我订报纸一样，我交了钱，你得给我报纸嘛，拿着报纸过后干嘛呀？看报纸啊，你生活里面也是这样的，既然浏览器这个作用，那Web服务端和浏览器是相对的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求网页</p>
</li>
<li>
<p>接收网页</p>
</li>
<li>
<p>展示网页</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_web服务器">14.3.2. Web服务器</h4>
<div class="paragraph">
<p>浏览器既然能请求网页，第一步就是受到请求，这个地方收到请求肯定是省略了网页，第二个就是处理请求，处理请求的意思就是说，他得知道是访问到哪个网址，然后他知道这个事过后，他应该先去准备网页呀，准备好了快递再给你寄出去，所以第三个就是生成网页，最后一个是发送网页嘛。</p>
</div>
<div class="paragraph">
<p>请求网页是对应收到请求，接收网页是对应发送网页。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>收到请求</p>
</li>
<li>
<p>处理请求</p>
</li>
<li>
<p>生成请求</p>
</li>
<li>
<p>发送请求</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在你知道了使用场景是这样的，就是我们看图说话：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/简易Web图.png" alt="简易Web图">
</div>
</div>
<div class="paragraph">
<p>就是用户在浏览器上面输入网址过后，敲回车会产生一个请求网页的动作，然后这个时候服务器收到这样这个请求，然后去理解去查看这个网址里面具体要访问哪一个，他就说白了这地方是查看或者分析出要查看分析哪个网页，找到那个网页的地址，如：/index.html，找到那个网址过后，那么交给程序代码去查数据库，去读取服务器上的各种应该处理的或者说分析的东西，然后最终拼凑出一个网页，那么拼凑出完了过后把这个网页原路发送给浏览器，浏览器收到网页内容过后把网页展示出来。</p>
</div>
<div class="paragraph">
<p>这个地方再做个补充，就比如：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/关系对应图.png" alt="关系对应图">
</div>
</div>
<div class="paragraph">
<p>qq.com，然后qq.com的请求过去了，然后返回回来的&lt;html&gt;标签嘛，就刚才结构化的文本，服务端把网页发给浏览器了，然后展示出来。</p>
</div>
<div class="paragraph">
<p>这是个引子，现在同样事情我们再把它往细了讲，在中间这个地方涉及到通信。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CS模拟图.png" alt="CS模拟图">
</div>
</div>
<div class="paragraph">
<p>所以浏览器是C，Web服务器是S，他们之间要发生各种请求和响应，那你要发生请求和响应，这个高速公路名字叫什么呀？然后这个高速公路叫HTTP高速公路，那这个高速公路上跑的车，那个车是HTML，现在我们就开始解释这个高速公路。</p>
</div>
</div>
<div class="sect3">
<h4 id="_客户端与服务端之间的传输媒介">14.3.3. 客户端与服务端之间的传输媒介</h4>
<div class="paragraph">
<p>然后我们现在详细来讲一讲这个高速公路上发生了什么，我们刚刚讲的是c这边和s这边它整个说话的过程，一共看起去两步嘛，然后这两步解决了他说话的过程，然后我们再了解一下他们两个说话过程当中传输媒介，这高速公路就传输媒介嘛，网线是一个传输媒介，软盘是一个传输媒介，u盘是一个传输媒介，光盘是一个传输媒介，空气是声音的传输媒介，水能传输声音，它也是一个媒介，但是你在太空里面说话有媒介吗？没空气就没媒介，为什么？声音就传不了？当然你把大海的水倒上去也不是不可以，那也可以传输了，就是有点有点废油哈。</p>
</div>
<div class="paragraph">
<p>所以那这个时候，我们就把这个高速公路展开。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/网线原理图.png" alt="网线原理图">
</div>
</div>
<div class="paragraph">
<p>我假设这边是C，这边是S，中间有一条河，所以那这个中间这个高速公路名字叫HTTP，所以就表示是中间这一块，那刚刚浏览器这个地方我就弱化这个里面具体的东西哈，我们着重讲一下浏览器这个地方他有个请求网页，所以这个地方我们他发生了一个叫请求，然后Web服务器这个地方他又回去了，我们把它叫响应，为什么刚才不叫响应，是因为刚才我们还在讲这个事情初级阶段我不敢用响应，然后一个请求，一个响应，他们中间的传输媒介是什么？HTTP，就像及了高速公路，然后这是往左边跑的车，这是往右边跑的车，只是车的牌子，一个叫响应，一个叫请求，仅此而已哈，然后说白了这个时候，你可以理解中间这个东西，物理媒介，这个中间是网线嘛，现在是这样的，我们把这个图倒一下，先画一个网线，用波浪线哈表示网线，然后这边是C，这边是S，然后那网线上面他有一条高速公路，当然你会发现其实高速公路上还有很多其他的东西，而这个地方最开始C向它发起了一个动作，那这个时候C朝S这边发送了点什么</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/请求.png" alt="请求">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/响应.png" alt="响应">
</div>
</div>
<div class="paragraph">
<p>所以这个时候S应该响应，现在有个问题了，那现在是HTTP是说明书，那它是一个规范吗？在规范里面肯定有关于传输的东西，我们刚刚说网页是通过他传的，既然你是传输协议，传输协议你肯定有关于传输的东西，现在讲的就是传输的东西，那应该还有协议相关的东西，我们刚刚讲的还要传输一些结构化的文本，文本在哪？就在这个车上面，所以这个时候他会把HTML源源不断的朝这边发，其实这个地方不是HTML是什么，其实准确来说就是应该是报文报头，所以这个地方其实你最开始发过去的东西不是HTML，所以这个地方准确说应该是什么，报文太专业了，换一个词，所以这地方你可以叫请求数据包，但是通俗点的说法叫网址，你就是把网址传过去了，只有网址上面带参数，我是普通人，我也不关心参数，比如说你问李俊祥他用鼠标点的时候他看得过参数吗？他想都没想这回事，你在QQ空间传相册的时候那个从来没有想他说他发起个POST的请求，为什么？你脑子里面不会想这些事的，为什么？因为和你没关系，反正也可以用，所以这个地方你是请求请求数据， 准确的说的话，这个地方应该是网址，你把网址相关的信息丢过去了，网址相关肯定包括网址本身，还有那个问号后面给他参数嘛，他如果是一些上传图片的操作，肯定还要把图片带过去嘛，所以叫网址相关，那我把网址相关的东西丢过去了，所以这个时候你回的时候回的是HTML数据，实际上你就可以理解为一个网页，过去是一个请求，请求数据网址相关的东西包含参数，回来的时候直接就网页了，所以你看到没有使用场景，他使用场景是这样的，发生在两端，当然真实的情况下头他肯定不是说是一对一的，真实情况应该是这个样子的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/多对一关系图.png" alt="多对一关系图">
</div>
</div>
<div class="paragraph">
<p>这是个s，那么s的话应该接受怎么样？全世界的人访问，所以你看到没有，那他要接收很多很多人同时访问，所以其实他是很厉害的，所以知道什么是服务器了吧？你搞清楚一对一的关系，你无非是在这个地方变成了多对一，所以c和s之间的关系是多对一。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http1_1_vs_http2_0">14.4. HTTP/1.1 VS HTTP/2.0</h3>
<div class="paragraph">
<p>我们在讲HTTP/1.1和HTTP/2.0之前，我们先问一下自己，为什么微软发布了Win7然后还要发布Win10？</p>
</div>
<div class="paragraph">
<p>因为你发版本一定是想塞一些自己想塞的东西，Win7已经塞不下去了，他必须要操了重新拆的Win10里面，你得总有点客观因素哈，这种客观因素因素肯定是你很主观的总结出来的客观因素，比如微软说Win7的架构太老了，我们重新搞一套，改成Win10，Win10更快，性能提升100%然后经常我看到这种新闻，我就很纳闷， 每一次那个发送的Json，他都说性能提高了30%，你是多慢呢？包括那些浏览器这些，也是说自己又提升了百分之多少，你说可以，关键你每次这么说我就很纳闷了，但为什么我感觉不到呢？我讲过的我家里面有一台宏基的上网本，他现在已经打不开淘宝首页了，就是打开淘宝手机是什么现象哈，我那个电脑开着我就没打开过淘宝首页，懂我意思了噻，就是再转圈圈，我也好不容易装上Chrome，为什么说好不容易呢，真的太难了，裸奔的Win七要装Chrome，要经经过各种环节，装上了过后他就淘宝手机一直转圈他就渲染不出来，当然有可能淘宝嫌弃我的Win7，他把我干了，但是不只是淘宝，京东打开也慢，但是京东能打开就是丑了点，为什么？因为可能你换了个新的操作系统，但是意味他消耗了资源更多，我那个上网本一共就2G内存，开了Win7，1.5G就没有了，然后剩下500M，开了个Chrome，占了200M，我也不知道为啥，然后剩下300M，看情况发挥，那就是这个情况，所以你总会塞一点自己的需求进去。</p>
</div>
<div class="paragraph">
<p>那么从1.1到2.0你要是想知道HTTP你得首先得知道一个组织W3C，就是你要是聊这个话题的话，你首先得知道W3C，W3C是什么？是万维网的一个委员会，具体你可以到我维基百科上去查，这个委员会他负责HTTP规范的制定，意思就是说这帮老爷爷管着你天天用的浏览器里面那他跑着的东西，当然我们在说HTTP的时候肯定是包括HTML，因为他们是一体的他们不是分开的，超文本传输协议，你得有超文本，你才有传输，你超文本都没有，你传啥传呢？你传一个Hello Word过去那没用，所以W3C负责制定他的规范，那他制定过哪些规范呢？大概是从1991年，HTTP好像是0.9我忘了哈，到后面过出现过HTTP的1.0，HTTP的1.1，1.1是大家欢迎的，因为用的最多，当然在1.0时候你的电脑都买不起，你更不要说浏览器了，都还没有奔小康呢，现在有HTTP的2.0，当然有2.0就有3.0，然后有巧了哈，2.0和3.0个都和Google公司有关系，所以欢迎更多的中国企业参与，参与互联网的基础设施的这个开发工作和标准制定，但是看起来还是太少了，华为参加的都是一些通信基础设施的，比如说5G的标准，还有一些就是其他领域，但是还是比较少的，比如内核也是有的说的这个，估计这个国内就华为提的多，像小米这些企业内核里面提补丁你想的别想了。</p>
</div>
<div class="paragraph">
<p>所以那这个地方的话，谁是W3C，他是负责规范的制定，那么他制定过哪些规范就是这些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP/0.9(没人用)</p>
</li>
<li>
<p>HTTP/1.0（Nginx默认，一点点人用）</p>
</li>
<li>
<p>HTTP/1.1（最多人用）</p>
</li>
<li>
<p>HTTP/2.0（）一点点人用）</p>
</li>
<li>
<p>HTTP/3.0</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么3.0现在还处于一个孵化阶段，还是个胚胎，那么现在可用的就是上面这些，0.9是没人用的，然后1.0呢？Nginx反带的时候，默认Nginx用的是1.0，为了兼容一些老网站，所以1.0这个有一点点人用,1.1这个用的是最多的，2.0这个是有一点点人用，为什么？因为他太新了。</p>
</div>
<div class="paragraph">
<p>然后现在我们来讲一下为什么你应该从1.1升级到2.0，讲完这个问题过后你就倒过去，就是为什么要去升级，然后讲完为什么升级，我们再倒过去讲它里面的技术细节，倒着来，首先，我讲一下当前为什么有HTTP2.0?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1.1慢（表现在加载网页速度慢，具体指的是同域名下网页加载速度慢，就是浏览器有限制）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你是前端程序员的话，你肯定听说过浏览器的网页并发限制，就是一个浏览器，你可能同时只能一个域名下面打开十张图片，然后十张图片以外，你要想打开的话，你必须得前面那一堆加载完了，下面始终才加载对的排队，就出现了排第现象，特别是购物网站，电商网站的首页的图片是贼多，然后你会发现，他们的图片很大可能性都是放在几个子域名下面，这个慢表现在就是纯说现象的话就是加载图片慢，加载网页速度慢，那么加载网页速度慢，这个地方都加载网页具体指的是谁？这个地方具体指的是同域名下网页加载速度慢，这个速度慢是指的有浏览器限制，这个就是第一个慢，就是浏览器有限制，现在可能有人有人会问，浏览器他活的好好的，他为什么要去搞一个限制？我觉得大家应该追根到底，为什么他要限制？你可不可以开发一个不限制连接数的浏览器？我觉得要是能开发出来大家早开发了，但是就没人干，证明这个活不简单或者证明这个活不可能，他这个地方地方慢是因为操作系统，他这个地方慢是因为他需要一个东西，他需要多个TCP链接，而且他需要三次握手，TCP连接多个三次握手这个东西为什么会导致他的限制呢？那个是因为这个，下面具体来说的话就是操作系统。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

像以前XP的时候，那个时候Windows同时都不用说几千个了，估计几百个你都会崩掉，卡顿重启才能好，可能大家没有在遇到过这种特殊情况，但是浏览器厂商经常遇到，为什么？美国图书馆本来就穷，因为美国人生活在那个水深火热当中，他们现在用Win97、98、XP，你想想今年都是2021年了，那个电脑好好的他们不可能无缘无故去换操作系统，他不可能去换电脑，所以这个时候，如果他上面装了个Chrom，你可以想象一下Chrom一启动，然后电脑就瞬间蓝屏，这不是不可能的，只能重启，没有什么是重启解决不了的，实在不行，换个电脑。

以前我还遇到过Win 7连接多个，Win7也会死，没想到吧，但是你问我具体连了多少个，这个我不方便透露，我只能说我写程序写的有点猛，就是我的那个Win7是作为一个请求的客户端，但是运行着运行着他就崩了，然后Win Server 2003也遇到过这个问题，XP肯定是遇到过的，你只能重启才能解决。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个地方操作系统有连接管理问题，那么操作系统它有各种各样版本，所以做浏览器厂商，要去考虑这些问题，这是浏览器本身的限制，涉及到操作系统层面，那么还有一个，这两个其实是一个原因，都是由于操作系统导致的。</p>
</div>
<div class="paragraph">
<p>那么还有个原因就是你的网络线路运营商的问题，它也会限定连接数，中国电信它的连接数是有上限的，你可以试一下，同时建立500个tcp，你会发现你会变慢，那是因为你开那么多连接去连接运营商的交换机，再去连其他人，运营商也有开销，你把连接端口都占了，别人怎么用？运营商只能说把你限制，为什么？你这种毕竟是少数，大多数十个二十个顶天，但是如果每个浏览器都开1000个连接，中国电信早垮了，所以浏览器厂商，他一定会考虑这两个最大的原因。</p>
</div>
<div class="paragraph">
<p>我相信我是全网第一个告诉你运营商有限制的，大多数人都会告诉你说操作系统有限制，但是你得知道这种限制不仅仅是操作系统有，网络也有，当然你说在国外就没有这个问题，我相信大家的交换机都是一个样子，只是外国人比较少而已，你不能用户少来相比，你人少是你自己不生。</p>
</div>
<div class="paragraph">
<p>这是第一个慢，那么第二个慢，它还是“慢”，有意思了，刚刚慢为什么现在还慢？这里讲的慢是执行速度慢，不管是传输还是执行都慢，所以这个地方分了两块。</p>
</div>
<div class="paragraph">
<p>1.传输量相对大</p>
</div>
<div class="paragraph">
<p>那么第一块就是传输，这个传输量指的就是字节数，HTTP他有自己的规范，有自己的请求报文和响应报文，然后这个时候，他的报文里面的头是不能压缩的，而那个头，你每一次请求网站网站，他都把固定头还给你比如说Cooking，首当其冲的就是Cooking，你访问拉钩、Boos直聘这些网站的Cooking，基本都塞满了，那个地方有200字节以上都不过分，打开F12你去看一下，贼长了，所以这个数据量主要意味着头的开销，尤其是cookie。</p>
</div>
<div class="paragraph">
<p>那么还有一个是重复，重复传输在没有经过任何处理的时候，重复传输一定是有开销的，所以传输量大就意味着HTTP/1.1更耗带宽，那么这个慢就体现在传输量相对比较大，执行速度我觉得都不是最重要的，因为压缩过后，其实按常理来执行速度应该会慢一些啊。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_HTTP1.1VS2.0_chapter">15. HTTP 1.1 VS 2.0</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_14">15.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/HTTP%201.1%20VS%202.0（1）.jpg" alt="HTTP 1.1 VS 2.0（1）">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP%201.1%20VS%202.0（2）.jpg" alt="HTTP 1.1 VS 2.0（2）">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HTTP%201.1%20VS%202.0（3）.jpg" alt="HTTP 1.1 VS 2.0（3）">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http1_1第二个慢是慢在哪">15.2. HTTP1.1第二个慢是慢在哪？</h3>
<div class="paragraph">
<p>我刚刚说了就是昨天讲了就是慢在他的请求头是重复传输的，比如说昨天我举的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>比如说昨天我举的例子，就是cookie，cookie这个字段经常程序员把一些存储的东西，有用户的什么id、域名都会放到里面，那这里面就无限膨胀，可能100字节200字节，每一次的来回传，其实是很消耗带宽的，但是那个值呢？你是没办法解决的，但是那个名字是可以做的，什么意思哈，就是比如cookie，我这个地方指的是名字哈那个值你肯定是没有办法做处理的，你没有说你上次传了我就存一下，HTTP没有这种功能哈，但是那个HTTP头的名字是重复传的，你想象一下，你访问一个网页，然后你肯定有HOST的字段，content-type，user-agent，包括些其他的什么长度这些东西，那这样的话，你每一次访问一个连接，你要发头可能加起来50个字节，第二次加载同一个网站的图片，那个头又来一遍。懂吗？重复传输，所以这地方头在重复传输主要指的是名字，所以第二个慢是，他的头是重复传输的。</pre>
</div>
</div>
<div class="paragraph">
<p>所以HTTP1.1慢，主要是慢在这两个点上。</p>
</div>
<div class="paragraph">
<p>当然还有一个慢是慢在它的内容没有压缩，所以第三个就是HTTP头没压缩，刚刚有人说GZIP，GZIP压缩那是压body的，你想象一下，GZIP压缩要耗CPU，解压要耗CPU，请求头那个东西本来就常用的，每次用之前就要解压，你不嫌慢吗？所以这个地方，这个压缩肯定是一种高效的压缩算法，肯定是追求高效简单，什么意思？我打个比方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>一个Base64你一眼就知道Base64你要反向来的话，任何在线工具你都可以解，所以解码和编码很简单，而这个地方也要用需要类似的东西，如果你这个地方把用7Z压缩了，当然可以压，但是太复杂了，你在协议里面还要加一堆关于压缩的东西，那就不符合实际。</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个头确实没有压缩哈，因为头里面经常，我刚刚说cookie嘛， 这个地方我们稍微普及一下压缩它是怎么降低带宽的？我打个比方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>我们传了一个字符串，它是这样的，123abc12579，比如说我们传了个这个字符串，第二次，这个字符串在cookie里面再传一遍，他同样也是这么长，但是呢有没有办法让他变得更简单呢，就是为什么提压缩说这个事，其实你可以不提，但是有这个东西更好，压缩的时候是怎么压缩的，我们看一下这个里面有哪些东西是重复的，1出现了几次？2次，2呢？ 2次，你看，其实这个压缩比率很低，顶多少了几个字节，但是我得再来一个哈,比如说你经常那个创建网站用户的时候，你的手刚好放在左边，你现在会输入这个密码：111111111111，那这个字符串我压缩过后,我先统计他出现了这个类型的次数,1两次，2两次，3一次嘛，就以此类推，然后这个地方一出现了几次，一出现了12次，这是统计次数，统计完次数过后我要干啥，我要把它压缩，那这样的话，你就会写一个公式，你就会写个压缩公式，我们就简单的表示一下:

123abc12579  --&gt;1x2,2x2,3x1... --&gt;11字节
             --&gt;1x22x23abc579  --&gt;9字节+4=13
111111111111 --&gt;111111111111 --&gt;12字节
             --&gt;1x12 --&gt;3字节+3=6

你就写的是一出现两次，这个字符串后面紧跟紧跟1X22X23abc579,这个就是压缩过后的，压缩过后，他会把你的单词出现的频次和位置都记录下来,他在还原的时候，他就能倒着重新还原,你想吧，你看到这个公式，你可以倒着写把它写出来,是可以的我这个表达很简单，但是你知道的那这样的话，原来长度就这个这个乘号可以忽略，那这地方长度是多少？9个字节，那么他有9个字节,那这个地方很明显，他本来是12个字节，我这么写了，过后我写成压缩算法的公式，写完那个过后三字节,而上面这个地方，他本来原来是多少？他原来这地方12字节，再加上一些压缩算法的开销，这个乘号你也算上两个，再加上这个四9+4=13，然后这个地方123好像也是三个，但是它数字是两位，就1234那么抛掉这个一的话就有三个，所以这地方是3+3最终等于六，你看了没有，你的内容重复性越高，压缩怎么样？压缩算法就越厉害，虽然他非常非常复杂，所有的压缩算法，他都是用的这种一样的公式，只是他的这个公式的计算方式是不一样的，他计算完了，他的存储格式一模一样。就是他在他的文件前面一行，始终都是说我是什么压缩算法然后单词有多少长度多少？其实非常简单，你都可以写个压缩算法，只是有没有人用另外一回事，比如一百兆你压出来九十九兆，成功的也压了，只是没人用，只是这这种反向压缩特别明显，你压一个空文件，你压的空文件比你原来文件大多了，这就是为什么会有区别，这个地方就是作为一个就做了一个延伸哈，就是你知道就可以了，这个和HTTP协议没有关系哈。</pre>
</div>
</div>
<div class="paragraph">
<p>那这个地方头没压缩，速度慢，连接有限，都是讲的1.1，缺点找的够多了，TCP连接有限这个我们再重讲一遍，就是他影响的是网页的加载速度，因为连接有限，它最终导致的影响就是网页加载慢。</p>
</div>
<div class="paragraph">
<p>然后请求头重复，可能对你来说没有影响，因为你看不见，但是他是个耗带宽，当然我说的耗带宽肯定是相对而言更耗带宽是一种比较，那么既然耗带宽，我就问你个问题，如果是手机上用除了耗带宽以外还有什么缺点？耗电哈，请求头加载的速度慢，也是耗电呀，所以说白了HTTP1.1就是耗电，你看请求头这个地方没有压缩，耗带宽，那耗带宽肯定就是耗电，所以用HTTP1.1你的服务器其实没啥影响，服务器的电费不是你交的，但是他关系到那么多人，为什么?服务器耗电时有上限嘛，但是你手机一天比如苹果手机充两次电很正常吧，安卓手机一天充两次电就有就有点奇怪了哈。</p>
</div>
</div>
<div class="sect2">
<h3 id="_为什么有http2_0">15.3. 为什么有HTTP/2.0?</h3>
<div class="paragraph">
<p>最主要是移动互联网的发展，那么HTTP协议，他已经没有在这个场景下面就是更高效的一种通讯方式，我们需要更高效通讯方式跟省电的通讯方式，所以这个时候，HTTP2就应运而生，当然最开始google开发的时候，他其实不是为了解决耗电的问题，当时google开发主要是解决网页速度加载慢这个问题，谁知道网页速度加载慢为什么对google有影响？网页加载慢为什么会影响google的生意？不然google开发它干嘛呀？他绝对不会吃饱了撑的，因为影响广告加载了，你自己知道当年google和那个mozilla 的 firefox浏览器有合作，在他的浏览器里面是内置的google搜索框的，这样是为了让用户不打开网页就可以搜东西，到后面google觉得这个样子好像挣的钱还是不够多，如果那个搜索框满足google自己的战略的话，他为什么还要去搞chrome浏览器？真的就是因为那个笔记本os嘛？怕不是哦，他一定是感到浏览器这个方向如果不投钱的话，感觉自己控制不了，为什么？这些用户用的都是垃圾浏览器，我得从我的需要出发搞一个最先进的浏览器，让用户访问google更快，用上google的产品然后最终让google的营收变好，然后事实证明，自从苦有了chrome过后，你打开google再也不卡了，至少你现在卡是因为其他原因而不是浏览器，所以这个地方应该还有厂商的原因，前面讲了一堆缺点，我更觉得一定不是HTTP2诞生的最重要的初衷，一定是耽误挣钱。</p>
</div>
<div class="paragraph">
<p>你想吗？google的广告脚本一般是放在网页的最下头，结果前面都加载完了，google都还没加载完，然后用户都看完了，都关了都走了，google广告都没展示出来，你想吧，google的JS加载不了，那自然而然google的广告图片就不能被调用，然后这个时候用户都广告都没看他就关他就走了，你看到没有google解决这个问题的链路的很长，我大胆推测一下哈这是很影响他的其中一方面，至于google当年说要基于chrome这个浏览器造一个笔记本，我觉得那个是试探性的，我觉得那个不是chrome浏览器被google盯上然后去改造的一个根本原因，所以这个地方影响google挣钱，他通过两个方式解决的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个他提出了HTTP2但是他提出的不是叫这个名字，好像他提的叫spdy：//。</p>
</li>
<li>
<p>然后第二个，他觉得光改造了协议还是不行，所以这个时候，他要搞个更快的浏览器负责加载速度，你会发现chrome是为了加载HTTP2也是为了加载，他们最终都是为了让广告JS文件加载更快。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然他可能有其他的这些作用，因为是这样的，一个事物的诞生，肯定不是单一原因，一定是有需求，这种需求肯定有主要的需求， 就像那个社会矛盾有主要矛盾和次要矛盾，我们在社会主义初级阶段主要的社会那个矛盾是生产力不足，其他的民族矛盾，或者就是那种阶级矛盾的都是次要的，要先发展生产力，所以这个地方对于厂商来说挣钱才是最主要的矛盾，其他的都是靠边站的，包括这个地方可以延伸一下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>就是微软在今年的上半年，他们基于Open JDK自己打包然后自己发布出去，你这个是为什么吗？就是你用Java，你用Yum包，就装了一个Java的软件就能用，那微软为什么要自己搞一个？不是想塞东西，那是因为Open JDK都是靠良心发行版自己打包，然后这个打包过程当中及不及时、版本有没有？比如说经常用着用着版本就没有了，那微软也头痛他的用户要老版本你不给， 然后微软就干脆自己搞了个打包服务，我帮你打包，打包完了过你装的微软的那个JDK里面，你都还塞了微软的云服务的API，你还可以一键调用他云服务的东西，他肯定要塞自己东西，但是塞完了过后怎么用？那个是一系列的，他绝对不是个单一的目的，</pre>
</div>
</div>
<div class="paragraph">
<p>所以，这个地方讲了就是为什么有HTTP2,既然我讲的都是HTTP1那你反向操作就是2了，HTTP2怎么样？解决了慢的问题怎么解决的？</p>
</div>
</div>
<div class="sect2">
<h3 id="_http2_0是怎么解决以上问题的">15.4. HTTP/2.0是怎么解决以上问题的？</h3>
<div class="paragraph">
<p>所以那这个地方HTTP2.0是怎么去解决一下问题的？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个连接数的限制导致加载慢。</p>
</li>
<li>
<p>第二个请求头的重复传输。</p>
</li>
<li>
<p>第三个压缩。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一个HTTP2.0使用的是长连接，所以说为什么刚才我介绍的时候没有说短连接哈，他的那些问题，肯定是短连接导致的，所以这个地方用长连接代替了1.1的无状态连接（就是短连接），什么意思哈，我这个地方画个图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/网络通信图.png" alt="网络通信图">
</div>
</div>
<div class="paragraph">
<p>这幅图表示网络通信的发生过程，如果我们要用1.1的话，这个地方肯定是指的为V1.1,1.1他加载一个网站的时候，你从连接过程能看到什么东西？你会看到这种东西，首先你会有看到他发起了三个连接，然后他连接不是持续时间嘛，所以我现在用这个连接的这个长度来表示他用了多长时间，箭头肯定是表示发生了这个事，所以我现在就画一个，然后你会看到这种图，首先他建立了第一个连接，第个连接比如说我们这个地方叫标尺嘛，就以这个为标准，这个的长度表示一秒钟哈，表示单位时间哈，那么就这画个标尺哈，这个表示一秒可不可以，那是第一个连接，我假设这个网页应该有5、6个连接，他就你会看到这种，我们定义一下，首先这个原点表示起点，然后这个结束箭头表示终点，然后这个地方我刚才讲的这个长度表示t，你表示他用了多长时间，那这个这个x轴和y轴，这个y轴肯定是自然时间，所以那这个地方这个它是一个轴哈，你可以理解为这就是北京时间，然后这个x轴表示的是什么？连接的次数，随着这边是TCP哈。</p>
</div>
<div class="paragraph">
<p>然后我们来看一下这个图代表什么意思，首先在零秒的时候，发起了一个链接，它用了4.5秒，然后可能在第2秒的时候可能发起另外一个连接，这样你会发现他就是这样分布的，现在有个问题，在HTTP/1.1的时候，图上1.5秒的时候同时有两个连接，后面也同样有一个时间存在多个连接，图上举例画的是非常分散的，但是在真正访问网站的时候可不是这个样子的，真正访问网站的时候可能在同一刻有非常多的连接。</p>
</div>
<div class="paragraph">
<p>而操作系统就会限制这个连接数，说白了，操作系统没有针对浏览器这种行为做单独的优化，这个是HTTP/1.1的情况，那这个时候在同一刻连接数太多了，就变成只要前面的连接没有完，后面的连接就要等他们这几个完了过后空出来一个位置再继续，就像排队吃饭一样，饭店总共八张桌子，有一桌吃完了，他把位置腾出来了，然后又塞了一个人进去，但是每一个人的结束的时间你是不知道的，所以始终那个饭店里面就八座人。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fandian.jpg" alt="fandian">
</div>
</div>
<div class="paragraph">
<p>所以第一张图就像一个火车时刻表一样，有起止时间，而第二张图你可以简单的理解为火锅店排队，出来一桌进去一桌，为什么？因为它这个地方容量有限，桌子可不相当于连接数。</p>
</div>
<div class="paragraph">
<p>上面看起来操作系统连接数有限，那肯定是改不了的，你就算弄到HTTP/100.0也会有连接数限制，图像和刚刚举的HTTP/1.0的图的X、Y轴是一样的那么HTTP/2.0是怎么解决这个问题的？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>打个比方

我们访问的还是同一个网站，那么我们要测试1.1和2.0的区别，测试肯定是同等条件下测试才有意义，那么访问同一个网站肯定JS、CSS、图片包括视频数量都是一样的，然后假设这个网站可能有八个连接。</pre>
</div>
</div>
<div class="paragraph">
<p>那如果用HTTP/2.0，这八个TCP用图来画的话是怎么样的？大概是这个样子的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/2.0.jpg" alt="2.0">
</div>
</div>
<div class="paragraph">
<p>首先，他肯定也会有第一个连接，然后这个图好像就没法画了，为什么？因为HTTP/2.0就只有一条线，里面包含了很多东西，那么这八个TCP应该代表的是八个网页文件，这个地方实际上只有一个连接，那他是怎么连的？这里我们就理解为，这个图就代表的是整一个连接，然后在这一个连接上要做什么事，他同样也要做HTTP/1.1的事情，那先请求第一个链接，请求完了，再请求第二个，也可能请求第三个，甚至请求第四个，从图上看起来和之前分布是一样的，但HTTP/2.0的连接始终只有一个.</p>
</div>
<div class="paragraph">
<p>然后再用另外一种高速公路的方式来画这个图:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gaoshu.jpg" alt="gaoshu">
</div>
</div>
<div class="paragraph">
<p>比如说这个是HTTP/2.0的高速公路，连接数是一个TCP，如果和之前的图同样的方式来讲的话，就是那个路上有几根箭头，它就是几个连接啊，当然可能要想更形象的解释的话，要单独去想办法画得更漂亮，但意思是一样的。</p>
</div>
<div class="paragraph">
<p>如果把这个例子转成火锅店的话，就是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/huoguo.jpg" alt="huoguo">
</div>
</div>
<div class="paragraph">
<p>同样是吃火锅啊，这是一号桌，同样客人有6个，然后大家猜一下他们是怎么吃饭的？一哄而上这个形容，确实效果是这样，但怎么做？这就是就像那个张学友的一个电影里说的：“在座的各位都是垃圾。”意思就是一个一个打太累了，你们一起上，所以他们去吃饭的话就会是这个样子，因为这个桌子够大，现在用那个箭头的长度表示上的时间，就是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/huoguo2.jpg" alt="huoguo2">
</div>
</div>
<div class="paragraph">
<p>所以这里一拥而上是没有规则的，同时上或者按批来都是可以的，所以这个东西有个专业的名词叫TCP多路复用。</p>
</div>
<div class="paragraph">
<p>上面讲的还是只讲了一个连接状态，HTTP/2.0他是通过一个连接，来回穿梭，永不停歇，通过这个方式解决了，那HTTP/1.1不可以吗？它可以这么做，但是1.1这么做的代价是要在服务器上或者是在某些地方关键的地方去设置，程序员不设置的话，他永远是一次没了、两次没了、三次没了，所以那种设置不是每个人都会的，也不是每一个软件都支持，支持这个设置的软件，Web服务器的软件，就很麻烦，所以现在把这个东西集成到了协议里面，解决这个问题了，当然这个地方是个比较夸张表达。</p>
</div>
<div class="paragraph">
<p>一个TCP连接可以处理n个网页，那如果我贪心一点，我建立五个TCP，那就是5N，那速度就更快了，那1000个呢？所以在一个合理的区间里头，HTTP/2.0这种方式更高效，当然其实我这个地方没有讲长连接和短连接的区别，其实并不是说这个跑的路的问题而是你用HTTP这种短连接的时候，操作系统在建立TCP的三次握手是非常花时间，建立的过程花时间，你要等，要等什么？操作系统它一个有个池子，上一堆人建立的摆在那没用，然后操作系统要去管他，管就要画代价，然后又进来一个，他就要管两个，这样的话，管来管去就花了几毫秒，但是如果有几万个几毫秒，代价就很大了，所以问题就是：如果TCP没有三次握手，是不需要TCP多路复用的，所以本质上这个地方是为了更少的TCP三次握手。</p>
</div>
<div class="sect3">
<h4 id="_三次握手">15.4.1. 三次握手</h4>
<div class="paragraph">
<p>是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>如果有a和b两个人，他们握手的话是这样的：

A：“B！”
B：“诶！”
A：“我给你个糖！”
A——糖——&gt;B</pre>
</div>
</div>
<div class="paragraph">
<p>首先A叫B，然后B答应了，然后A就开始要给B传东西了，就是这样一个过程。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sanci.jpg" alt="sanci">
</div>
</div>
<div class="paragraph">
<p>所以这个地方首先A给B一个SYN，然后B收到了给A一个ACK，然后A再给B一个SYN+ACK，第一步是A叫B，然后第二步B说收到，第三部A就说我要传个糖给你，接下来，A就直接把糖传给B就可以了。</p>
</div>
<div class="paragraph">
<p>这个过程超级花时间，因为这地方已经来来回回三次了，</p>
</div>
<div class="paragraph">
<p>刚刚说HTTP/2.0一个TCP连接有N个网页，那么就是1N，那么再加上一个三次握手，那就是1N+1SYN，那么HTTP/1.1同样是8个连接，那么就是N+N*SYN，那么相比下来就少了很多次三次握手，这个才是HTTP/2.0的精髓，所以市面上讲HTTP/2.0的都没有讲到这个，因为他讲不明白，也没办法跟你讲明白。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_减少http头部的传输量">15.5. 减少HTTP头部的传输量</h3>
<div class="paragraph">
<p>先写个最最简单的报文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GET /index.html HTTP/1.1
Host: qq.com
User-Agent: Chrome/90.0</pre>
</div>
</div>
<div class="paragraph">
<p>这个是HTTP/1.1的请求报文，然后首先看头，头里面又分了头的名字和头的值，所以这个地方它是由：“名称：值=HTTP头”组成的，这个是HTTP/1.1，它在访问的网页上的每一个链接时，比如都是腾讯网页，同一个域名下面，它访问每一个链接的时候，这些东西都是硬开销，你想一下，哪怕是换了个网站，这个头也是在的，只是后面的值在变化，比如说，一个人用Chrome/89版本，另一个人用90版本，那么头部的值是要变的，域名也是会在随着你访问的网页在变，所以你会发现前面的名称都是硬性开销，他会重复的传无数遍，而HTTP/2.0的协议报文其实已经不是这个样子了，但是我为了更好的表达我的意思，还是写成和HTTP/1.1一样的格式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GET /index.heml HTTP/2.0
1: qq.com
2: Chrome/90.0
Datetime: 2021-10-10 12:00</pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2.0头名称对应表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1--&gt;HOST
2--&gt;User-Agent
3--&gt;........</pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2.0在浏览器的代码里头，都有头名称对应表，包括手机上的浏览器，这个时候你会发现他传输的时候变的是头名称那一部分，从以前的N个字节变成了现在顶多2字节，因为他头很多，假设有99个头，九十九个常用的，不常用的比如说你自定义的就直接传名字，因为你自定义的在浏览器内置里没有这个东西，所以他减少是内置的东西，上面的Datatime就是我们自己定义的，它就没有办法用数字来代替，为什么？因为你的浏览器内置没有这个，这个必须这个协议的制定方，比如google，比如说W3C，他们加到表里面的才有，没有的就是文字，这样就省掉了那种常用的头，然后服务器再按那个对照表挨个个还原，所以区别就在于常用，那么HTTP/2.0就是用数字代替名称来减少传输字结数。</p>
</div>
<div class="sect3">
<h4 id="_http头压缩">15.5.1. HTTP头压缩</h4>
<div class="paragraph">
<p>刚才已经够简单了，但是感觉头部还可以加点东西，那为什么不干掉第一行？因为第一行大多数情况下都在变，变化性太高了，你加压缩的意思就是说他重复的几率不可控，比如说111.html，关键是服务接收到后连你是啥请求都不知道，服务端还要先解，他都不知道你是HTTP协议，为什么？你这样都没有用HTTP的方法开头，所以他不知道你是谁。</p>
</div>
<div class="paragraph">
<p>那第一行是起的自报家门的作用，非常重要，所以第一行你不能压缩，你压缩了过后，别人就不知道你是什么协议了，为什么？就像刚刚说TPC三次握手，你都不握手了直接传东西，我咋知道你是谁？</p>
</div>
<div class="paragraph">
<p>那下面的头可不可以管呢，现在就有问题了：请求报文除了头以外，响应报文可能还有Body之类的，我们就先不讨论，现在我们先把焦点聚在头上面，我们可以数一下头的值里有多少个重复的字母，其实上面写的是最简答的，字节比较少，现实中这个地方很长这一段，你们可以去看一下自己浏览器上面这一段，超级超级长，甚至里面还包括了苹果的标识符，苹果那个叫Safari浏览器的标识符特别长，所以才针对这一块压缩，因为重复性越高压缩比例就越高，我们先不讨论算法的优越性。</p>
</div>
<div class="paragraph">
<p>我们先总结下特点，头里面有包含的有数字、字母还有一些常用的符号，所以常用的东西就是这些，如果按量来说的话，字母最多、数字第二、常用符号最少，所以要压就先压字母，就不要挑软柿子捏了，这个地方就要捏那个出头的，抢打出头鸟嘛，所以这个地方最符合又最简单的压缩算法叫哈弗曼算法。</p>
</div>
<div class="paragraph">
<p>哈夫曼算法是按字母的使用频率来压缩的，常出现的字母压缩比例越高，较少用的字母压缩比例比较低，这样的话传的字母越多压缩比例就越高，那么 `哈弗曼算法+字母再加上剩下的other`最后就等于个功能叫HPACK。</p>
</div>
<div class="paragraph">
<p>这个HPACK有点像包的意思，H肯定是HTTP里面的头的简写，Pack就是打包的意思，这样的话，用哈弗曼算法只要把字母一搞定剩下的数字啥的顺带解决一下，只是不要反向压缩就可以了，不要压了比没压还大，所以这个算法他主要是非常简单，它的论文长达1.5页，意思就是说算法很简单，只需要那么一点空间就解释明白了，那既然他压缩了，带宽就少了，那么带宽少了手机就不耗电了，然后你说：“解压还要耗电”，解压和那个重复性比起来简直就是九牛一毛，都可以忽略不计了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_延伸">15.6. 延伸</h3>
<div class="sect3">
<h4 id="_http的body是不是可以压缩">15.6.1. HTTP的Body是不是可以压缩？</h4>
<div class="paragraph">
<p>正经内容就讲完了，那现在有个问题就是：众所周知HTTP的repository都有他下面的body，那Body也可以压缩吗？怎么处理的？</p>
</div>
<div class="paragraph">
<p>Body在HTTP/2.0出现之前，已经有一个叫gzip的压缩算法了，比如说POST加上Body，那Body可以用gzip，Body的头已经被压了剩下就是这个了，如果是用2.0的话：就是Post+Body(gzip)+Header(Hpack)，这里就是两种压缩，更小了，但是1.1就是：Post+Body(gzip)+Header</p>
</div>
<div class="paragraph">
<p>你会发现不仅是连接状态的问题，还有个头的问题啊。</p>
</div>
<div class="paragraph">
<p>所以这个作为延伸内容，你理解一下可以了，gzip是非常通用的一个算法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_http3_0">15.6.2. HTTP/3.0</h4>
<div class="paragraph">
<p>我们刚刚有一个问题其实我很想讲，但是我憋住了，当时不是说计算那个TCP三次握手，那如果没有握手，就直接解决问题了，还搞那么复杂干嘛，所以3.0就直接抛弃了TCP协议，使用了UDP协议，然后他是不需要三次握手的。</p>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>你放学回家走在路上，突然你妈从后面，拿个苹果扔给你，扔完就走了，结果你成功被苹果砸了，说白了，你妈扔东西给你的时候她没有先给你打招呼，然后你一回头就砸了一个包。</p>
</div>
<div class="paragraph">
<p>所以说他不需要握手，意思就是说，你是客户端或者我是服务端，那么客户端向服务端丢东西的时候就不再握手了，服务器如果被核弹给炸了，客户端也不知道为什么打不开那个网站。</p>
</div>
<div class="paragraph">
<p>那么问题来了：服务器怎么去保证他接收数据是正常的？这时候google就说：“首先的浏览器是我写的，服务端丢东西不给我打招呼，那我自己验证一下嘛。”为什么？刚才不是发了个请求，那我给我每个请求编个号，收到的时候再校验一下里面的ID号码，说白了，以前是操作系统负责帮你传东西，现在是浏览器和服务器之间在操作系统上面加了一层软件，软件和软件之间沟通就和操作系统没关系了，操作系统变成个空壳了他就不再忙活了。</p>
</div>
<div class="paragraph">
<p>那么还有个问题：现在UDP这样，那我不就可以把UDP直接打给支付宝然后让他崩溃，我又不需要打招呼。</p>
</div>
<div class="paragraph">
<p>这就像你妈觉得你冷一样，衣服一层套一层，那这样的话UDP一直掏给你，最后就变成个巨人，如果是服务器的话你就瘫痪了，为什么？因为请求居多。</p>
</div>
<div class="paragraph">
<p>那我直接从我电脑上传一个G的数据到支付宝可不可以吗？可以啊，只要你家里带宽够大，然后支付宝就因为你一个人垮了，所以这种事不要干也不要去尝试。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/google.jpg" alt="google">
</div>
</div>
<div class="paragraph">
<p>由上图可知，google和厂商他们在客户端和服务器之间以及操作系统，上面再加了一层网络层，他们网络层是通过UDP传输的，而以前是TCP，当然UDP肯定是操作系统有了你才能用，但是他现在是把逻辑放到自己软件里面去做校验呢，所以他们现在是一体的，直接把三次握手干掉，速度肯定更快了。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYANMOJO_chapter">16. 智眼设计（采集模块）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_15">16.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/智眼设计-采集模块板书1.jpg" alt="智眼设计 采集模块板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/智眼设计-采集模块板书2.jpg" alt="智眼设计 采集模块板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_网络拓扑">16.2. 网络拓扑</h3>
<div class="paragraph">
<p>今天讲的设计是设计Agent相关的，主要是打通Agent的模块和最前端的配置产生交互的链度打通，所以贯穿了几块地方，今天讲的模块是指的采集模块，先把网络拓扑画一下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/wangluoyoupu.jpg" alt="wangluoyoupu">
</div>
</div>
<div class="paragraph">
<p>就还是之前我们讲的那样，最上面是一个User，那么User会访问前端的Web服务器，那么这个Web服务会依赖于后端的Server的服务端，这个Server就依赖于Agent，那么每一个Agent下头就有各种采集模块，那在采集模块这个地方，就有网络、CPU等等各种模块。</p>
</div>
<div class="paragraph">
<p>整个网络拓扑就这样了，这里就分了几层，User和Web就属于Web层，Server涉及到一些Java间件，那就是Spring Boot层，然后Agent就是纯操作系统层，最后采集模块这里就是Mojo层，Linux这一块肯定涉及的是一些客户端的行为，实际上我们会把它叫做客户端，但是在内部他和模块之间，他是服务端，但是和整个相比的话，他是客户端。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解决问题">16.3. 解决问题</h3>
<div class="paragraph">
<p>那我们今天要解决一个问题，就像我刚刚说的，网络不是要做过滤吗？然后你的Body参数是怎么到达这个采集模块的？</p>
</div>
<div class="paragraph">
<p>刚刚不是说如果我网络监控默认启用的话，他会监控所有的东西，但是实际上我们应该不会允许他在默认情况下工作，Network这个Monitor监控，默认情况下他应该是禁用的或者运行空转，一定要由用户产生具体的配置，他才会工作，他跟CPU模块不一样，他的内容太多了，我昨天在我的笔记本上试了一下那个RUST程序，在没有任何优化的情况下，默认是CPU占用0.0%，然后我把b站的视频打开，然后就多了很多UDP的包，一直往上报，报的过程当中我就看到CPU大概高峰期在5%，低谷应该在2%的样子，当然笔记本的CPU肯定没有服务器的强大，但是不排除对方买了一个阿里云的，他可能CPU频率很低，然后软件工作起来占了50%，那针对这个我们就要做一下优化，过滤掉一些不需要的东西，那么CPU的占用就可以降下去，所以做一下过滤是非常好的事情。</p>
</div>
<div class="paragraph">
<p>那这是我们先要解决的一个问题，CPU这种东西是不需要我们去控制的，为什么我会先写个Network，这是因为昨天我在想的时候，突然晃了一下，就是我的大脑去想了一下，实际上我应该有自己的方案，但是我把它拿出来，我们一起分析一下。</p>
</div>
<div class="sect3">
<h4 id="_补充为什么要着重程序设计">16.3.1. 补充：为什么要着重程序设计？</h4>
<div class="paragraph">
<p>因为写程序最重要的是设计，写代码你总会学会的，但是学设计这个事情，你就算是写十年代码，你也是那个水平啊，就额外讲一个，我今天是5:45下班的，为什么那么晚呢？平时5:25就开始摸鱼，就开始准备走了，就是因为我们的程序员，就是那个十年经验的，一共加起来行数应该有300行，然后他今天一共就动了20行，结果他找了六个BUG出来，他把我正确的代码删了，写了个错误的代码，然后单元测试一跑各种错误，然后他前脚就发现了第二个BUG。</p>
</div>
<div class="paragraph">
<p>所以我讲这个话的意思就是说，在我的高标准里面，这种行为不是一个优秀的工程师应该出现的，为什么？他并不是写不来语法，他的问题出在那个代码不是他原创的，他是懵的，他并不是说不负责任，为什么？他想负那个责任但他也搞不懂，当然你要说归大的责任心，确实没有责任心，为什么？你自己维护的代码，好歹应该全部去了解一下，我设计那个东西，设计加上代码实现还有Demo，我写完的那一刻，我花了整整三个周的工作日，就是除了晚上都在搞，然后这三个周里，我还有各种开会、各种其他事情，所以根本就没有花三个周，但是我跟他差就差了三个周，因为我一旦核心代码写完了过后，我就开始做异常检查，开始填充东西，大家知道我写代码的风格了：greating、Hello World！都是从那来的，然后那三个周里，我设计的过程当中他没有参与，所以他完全是懵的，他都不知道为什么这样设计，然后我给大家画了个图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jieshi.png" alt="jieshi">
</div>
</div>
<div class="paragraph">
<p>意思就是：我的数据是一种事件驱动的服务器，你要有数据进来，然后这样进来然后这么出去，他就懵了，程序里面哪儿的这个逻辑？我没看到了，他是看不出来的，你知道吗？他到现在都不理解这个图是什么意思，我的意思就是说：你数据从这个地方进来，你会经过各种路由，而且它是单线的前后依赖，最终又会从这个起点再出去。</p>
</div>
<div class="paragraph">
<p>其实写代码就是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>IF Something

...........

return....</pre>
</div>
</div>
<div class="paragraph">
<p>这样可简单了，就是这个样子，甚至连IF都没有，然后就一脸懵逼，为什么？因为中间调的东西刚好就是下一个类的，然后又开始调下一个类，就这么嵌套的，最后可能经过了20个类，代码就直接从Return出去了，这样别人一看就看不懂了，所有逻辑全是中间那一部分，他点进去后发现里面还有设计模式，就更头晕了。</p>
</div>
<div class="paragraph">
<p>所以要重设计，重编码，这两个都很重要，没有谁轻谁重的问题，设计的时候不要觉得无聊好吧，如果你觉得无聊的话，就有问题了，你现在都提不起兴趣，到时候写代码的时候更没有兴趣了，为什么更无聊？现在设计的时候好歹可以动一下脑子，但是写代码的时候就不是动脑，而是动手，天天Google。</p>
</div>
</div>
<div class="sect3">
<h4 id="_agent获取用户配置逻辑">16.3.2. Agent获取用户配置逻辑</h4>
<div class="paragraph">
<p>那么刚刚我们说网络它是需要参数的，我们以前说过的，我们在Mojo层，启动模块的时候，会有个配置文件XXX.ini，然后那个里面有这个程序的启动路径，但关键是你在路径那里你不可能写死一个8080，而且万一端口是多个参数，所以这个情况下这个程序启动起来的时候应该没有任何东西，应该是处于一种空白，那么它什么时候有东西呢？应该是动态插入，就像插件一样，什么意思啊，他启动完了过后，然后每隔一段时间去请求一下服务端，问服务端他接下来该干嘛？</p>
</div>
<div class="paragraph">
<p>那看来Net模块肯定不会起服务的端口，肯定是定时去请求Agent，CPU模块肯定是不请求，那请不请求谁说了算呢？肯定是掉我们的sdk去请求的呀，那这样的会变成了一共五个模块，其中一个网络监控模块会定时去请求Agent的服务端口，问他有没有东西给我那么这样的话，就只有一个模块有这种交互行为，其他是没有的，比如像内存监控就是没有的，但是进程是有可能的，进城那么多，不可能每一次都把所有的列出来，所以你可能会有默认需要哪些进程，然后把在把默认的进程情况打出来，你可能还要排除某些东西， 比如系统的内核进程。</p>
</div>
<div class="paragraph">
<p>因为进程太多了，你得有个限制或者筛选，如果你跑了个PHP这种东西，他起了800个进程，你每次检查的时候，不可能把800个都列出来，除非你真的需要那800个，所以这时候里可以选择所有还是过滤后的数据，你也可以排除，这才是合理的，因为你人工去管理服务器进程的时候，你也不是想看所有，你有几种情况，看CPU最高的、看内存最大、还有就是看Mysql进程，然后加个管道把它塞出来，这个时候你日常是这样用的，这个上头其实也是和你日常使用一样的逻辑，只是代替了人工，通过勾选去解决。</p>
</div>
<div class="paragraph">
<p>所以先口头总结一下：我们之前讲过的，在Server这边，一旦用户在这个网页上配置了东西过后，比如说配置某一个监控的一个行为，我们假设现在对所有主机有效，那他配完了过后点保存，那么会触发后端的行为，这个时候后端发现他在正在触发某些功能的时候，他应该从他的配置里面去做调他的回调，那么Agent看起来在启动的过程当中就应该保存，那天我们讲的是，这个东西要持久化嘛，因为你不持久化，下一次如果用户没有新的设置，Agent也没有了，如果不持久话的话就相当说他每次启动的时候去拉一下，这样也不是不行，那么采用HTTP/2.0长连接也是没有问题的，因为只要不三次握手，一般都很快的，那这样的话，HTTP/2.0就会带来一个问题，因为HTTP/2.0默认配HTTPS证书，那看来我们还要自己搭一个证书服务器，顺手把那个什么加密服务一起做了，所以说如果你要用HTTP/2.0的话，你就应该有证书签发，那么签发就有个问题，证书会过期，然后哪一天证书签发失败了，所以这就是为什么没有人去做这个系统，很多人宁愿自己写一个协议，那自己写个协议也有问题：维护性变差了，HTTP/2.0好歹知道过期了，毕竟还是通知到了。</p>
</div>
<div class="paragraph">
<p>所以我们之前讲的就是说这个地方有用户设置的时候，Server会发一个回调，他会把Agent注册的时候带来的回调请求一遍，那么Server请求一遍过后，那Agent就拿到了他想要的数据了，看起来数据应该是是放在某个地方的，我们现在就假设是放在硬盘上的，那他放到硬盘上过后谁来调？也就是说，用户在网页上点了之后，Agent的配置文件会动态更新，然后下面的模块就调配置文件，就相当于是说：你一旦触发这个东西后，他的配置就会Reload重载，我们上次讲到这个地方不想引入数据库，你要是引入个数据库，就太庞大了，你就算用SQLlite也是可以的，SQLlite是很好用的，因为这个地方其实写的情况很少，你在那写让对方等一下也不是不行，为什么？因为这个地方只存的有配置，所以SQLlite其实是可以的，硬盘也可以的，因为你存配置文件他也要上锁的，你每次写的时候，别人读是有问题的，说白了就是文件锁，因为在同一时刻又写又读，理论上是有问题的。</p>
</div>
<div class="paragraph">
<p>那么就相当于是说服务器就调了一个Agent的回调，然后是Agent拿到了想要的数据，并保存的硬盘上面，那看起来这个Network模块，应该去问Agent，因为Agent和模块之间问是有一个好处的，它们都是本地的，而且是通过HTTP通信的，所以通过HTTP通信的话，他以前他不是默认要上报吗？我还有一种逻辑就是一直向Agent拉，比如说每一分钟请求一下，一分钟看起来其实没关系，用户就多等一分钟，主要是为了频率降低，那这样的话，一个小时60分钟，那么一天1200次左右嘛，一天看起来不多然后，但是五个模块加下来肯定不一样，只是说现在只有Net模块会触发这个，其他是不用调，但是进程看起来是需要的，因为进程太多了，说白了，网络监控多不多？进程多不多多？甚至以后我们还有文件读写监控，那个也多，因为随时随地硬盘上都在读写，所以数据多的地方一定有主动请求去问配置，简单的就不用管他了。</p>
</div>
<div class="paragraph">
<p>所以那这个地方触发逻辑是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.用户更改(启用)模块配置

2.Server触发回调(Agent)

3.Agent收到配置数据并保存

4.Agent重启所有采集模块

   4.1采集模块启动时，HTTP Pull配置</pre>
</div>
</div>
<div class="paragraph">
<p>之前我们想的是Agent等待有需要的采集模块pull，现在改一下逻辑，配置完了之后所有模块的Reload，挨个重启嘛哎，这个办法比Pull好，因为Pull有个问题，他有定时开销，那这个地方就应该是Agent重启所有采集模块，那么这个时候就要有一个逻辑了，就4.1采集模块在启动的时候要Pull配置，这样也解决了刚才我们说的延迟的问题，第二个节约了资源。</p>
</div>
<div class="paragraph">
<p>最后我们来复盘一下逻辑，用户在这Web里启用禁用配置，那么Server收到请求过后，他判断是不是负责配置模块的接口，那个模块里面就有个代码，就是要调用Agent注册的回调，然后这个回调就触发了这个Agent的后续行为，就是：一旦他回调收到过后，他会重启下面所有的模块，而模块在重启时，他会加载自己配置文件，还会去从Agent拉，因为配置文件只是说自己在哪启动，启动的间隔是多久，但是没有解决输出结果处理的问题，一般是过滤啥的东西，这样的话，就整个逻辑就完成了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_接口安全">16.4. 接口安全</h3>
<div class="paragraph">
<p>这个地方我们刚刚讲了一个就是API校验的问题，所以我们这个接口安全，一定不是校验，校验的意思就是我对某个参数进行校验，长度进行校验，安全是指什么？整个系统，打个比方，这是整个系统，安全的意思就是说，全方位的安全，全方位的安全可不是指教验一个参数的问题，所有参数，所有网络通信绝对不能出错，传输层必须加密，所以上来HTTPS，所以我这个地方讲的安全，知道他们的区别，校验范围很小，安全范围更大，比如说人身安全，我可没有说是你跌倒了还是掉水里了，只要你人死调了都是安全问题，看到没有，但是视网膜校验，只是眼睛这个地方，检验你的眼睛坏没坏嘛，他不会管你口腔，不会管你缺胳膊少腿嘛，所以那这个地方，既然是安全的话，那么第一个那肯定就是传输层也保持安全，上HTTPS，这地方都是HTTP协议嘛。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTPS</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以这个地方那么安全手段，其中的就是你的接口传输一定要基于TTPS，就是不能被别人直接抓包给你抓跑了，这是传输层，那么传输层解决完了过后那我传东西安全了，那我的接口安不安全就是另外回事了，传输或者通信，通信安全，然后第二个那么就是属于业务层面的了。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>接口</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_身份认证">16.4.1. 身份认证</h4>
<div class="paragraph">
<p>你接口那么安全传过来了，你对这些参数有没有校验？身份有没有认证？所以这地方又分了两块，那么在接口这个地方分两个，第一个是身份认证，身份认证我们一般说像那种接口调用或者是云服调用的，你一般都有个Access key id和secret access key，key id那么用来标识你的身份，那么secret access用来做你的signature签名的加密，加面那个字符串，对方只要解不开那个字符串会怎么样？他就不能改参数，所以那这是一种方式通过signature。</p>
</div>
<div class="paragraph">
<p>还有一种方式就是我把我的token，我完全相信于他，我把我的那个secret 或是token在网络上传输？刚才我们讲的那个Access key id和secret access key的方式，他的那个secret在网络上是不传输的，只传输到他加密的一串密文，对方能够解开你就用，解不开你就活该，解不开你就不能改我参数，因为对方服务端会校验这个参数的，所以这个地方分数又分了两个，第一种就是：Access key id和secret access，通过这种方式他可以加密一段密文，然后还有一种方式就纯粹就是基于token字符串，这种方式就相对说我生成个字符串，你不要告诉别人，就是只要被别人抓到包你就玩犊子了，所以用token这种方式绝对要用HTTPS，但是上面这个是可以不用的，为什么？因为你靠signature，在业务层自己给自己做了一段校验，所以这两种方式都是可行的，所以一般这两种可能有先后顺序，严格意义上的系统，它会先有一个是叫getToken的接口，你把身份认证这段给他过后，生成一个token，token有一个有效期，有效期以内你都不用再做上面这个校验这一步了，所以他可以独立存在，他也可以相互依赖可以转换，为什么？因为第二种简单嘛，不用每次去计算那个签名，你可能会生成个token永远不过期，是不是可以，但是你不要让别人看见了，所以这种情况下就依赖于传输层的安全，当然有人偷窥你屏幕拍了个照那就没办法了，有的人把那个token写到配置文件里面，网易不是有个程序员，他把他那个生产服务器的他token，还有那个数据库密码传github上面去，然后把整个项目开源了，慌得不得了，连夜网易的人加班，把东西全改了，所以这是身份校验，就是who are you？说白了，他问客户端，你是谁，用token我肯定知道你是谁，为什么？token里面一般包含某种东西，你是可以把它解开的，那这是身份认证，我没讲参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_参数校验_3">16.4.2. 参数校验</h4>
<div class="paragraph">
<p>这个时候你第二件事情做参数教验。然后这个参数校验一般涉及到接口的那个参数的数量，参数的名称，参数的长度。格式，这个地方我就不去过度展开，把它简单写一下吧，然后这个值一般要涉及到值的长度，有长度是不是有格式？ 然后这个还只是V2。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接口的时效性校验">16.4.3. 接口的时效性校验</h4>
<div class="paragraph">
<p>还有第三个，接口的时效性校验，就是你接口这些参数，它应该有一定时效性的，比如说刚刚想的15秒20秒，所以一般像哔哩哔哩他们那个视频，你每次请求他那个媒体服务器的时候都要中间到带个时间戳就当前你的时间戳，或者你token生成的时间戳，他那时间戳用的计算你这个接口有效无效的，说白了用来迷惑你的，反正你不清楚，我多一层判断，对于你来说就多一层隔阂和阻碍，所以这个一般是为了防止有人拿到那个接口，他也不知道你的那串数据是干啥的，直接来复制重新执行就扣了你1万块钱，不行吧，以前我们那个程序员就中过招的，PHP程序员，我们的业务系统扣费充值接口，他没校验，别人也没有知道他密码，就把那个网址拿过来复制了一遍刚又没用HTTPS，刚好那个人就自己充值了很多钱。</p>
</div>
<div class="paragraph">
<p>所以你看到没有，这里面就设计到几种，看这个地方和谁有关系？这个地方的通信肯定是所有都用HTTPS，毫无疑问，所有的，当然我刚不是说有到一个问题嘛，你全部都用HTTPS意味着你要有一个域名证书，然后你就域名证书的分发，所以这个时候我们就假设这个东西是先要手动来，大不了以后再单独给他开发一个管理系统，多做一点总有好处的，所以做方案的时候，你要尽量的覆盖完整个逻辑，这个才叫企业级方案，就是说白了你去做，按作业的方式来做，你顶多就把那个demo写完了，然后别人老板拿着也不能用，下一次你心想拷过去发现拷了白拷，为什么？都有，没有价值。</p>
</div>
<div class="paragraph">
<p>所以设计到接口这块的话，这个用户这端有这个接口校验，那server这一端也有，就相当于是说这一段端，agent这一端有，然后整个校验在server这一块，那现在我们套这个逻辑套进来看一下，对于我们来说，因为我们这个系统它不是一个sdk，也不是个云服务，它就是我们自己的业务系统，所以那个这个token的话，就在系统里面直接生成，就不用经过这前面两个东西了，所以我选择他，因为他简单，他不用每次去校验，还有一个问题，对于我们系统来说，你关心就是你关不关心，比如agent这个地方有人来访问，你关不关心他的token身份是谁呀？你并不关心是哪个agent访问的，你只关心说，首先他这个ip地址是白名单是能进来访问的，然后他给了有效token，信任他就完了，为什么？你不可能进我办公室里扫个绿码吧，你不会吧，进大门的扫完了我就相信你了，进来你还扫个密码也不是不行，但是你不觉得形势大于意义吗？为什么？同呼一片空气，你少了个寂寞，所以那这个地方的话就看起来我们整个通信呢就是基于token，那如果我要写个例子的话，就可能是这个样子的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost/index.html

auth：1234567</pre>
</div>
</div>
<div class="paragraph">
<p>有可能是这样的，然后这个是一个get嘛，那么我要带个头，比如说我就加一个请求报文的头嘛他头叫auth什么什么冒号，这个后面是不跟那个token，token比如说是123456，那这样的话我的服务端我把这个头取出来我就知道有没有效了，那么有效了过后，剩下的事情就是说把这个参数取出来，比如说他带了个问号，比如说带了个问号比如说user=abc可不可以，那这样的话你就得信任他，把参数取出来就做后面的事情了，我先讲粗的，等一会我们再讲细的，然后你们到时候去整理笔记的时候，你要把这个例子自己去过做扩展。</p>
</div>
<div class="paragraph">
<p>那这个看起来在这个这一块是管用的，其实是有问题的，等会再讲 问题在哪好了，那这块可以用这种方式，那这一块也可以，你请求的时候带上你的token，看起来web-server ok了，那么server-agent ok了，现在我们要让我们要什么，我们要让user这一层ok，这Net一层ok，总的来说那看起来在这个地方只要是token就可以了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_校验过程">16.4.4. 校验过程</h4>
<div class="paragraph">
<p>那我可以假设，整个校验过程是这样的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先在agent安装的时候，那么在他安装的时候会做一个配置，在这个agent.config文件里头增加一个叫token=的参数，他这边不是生成一个token吗？你手动把这个token复制到这儿来，所以这个地方是给token=，那这样的话他们之间你如果真的想就是让他不一样的话，你生成无数个token就可以了，但是没有必要都是agent，所以你单独给agent生成一个token就可以了，为什么？如果别人都把你网络监听了，那我也没辙，所以那这个地方就填一个服务端的token，那他去请求服务端的时候带上这个token服务端相信他了，所以这个token不能发给其他人，那这样的话就相当于他请求的是带上那个token，再带上一些就他必要东西就能上传报数据了，第一步应该是server这儿生成token，生成token过后，那得到个值。</p>
</li>
<li>
<p>那么第二步你应该把token填到agent.config给里面。</p>
</li>
<li>
<p>第三步那你应该这个地方带token调上去往上推嘛。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_回调">16.4.5. 回调</h4>
<div class="paragraph">
<p>这个解决了，然后这边看起来ok了，因为这个地方肯定和token没有关系，因为他是和服务端嘛，他只要不和服务端直接发生关系的是可以的，现在问题来了，他向上报数据的时候是可以，他调回调的时候呢？调回调他咋知道谁可以调我的回调，肯定是也要个token，所以应该有一个server的token，还有个client的token，这边就应该还有一个什么agent的token，我叫a token，那么生成这个东西过后，那么比如这个是第一步a部，那么这个a步那在服务端这边他去他去注册的时候，去注册，因为他启动的时候嘛，他向服务器注册嘛，当然这种注册应该是第一次，第二次，他不需要再发生注册关系了，你怎么判断第一次注册，第二注册？他注册他的吗？他注册和agent没关系，和server有关系，server上面你是比如上次点了个ok注册成功了，第二次他自己发起注册，没有关系，你返回跟200ok收到就可以了，至于后面的事情，他不关心，为什么？因为注册是让他告诉他我是客户端，请你相信我，然后并且把我的信息和回调留下来，所以这种注册动作，按理来说他是应该是每次启动都发起，至于对方反什么，他不关心，我知道你200ok就可以了，至于你绑不绑定还是怎么绑是你服务端的事情，所以你应该有个列表注册客户端，那个xxljob也有这个东西嘛，那个里面有一个叫机器注册，你点一下绑定完了他才能后面发东西，没有注册光有这个接口token，你是发不了东西，为什么你通过了身份校验，但是通不过业务检查，为什么？你没有完成注册，为什么要注册呢？就是为了处理那个回调，就算你把我token破解了，只要我手动没有点那个绑定注册按钮同意注册，你同样不能发数据上来，是不是更安全了吗？所以这个地方还有个agent，所以你会发现其实这样做下来就已经很安全了，每个环节都是可控的，那这个地方向上面发起注册，然后注册的时候一定要填一个他的回调地址，然后他回了地址的那个问号后面有个token等于多少，所以这个时候那么他产生回调的时候callback，他产生回调的时候是不是要填这种https：//xxx：8080，然后后面可能要跟有什么问号的url这类，我就不管了，比如说什么什么动作跟参数他也要带个头，这个地方填的是a token，所以那这样的话这个倒着来的时候callback，他也要请求个网址，他这里要把token带过来，做双向验证，我请求你有token，你请求我也有token，这个地方有意思的事情了，这token谁先谁后，第一时间那应该是服务端生成个token，你手动把它填到客户端里面去，然后客户端因为已经拿了这个token了，他去注册的时候因为已经通过了校验就把自己token带上去，他用的是拿回来你会发现就是变成了我刚刚说这种，你看这个逻辑你没有两次完成吗？你一步就完成了，这过程当中，你点一下鼠标，点同意绑定，同意注册，对于你来说代价很小的，你不用再把这个token填的服务端去吧，那么傻吗，你竟然相信他了，你应该把他这些东西记录下来。</p>
</div>
<div class="paragraph">
<p>他要先完成注册才有callback，你先填token填好然后配置文件填好了过后启动它嘛，启动他的时候，他向服务器发起注册申请吧，注册申请里面带了个tokne的文字参数嘛，比如说你就带个问号带上去噻，说白了你请求的是服务单的地址，在后面问号跟一个token不行吗？这个地方是我请求服务端他给我的token复制的那个，我就把我自己的给你，让你记下来，是不是可以这两个不一样嘛，所以才那这样的话，服务端就有你的回调了，你的回去就是这个网址嘛这个网址带一个token嘛，你如果觉得嫌麻烦，你直接可以用get把token添了这个地方就不用这种头的形式嘛， 也是可以的，那这相当于是说服务端你要先把token复制过来，然后再启动它，启动他的时候，他会向上请求注册，请求注册的时候，参数里面有个东西，就是他的a token，那这样的话，他产生回调的时候，他自己拼参数 url 8080的url加上token，加上那个要做的动作的参数值，这些东西往下报，agent这个时候是服务器的，server是客户端的嘛。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_apisys_chapter">17. API System</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_16">17.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/API系统板书.jpg" alt="API系统板书">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_api系统">17.2. What is API系统？</h3>
<div class="paragraph">
<p>API系统，那么这个地方API系统肯定指的是协议对的？我们通常说的API前面都省掉了HTTP，或者可以说基于HTTP的API系统，为什么我们省掉HTTP？你想一下，我都用TCP了，还用问号传参数，屁股后面跟一节就完事了。</p>
</div>
<div class="paragraph">
<p>所以API系统通常都基于HTTP的，那首先我们要知道API是什么？API的英文是(Application Interface)就是应用程序接口的意思，那既然前面省掉了HTTP，那就是HTTP应用程序接口。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_系统system">17.3. What is 系统(System)?</h3>
<div class="paragraph">
<p>系统是啥？</p>
</div>
<div class="paragraph">
<p>日常看到过或听到过的比如：操作系统、数据库系统、ERP系统、OA系统，但是你从没有听说过什么微信系统、支付宝系统，因为你不会叫支付宝系统，可以叫支付系统，那支付系统指的就不是你手机上那个App，而是指的支付宝服务器上那堆东西。</p>
</div>
<div class="paragraph">
<p>所以这个地方指的系统，先拆开看，统字可以理解为统一的意思，但系统这个词很怪，要组词的话不好组，统一，一统、系统、统系都不对，所以它重点在系字，统字单独放到这个地方也不知道啥意思，为什么？因为他翻译出来的，在古代我们可没有这玩意，所以我们换成System来讲，Windows、Linux、UniX它们都是一个System，然后还有一些单片机要用的，非常非常嵌入式的系统，比如就像有些智能设备里的系统。</p>
</div>
<div class="sect3">
<h4 id="_软件">17.3.1. 软件</h4>
<div class="paragraph">
<p>结合上面说的，你会发现这个东西看起来是某一类东西的统称，我们先定义它，首先我们知道它是一类软件的一个称呼，当然OA系统这种很牵强，但是为什么大家通常那么叫？是因为它里面有很多逻辑，那么他一定是复杂的，像Windows、Linux、Unix他们可能偏底层，包括数据库系统也是，但是说到OA、ERP系统，全世界都是、看起来系统有应用层的东西，也有服务器上用的，跨度很大。</p>
</div>
</div>
<div class="sect3">
<h4 id="_复杂">17.3.2. 复杂</h4>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>复杂的东西也不一定非常庞大吗？不一定，为什么？你可能走过了五道保险的还是那种带旋转的保险门，结果就取了100块钱， 所以它不一定复杂就臃肿或者说不一定复杂就臃肿，为什么？有可能写2000万行代码里面都是IF，Else也不是不可以，德国有个政府开发了20多年的软件系统，现在代码好像去年还是前年突破了2000多万行，结果程序员由于受不了频繁离职，那个项目就一直烂尾，那这个系统复杂吗？我觉得不是，我觉得他们可能在坑钱，2000万行Windows都写的差不多了，就是你开发了史诗级的，要代替NASA上火星都没这个复杂。</p>
</div>
</div>
<div class="sect3">
<h4 id="_体量较大">17.3.3. 体量较大</h4>
<div class="paragraph">
<p>体量较大，什么意思？</p>
</div>
<div class="paragraph">
<p>比如说我随手就用Python写个爬虫，它不会叫爬虫系统，但是之后花了一年把这个东西完善了，这个就叫爬虫系统，然后再比如说我们写监控系统，你写两天，你根本不配叫监控系统，但是你在持续不断的完善，覆盖了你想做的领域，完善了功能，又能满足用户的需求，这个时候就可以叫监控系统，但是你只是装一个监控的软件，然后画个图啥的，那就不叫监控系统，为什么？因为你没有解决真正意义上的问题，你的覆盖面是非常非常有限的，而且它不复杂它非常简单，就是一个页面，比如说你有个Blog，不可能就叫博客系统，开发这个的人叫博客系统，但是对于你来说，它就是一个博客页面，博客不是你开发的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_功能完善">17.3.4. 功能完善</h4>
<div class="paragraph">
<p>比如说你说在UNIX或者Windows下头，基本上你所有的事情都可以做，Linux也是可以的，并不是说我只能挂QQ啊，你要是开发个只能挂QQ的系统，叫QQ系统好像也不对，那只能叫QQ。</p>
</div>
<div class="paragraph">
<p>你当然那种飞机上的那种实时调度系统，那可不简单，它包含了自动导航、自动驾驶、自动检测障碍物，还有各种控制，飞机上是有各种各样的子系统组成的大系统，他的系统和系统之间是隔离的，但是这个时候，你不会叫他软件，你说飞控软件？飞控软件指的是你的User Interface，就是你看到的那块，但是对整个飞机来说，你是有飞控的，是叫飞控系统而不叫飞空软件，但用大疆上面那个东西，那叫飞控软件，遥杆摇两下能有多复杂？确实也挺复杂的，但是和飞机那个相比，一架飞机200亿人民币起步，干线飞机可能十、二十亿，主个主线飞机那就不一样了，所以你看这个时候啊，它们体量不一样，同样是飞控，你解决的是无人机的飞控还是解决真正飞机的飞控的不一样的，为什么？真正的飞机出事的时候，你还要保证他的稳定性，但大疆那个撞山就撞山，都没有让Pull Up拉起来。</p>
</div>
<div class="paragraph">
<p>工业标准就是工业期的，产品级是指的互联网，这里面我们可能叫产品级，但是对这种实操、真正实物的东西，我们叫工业级，工业级就意味着零下40度，飞机不解体，系统不死机，好像大疆做不到，所以他是民用级的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_总结_2">17.3.5. 总结</h4>
<div class="paragraph">
<p>上面4个特点连起来就相当是说系统是：</p>
</div>
<div class="paragraph">
<p><code>一种体量较大、功能完善的复杂软件，并且能满足用户在某个场景的需求。</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_apiapplication_interface">17.4. What is API(Application Interface)？</h3>
<div class="paragraph">
<p>最开始我们只是简单理解了API是啥，说白了，就是没有说人话，其实API的意思就是传递数据的一种方式，什么意思？不用API我用TCP也可以传数据，不说普通话说英文也可以实现交流啊，所以问题在哪于怎么让对方能够听懂，就比如你们两个在开始之前约定好，就像小时候玩的一根线两边接着一个纸杯子，然后你在说话，对方听不听得懂，这得看情况，实在说不懂，拿电筒闪两下当暗号也是可以，提请约定好暗号的内容，比如说闪三下是妈妈回来了，两下是爸爸回来了。</p>
</div>
<div class="paragraph">
<p>那么具体到计算机这个领域的话，但凡涉及到这种带Interface的，都是传递数据的，比如说鼠标不是用的USB吗，USB一插上去，就相当于把你的手的动作传递给电脑了，那个摄像机通过USB插到你电脑上，电脑上也可以收到视频，他也是在传递数据。</p>
</div>
<div class="paragraph">
<p>那么Interface在计算机领域是用来传递数据的，我刚刚举例说的是硬件的Interface，那Application肯定是指的软件，但凡知道计算机的都是知道数据，种子是数据，磁力链接是数据，图片也是数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="_什么是api系统">17.5. 什么是API系统</h3>
<div class="paragraph">
<p>把上面讲的结合起来就是：用于传递数据的、复杂的、体量较大的、完善的软件功能或者软件规范，当然我不要求你把两个东西强行合在一起，这玩意儿强行合在一起是别扭的，你把它分开看，你两个都懂得就好了，这个不涉及的那种质变啊，1+1就等于二，单独理解都没问题，合在起也是能理解的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_3">17.6. 使用场景</h3>
<div class="paragraph">
<p>刚刚有个地方很重要，就是传递数据的 `一种`方式。</p>
</div>
<div class="paragraph">
<p>一种，那就意味着有很多种，那就要问个问题了，第一台计算机被发明出来他需要传数据吗？那第二台呢？说白了，最开始美国人造航母可能干了，闲的没事干，发明个计算机也不是不可以。</p>
</div>
<div class="paragraph">
<p>这样的话就相当于是说一台计算机你是不需要传递数据的，两台计算机，你也不需要，为什么？最开始连硬盘是啥都不知道？计算机是用的计算数字的，在计算机被发明之前中国或者国外都有各种机械装置或者那种木的结构旋转，然后就算出到什么数，就是天文学的那种，转来转去，然后知道约什么时候日食，是可以算出来的，那个时候是基于特定的公式创造了这种设备，这种东西叫专有装置，比如说我专门发明一个门铃，那个玩意只能当门铃。</p>
</div>
<div class="paragraph">
<p>所以在最开始啊计算机被发明出来一定是为了代替已有的那一部分东西，后面才变成通用计算机，因为它最开始一定是非常非常贵的，一定是国家才买得起的，然后是政府买得起，后面是有钱人买得起，最后到普罗大众都买得起了，95年过后，电脑就飞进的千千万户的家里面，然后比尔盖茨找到IBM，跟IBM说以后是个人电脑的天下，IBM给了他个白眼，你在说屁呢？</p>
</div>
<div class="paragraph">
<p>所以就说到这个地方，那使用场景的话，既然数量非常少的情况下是不需要传递数据的,而且HTTP0.9大概是在91年HTTP才被发明出来，那么91年就是那个时候，HTTP的才被发明出来，就证明那个之前是没浏览器的，他应该是同时诞生的，不然你那期展示啥呢？Hello World吗？美国人当时发年发明互联网，但是他们当时发明的东西叫局域网，从那个时候开始的才有真正意义上的传输，可能在那个之前，他能够单点对单点就说白了美国人在那个时刻估计发明了一种交换机，交换协议就现在来IP层，就现在TCP这些东西嘛IP层嘛，负责局网的交换嘛，那个时候应该被发明出来，在那个之前，计算机和计算机机之间一定能够靠网卡对连，绝对是没问题的，但是当时对连变成那样的我们三个人你连了我，我在连他，但是你们俩相互不知道对方的存在，那一台机器顶多就插几根网线嘛，你解决不了互通的问题，然后你这个时候就变成了你要满足这种情况，我就要做一种转发，最开始一定是这样的，我的网线越来越多我就想我能不能把数据导给他，慢慢的才应该有这个交换协议的存在呀，他是一个递进的过程，比如说有人不是开玩笑嘛，把3090显卡拿到十年前给那些看，你说能抄出来吗？抄不出来，为什么？他连个打底的模型都没有，他怎么抄？你告诉我，你好歹给他个基础版？让他在比如说97年67年那个时候开始慢慢往上堆那是可以的，但是你给个3090给他对不起抄都没法抄，为什么？因为是有Bug，你慢慢补补着补着那个系统越来越完善，你说这个地方有个idea，慢慢慢的就插上面垒了，一下子他就抄过去？逆向都难，因为他是个整个工业的结晶集成电路嘛。</p>
</div>
<div class="paragraph">
<p>所以这个地方使用场景那讲的这个地方就说，那传输数据的需求从六几年，那美国人而发明的互联网，从那一刻开始，才是真正意义上的传输，可能在那之前有软盘，软盘那个东西只能说叫一种传输介质，它不是一种传输方式，空气是一种声音传播的介质，水也是，它是一种介质，但是你没有听说传输空气，传输声音吧，没有谁这么讲吧，传输的意思就持续不断，源源不断，所以这个使用场景是说第一个一定是交换数据。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>交换数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后既然是交换数据，那你证明是什么？至少两方，而且一般涉及的多方，所以这个是我们去假设，那么最小单位是2。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计算机数量最少为2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个地方的计算机要打引号哈，因为你在你一个电脑上面写起两个端口传数据也是，我们理解的是这个计算机是一种角色，你可以理解为虚拟电脑，计算机一般是非常专业的称呼嘛，我们一般叫。你读的什么系？计科系计算机科学与技术然后这个时候我们没有叫电脑系，是因为计算机是一种非常专业的名词，而电脑是一种俗称，所以我这个地方没有写电脑，computer嘛，所以翻译就看人对方是一个普通人，就叫电脑，但如果对方是个程序员就说计算机，计算机爱好者嘛，有那本杂志嘛，那这个地方至少为2。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>持续传输</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么第一个是交换数据，然后这个数量限定了，应该还有一个，我比如说我拿那个激光闪一下是不传数据是，但是这个玩意是一直不放手，一直传光纤，源源不断，持续传输，这个地方讲的持续传输，不是说的每一秒钟都必须有什么，他是说一种可能性，他可以一直说，他也可以间歇性传，那这地方使用场景是交换数据，计算机数量至少为2然后可以持续传输。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>必须简单</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我就问你个问题，如果你要用这个API来传数据你要倒腾两天你愿意用吗？在这个出现之前，传数据是非常麻烦的一件事情，就是自己撸一套应用程协议，不管那个协议是简单还是复杂，比如说：我们那个HTTP不是起始行嘛，有的人就那行里头规定前五个字节表示什么意思？表示方向向右，后五个字节表示方向上下，我就可以用两个字节表示一套协议哦，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/01表示图.png" alt="01表示图">
</div>
</div>
<div class="paragraph">
<p>什么意思？比如说这个东西是用的那个红绿灯，那个不是有些有箭头嘛，我也这么假设，当这个地方为1的时候那么你表示箭头朝左，当这个地方值为0的时候表示直朝右，然后当这个地方也是一样为1的时候表示上，当这地方为0表示下，所以这个地方翻译一下就是朝右下，是不是一套协议吗？和数学像不像？等式替换嘛，只是说你这个数字是给计算机看的，你要给人看的要翻译一遍嘛，但是你的数据又是在那个网线上流淌的找的，所以这个时候你要让计算机先懂，他懂了你翻译给人那个才能听懂，你不能在网线上传人类的语言那叫语音，所以说数据它的表现形式是不一样的，所以那这个时候，这个就最简单的协议吗？我甚至还可以用一个直接表示上下，就简单一半嘛,那这样的话就相对说你每次传动性是这样的：1字节、1字节、1字节、1字节、1字节，然后这个时候对方说的是这样的，01001000来翻译一下，你知道怎么翻译的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/八位.png" alt="八位">
</div>
</div>
<div class="paragraph">
<p>我现在做一个延伸，当我觉得一个字节太浪费的时候我我告诉你那个交通信号灯一共有八个。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/红绿灯.png" alt="红绿灯">
</div>
</div>
<div class="paragraph">
<p>我现在要要求你用一个字节的表示，然后一个自己刚好等于八个二进制位，所以当这个灯亮的时候是1,我打个比方，然后其他都灭，然后这个时候，你得出了数字是1，是不在刷二进制了嘛，我能够用1个数字，就是从0-9我能用一个数字表示八个交通信号灯更省流量了，那是不是通信协议吗？是不是也在传数据吗？我们都不说那么高大上的，就拿交通信号灯这种来举例子，说到这个地方必须简单，不是可选的，是必须简单的，这就像我们在做监控系统这个智眼的时候，我们在考虑个问题，我们传数据其实也可以照一套我们自己的数据传输的协议，对的省流量，而且安全可控，而安不安全定说，至少可控你自己发明的，你自己知道怎么弄，但是有个问题，另外那个人过来学的时候你又没有文档，你又没有视频教程，所以就很尴尬了，所以那么这个就必须简单好用这个是必要条件，这是必须的，前面这个持续传输我刚刚讲了嘛，你可以传两下都是可以的，然后至于这个数据，那个数字为2你要传输嘛总得两个点嘛， 两个点构成一条直线你才能传上，然后这个地方交换数据，你都不传数据你搞这后面干啥呢？那么使用场景就限定住了，然后这个时候我们讲的是HTTP，他是用这种协议来传输，而这种协议叫超文本传输协议，Wiki上写的是它是一种最简单的应用程协议，然后像你没感觉到还很简单，但是书上都是写的很简单，你们的老师也会告诉你，这是世界上最简单的一个协议了，证明其他协议很复杂。</p>
</div>
<div class="paragraph">
<p>使用场景就就知道了我们我们在延伸下面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>格式化或结构化的参数列表</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那既然是HTTP相关的这个API系统，那么他的场景看起就是为了传输数据，那传输数据的过程当中，接下来这个地方该填啥，使用场景吗？你想HTTP那个Url你是怎么写的？格式化或者结构化的参数列表，问号后面嘛，或者放到body里面他也是格式化的呀，我们认为的HTTP它就是格式化的结构化的参数列表，意思是拿了就用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP + TLS（openssl）= HTTPS</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>具体到HTTP的话，那我们要给这个API系统加密，是不是很简单？直接HTTPS就可以了，就相当是HTTP加上TLS会话层，这个是什么玩意儿？就是你们常见的这个，类似于它openssl，你们每个人电脑上都装到这个库的，他就提供这个算法，那么最终等于HTTPS，所以标准嘛，标准的好处就是加密方便，证书你可以自己生成，你也可以让别人那个花钱给你生成只是说浏览器展示绿色的锁还是红色的叉叉而已，但是已经达到了传输数据的目的，只是对方信不信任你这个证书而已，那么格式化参数，那么就这个加密方便，有加密的你看到没有，基本上这几个一组合在一起。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>灵活</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我问你个问题吗？传参数是你可以放到Url里头，你也可以放个body里头也可以放到头里面，灵活，这就是灵活，我没有强行总结，你用就是这么用的呀，你要说数据库的一致性、原子性的才叫强行总结，你用数据库，你感觉到原子性？你怕没感觉到，但是你吃面包你感觉到香，你喝水你感觉到解渴，所以说如果要成为强行总结，就说别人用完了，没有直观感受到好处，那就是强行总结，比如说我为什么用Mysql，方便啊，然后别人跳出来，你咋不讲原子性一致性呢？没感觉到啊，就是一个命令就装完了嘛，他他刚好能用嘛，我又不是那种专家，用到全世界就我那1%，只有那种人他才会强调这个，你Mysql存过数据，你装个Psql我就不能存数据了？你装个Redis的时也可以存，Redis存，有一天重启了，没数据了，哎，好像有数据，因为Mysql的每五秒钟会down到硬盘上，好歹五秒钟以内不丢，你看到没有，其实很多时候也满足，只是你要求越来越高哈，那你五秒钟以内的都不能掉，这个时候你才会去强调这些东西哈，所以直观的我们这个地方使用场景强调的是直观的，因为用过HTTP，当我没讲，但是你都是用过的，所以这个是一定是灵活的。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_SJKYL1_chapter">18. 数据库原理（一）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_17">18.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/数据库原理(一)板书1.jpg" alt="数据库原理(一)板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数据库是什么">18.2. 数据库是什么</h3>
<div class="paragraph">
<p>今天讲数据库原理，我们讲的数据库原理，肯定是从我们编程角度，需要多次讲多少肯定和数据库原理的论文不一样，比如说你要讲大数据的话，我把Google的三篇论文翻出来给你讲一遍，你听懂了就可以写代码了，但那样的话就没为没显得高射炮打蚊子，因为里面设计很多分布式的东西，那这个地方数据库也是一样的，就是它范围很大，我们把它精简到一个最迷你的一个模型里头，那么既然讲数据库原理，你肯定回答这个问题，你要知道数据库是什么之前你就要举例子，你把你生活当中拿就是遇到过的例子举出来：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mysql：现在我们知道的数据库首当其冲的肯定是Mysql，因为他在的互联网企业当中用的最多。</p>
</li>
<li>
<p>PostgreSQL：一个开源的关系型数据库。</p>
</li>
<li>
<p>Oracle：Oracle在政府和银行用的很多，为什么用的很多呢？因为在那个年代实用的数据库就没有第二个了，所以他现在是缺少中国市场，同样是全世界第一。</p>
</li>
<li>
<p>SQL Server：微软Windows平台的，这个东西我只能说确实不错，但是和我没有多大关系，因为我又不用Windows，他挺好的就是有点贵，免费的也是可以，我那个时候用的是SQL2008、2012，最大支持cpu4核，等于说你cpu再多他也只有这个性能，所以说你在4核能跑就可以了，他有免费版是挺ok的哈，用C#的话基本上无缝集成，但是现在大家都在用Java，然后用PHP搞互联网嘛，然后现在GO语言也在搞，但是到现在为止，没有听说哪一个大公司哪个大项目会用SQL Server，SQL Server去年已经在Linux下能跑了，我说的是能跑，用不用那是另外回事情了，微软是先把.NET弄成个调.NET core，能够在你Linux下面跑，然后把编程语言跑完了，再把SQL Server移过来，所以那这个地方都挺不错的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个地方Mysql和PostgreSQL在互联网行业是最受欢迎的，Oracle和SQL Server这两没互联网啥事，在互联网的行业是这样的。</p>
</div>
<div class="paragraph">
<p>什么叫互联网行业？你手机用的app，你的网络购物，那么它就是典型的互联网应用，然后这样的话就意味着你的订单量很大，那这种情况下面的话服务器多吧，服务器多用Oracle贼贵，维护也贵，主要是贵不是不好用。</p>
</div>
<div class="paragraph">
<p>所以数据库是什么？那么列出来这三个，所以这个地方我们就按普通人的这种认知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>数据库是保存数据，能用过SQL增删改查的计算机软件。

重点：关系型的、SQL</pre>
</div>
</div>
<div class="paragraph">
<p>Redis是数据库吗？你看他符合定义吗？他能永久保持数据，但他不能通过SQL查，所以我们这个地方指的数据库，通常指的是关系型的，而且是SQL的，这两个很重要，在Redis和Mongodb出现之前，这些数据库全部都是关系型的，极少数可能有那种昙花一现的数据库，所以大家在通常讲数据库的时候，一定指的是关系型的数据库，而且关系型的SQL数据库，所以通常大家指的是这个，所以我们就不会说Redis是一个数据库，Mongodb其实我们也不会认为他是数据库，包括ES，我们也不会认为他这个数据库，他们单独给那种取了个名字叫NoSQL，不是SQL，那就肯定就和这个八杆子打不着一起，所以那这个地方我们通常指的数据库，一定是关系性数据库。，像那种Redis或者Mongodb或者ES，你可以把它叫数据仓库软件， 那这样的话可能更贴切一些。你想嘛ES也不能用SQL查，只能用JSON，Mongodb其实也是有特殊的语法，你看那个Redis用getset搞了半天，也能做，所以那种可能归为纯粹的NoSQL或者是数据仓库，或者叫数据存储软件会更好一些。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_4">18.3. 使用场景</h3>
<div class="paragraph">
<p>那这个地方既然提到使用场景这个地方你要提关键字了，永久保存。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>这个地方补充两点哈，通常说的数据库肯定有它里面的内容，内容组织形式，那么首先你的有数据库，然后第二个是得有表，所以他是这两个形式的组成的。

* 数据库 Database

* 表 Table</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个地方使用场景的话，其实这两个和使用场景也没啥关系，主要是永久保存和SQL，那这样的话使用场景肯定就举例子了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>银行保存余额</p>
</li>
<li>
<p>电商订单</p>
</li>
<li>
<p>病例</p>
</li>
<li>
<p>QQ号（社交类）</p>
</li>
<li>
<p>政务系统</p>
</li>
<li>
<p>游戏装备</p>
</li>
<li>
<p>报警记录</p>
</li>
<li>
<p>违法记录</p>
</li>
<li>
<p>维修记录</p>
</li>
<li>
<p>酒店开房记录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有很多就不写，所以使用场景你发现只要数据不能掉的，通常意义都是用数据库来保存的，这是使用场景。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么保存数据的工作原理">18.4. 怎么保存数据的（工作原理）</h3>
<div class="paragraph">
<p>这地方肯定讲的是How，实际上这个地方问的是工作原理，我们讲编程的时候我们会说怎么去调它，但是我们在讲纯数据库的时候，怎么保存的意思是说，你把数据给了Mysql他怎么保存到硬盘上的，你问的肯定是这个，为什么？我们讨论的是限制了范围的，所以那个地方讲的肯定是数据库的工作原理，那很简单，我们先来复述一遍，我打个比方：</p>
</div>
<div class="paragraph">
<p>你到天猫超市你去买了一瓶水，从你进门开始看发生了什么？你进门的时候挑选商品，挑选了商品过后，你把商品拿到前台结账，然后轮到你过后，那么店员扫二维码扫条形码，系统显示价格，系统显示了价格过后说五块六然后这个时候你要付款，不管你用任何方式付款，就是扣了你的现金扣了你的余额，那么你用银行卡，支付宝，微信现金都可以，然后付款，自从付款那一刻你的交易就结束了，那这样的话就证明就是说你的交易行为就结束了，那这样的话在天猫超市的系统里面有条五块六的购买记录。扫了商品再扫你一下，这个记录我假设他在当前产生了，但是他还没来得及传出去，那这个时候，他这个时候应该形成一条购买记录，购买时间，哪家超市，或者超市的代码，然后商品名称，商品规格，商品单价，商品条形码，如果不存的话，你不觉得那个信息逻辑是不完整的吗？当然有另外一个问题了，他入库的每个都扫了一下条形码，你看现在这就很尴尬了，所以他应该有批次，他条形码应该指的是批次，所以就是相当于批次，批次完了过后就是打不打折，然后这个时候产生这个记录放在这个位置了，他怎么到数据库里面去?</p>
</div>
<div class="paragraph">
<p>数据库肯定是中间过程嘛，那数据库既然是直接写到硬盘上，那为什么你不直接把那条数据保存在硬盘上,这过程当中数据库干了几类事情，第一个数据库通过网络IO接收，这是典型的嘛，3306端口嘛，然后通过端口接收过后接到数据，他肯定要先把它做一个格式化嘛，格式化成自己的格式，你也可以理解为编码，编码成自己的数据库的格式，以特定格式存在硬盘上了过后Mysql才能特定格式去读吧，他为什么这么干，而不直接是写0101乱存就可以了，那是因为他从硬盘上读完了过后，他要做各种分析，缓存，各种加速，各种索引，所以如果你不是特殊格式的话，他很难处理，所以数据库，它第一个职责，这个地方讲的是种典型哈，但是他没有涉及的更多的特性，这个地方第一个，那么它保存肯定是保存自己的格式，所以你要靠他，为什么保存自己的格式呢？是因为他自己有索引功能，他为什么要有索引功能呢？因为他想快，他想查询快，这个查询不管你是单表查询还是多表查询，他就是想快，你为什么不放硬盘上？很慢呀，越访问越慢，你一个人访问都没啥事，你自己都可以hold得住，但是你那个硬盘多读几次就崩了，就这么跟你讲全世界的数据库，不管是谁，他写入的数据永远无限接近，不管是比尔盖茨还是更牛逼的人，你弄的数据库，你写数据的速度永远无限接近，为什么？因为写的速度不是你数据库决定的，是谁决定的？硬盘，硬盘就这么慢，你保存的再快，有啥用，所以说数据库不管你再牛逼，你写数据依赖的是数据库外部的硬盘硬件设施，所以这个时候，都一样慢，我是假设他的整个逻辑已经非常完善了，然后代码0损耗，这样去写数据库，保存硬盘上那个速度一定是无限接近的，那么既然他都是一样的，那他的区别肯定还是有的是什么，查询速度这个说白了通常统称叫性能，所以就第一个用数据库肯定是为了性能，肯定不是为了好看，第一个那肯定是他的使用效率，软件的使用效率，查询效率高，那么你才会用的，为什么你都叫数据库了，你查询慢，谁用你？你还叫数据库吗？你叫的文档算了，第一个，那就是性能好，使用效率高，第二个数据存储方便，抛掉这两个特性，你那个数据库没人用，虽然他也叫数据库，世界上数据库可多了，但是你不会每个都用，因为你要考虑慢不慢，快不快呀，用的方不方便，这两个看起来才是引入数据库的一个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用效率（性能）</p>
</li>
<li>
<p>便利性（SDK？）（API？）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那是怎么让他发挥效率的？说白了你有之所以不用文档的方式去存储，和引入数据库存组一定有区别，而你把这个区别讨论完，你就知道数据库的原理是什么了？首先，我们就先说简单的存一个Text，你可以在里面增加删除修改，增删改查都是可以做的。所以那这个时候它是文档，数据库可以理解成某种意义上的文档，只是那个文档不是你直接编辑的，是数据库编辑的，所以他们的起点和终点是一样的，起点是你输入的数据，终点保存到硬盘上，那中间发生什么，为什么？事物嘛，你拿来这么一对比对比就能看出了他的区别了，而不是孤零零的说，为什么有Linux？Windows不是挺好吗？我都讲过嘛，贝尔实验室的老头子他们想要个多任务系统，那既然有多任务系统，那证明他们以前用的是单任务系统，你登进去了就不能用，为什么？就一套键盘一个显示器当然不能用啦，怎么实现多任务系统的呀，通过网络登上去，用自己电脑登它，然后同时多个用户，是不是这意思嘛？你肯定有单任务系统才有多任务系统嘛，所以事物都不是孤立的，所以回到这个问题，起点是输入数据，终点是保存到硬盘，说白了这个地方就是0101，那中间发生了什么？</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/原理图.png" alt="原理图">
</div>
</div>
<div class="paragraph">
<p>你输入数据，打开了一个编辑器，输入数据点保存，任务就完了，那数据库是什么？你打开了一个Mysql的编辑窗口，把那个数据输入到Mysql窗口，点一下保持它就完了，是这样吗？那肯定不是我们关注的重点，看起来都是一样的，但是我们想关心的是那个数据库的编辑器或者是交互窗口他做了什么，那这个地方输入数据，那么我就假定都是窗口，编辑UI嘛，因为UI就是窗口的意思，那么在编辑窗口编辑数据，那么得保存，第二步嘛，那第3步发生了什么？自从你保存完了过后，就已经脱离你的控制了，要你这个和我们之前讲的结合起来，你数据库肯定有编码，结码，先编码，所以说保存数据这个里面有有东西，那么编码要发网络发送，那么发送完了就是网络接收，比如这个地方就通过3306嘛，那么网络接收后面就要解码，解码完数据就得到他想要的格式了，所以他解码完了是在解析他，数据解析是哪张表哪个数据库的，那么解析完了过后，他应该产生第一个哪一个数据库？第二个哪个表？然后第三个详细数据（记录），他解析完了过后，剩下还是说他要去做后面的事情，那他这样做完了过后，你会发现他已经开始靠近硬盘了，他这个是应该考虑硬盘怎么保存的问题了，所以这个地方他同样有编码。有个东西等一会儿有详细讲，叫数据库存储引擎，按照数据库存储引擎格式编码，编码完了过后，那所以这是一个很典型的过程，你会发现有意思是在这，这是个独立的一个阶段，上面的是不会有中转的，哪里会发现这个地方是最容易的，我发现这叫什么吗？HTTP是这样的吗？Mysql也是这样的呀，我都不说数据库了，包括你的视频也是这样的，包括你的音频，也是这样的，所以这个地方是网络协议的处理的一个流程，就这个是非常典型的，而这个地方他解析数据。你传过来，他要解析，然后这个解析这个数据还是现在还是内存里，他一定要分析完了过后是哪个数据库哪张表，然后记录数据是什么，拿到这些东西过后，带着目的带着这些信息再去问存储引擎说我要存个东西，是什么样的格式？那么去调一些函数过后，他把这个当输入参数传给这个编码函数，怎么样他就会反应串支付串给你编码后的支付串，你再把这串支付串保存到硬盘上。</p>
</div>
<div class="paragraph">
<p>现在有意思就解析这一块，为什么要有存储引擎哈，就拿Mysql举例，Mysql在5.0之前哈，他一直用那个存储已经很老旧的，那个存储引擎只要你更新任何一张表，所有查这张表的人必须排队，锁表意思就是说：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>我在这个房间里面使用的话，比如说，我在用这张房间，外面所有人必须排队，然后我用完了出去了其他人才能进来，慢嘛。然后后面Mysql更新的新版本的存储引擎过后你可以进来，你坐的那个位置，除了那个位置以外其他人都可以用，这样的话，就变成了一个是锁表，一个是锁行，意思就是说一点，很明显，锁一点点的性能更好。</pre>
</div>
</div>
<div class="paragraph">
<p>所以你看出了存储引擎对数据库的影响有多大了，最关键是他以前那个存储引擎还不支持事物，什么叫事物：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>双十一京东上面买东西扣余额扣到第二笔订单的时候，你又下了五个订单，但是你全选完了那个系统扣款可能是一笔一笔的扣，扣到第三笔的时候报错了，请问你的订单交易成功了吗？如果像以前的话，他也不知道。但是你有新的存储引擎过后，第三笔失败了，那么他就会反告诉用户双十一你的订单买失败了，具体哪个地方，我也不清楚自己看日志，然后交易失败了过后他就会把你扣的钱又退给你，这就是事物。</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是说，在那个事物区间里面发生的所有事情都可以回滚，都可以撤销，像极的人生编辑器，在数据库里面，他也有后悔后悔功能，改错了就后悔撤销，你可以主动说我后悔了我撤销，我自己撤销也可以，在报错的时候撤销都是可以的，所以存储引擎对数据库的影响超级的大，然后这是还是一个例子，第二个例子就是快慢的问题，新的存储引擎，它的查询效率更高，为什么？以前存内存里面的时候要查三次才能拿到某条数据，现在有Hash表，效率从以前0n变成了现在01那肯定快了，所以影响很大这地方涉及到的一个事物，主要涉及到的这三块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>事物</p>
</li>
<li>
<p>锁表（查询）</p>
</li>
<li>
<p>索引</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这三块对一个数据库影响很大，我刚刚就简单讲了一下，然后这个过程我们再来套一些实际的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>比如说我们现在做一个简单的查询，那查询的时候你要输入一个SQL，SELECT * FROM Table，然后这样的话就相当于说你指定了表的名字，你在SELECT之前先USE数据库，或者说你的FROM db.表名字，然后这个时候又相当于你又指定了数据库，又指定了数据库的表，甚至你还有 * FROM那个*号也可以换成具体的列，那这样的话这叫元数据嘛，一元两元的元，不是原始的原，这元数据意思就是说最初的未经加工的数据，那你把这个元数据那么编码，这个SQL做编码，把这个SQL做编码，那么编码后的SQL就带了Mysql的报文，报头嘛，报尾，中间就夹着那个SQL，然后通过网络的3300端口发给服务端，经历三次握手，我就不讲了，那太细了，那么上次握手过把数据发过去，那么Mysql服务端说我收到了，收到完了之后，他再把他报文报头东西按照他的规则挨个切开，切完了之后忽悠剩下那串SQL了，然后这个时候，他应该自己写一个SQL解析器，SQL解析器其实以前叫网络协议，SQL这个东西就叫本地协议可不可以吗？就是一个字符串协议，他把那个SQL丢给他的编译解析器，解释器他会把这个SQL里面的哪一列是查询还是怎么了，然后数据库名字表明字包括WHERE条件，它从一个字符串格式化成一段一段的，方便他拿数据嘛，不然的话那么长一个SQL你的那个肉眼倒是能看清楚在哪，但计算机懵的呀，到底是一个 * 号吗？还是那个F吗？他不知道怎么切，所以他现在是也要拿刀子切嘛，把里面重要的元数据切出来，切出来了就放在那嘛，为什么那么复杂还要写SQL，那是因为你笨，你要是能写0101他至于那么恼火吗？</pre>
</div>
</div>
<div class="paragraph">
<p>所以这个时候哈就是之所以用SQL，还要转一次才能让计算机明白是因为人脑没有计算机那么死板，人脑不能理解这种东西，人脑只能理解你形式化的东西，所以他这个地方收到过后他在做解析的时候把SQL解一遍，这个地方有个SQL语法解析器，那么他把那个语法解析完了过去能拿这些东西，然后拿着手上过后那么他就应该去让他的存储引擎去读了，就和刚才不一样了，刚刚是写嘛，他就怎么样，他就问存储引擎这个数据库这张表请你拿出来，那这个时候他肯定就会去读下头，读完了又返回来，然后返回来又绕回去，又把过程倒着来一遍，就出去了，这个时候刚刚进来的时候是一个SQL语句，返回的时候一定是一个结果，那个结果一定是个列表，你的数据库是不是列表吗？你的Excel是不是列表吗？你的编号是不是从一开始的嘛？所以说他的列表一定是从0123456789，所以怎么样到了这个地方。他就倒着来，那这个时候，你反回去的时候是一个列表清单，就是这张表的或者是这个查询的结果清单一行一行返回回去，然后到了这个位置，那么他解码解码完了过后，这个软件就把那个数据按一行行的格式展示出来，刚讲的增加，现现在讲的查询删除更简单，SQL传进去DELECT什么什么东西，到了这个地方，他发现你要删除，就告诉存储引擎请你把这个表的这个数据删了，那么他就找到数据删了，改的话就是更改一个数据将那个地方以前的数据重新覆盖一遍。</p>
</div>
<div class="paragraph">
<p>所以那这个地方就是不管你怎么套，你会发现都能讲通，大致逻辑都是差不多的，我就不用挨个来讲，然后现在问题来了，数据原理就那么简单吗？其实不是的，这个地方少写这个字。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bianchengjiqiao_chapter">19. 编程技巧</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_18">19.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书1.jpg" alt="编程技巧 企业级板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书2.jpg" alt="编程技巧 企业级板书2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书3.jpg" alt="编程技巧 企业级板书3">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书4.jpg" alt="编程技巧 企业级板书4">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/编程技巧_企业级板书5.jpg" alt="编程技巧 企业级板书5">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是编程技巧what">19.2. 什么是编程技巧？(What)</h3>
<div class="paragraph">
<p>今天讲编程技巧，那首先还是老样子，编程技巧是什么？首先这个技巧指的是什么？这个地方的技巧对于你来说叫技巧，对于我来说叫基础，其实这个东西代表的就是优秀工程师的一个基础技能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景_where">19.3. 使用场景 (Where)</h3>
<div class="paragraph">
<p>什么时候该用编程技巧？清晰表达逻辑的时候你就需要用我认为优秀工程师的一些基础技能了，当然你的代码自己都没有逻辑，就谈不上这个东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_怎么用how_2">19.4. 怎么用？(How)</h3>
<div class="paragraph">
<p>怎么用这是今天我们重点讲的。</p>
</div>
<div class="sect3">
<h4 id="_引申">19.4.1. 引申</h4>
<div class="paragraph">
<p>当你没有听我讲这个之前，不管你是工作了半年甚至十年，我讲的这些方法你根本就不会掌握的，另外个层面就是你说这个东西掌握人多不多，多，为什么？在GitHub上面写开源代码的人多多少少都掌握这些，但是在你的生活当中是遇不到这种人的，为什么？GitHub看到的项目也可能就那么几十万个程序员，还是全世界的，不要认为给银行做项目那些就是TOP了，做银行做项目这种人，他是会写业务代码，而编程技巧和业务代码一点关系都没有，为什么？业务抽象到最后，抽象是作为数据抽象，然后最终写到纸面上的时候就是代码抽象了，那么这个过程当中就要依靠编程技巧，但是代码抽象这个不是唯一的方法，就像刚刚说的你可以写IF，也可以写查询表、设计模式，所以有很多种表达方式，甚至你用C语言都可以，就全靠指针，全靠回调函数也是可以做的，所以在银行里面的人，只能说他对那个业务很熟，不一定说他编程技巧是最好的，为什么？编程技巧没有最好，因为编程没有衡量标准，比如说我们同时参加高考，都是同一个地区的，用同一套试卷你能考出来，但是你并没有听说过谁去招聘的时候限制必须要什么软件工程师证书，我没有毕业之前听说大家考那个，然后去看了下那个题还考DOS和一堆上古时代的东西，我直接看都不想看，为什么？首先如果一个证书他学的东西都是过时的，我就认为那个证书没有任何价值，从我的角度来说的软件工程师证书是没有任何用处的，那编程既然没有衡量标准，那你怎么知道你用的是好的或者是合适的？然后这个过程当中编程难就难在这个地方，比如说同样是写一段代码，你写的就和别人写的就是不一样，但是每一年有那个C语言一行代码的比赛，一行代码可以写个游戏，但是写一行代码写游戏的人在公司都被开除了，为什么？因为企业里面要的不是很NB的技巧，要的是协作，所以我讲的东西肯定是企业级的，意思就是说，我们不搞技巧，我们也不钻牛角尖，比如说考个题，问你i和i有什么区别？说实话，放在哪个位置他能加上就可以，然后这个时候，你不在乎我不在乎，你就不会去考虑这个问题了，比如说，有些题是这么说的a = a++-,请问最后他是等于几？你要是敢这么写的话，放心，你的leder会打死你的，为什么？因为只知道你写了一行代码，但我并不知道你这行代码代表了什么意思？</p>
</div>
<hr>
<div class="paragraph">
<p>所以技巧是为了清晰表达自己的逻辑，刚刚逻辑表达不清晰，到后面你怎么去让别人看懂你的代码，所以一般我交出去的代码，代码员是不会重构的，为什么？因为他们重构不了，他们只会在我的基础上面加东西，他不会去改我的，就算改我的，其实也只是改一些，就是后面业务有新增、变动或者是我确实写了Bug，他可能去做这种，但是他不会去改我的逻辑，为什么？他已经想不到更好的逻辑了，但是每一次看到我同事在我的基础上加的逻辑，我就很头痛，为什么？明明我的逻辑很完整，结果你加了东西过后不伦不类的，查数据库在A，然后又用在B，然后C又调了A，然后我就懵了。</p>
</div>
<div class="paragraph">
<p>那么为了清晰的表达逻辑，你就要用这种技巧，所以这是优秀工程师的一个基础技能，它并不是非常非常进阶的东西。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景一">19.5. 使用场景一</h3>
<div class="paragraph">
<p>刚才我问大家一个问题说你接收三个参数，那这三个参数分别是算法的A1，A256和A512，那如果穿个2048进来会怎么样？那么我就从这个入手，讲一下如果是我我会是怎么做。</p>
</div>
<div class="paragraph">
<p>首先我们就假设一个场景，那么这个场景里头，要接收一个URL的URI参数m：</p>
</div>
<div class="paragraph">
<p><code><a href="http://localhost:8080/?m=SHA1" class="bare">http://localhost:8080/?m=SHA1</a></code></p>
</div>
<div class="paragraph">
<p>然后这个m，有三个可选项： <code>SHA1</code>、 <code>SHA256</code>、 <code>SHA512</code></p>
</div>
<div class="paragraph">
<p>那既然叫可选值，在编程领域，你只要看到那个参数啊，它有这三个字可选值，那就意味着一定是枚举，然后现在新的问题来了，枚举是什么？枚举就是把你的可选值列成列，当然你说可以放到数组里头啊，数组也可以，但是你怎么校验数组？你怎么校验字符串数组里面的字符串？就比如说你要校验多没多空格或者你敢打赌某个字符不小心敲成小写的？所以这个时候用数组其实是可以啊，等一会我们再来讲它的用字符串表示的不合理的地方在哪。</p>
</div>
<div class="paragraph">
<p>现在就先讲一种我认为正确的处理方式或者说是比较合理的一种处理方式，那既然这个地方它是枚举，那我就在Java里面写成枚举，然后这个时候我就写个Java Enum(枚举)去表示上面这个的话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Enum

M_SHA1</pre>
</div>
</div>
<div class="paragraph">
<p>就会有个枚举叫M_SHA1，这个变量名是合法的，那既然是合法的，那肯定他也是一个合法的枚举，通常来说，你会这样等于一、二、三，这里我们直接一上来就用一个标准的做法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Enum

M_SHA (1,”SHA1”)</pre>
</div>
</div>
<div class="paragraph">
<p>一般我会把这个枚举类改造一下，我让这个东西变成一个迷你的Class，然后在后面写上SHA，下面套路你就知道了，我这样做的意思就是说普通的枚举，他只能表示数值，但是我想在枚举上做一些字符串、值的比较，这两个我都想用，我不想写在两个地方，所以这里我就先讲我认为标准的方式。</p>
</div>
<div class="paragraph">
<p>那下一个就是把可选值加上去：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Enum

M_SHA (1,”SHA1”);

M_SHA (2,”SHA2”);

M_SHA (3,”SHA3”)</pre>
</div>
</div>
<div class="paragraph">
<p>当然这个地方我肯定省略了这个类的名字，那先取个名字叫Enum Method，这是美举，然后这个时候，你看到没有三个可选项都在这，这些字符串你都认识，是用户输的那个，那前面的1、2、3是什么意思，是因为每一个美举，他一定要对一个数字，这样就很方便编成语言去区分，比如说你没有写1、2、，编程语言他就分不清楚你这个字符串和这个字符串有什么区别，所以每一个语言的枚举，它的基础类型都是数字，不管是长度多长总归它都是数字，所以这个是它的基础特性，就是所有的枚举都是数字，只是Java在数字上加了点东西，方便等一会再用，那这样看起来如果用户传了个这个，那么他就等于1，我要怎么表示这个1呢？首先我肯定不会在那个地方写个1，其实M_SHA1就是表示那个1，那这样的话你在代码里面看到M_SHA1就看到了1和SHA1，用M_SHA1做代号,用它来代替你在到处用字符串、引号，因为你知道的人脑是不可靠的，你到处都用引号手动去打，这样你是能打，但换个同事，他能打对吗？</p>
</div>
<div class="paragraph">
<p>所以这个时候你的同事就变成你的用户，用户的输入是不可靠的，一定要做校验，还有在类型上去限制它，等一会我们来总结，这里我们先把方法讲了。</p>
</div>
<div class="sect3">
<h4 id="_接收参数">19.5.1. 接收参数</h4>
<div class="paragraph">
<p>那既然有枚举了，就要接收参数，假设我现在已经收到了参数m，那就相当于说第一步啊，那么接收的参数参数m，那这个时候m等于字符串，所以现在这个m是等于SHA1，那现在我拿到这个后，要做参数教验，我有几种做法</p>
</div>
<div class="paragraph">
<p>1.IF</p>
</div>
<div class="paragraph">
<p>if m == “SHA1”</p>
</div>
<div class="paragraph">
<p>那既然可以这样写，那也可以往下继续延伸，写多个IF，但问题在于，如果有100个可选值呢？最关键是只有三个没错，确实他只有三个，但是你要是三个都解决不了，你何来解决100个问题，所以我讲过的，从我的这个经验来说的话，我经常是用一种方法解决所有的共性问题，既然这是一种参数的可选择问题，你就应该把这种问题归纳成一种简单明了的方法，以后在你的软系统里面，只要涉及到这种的，通通只用一种方法，就问你个问题，你的同事拿到你代码的时候，逻辑就很简单，这个人我已经看透他了，怎么看透的？他只要是可选值，他都会用枚举，那就变得简单了，只要你变得简单，你的同事就不会在代码里面写Bug，所以你不能一会儿用枚举，一会儿用IF，一会儿再用查询表，你这是在秀你的技巧，但是秀技就很讨厌，你知道吗？俗称装逼，装逼是要有限度的，所以这个是你用IF是确实可以做的，没毛病，但可能看起来没什么好看而且最关键万一以后你老板说要加两个算法，以前是三个，再加两个就是五个，然后你就在后面加，那么参数校验是加了，但是后面在用那个算法的时候，总得有地方判断它是哪种算法？你又得判断，然后你说把这个包装一下，然后写成SDK跟我的同事用，那你同事又是传的字符串进来，你又得校验一下吧，这样不累吗？这等于说你一个相同的逻辑会在出现在不同的地方，要是这个逻辑不完整，不自洽的话，你很容易留下隐患。</p>
</div>
<div class="paragraph">
<p>就像昨天我们公司团建，我跟我同事讲我写代码都是叫防御式编程，我会因为防御式编程花非常多的精力在我的封装、易用性上面，甚至包括我的变量名、使用文档、说明等等，这些东西我会花时间，为什么？因为我宁愿花时间，也不原因出了问题，我帮你找Bug，然后发现是我的问题，那样的话就更花时间，所以从一个内行的角度来看，我是在优雅的编程，我这种优雅体现在：“你能想到我都想到了，你没想到我也我也想到了，我想的始终比你多一步。”这就是工程师和工程师之间的差距，你但凡多想半步，就好非常多，不是好一点点的问题。</p>
</div>
<div class="paragraph">
<p>2.枚举</p>
</div>
<div class="paragraph">
<p>第一种方式肯定是不可靠的，因为你还是用字符串的方式来做的，那么A2的方式是拿了枚举，得把m转成枚举才可以，所以我一定会有这个语法，这里枚举我就用e表示，那就叫me，那么me这个枚举，他肯定是来自于m，所以你可能有一个方法或者强制类型转化，比如说强制转成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>me = (method)m</pre>
</div>
</div>
<div class="paragraph">
<p>我们假设这句话他是合理的，那么强制转换过后me就等于其中一个类型，传进来的是SHA1，那这个m1= M_SHA1，所以这地方就写个注释，那这个地方其实就是等于的M_SHA1，那做了个强制类型转换过后，那他就是me了，然后这个时候me要去调加密算法，要传给下一个Class，就假设我们调的是那个MAC：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mac = Mac (me.getname)</pre>
</div>
</div>
<div class="paragraph">
<p>现在你又开始有槽点了，这地方本来接受的就是字符串，那为什么不把这个M直接传过去？那实际上这个getName实际上又是等于一个字符串，那为什么不直接把m传过来？听说过SQL注入吗？打个比方，这个地方是个查SQL的，要是传一个rm -rf进来传或者Delete，然后你就会发现这语句就不是你预期的，就变成了一个Select里面悄悄带了个inset，那你的数据库表是不是就被改了，所以你对你的代码能控制吗？那就是万用灵活的API接口，就是你的编程啥都不用干，只需要几个注入的接口，前端那边只需要传SQL过来啥都能做，前端那个人直接查表可方便了。</p>
</div>
<div class="paragraph">
<p>所以这样风险贼大，因为用户的输入是不可信的，永远是不可信的，哪怕他是你的同事，为什么？你也解决不了你同事犯傻，所以做了一个类型转换，转过来，转了类型过后至少这个me你是信的过的，为什么？因为me是三个当中其中任何一个，那万一me没有在这个可选值里面呢？那这个代码就要改造，他有一个最终的版本，一般来说我们要去把一个东西转成一个美举，就是强制类型转化是可以的，但是这个地方要写一点代码，那个代码我就不写在黑板上，那在，枚举类里头有几个方法，第一个方法是获得SHA的值，我们就叫他GetName，前面的数字我们就把它叫GetValue：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>String GetName();

Int GetValue();</pre>
</div>
</div>
<div class="paragraph">
<p>然后这个地方除了这两个以外，还要去把Name变成枚举键，所以你应该有一个返回math的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Method toEnum(String)</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是有三个函数，因为我说了他是个Class，他只是刚好和枚举有点关系，其实枚举你一看就知道是基于Class改造出来的，GetName是返回这个字符串的，这个GetValue是返回数字的，还有一个是从字符串变成枚举的，所以我们使用方法是这样的，先传一个字符串，得到一个枚举，拿了这个枚举和Enum过后，然后Enum.getName就得到支付串，然后getvalue得到的Int，主要是方便，没有其他原因，那这个地方的话，me很明显要调枚举类的方法，而这个方法的肯定是一个静态方法，为什么？因为这个里面的东西和内成员是没关系的，因为你传的东西最终是反了一个自己，而你没有使用任何类成员的变量，所以就不管Static的问题，我就直接用了，就掉math的一个静态方法，叫toEnum，然后接收的参数是m</p>
</div>
<div class="listingblock">
<div class="content">
<pre>me=method.toEnum(m)</pre>
</div>
</div>
<div class="paragraph">
<p>这样的话这句话就解决了问题,但是现你们现在还有一个问题没解决，就是如果他输入的参数不是你预期三个当中的其中一个，怎么办？所以这个时候啊，对于我来说，我会悄悄的加一个东西，加个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>M_NONE(-1,”NONE”)</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是无效值，所以我这个地方是先转换，转换完了之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>IF(me == M_NONE){
log_error(...)

retrun

}</pre>
</div>
</div>
<div class="paragraph">
<p>意思就是如果等于NONE的话就ERROR，这个地方就处理ERROR，打个错误消息，然后retrun，至于retrun什么就不管了，那这样他就终止程序运行了，那经历过这一步过后，这个m就是可信的了，所以现在可以把ME去做加密：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mac = Mac(me.GetName())</pre>
</div>
</div>
<div class="paragraph">
<p>那现在得到了这个，而这个地方在使用的时候，你会发现m.GetName又把字符串给还回来了，然后这个时候，你拿出来做一些其他事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mac.dosomething()</pre>
</div>
</div>
<div class="paragraph">
<p>其实代码用的时候其实就这么几行，枚举啥的都不算的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_划分阶段">19.5.2. 划分阶段</h4>
<div class="paragraph">
<p>然后这个时候给代码这边分个阶段从这个地方啊延伸出来的然后，这个地方是属于参数参数的数据接收，啊那数据接收完了过后，这一段
对的这个数据教业吗，</p>
</div>
<div class="paragraph">
<p>那么枚举的代码算行数，刚刚我是说几行就解决了，为什么不算行数？因为这是相当于一个工具，下一次你还会用的，只是你调用他的地方和名字改了，所以这个东西是不算行数的，为什么？你可以复用，除了这个地方可以复用，甚至说你可能项目其他地方也会用到这个，所以在这种场景下，这个方法的就变成了写一次代码，我就可以一直用，如果如果他不满足需求，我就把它改成满足需求，又灵活，比如说我不想去判断那个IF，我就直接在这个方法里面抛出异常，抛了异常，Java就往外面丢，最外层再来个Try Cach把它包裹起来，所以这个是没有抛异常的版本，我不是不抛异常，是因为有些程序员，他不想要异常，所以我的基础代码一般是不喜欢抛异常的，为什么？因为抛异常外面不好处理，他对你的入侵性太强了，一旦抛了异常，所有用你代码的人都要用Try cash，然后1下就多了五行，然后你的代码结构，就成功的被打乱了，为什么？Try Cash其实是没有逻辑的，因为你永远不知道是哪个地方出去的，所以这个是你要根据返回的异常类型，然后里自定义个叫那个枚举异常，那里写1000个累，那你有1000个异常？不然的你怎么区分是哪个代码出错了？</p>
</div>
<div class="paragraph">
<p>所以Try Cash有时候好用，有时候它不好用，要分场景，在你经验不足的时候，要慎用，你每次要想明白为什么，而不是无脑的直接敲出来，这是第一个问题，就是这个异常的问题，然后还有个工具重复使用。</p>
</div>
<div class="paragraph">
<p>第二个就是为什么不用Map？你这个地方用map的话，无非就是说有一个Map，有枚举里的一些东西，是这样的你用Map有一个很致命的问题，你用枚举转成map里面的东西，你还是得校验，代码少不了，你只是把两个Get省了，第一个你少了只是GET然后你下面类型转换你还是得做，就是相对来说插入一条那个Map的元素，哈西表里面插入一条，一个Key对应的Value，你只是少了两个GET这个代码，但是这个转换没少好这是第一个，第二个是当我想在其他地方表示这个SHA1的时候，如果你有Map的话，你要从Map里面把值拿出来，那你怎么保证里面有东西呢？你是不是还要判断一下是不是包含这个值，包含这个Key，再把值拿出来，因为你不判断的话，虽然你假装知道有，那万一哪天你手贱把它给删了呢？数组、哈西表这些东西叫动态容器，什么叫动态容器？就是永远在屁股后面可以加、可以删，特别灵活，灵活到什么程度呢？什么时间删的你都不知道，比如说你明明在最开始初始化有三个Map的元素，结果到中间你老子抽了你从中间rmove了一个Key，然后就剩俩，然后你后面去用的时候，你假装还在，结果你引入了隐患，媒体最大的好处是你只要不删我的代码，你的容器、数量是固定的，等着被别人用，别人只需要用字符串的初始化就可以了，当然这个地方我再精简一下，那这个地方既然可以转成这个枚举，看起来这个枚举是可以写个构造函数直接就代替他了。</p>
</div>
<div class="paragraph">
<p>所以这个地方他的构造函数和他同名，他构造函数接收一个字符串，现在就已经很简单了，所以刚才两个问题啊，第一个为什么不用Map，第二个是封装代码的意义在哪？</p>
</div>
<div class="paragraph">
<p>那么这个地方封装代码的意义就是能重复使用，逻辑固定,然后不用Map是因为要无视动态容器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用场景二">19.6. 使用场景二</h3>
<div class="paragraph">
<p>和之前同样的例子，换个场景，刚刚的场景很简单，刚才的简单，简单在于那个值，是把它当字符串在用，那个字符串和你的业务逻辑里面没有非常强的耦合性，你会发现刚才是这样的，就有有些参数传进去，就只是用一下值，但是有些参数传进去，就要基于它构造一些东西，所以这个地方我们就开始讲工厂模式，先把这个m换成Car，之所以这么举例，是因为要无限向你靠近，但是做业务的时候就不一定了，那个时候就可以根据需求自己去换，这个地方可以任意换。</p>
</div>
<div class="paragraph">
<p>那这个时候就假设要这个参数的值去创建一个类，然后这个类里面又有自己的一些东西，比如我就看其实不叫car，简单表示这个地方的值就比如是Bus，那就相当于说这个地方如果传进去的是Bus，Bus的话要买车票，那他就有逻辑了，你会发现这个时候就跟你的逻辑强耦合了。</p>
</div>
<div class="paragraph">
<p>所以刚才那种是非常浅显的，而现在是变成很明显的东西，当然你会发现他肯定是枚举，为什么？因为你要做参数教验，只要是参赛校验，他就是可选值，所以刚才那个地方你一定要用上的，只是发生在后面的变化，所以这个地方我就跳过枚举，等会直接写。</p>
</div>
<div class="paragraph">
<p>那车辆的话，除了Bus、Track(货车)还有Bike，那首先我们要接受参数，就接受参数的可选值先列出来，这地方Car的第一个可选值肯定是Bus，第二个是Track，可能第三个就是典型的Car(小型车辆），然后肯定就是用枚举，我们就省略枚举下面的步骤，这里枚举的意义是在于他刚好是可选值，你要用可选择的枚举来做参数校验。</p>
</div>
<div class="sect3">
<h4 id="_补充c语言中的枚举">19.6.1. 补充：C语言中的枚举</h4>
<div class="paragraph">
<p>这里简单提一下在C里面枚举比这个校验更简单，因为有效的值，我们一般是从0、1、2、3，在C语言里面，这个没有刚好是Int，所以我们经常转换完过后，判断那个Car的Int，在0-3这个范围中，如果是无效的枚举的，那么他的Int是在范围之外的，所以写C语言非常非常简单，用Java写了那么大一堆，结果C语言两三行就搞定了，当然简单是要付出代价的，就是可维护性以及对人的要求都很高。</p>
</div>
</div>
<div class="sect3">
<h4 id="_代码逻辑">19.6.2. 代码逻辑</h4>
<div class="paragraph">
<p>既然已经有枚举，那么参数校验肯定也会做，这个地方我就直接这个代码逻辑，就不说那种IF/Eles的情况了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.intputCar = arge[“car”]</pre>
</div>
</div>
<div class="paragraph">
<p>首先接收参数，显然得有个car，去获取用户传进来的参数，现在就假设这个地方是可以通过数组拿出来的，那这样的话你拿到第一个变量。</p>
</div>
<div class="paragraph">
<p>然后现在要做参数教验，做类型强制转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2.CarEnum = Car(inputCar)</pre>
</div>
</div>
<div class="paragraph">
<p>把这幅串传进去这个枚举。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>3.if (carEnum == C_NONE){

retrun;

}</pre>
</div>
</div>
<div class="paragraph">
<p>判断传入的字符串是否在枚举中。</p>
</div>
<div class="paragraph">
<p>那现在得到一个枚举，那我要基于这个枚举去创建一个类，那现在假设这个类的已经提前写好了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Class Bus—&gt;BaseCar

Void do()</pre>
</div>
</div>
<div class="paragraph">
<p>首先继承的肯定是有一个公共基础类，那这个公共基础类就是BaseCar，那Bus里面有一个买票的动作，所以这个地方就假设他没有返回值， 然后有一个Void do()，这个我们等一会再具体说是掉什么动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Class Track—&gt;BaseCar

Void do()</pre>
</div>
</div>
<div class="paragraph">
<p>既然有了Bus，那肯定也还有Class Track，他也继承了BaseCar，Track里面也有Void do()。</p>
</div>
<div class="paragraph">
<p>现在我们讲的不叫设计模式，我们是从参数输入来讨论的，但设计模式是根据设计的角度来讨论，这两个是不一样，所以我们现在讲的使用技巧，但是你并不知道为什么或者你知道什么时间用，所以理解层次不用那么深。</p>
</div>
<div class="paragraph">
<p>现在有个问题：怎么从用户输入这个参数去上面说的一个类？意思就是要基于这个枚举，就比如说是Bus枚举，然后怎么去创建Bus类？</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Car = CarFactory.getCar(CarEnum)</pre>
</div>
</div>
<div class="paragraph">
<p>那这个地方肯定要得到这个Car，上面Bus和Track都属于Car，那这个地方肯定是有个Car的工厂(CarFactory)，然后把参数传进去，那么这个getcar里面就去做判断，判断你传的是哪种枚举，然后哪种枚举对应的是东西，现在假设我们不知道里面是怎么具体做的，假设他现在得到对应的一个类，那现在就有一个问题：你得到Get返的东西，你肯定不能在这儿直接写个Bus，为什么吗？如果这样写的话，每次用户用一下你就要重启服务器，重新编译代码，你不觉得这样就变成了ATM取钱的时候，里面有小人数钱吗？所以看起来这里肯定不能直接写Bus，那这地方肯定就要写BaseCar。</p>
</div>
<div class="paragraph">
<p>那这个BaseCar其实应该有相同或者类似的方法，打个比方，比如说公交车有买票，那Track一定得有买票，不然的话，然后这个地方调了过后，就会出现这种语法，Car.Do(买票)，但卡车不用买票，你不可能还判断一下方法的名字，为什么？因为前面都是BaseCar，那你的方法名字必须完全一样，玩犊子了，为什么？我们具体讨论一下，他为什么传那个汽车进来？因为他肯定要坐。</p>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>我们现在这个乘客，首先乘客要选择乘坐哪种车，那么乘坐车的时候，公交车和卡车他都可以坐，说白了从更大的角度来说，你是在使用这辆小轿车，那你使用小轿车和使用卡车没有区别，为什么？你既然都做了，而且都有货物，小轿车有行李箱，可以把货物放在后备箱，卡车，你也可以放后备箱，就是放的多一点点，说白了，就像那个挖掘机，你家里面的玩具挖掘机和外面的挖掘机都叫挖掘机，只是挖的东西不一样，但是他们都是挖掘机，体量不同，但实际上对他们动作是一样的，这个地方首先方法应该是一样的，你要先打车，就是Void Cal()，相应的Track(货车)也有个Call，Call先把车叫过来然后就要使用，这个时候你有货物，但货物是不同的，所以使用的方法名字可能是一样的，但是你的货物不同，但不管怎么不同，它都叫货物，就比如说不管是一个行李箱还是一吨铁，它们都是货物，但是他们的体积和容积是不一样的。</p>
</div>
<div class="paragraph">
<p>这样的话，就变成了第二个方法就就是Void Use()，这个时候你要穿个Size，你就根据你的需要的Size去定义它，比如说Size传进去，然后在Bus里面写If Size&gt;500公斤就拒载，这样它就返回值了，说明返回值了Boolen值，你会发现方法名字是一样的，调这个地方是没问题。</p>
</div>
<div class="paragraph">
<p>那么首先你应该是Car.Call()，先叫车，其实还可以更升华一下，不在这儿叫他，可以提前叫，这里无非就是要选择叫那种车，但是我们现在放到这儿也没关系，只是说从这个地方衍生出来的问题而已，所以这种编程技巧会让你写代码越写越舒服。</p>
</div>
<div class="paragraph">
<p>第二件事情就是，你叫到车了，这个时候你要上车，结果司机一看你拉了那么大一箱东西，给你拒载了，所以说叫完车过后就要用车，然后这个时候你要传你带的货物的Size进来，但你会发现现在的URL没有Size参数啊，加上就可以了，那这个地方把Size传进来了，他有一个返回值，那么我们把这段代码总结一下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>BaseCar car = CarFactory.getCar(carEnmu)

car.cal()

Boolen status = car.user(size)

if (status &gt; 80){

print(“886”);

}else{

car.run();

}</pre>
</div>
</div>
<div class="paragraph">
<p>接着上面的讲，刚刚我们说这个Factory里面其实我们是没有写明的，，包括什么时候拒载、什么时候同意也是没有写明的，那先写Factory，那么就有个Class，叫Car Factory：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class CarFactory</pre>
</div>
</div>
<div class="paragraph">
<p>然后这个类里面有getCar方法，刚刚我们调用的时候直接大写的，并没有实力化对象，证明他是个静态方法，所以这地方就写直接写方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public Static BaseCar getCar(CE){

}</pre>
</div>
</div>
<div class="paragraph">
<p>那接下来就判断CE：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>if (ce == EnumBus){

return new Bus();

}

if (ce == EnumTrack){

return new Track();

}</pre>
</div>
</div>
<div class="paragraph">
<p>像这种情况，如果你的这个工厂类很少，这样写其实是可以的，这是第一种情况</p>
</div>
<div class="paragraph">
<p>那么第二种情况，就是假设类型有很多，那么就要写一个查询表，这个地方我们之前是用的枚举，枚举就类似一个查询表，因为他可以用Map代替其中一部分，那都和Map类似了，肯定也类似于查询表，那现在我们肯定就只需直接需要Map了，所以刚刚讲的就是方法一，现在讲方法二，方法二肯定要先构建查询表，这个查询表还是用Static表示，他就表示只初始化一次，那这样的话就是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Static Map&lt;CarEnmu,BaseCar&gt;map ={

{EnumBus,New Bus()},

{EnumTrack,New Track()}

}</pre>
</div>
</div>
<div class="paragraph">
<p>这样就构造了个查询表，因为现在只有两个，如果有更多的就直接加上去，一般情况下有多少个美举，就会有多少个查询表，大不了反个空，但是这只是一般情况，一般情况下他都是空的，就证明你没用，那你写枚举干嘛？你应该真实有这个美举，还有对应的这个类这样的话就可以不用做异常判断的，因为他肯定是存在的，不存在空指针，直接让代码报严重错误，你就不用去管他了，因为这是你自己引起的，所以一般意义上，我并不会去检查我自己的代码，但是用户输入的就必须要检查，你自己写的代码报错了叫Bug，但是外部传进来的，那就叫安全隐患，这两个级别可不一样，所以一般你自己写的代码，就不要去到处检查，不然代码写的贼丑。</p>
</div>
<div class="paragraph">
<p>那接着刚刚的说，这个地方直接就用Map，然后传了个参数CE进来，这个时候肯定是在Map里面去找CE，那这地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>if (map.equer(accesskeyid)){

retrun map.getce

}

throw net Exception (“...”)</pre>
</div>
</div>
<div class="paragraph">
<p>通过这个方式，你唯一要做的就是每一次新加个Key过后，下面都不用动，只需要加查询表，而刚刚if的方法是每一次有新东西，你就要加两行，其实区别不大，但是很明显这种维护性更高一些，而且这个很不容易写Bug，想象一下，你写IF的时候，可能某个地方可能写错，但查询表你不会写错，为什么？因为它是挨着一起的，而且最关键是Map一个Key只能有一个值，如果有两个重复的Key代码就会报错，但是里写错了IF，他也不知道你想表达什么，他就正常通过了，所以这个Map，一个Key对应一个Value，他帮你保证不会重复。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>switch ce:
case EnumBus:
retrun new
....</pre>
</div>
</div>
<div class="paragraph">
<p>还有一种方法就是用Switch，但是你发现和IF没有什么本子区别，都是一样的，只是说语法上更连贯，但是Switch比IF，Switch会提示你，你的枚举里面有五个，但是你case里面只有四个玩意儿，请问是少了吗？</p>
</div>
<div class="paragraph">
<p>那么判断就有这三个版本，那肯定作为我来说，我常用的是查询表，是这样的，如果只有两三个值，而且预判过程当中不会超过十个的时候，我有可能会用Switch，但是那个地方很明显超过了八、九、十个的时候，那肯定就用查询表。</p>
</div>
<div class="paragraph">
<p>所以就看数量的问题，量少用IF，量再多一点点，就用Switch，量很多的时候就用查询表，查询表就相当于对于我来说就是究极绝招，要是特别特别多，那你的需求就有问题了。</p>
</div>
<div class="paragraph">
<p>那为什么不存在数据库？因为这个叫逻辑，存数据库叫存数据，数据是不带逻辑的，只有你使用的场景不同的时候，他才带逻辑，你放数据库里面，得先查出来，查出来后，再把它初始化成一个Map或者列表，那个时候他才是有逻辑的，所以放到数据库里面是一个很致命的问题，你不用的时候，那个数据库都不知道有啥用，等你要用的时候，你都不能确定是不是你想要的东西，载入进来你还要判断，还要做数据检查，为什么?因为这是从外部输入的，而我写的代码里面的好处就是说编译器包括IDEA，他会警告你，所以从数据库动态加载或者是说从URI动态传入，都有一个问题，就是要校验，你要校验你的Key、Value是不是对的，而我写的代码好处就是我不需要校验，只要错了就异常，那个地方一弄就变成了这个上头你要先载入做校验，然后才是下面这些逻辑，所以基本上我不太可能把这种需要逻辑的可选择值放到数据库里，非常非常少，除非为了保证整个业务系统的逻辑连贯性才会放，但是如果放到这边比数据库好，那肯定选这边，对于你来说，无脑放这就可以了，数据库少用，要是某天数据库宕机了，没东西了，那就是严重的致命错误，Java内部不容易出问题了，但是用数据库就涉及到第三方调用了。</p>
</div>
<div class="paragraph">
<p>那现在你知道这个Getcar怎么来的，就是构建查询表，只是查询表写的时候，选择用哈西表还是用Switch或者IF，你发现他们逻辑都是一样的，就相当于你先构造了一个表，你传了个值进来，然后问这个表然后又出去，这逻辑像不像人工智能？人工智能基本就神经元，进去一个东西，出来个东西，出来是啥，反正你也不关心，现在我们来解决什么时候拒载，什么时候同意的问题</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_拒载同意">19.7. 拒载？同意？</h3>
<div class="sect3">
<h4 id="_bus">19.7.1. BUS</h4>
<div class="paragraph">
<p>这个地方有两种选择，像之前讲的那种情况，可以理解为一个基础类，然后基础类有个好处，它是可以放内成员和内成员函数的，说白了就是可以有属性和函数两种东西，你也可以说，这里不是继承关系，而是是实现关系，就是这个写的是一种接口Interface，Java里面interface永远都是Public的，Interface里是不允许出现成员变量的，那么就意味着如果你要用的类似于变量成员的时候，你就不能用接口了，所以这个地方我一般都会写一Interface，然后如果出现了需要用到内成员的情况，我就会把这Interface换Class，然后写成继承关系，这个以后讲Java基础语法和逻辑会讲，现在只是提一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Interface BaseCar:
void call()
boolean use(size)</pre>
</div>
</div>
<div class="paragraph">
<p>那这个地方我就先写成Interface，这个Interface要有两个接口，一个没有返回值的，就是叫车，然后一个是boolean，就是用车:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class Bus extand BaseCar

class Track extand BaseCar</pre>
</div>
</div>
<div class="paragraph">
<p>然后还有两个类，那个叫车就不写了，没啥意义，反正就是都会到，不到就不到噻，就把这个返回值改成boolean-叫车失败，但那个逻辑没有参考性，但是Use方法是有参考性的，叫车就只占个位置放在那就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class Bus extand BaseCar

void call()

boolean user(size)</pre>
</div>
</div>
<div class="paragraph">
<p>比如说现在是Bus公交车，那个公交车上的乘车乘客守则上写了的一个人就是携带的物体啊按体积算的大概应该是一平方，就比如你背一个箩筐，那肯定是不行的，但拉杆箱是可以的，他是按照体积来算的，这里我们就按公斤数来算，比如说公交车的上限是120公斤，那么这个地方我肯定要写一个静态的最大值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static int maxsize = 120

然后他进的第一件事就是判断：
boolean user(size)

IF(size &gt; maxsize){
retrun false
}

...

....

retrun</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_track">19.7.2. Track</h4>
<div class="listingblock">
<div class="content">
<pre>class Track extand BaseCar

static int maxsize;

void call();

boolean user(size);

IF(size &gt; maxsize){
retrun false
}

...

....

retrun</pre>
</div>
</div>
<div class="paragraph">
<p>这里就是两种逻辑，而且你会发现他两个都用到了Maxsize，那就可以把这两个提到父类哪里，声明一个最大Size，虽然父类不知道Size是多少，但其实都是一样的。</p>
</div>
<div class="paragraph">
<p>这样写是没问题的，就看你的洁癖程度到哪种程度，你的优雅程度越高，你会越往上提，然后你会发现代码就变多了也变复杂了，这样的话，新手能看懂，但是往上一提，新手就看不懂了，所以你发现我这样一个逻辑可以实现无数种分支，然后不管是叫车还是用车，他都可以在一套大逻辑下面，就是经典描述工厂模式意思就是都在造车，然后造车都要经过提炼石油、制造赵轮胎、然后生产线，这样大体步骤都一样，只不过实现细节不同，那在造东西的时候，你就适合用这个，你会发现大体步骤都一样，都是用车，你不管的是货拉拉、滴滴还是T3，你说你得叫车吧，叫了车后，车要找到乘客定位，再到达指定地点等待乘客，然后司机发现这个乘客手上是拿了一只毛笔，还是拿了一吨铁力管它的呢，然后这个时候你都没有看到乘客，肯定没有办法拒载，但是当人数超载或者货物超载了，那么他就有可能拒载，那么就是IF(同意)，那么乘客上车走，IF(不同意)就点拒绝，然后走，只是走的时候乘客在不在上面而已。</p>
</div>
<div class="paragraph">
<p>所以大体逻辑是一样的情况下，你就可以用这种布局或者说是这种套路，任何软件系统、编程语言都是一样的，只是说语法的问题，这就是编程的魅力，只要理解了思路就好了，语法问题真的不是大问题，因为语法你总有一天会学会，但是编程思路错了，那任何编程语言都救不了你。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_代码实现">19.8. 代码实现</h3>
<div class="paragraph">
<p>查询表、工厂模式一用，然后各个地方组合，函数一封装，可能就没有IF else了，所以IF多就是因为没有设计，没有设计的代码就不要给我提多少IF的问题了，为什么？因为你不配，因为你就算把IF解决了，该有问题还是有问题，比如说他放到Map里面，但没有判断Key，然后就直接用，这样就有可能空值，当然反正都是异常报错，那万一那个地方是三数据库结果呢？空的时候也删，不空的时候也删，所以就等于说你的编程是有危害的，会对系统产生危害，产生危害就可能就处于不可控的状态了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设计校验步骤">19.9. 设计校验步骤</h3>
<div class="paragraph">
<p>那这个地方参数校验我们先写个URL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost/greeting?AccessKeyId=123&amp;SignMethod=SHA1&amp;SignNoce=4567&amp;Timestamp=145789&amp;Signture=abcd</pre>
</div>
</div>
<div class="paragraph">
<p>我们先看一下这五个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.AccessKeyId

2.SignMethod

3.SignNoce

4.Timestamp

5.Signture</pre>
</div>
</div>
<div class="sect3">
<h4 id="_accesskeyid">19.9.1. AccessKeyId</h4>
<div class="paragraph">
<p>然后看看这些参数你看要做哪些校验，就先拿AccessKeyId举例：</p>
</div>
<div class="paragraph">
<p>1.要验证他是否存在。</p>
</div>
<div class="paragraph">
<p>2.要验证它的长度。</p>
</div>
<div class="paragraph">
<p>就像这里KeyId一定是固定长度的，固定长度的随机字符串是有限定条件的，所以你要对长度进行教研。
3.格式校验</p>
</div>
<div class="paragraph">
<p>KeyId应该涉及到的是字母、数字、没有下划线，啥都没有。</p>
</div>
<div class="paragraph">
<p>这里长度和格式是两回事，平时表达的时候，你说他的长度多少，但是我们一般会把他两强行分开，格式是格式，长度是长度，这只是对AccessKeyId涉及到的三种情况，可能还有其他的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_signmethod">19.9.2. SignMethod</h4>
<div class="paragraph">
<p>第二个SignMethod肯定是在对枚举进行教验，但是他又涉及到是否存在，长度就不用管了，因为如果没有匹配到枚举就会直接报错，所以就是是否存在，然后转成枚举校验。</p>
</div>
</div>
<div class="sect3">
<h4 id="_signnoce">19.9.3. SignNoce</h4>
<div class="paragraph">
<p>随机数是这样的，首先我们要判断下他如果传个1传个2可不可以？不可以，因为1和2没有足够的复杂度，你本来就是因为安全才加入随机数的，结果就放个1、2、3过来，那谁都能猜，所以说这个时候啊应该要求五位数以上的，说白了就是应该有个取值范围，比如说这个取值范围可以是1000那么到9999，肯定是在某个区间，而且区间直接把简单的排除掉了，所以那这个地方看起来就是：</p>
</div>
<div class="paragraph">
<p>1.存不存在。</p>
</div>
<div class="paragraph">
<p>2.转成INT过后他的取值范围是多少。</p>
</div>
</div>
<div class="sect3">
<h4 id="_timestep">19.9.4. Timestep</h4>
<div class="paragraph">
<p>Timestep肯定的是能转成Java时间对象，转了过后，如果不是一个正确的时间格式，他会报错，比如说他转了后刚好等于1970年1月1号00时00点，那肯定就转失败了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_signtrue">19.9.5. Signtrue</h4>
<div class="paragraph">
<p>那这个Signtrue肯定是有长度的，为什么？你的签名方法是固定的，但是在你穿参数的时候，你并不知道那个256是长度，所以你应该是校验最小长度，SHA1生成的这个Signtrue可能有20位，SHA512生成估计就是30位，所以是校验最小长度和最大长度的区间。</p>
</div>
<div class="paragraph">
<p>所以就光这五个参数的接收，事可多了，这种参数校验纯用IF都能做，但是想一下这样做的话，你的Controller肯定特别特别长，全是IF Else，而且很麻烦，最关键是以后加参数，你还得改，改的时候，指不定会出现问题，人脑是不可靠的，要假设你一定会出问题，所以你就要让你的逻辑统一。</p>
</div>
</div>
<div class="sect3">
<h4 id="_什么叫逻辑统一">19.9.6. 什么叫逻辑统一？</h4>
<div class="paragraph">
<p>就是处理一个参数的时候，用的一个方法，处理十个参数的时候，也是用的那个方法，只是说处理的时候细节不一样，就像我们刚刚用那个轿车里面的用车一样，用车的时候细节是不同的，而参数校验无非就是存不存在、有没有长度要求、有没有范围要求，而长度要求、范围要求是属于校验里面的一个小步骤，所以我们现在就把这个总结出来。</p>
</div>
</div>
<div class="sect3">
<h4 id="_总结_3">19.9.7. 总结</h4>
<div class="paragraph">
<p>1.是否存在参数。</p>
</div>
<div class="paragraph">
<p>2.有无长度要求。</p>
</div>
<div class="paragraph">
<p>3.有无格式要求。</p>
</div>
<div class="paragraph">
<p>4.是否是有效值。
有效值里包括校验类型和取值范围</p>
</div>
<hr>
<div class="paragraph">
<p>参数教验事可多了，你脑子里面是这么想的吗？你脑子里面就想着参数传进去，能用就可以了，同样是写代码，为什么你的质量那么差，我的质量那么高，就是因为我考虑的比你多，我一定会用最坏的情况，脑子里想着假设有人来攻击我，我要怎么做到天衣无缝，至少在不用暴力把我压垮的情况下，数据类型上面是对的，你把服务器攻破了那是服务器的问题，和代码没有关系，只是问题关系不大哈啊，所以那这个地方就看起来，在做参数教验的时候，你要满足这些条件。</p>
</div>
<div class="paragraph">
<p>现在我们挨个走一遍：</p>
</div>
<div class="paragraph">
<p>1.AccessKeyId</p>
</div>
<div class="paragraph">
<p>校验：1.是否存在2.长度要求3.固定长度的4.格式要求</p>
</div>
<div class="paragraph">
<p>AccessKeyId有效值校验是在数据库里。</p>
</div>
<div class="paragraph">
<p>这个地方我们讲的是HTTP接收校验，意思就是说不能查数据库，我们现在的层次是HTTP接收，数据库有没有效我们不管，我们只需要保证前面的。</p>
</div>
<hr>
<div class="paragraph">
<p>2.SignMethod</p>
</div>
<div class="paragraph">
<p>校验：1.是否存在2.长度要求3.校验是否存在奇怪的字符4.取值有效范围就用枚举实现</p>
</div>
<hr>
<div class="paragraph">
<p>3.SignNoce
校验：1.是否存在2.长度要求3.必须由数字组成</p>
</div>
<hr>
<div class="paragraph">
<p>4.TimeStamp
校验：1.是否存在2.不能小于今天3.必须由数字组成4.转换出来是不是有效的Java时间对象，然后判断一下比当前时间是否相差至少15秒。</p>
</div>
<div class="paragraph">
<p>但是这个15秒属于接受校验，因为如果超过了15秒就属于错误的URL
但是上面那个AccessKeyId就不属于接收校验了，因为要查数据库，它属于深度的业务教业，判断用户名是否存在。</p>
</div>
<hr>
<div class="paragraph">
<p>5.Signtrue
校验：1.是否存在2.长度要求3.校验是否存在奇怪的字符4.校验接收的和生成的是否一致</p>
</div>
<hr>
<div class="paragraph">
<p>所以你只要TimeStamp那个能理解,那Signtrue也能理解，但是有个问题:你要验证Signtrue之前你要先验证AccessKeyId，套娃就套起来了，但AccessKeyId要查数据库，所以在做纯接收的时候，你做不了Signtrue的校验。</p>
</div>
<div class="paragraph">
<p>所以校验分两种，包括刚刚说的那个15秒，上面常见的存在/长度/格式/是否有效这些东西叫值校验，意思就是基于字符串本身做校验，那刚刚还提到了一种更深度的校验，就是逻辑校验（业务/功能）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_逻辑校验">19.10. 逻辑校验</h3>
<div class="sect3">
<h4 id="_数据库查询类">19.10.1. 数据库查询类</h4>
<div class="paragraph">
<p>我们这个地方讲的是API，肯定就不是业务，讲的是功能，那刚刚有几个不确定的校验，第一个就是AccessKeyId，那包括的就是第一种数据库查询类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_有效时间校验">19.10.2. 有效时间校验</h4>
<div class="paragraph">
<p>然后第二种是刚刚那个15秒，其实15秒划给值校验也是可以的，因为他也是属于校验URL是否有效，如果把他强行分成值校验和逻辑校验，他肯定是属于逻辑教研，说白了就是自变量：长度/格式/是否存在这些是属于值的，比如说数字，也属于值，因为那是写死固定的，但是动态的，比如这个15秒是你可以改的，因为它和URL没有关系了，所以说15秒的情况可以总结为有效时间校验，属于逻辑校验的一种。</p>
</div>
</div>
<div class="sect3">
<h4 id="_综合判断">19.10.3. 综合判断</h4>
<div class="paragraph">
<p>第三种情况叫综合判断。</p>
</div>
<hr>
<div class="paragraph">
<p>所以参数校验严格意义上分成两类，我在写代码的时候，我也会把它分成两类，但逻辑校验可能隐藏在某些代码里头，和值校验没有关系，逻辑校验是一定要做的，说白了一个再差的程序员都会做其中一部分，反而值校验是优秀的程序员才做的，因为值校验不管做不做都不会对交互产生影响，但是逻辑校验不做的话就会产生很大的错误，而且值校验对系统没有危害，为什么？你看不出来，逻辑校验就直接系统不按预期工作，就是Bug，软件测试都能测出来，但我没有见过几个专业的软件测试测值校验，不要太相信那些测试，他们一天就点来点去，如果你不要求他，是不会测值校验的。</p>
</div>
<div class="paragraph">
<p>那这两个校验怎么实现呢？是这样的，做这个校验，工作量真的很大，你每次加个参数可能要加很多个类，相反比起IF，是个程序员，都会选IF，但是IF有一个致命的问题，就是你的逻辑每次都是散的，为什么？我们刚刚讲了五个参数，他的校验方式都是不一样的，对长度的要求，还有对有效值的判断，那个代码写法是不一样的，这样就会导致什么看起来都是IF/ELSE，代码里面怪怪的，为什么？每个IF东西都不一样，如果全部都是长度判断就贼简单了。</p>
</div>
<div class="paragraph">
<p>那么首先你要从大逻辑上解决这个问题，做参数教验大的逻辑是什么？既然叫参数教验，肯定针对的是参数个体，为什么？你校验的时候是一个一个校验的，所以说肯定是基于参数个体挨个校验，至于这个调教验要分几类，管他的呢，挨个都校验，只是这个校验函数是空的，永远返回true，但是步骤是摆在那的，那这样的话是是所有参数步骤都是一样的，那是不是就可以写成刚才的工厂模式了，这个和刚才叫车是一样的步骤，这里参数校验步骤都统一出来了，但是函数里面细节不同，策略模式以后再说，现在太早了，策略模式和这个不一样，这个地方你要先创建校验的对象，有了校验对象过后剩下的才是其他模式，而工厂模式是专门用来生成对象。</p>
</div>
<div class="paragraph">
<p>所以这个地方的我针对的的重点是：校验参数个体，那既然是个体，就应该每个参数对应一个类，就是那个参数类，那你现在有个疑问：就一个参数，至于搞个类弄他吗？不觉得好麻烦吗？写个代码还要去分析这些。</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>假如你代码写完了，那请问你的代码拿到别人的电脑上能工作吗？那我的代码为什么能拿到你电脑上的工作？那是因为定义Java的版本，Maven的版本/动作所有都的统一了，然后使用方法就在单元测试里面。</p>
</div>
<div class="paragraph">
<p>所以至不至于这么做的目的前提条件是你的软件项目能生存多久，如果软件只跑三天就删了，就不要搞这个，要是你要跑三年，而且你的代码是团队协作的话，请你搞这个，如果你的代码永远只有你一个人用，不要用这个，所以说，现在是在提高你的上限，至于下限多低，看情况。</p>
</div>
<div class="paragraph">
<p>那我先用AccessKeyId来举例，我们现在在写一个叫Accesskidparam这个类就表示参数的意思，然后我的构造参数，接收的是那个支付串，说白了Java帮你接收了总的参数，所以这个东西啊，一定不是只接受一个参数。</p>
</div>
<div class="paragraph">
<p>那这个类的全称就是AccessKeyIdParamChecker，Checker就表示验证器，那参数教验他的初始化参数就应该接收那个字符串，因为那个Java接收的都是的是字符串，当然你也可以接受Int，记住：如果我们要用自己的报错，那个Java接收的对象的所有类型必须是字符串，如果你声明成数字的话，他不仅不传数字还会报400错误，这样用户就看不到你错误了。</p>
</div>
<div class="paragraph">
<p>接着往下走，他的构造函数就写出来了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>AccessKeyIdParamChecker(String s)</pre>
</div>
</div>
<div class="paragraph">
<p>具体实现就不管他了，你肯定要去接受一个参数，然后肯定还有个l类成员去把这个参数保存下来，那这个地方就应该有一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>String value;</pre>
</div>
</div>
<div class="paragraph">
<p>默认是这样的。</p>
</div>
<div class="paragraph">
<p>然后把这个代码写完：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>value = s；</pre>
</div>
</div>
<div class="paragraph">
<p>这样就保持下来了。</p>
</div>
<div class="paragraph">
<p>那上面的写完后，还要写方法：</p>
</div>
<div class="paragraph">
<p>1.是否存在
数据库查询类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Void exists（）{

}</pre>
</div>
</div>
<div class="paragraph">
<p>代码里面的逻辑我就不写了，我觉得里面的东西每个都不一样，没法挨个写，就说白了你要判断这个value是不是等于空指针或者空字符串，如果等于那就认为不存在。</p>
</div>
<div class="paragraph">
<p>2.是否长度要求</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Vodi checkLength（）{

}</pre>
</div>
</div>
<div class="paragraph">
<p>3.校验格式</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Void checkFormat（）{

}</pre>
</div>
</div>
<div class="paragraph">
<p>4.校验有效值</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Void checkValue(){

}</pre>
</div>
</div>
<div class="paragraph">
<p>那么不管是校验类型，取值范围都是在这里面做的，那如果你有n个这个类，这个时候你怎么去调它？然后怎么结合起来，现在是用那个Spring Boot接收了一个完整的对象，里面包含了所有的参数列表，就相对来说每一个参数列表都要调用上面那个校验器。</p>
</div>
<div class="paragraph">
<p>我们就先按这个记流水账的方式写，那相当于是说要初始化校验器，简称校验器为Checker：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Checker a = CheckerFactory.setcherk()</pre>
</div>
</div>
<div class="paragraph">
<p>那么传过来过后，你要怎么调呢:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a.exists（）

a.checkLength（）

a.checkFormat（）

a.checkValue（）</pre>
</div>
</div>
<div class="paragraph">
<p>现在有个问题，我没有把那个返回值用起来，因为这个地方，如果全部反布尔值看起来有问题，为什么？因为IF判断布尔值贼麻烦，这个时候就直接抛出异常，然后在外面捕获，这样更简单暴力。</p>
</div>
<div class="paragraph">
<p>然后这个地方我就写一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Catch (Exception e){
    return ....
}</pre>
</div>
</div>
<div class="paragraph">
<p>这里面的message随便写，就是提示用户说你参数少了，其他都是一样的，然后在调用它的地方用Try框起来，然后我就往下写，这是一个参数校验的逻辑，第二个参数检查跟他是一样的，只是在这个地方构造的时候，看起来可以用工厂模式，跟刚才一样，这地方是个Factory返回一个校验器，校验器把提成interface的方法，那调用他的就是个interface，而这个工厂返回interface去包住这段代码，那这个地方应该实现某个接口，有切克的接口嘛继承接切克嘛可不可以啊那这地方就是切克切克a等于什么切克工厂
然后就这个时候，工厂里头有一个get，我就直接写get切克啊括号码参数然后最后你既然这段代码你是解决了一个，但个体那你下面只需要写一个或循环参数列表吗或循环什么lenglish这个历史的就是参数列表上啊，这是个体嘛然后就个体就相当于是说把这个代码写到这里，回来，你哪怕有无数个参数，你只需要加什么加factor里面那个查询表你发现没有这个，这个代码已经不是新手代码了早上我都还是存新手到了现在已经不得不能要了就是看懂一点点啊，参数教练我就讲完了</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_SJKYL2_chapter">20. 数据库原理（二）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_19">20.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/数据库原理(二)板书1.jpg" alt="数据库原理(二)板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数据库原理二">20.2. 数据库原理（二）</h3>
<div class="paragraph">
<p>数据库不是个孤立的东西,之所以为什么数据库在国内至少到现在为止，没有一个大家主流接受的一个公司或者一个人能做出来，是因为数据库跨了存储文件存储系统、网络IO、操作系统甚至有些做得极客的地方还会针对cpu或者操作系统做优化，最关键的是，它里面有非常非常多的算法，什么意思？比如你写一个查询，每次稳定到200秒输出结果，这非常ok，但是你要把200秒提升到0.2毫秒。这个就已经是跨数学了，可能会用到很多数学知识,这完全就不是人干的事了，只有大神才能Hold住，说白了谁发明的操作系统的，谁就能写数据库，是这样的，去看那些做数据库的人，他们很多都是做操作系统出生的，所以数据库不是一个孤立的东西，在你学习的时候，不要想着把MySQL所有东西都学完，就只学你要的那部分，学你关心的那部分，就比如说数据库是怎么解决网络收发的问题，你关心那个干嘛？难道数据库只能用网络收发，就不能用Socket通信了？只不过用Socket就只能在本地，然后再就加一个Nginx基于Socket做个反带，我就问你，我可以给予80端口查数据库吗？那那个网络也不是必须的嘛。</p>
</div>
<div class="paragraph">
<p>那第一点是什么？刚讲了那么多，我们通过举例子来，就不那么文绉绉的，就是由一个问题引发出后面一系列的问题：</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Select * from table;</pre>
</div>
</div>
<div class="paragraph">
<p>执行这个查询后肯定会返回一些东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0.2S
100000 rows</pre>
</div>
</div>
<div class="paragraph">
<p>那这100000行，用了0.2秒，那请问可以把它速度再往上提吗？前提是什么？第一个你要知道你需要查那些列，这个时候你就会优化这个SQL里的*：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Select id from table;</pre>
</div>
</div>
<div class="paragraph">
<p>那假设现在这一个语句从0.2秒变成了0.095秒，可能还是有100000条,那还能继续做优化吗？优化可以限制查询的数量或者加一个索引，那问题来了：为什么限制数量过后它会快？为什么只查和不限制一个慢一个快？我们忽略掉MySQL打印那么多东西要花的时间，就假设在MySQL里面，内部处理时间等于零，那你查询100万条和10万条，为什么10万条快？想过没有？可能会说10万条明显数据少一些，所以这里面就涉及到文件IO了。</p>
</div>
<div class="paragraph">
<p>所以这个地方做优化有两个手段，第一个：索引，第二个：限制数量，其实你会发现这两种优化手段的角度是不一样的，但是我们现在不讨论什么是索引，我们现在就假设你已经知道什么叫索引，那第二个刚刚说的数量其实是解决了一个文件IO的问题，那什么叫i，o啊？全称是Input、Output，这个地方的文件IO指的是FileSystem Input、Output,说白了就是他最终会找导致硬盘去读东西，所以如果孤立出现I、O，我们一般指的是硬盘，但是如果出现在嵌入式中，那个I、O一般指的是串口，就比如显示器后面有个口子，插上去，这就叫I、O，所以I、O出现的位置、场景不一样，对应的含义也是不同的，看起来就是通过减少文件读写或者说是减少文件I、O的消耗。</p>
</div>
<div class="paragraph">
<p>那索引呢？上面是减少数量，最开始读10万条优化后读1万条，就已经影响到结果了，而索引其实不影响结果，可能大家脑子里有这个意思，那我们现在把这个范围扩大一下，你不要限制在你杯子上面，我就问你一个问题，看起来你说的是Hash表结构，那MySQL里面肯定没有HashMap，肯定是没有Java那套，他也不大可能说在内存里面写个Hash表，这一重启索引就失效了，不可能吧？那现在我假设他有一张Hash表，那这张哈西表在哪？我们就来推啊，现在我直接告诉你他在硬盘上，那在硬盘的哪个地方？问你个问题吗？加了索引之后是不是可以通过Show index查出来，我就这么跟你讲如果你不会Linux，那今天这节课我没法上，就是现在我假装大家都会Linux，假装大家都知道文件系统，比如NTFX，Xfs，假装大家都知道，如果这些技术条件你不知道的话，我这个地方没法讲。</p>
</div>
<div class="paragraph">
<p>那我们就开始用推论的方式来推，因为这个我也没有仔细去想过，我只是突发奇想举个例子：首先我刚讲过我用了SQL基本上就能猜到后面，我们现在通过索引也是一样的，索引是create index，数据表来也是create table，查数据表表是select，索引是Show indax，看起来Show index是查的具体索引的内容，那看起应该有个玩意可以把所有索引查出来，不然我Show indax在哪去找的，这样你就会发现那个表的使用跟那个索引，虽然他们亮东西不一样，但是你会发现，他们对于MySQL的操作入口是一样的，可能对用户来说是不一样的，但对MySQL来说看起来是一样，你要是不信就直接监控你的硬盘，你如果查index的时候他肯定消耗I、O。所以你的索引、索引数据就是那个索引的名称、哪两列，它是你保存在MySQL里头，他首先不是保存配置文件，我就直接不卖关子告诉你，索引是保存在他的存储引擎里面的，你的数据库的表在哪，你的行的记录在哪个地方，索引就保存在这个位置，所以要回答什么是索引，只要回答完这个问题，基本上MySQL原理，我们就讲完了，为什么？因为回答这个问题，首先要讲存储引擎，我要讲出自引擎，然后再讲Linux文件I、O，然后还要讲了在存储引擎里面是怎么去存数据的，MySQL的数据是怎么存的，表数据是怎么存的，索引怎么存的，因为你都讲存储引擎了这些能不讲吗？但如果脱离操作系统单独来讲存储引擎，得写100篇论文，毫无疑问，但是今天我们不是论文比武大赛，我们是想搞明白，所以这个过程当中，我们就从多维度来观察同一个东西。</p>
</div>
<div class="paragraph">
<p>所以这个地方索引，他英文叫index，是他创建语句是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Create index ....</pre>
</div>
</div>
<div class="paragraph">
<p>然后查询单个索引的话是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Show index ...</pre>
</div>
</div>
<div class="paragraph">
<p>语法就不具体写了，巧的是，数据表也在用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Create table ....</pre>
</div>
</div>
<div class="paragraph">
<p>查询表也是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Select ......</pre>
</div>
</div>
<div class="paragraph">
<p>这样你会发现在MySQL，他把这个封装成差不多的操作方式，肯定就是为了你方便，那我问你个问题，他用一样的操作方式，很大可能性他的存储的结构是一样的，首先我们在讲索引之前你得先把表是怎么存在讲明白，所以你得先明白什么叫存储引擎，表是存在存储引擎里面的，所以这个就是第一个啊就是二啊。</p>
</div>
</div>
<div class="sect2">
<h3 id="_什么是存储引擎">20.3. 什么是存储引擎</h3>
<div class="paragraph">
<p>首先为了方便，我就把存储引擎简写为EG,那之前我们确定的事情是：1.数据表是存在存储引擎里的，存储引擎相对于文件系统来说是一个“大文件”。那还有什么？，索引和表也是一样存在存储引擎里，那现在就有人问了这个EG是个啥？这个其实很简单：</p>
</div>
<div class="paragraph">
<p><code>存储引擎相对于文件系统来说是一个“大文件”。</code></p>
</div>
<div class="paragraph">
<p>这里的文件系统肯定指的就是说可以是Xfs或者NTFS，相对来说，它是个大文件，大文件平时在Windows最大文件可能是某些电影，4K的可能有40个G，其实这里和大文件和那个电影本质上大致是一样的。</p>
</div>
<div class="sect3">
<h4 id="_视频播放器">20.3.1. 视频播放器</h4>
<div class="paragraph">
<p>这里建立概念了，接下来谁告诉我MP4或者MKV或者是AVI这些文件的播放器干了啥，首先你怎么看电影的？双击视频文件，这时如果你的文件很大，它就会有个读取的过程，那在这个过程中读取的是什么数据?那肯定是读取他自己的内容，为什么举这个例子？因为刚才有人跟我说顺序读写，难不成你还能跳着读？你的播放电影还能跳着播？就你不要说什么顺不顺了，说白了就是用户想看哪个位置拖进度条就行了，那数据库可以拖吗？数据库有进度条吗？但数据库 有记录行数，简单说一下播放器怎么播放电影的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.双击。

2.播放器自动去打开文件。

3.打开过后会调操作系统的Read函数。</pre>
</div>
</div>
<div class="paragraph">
<p>他的open的时候，肯定加了文件参数再加个“R”，意思就是只读嘛，并不是说放一次就坏了，你以为你是dvd，还加了点灰尘啊。</p>
</div>
<div class="paragraph">
<p>如果播放器发现文件很大的话，双击过后那个播放器就会在转，它还在等，等什么？在等你的电影文件从硬盘上加载到浏览器播放器里，看起来这个播放器他肯定不是加载40个G，你的电脑那个内存一共才八个g，要加载40个G是什么概念？，所以播放器绝对不是那么傻，播放器肯定是只加载一部分，比如说他每一次加载的时候加载20秒或30秒的文件就可以了，那他是怎么知道是20秒还是30秒？假设是MP4文件，播放器就知道应该读多少帧，因为MP4是按帧数来的，比如读1000帧，那就是啪啪啪啪啪读了过后播放器就把那第1000帧解码成画面，因为你知道的有些播放器不带解码器，你发现播不了，但你装个MP4、MP3的解码器他就能播了，说白了读文件是先读后面才解码，所以他读的那个固定长度可能是有一个大家约定的这么一个缓冲区，可能是两兆，也可能是二十兆，但是他一定不是按帧来的，因为播放器缺少解码器的时候，播放器其实已经打开文件了，而且你发现他要读文件，他肯定要读一点点，然后再把这东西传给解码器解码，解码器解码了过后解不出东西，挨个试都解不出来，然后就报错。</p>
</div>
<div class="paragraph">
<p>所以播放器其实很简单，那个说明解码器很值钱，所以你要是发明了MP5标准,然后卖给那些人或者开源，你就挣钱了，大家都用你的标准。</p>
</div>
</div>
<div class="sect3">
<h4 id="_存储引擎">20.3.2. 存储引擎</h4>
<div class="paragraph">
<p>播放器搞懂了，我们再回头看存储引擎，既然播放器和存储引擎在保存形式上面都是一个大文件，那这个存储引擎的文件和电影文件有什么区别？刚刚说了电影文件是通过编码器解码器，它有编码，巧了，存储引擎也有编码，这个世界就是这么怪，你只要懂了协议啥都懂了，之前我们说协议就类似一本说明书，那MP4如果没有说明书的话播放器能播吗？不能，所以那个解码器里面实现的是说明书上的功能，翻译，就相对说播放器自己是不带说明书的，他需要有一个人帮他按照说明书把它翻译成他那个播放器能懂的画面，说白了，你在做格式转换，转换成播放器认识的，播放器只认识0101,那为什么要带编码，不直接保存0101呢？因为编码可以压缩，这么做就是为了省空间，要是空间无限大谁还发明MP4格式,直接存，比如说那个相机单反你拍过有raw原始格式，原始格式随便怎么放大，它没有失真的,但是你用JPG导出来一放大,那个像素点就出来了。但是你用png机会好很多，因为PNG太差了，压不了，为什么？因为PNG他说自己是不失真但是又带那么一点点压缩，但是jpg是全损压缩，是真压缩，是对图片做了处理的，而PNG他还要带那个透明图层，他是有很多其他的东西的，说明他做的工作挺少的，协议各有各的特点，你一旦懂了格式这玩意儿,其他就很好理解。</p>
</div>
<div class="paragraph">
<p>同样的，协议也是一种格式，然后这个地方是MP4格式，然后存储引擎也是有格式的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_格式">20.3.3. 格式</h4>
<div class="paragraph">
<p>那讲到格式了，这地方有MP4,MP3，还有AVI，假设不一定是电影嘛，那我现在问那个问题：为什么不讲MKV？因为MKV还可以再压，MKV是在这个外面再压了一层，压缩的压缩，但是AVI是不带压缩的，比较原始，是第一层，但是RMVB那个玩意儿压的也挺厉害的，所以AVI你会发现文件很大，MP4的话大概容量小一半,但是你发现更有意思的同样是MP4格式，有些是用H265压缩的，你会发现本来是1.9个G，用了H265大概就是一半,更夸张，然后你会发现那个MKV在外面在包了一层，你不管MKV做了啥，他包了一层，看起来不仅仅是压缩或者没有压缩的，但是你想为什么他不用MP4要弄成MKV那肯定是有原因的。</p>
</div>
<div class="paragraph">
<p>那既然视频文件有格式，那其实存储引擎也有格式，如果MySQL举例的话，当前大家在用的格式叫innerdb，以前叫myisam，这玩意儿就是个垃圾啊，不支持事物，不支持存储过程，还锁表，然后innerdb肯定是解决了这些问题，所以MySQL被更多人接受，他有两个阶段，没有数据库，能够在PHP里面读，当时PHP那么流行，要个数据库配合，刚好PHP无缝用MySQL，大家用它，最后发现很多问题，没有事物，没有很多东西，这个时候就只能在PHP里面用，但是MySQL自从用了innerdb后，更多的人接受他了，太简单了，有典型的数据库的事物、存储过程、锁行，而且性能肯定也是有提升的，还有索引，说白了就是各种都有提升，那么用Java也可以用MySQL了，相信在那个之前用Java的人还是会说要不用Orcle或者PostgresSQL，MySQL应该就没有那么流行，所以他分成两个阶段，一个是电商流行的时候，然后第二个就是电商热已经过了，Java火的时候，那么MySQL份额应该会更大，但是如果他还是用myisam，我相信会更少人用,也不是说没有人用，会更少。</p>
</div>
<div class="paragraph">
<p>所以在这个地方，电影有格式，那我们的存储引擎也是有格式的，那现在这个存储引擎是什么？我们开始下定义了，存储过程就是：</p>
</div>
<div class="paragraph">
<p>一种用数据库存储格式保存的大文件。</p>
</div>
<div class="paragraph">
<p>这个地方保存的意思就是那个内容里头就是有编码，就非常明确了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_存储格式">20.4. 存储格式</h3>
<div class="paragraph">
<p>刚才电影的存储格式是MP4,存储引擎的存储格式看起来就有inner db。</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>假如我是发明MP4那个人,我们就把那个电影文件展开讲，比如说哈这个地方是一个MP4文件:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/MP4.png" alt="MP4">
</div>
</div>
<div class="paragraph">
<p>在这个前头位置，你要写上我是MP4，然后用的是MP4的h256编码做的，还要告诉别人这个文件的总大小，比如说是100个字节，不然的话，你那个电影文件可能觉得屁股空白后面去了，用这种套路，最终他在后面就会填，比如这里我就用0101表示，有100个字节，之所以它为什么在开头写上这个总字节数，是因为万一这个文件屁股后面多了两字节，他可以说：“对不起，MP4文件播放错误。”好巧，你用BT下载的时候，很多时候都会出这种错误，多了两个字节，少两个字节就放不了，但这个时候你可以用vlc强行放，但是有时候拖进度条会报错，为什么？因为你的字节数不对，你拖的时候，他可能有些地方要按百分比算位置，结果拖两下他就迷路了，为什么？因为你少了两个楼梯。</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>你走楼梯走着走着少两阶，我就问你你摔跟斗吗？你100%摔？都不用讲为什么，因为你的脚已形成条件反射了，找楼梯每次用力要均匀，你一脚跨下去突然少两节，你1000%当场摔地上，还有一种情况就是，和这楼梯相关，和数据库没有关系，走楼梯的那个台阶突然从五厘米变成了七厘米，很多人踢脚背，就撞地上去了，摔在那个地方也是摔,只是一个朝下一个朝上，有个视频怎么样，那个台阶我就不说了，台阶故意高了1节，你说矮了一节就算了，是这样的，你从下面往上走，他高了一节，你是踢到那个地方往前倾，结果你跨下去，他突然高了一节，一样的你从上面往下走，你会发现你踩的时候，踩空，为什么？因为你的预判是五厘米，你的脚用力的时候是用在五厘米那个位置的，结果一脚踩空，而刚好那个人又挺坏的，前面有个限高杆，所有人的撞上去，为什么？因为大家都喜欢看手机，可香了。</p>
</div>
<div class="paragraph">
<p>那又回到这个地方，所以他一定会在头的前一行或者头的固定字节用这个套路，用这个套路地方很多，打个比方有没有人装过Windos系统，装过Windos就有个索引mbr,有时候Windos起不起来，到了黑区区的窗口那个地方,因为在你的硬盘最开始的位置,那个地方就写了mbr大小多少？是什么类型的启动盘？用哪种类型启动，然后Linux比如说有人把Arch给搞崩了，没事弄好就好，为什么？引导重新装一遍，把那个分区文件的头重新覆盖一遍,用Pacman去装那个引导Grub，装完过后他就会把头覆盖一遍就好了。</p>
</div>
<div class="paragraph">
<p>所以各个文件类型都是一样的道理，大家都是，不管是PNG、PDF、word、zip都有，全世界都是这么干的，那这么理解没毛病的，打个比方，你怎么知道抓包的时候是一个HTTP包？很简单，开头是get、post、delect、update除了这些以外的都不是，所以这个地方是一个枚举值，然后这个时候用get开头，屁股后面是/r/n换行的，那肯定是HTTP，当然你要求更详细一点，就是中间怎么割的，必须版本号之类的，那再说,但是开头你是能确定的,像我们公司写代码，两代协议混在一起，混出来的那个东西叫7b，7b就表示是某种数字嘛？然后他转成数字就是比如说195，结果我正常的内容里面有个东西刚好是叫七b，结果就出现了此7b非比7b,然后就报错了，后面一解析，啪啪啪全错了，那个包都不能用，我们现在就是因为这个头痛，所以我们现在的解决办法是先按七b的协议解析一遍，如果报错，我再按另外一个方式解析，但是如果我把数据调过来，你会发现一切全错了，一样的道理。</p>
</div>
<div class="paragraph">
<p>所以你看，他没有那么巧，我刚刚举了那么多例子，全世界都在用着用这些文件头，所以这个地方你可以理解我有个东西叫文件头，我刚刚讲了Windows的启动盘有MBR，然后包括你的DOS分区，包括你的PNG等等基本全世界都有了，那现在有个问题，innerdb格式开头也有这个东西，以此类推嘛，我们可以马上在那个MySQL的上面，打开这个文件的前面去看，一定有特殊的标记，你把不同服务器上MySQL的文件打开都有这种，甚至可能是MySQL的版本号，比如说他是1.0版本还是2.0版本的格式,1.0版本的格式和2.0肯定不能互通,那能互通我升级你干嘛呀？一定是你有缺陷，所以这个时候，那么innerdb也有文件头，我说这个的意思就是说我要画一个出来，而且看起来这个文件，他应该也要写自己的长度，但这个文件，它是一直在变大，但是这个变大很有艺术，我猜测是这样的，因为我有MySQL配置的时候，他的这个你用ll命令去看，不要用du命令哈，因为ll命令去看你会发现这个文件明明只有几k，但是因为ll命令能算出几十个g出来，用ll命令 看是系统分配给他的文件属性里面叫大小，文件属性里面那个大小30个g，但是用du命令查出来的时候叫占用的磁盘空间大小， <code>占用</code>，注意这两个词哈是不一样的，所以我有合理的猜测这个地方的大小是他那个Mysql改了个配置，重启过后立马就创建了Innodb这个文件，那个时候就写死了，这个大小都是不会随便改的，因为改会改错的，你想嘛，每个人都在改一遍，以谁为准？最好的方式就弄在这儿不动了，所以有个参数就那么巧叫innodb filesize，或者叫innodb size，你不觉得那么巧吗？你手动去改这个大小，当然没问题，但是有个问题就是，这个如果文件有人用呢？你要去占用这个文件去改这个文件系统上这个文件的大小，数据库卡死了吧，你都把数据库停了那谁在改啊？你手动改当然也不是不行，手动把这个值改了，改完了过后把这个文件在Linux下面把它改大，我们叫扩容，这就有个问题了，你是简单的在屁股后面加空白吗？加000吗？你怎么保证你不影响这个这个文件的正确格式被解析出来？万一你改完了过后他结格式乱了呢？所以你需要，你需要一个有东西叫innodb-tools，简称扩容工具来做，是官方给你出吗？所以按正常逻辑设计来讲的话，这个值是不会轻易去改它的，相反，他会在创建文件的时候就把这个分配好，就把这个写死，但是呢不占空间，为什么？因为后面全部是0，记住，一个文件里面如果全部是这种空白符的话，它是不占用空间的，但是巧了，你用cp参数默认去拷他去copy他，对不起，他那个0他会重新给你分配一次空间，你会发现原来是那个文件10m你copy出来有30个g，你是不是可以搞别人？懂意思了吗？然后你在U盘上放一个10m文件，对，就是我U盘上那个30个g的，你拷出来他拷出果然30个g没骗我，但是U盘只有2g。然后你又跑去骗记者，我发明了中国独特的有专利的压缩算法，能把30个g压成2g，你看你看了没有，其实我讲了那么久和Mysql半点关系都没有，你发现是这样子，我讲到哪个地方和Mysql有关系？你告诉我，除了这个名字以外哪个地方和Mysql有关系？哪儿和Mysql有关系，你告诉我，你会发现，这个时候我们是上文件系统课，所以我讲过的写Mysql数据库，或者Psql，SQL Server这些人全部都是搞文件系统的，全部搞操作系统的，只有这样的功力，你才hold得住，为什么？就这个东西我都要花一个小时给你讲明白，你不觉得Mysql离你有点远吗？</p>
</div>
<div class="paragraph">
<p>所以这地方他默认填0，后面是这样的，我打个比方是，现在我创建了一张表，你这个文件那么大，是不是有些地方应该用来存表？比如说这个地方用来存表名字，那有些地方应该存数据，然后有的地方好像是用来存索引的吧？现在有个问题了，你咋知道点地方存索引呢？你想过这个问题没有？说白了我们分区间，我们我先全部填充成，我等会来讲，所以我先把它写出来，这个时候哈这个地方我们会分区间我打个比方我直线的地方我假设它存的是table，我比如说打两个直线的这个地方的表示存的index可以吗，我假设我用波浪线的表示表的数据，可不可以？现在有意思了，你咋知道从哪个地方开始是表？你咋知道从哪个地方开始是那个表的名字呢？是不是有这个问题？你想吧，程序员是逻辑非常严谨的一种一种生物，他会做一个这种无厘头的事情吗？不会，所以这个时候存储引擎有两个文件，这个文件叫Data文件，叫数据文件，还有一个文件叫Log文件，日志文件，我就问你个问题吗？我这个地方可不可以用一段一段的表示？什么意思？我打个比方：</p>
</div>
<div class="paragraph">
<p>我创建了一张表，我就用逗号分割，我怎么写？我就假设最后创建一张表嘛，我就写一个table-pos=101可不可以？当然写的是是二进制哈，你翻译完了？翻译成你的英文可以写成这样子吗？在101是啥吗？就Data文件第101位置，这叫起始位置，是不是应该还有个长度？从1开始长度为10就是1+10就是11，那么你起始位置是不是应该有个长度位置？所有还有个长度，长度200，这样的话 你是不是就知道某一张表的位置了？然后那张表叫什么名字呢？要么你在这个地方加点复杂的逻辑，要么你再写个叫table name position，然后至于他们之间的关系，你再去对应一下，这个Log文件是不是可以做很多事？就是这个里面只有数字，位置，长度这些东西，最后这些位置拼在一起。</p>
</div>
<div class="paragraph">
<p>而且我敢打赌，索引的信息应该也在里头，你想吧，你存表的时候，insert的时候，update的时候，delete的时候，那个位置已经改不了了，你想比如说你的电影放到D盘，你能无缝的移到c盘去吗？不能，因为你要用移动命令？那现在改位置？但是你加索引是不是很快。我们倒着推，加很快就意味着没有挪位置，没有挪位置他是怎么加索引的，只加了Log，我就简单一点写嘛，这个地方就写一个叫index，比如说我们的index是叫a，a等于table，101.50个长度，我写的就很简单哈他实际上肯定比这个复杂多了，那这样的话我是不是能算出索引的位置，我知道他是个索引了，然后我都有a了，我能不能有a1、a2?加索引这么一加Hash表就构造出来了嘛，他最终是不是构造个Hash表嘛？只是说他在Hash表的这个数据放在了硬盘上，Mysql启动的时候可能要加载，你看到没有我这么一讲，你会发现我从始之中我就没有讲过Mysql专业知识，所以你发现有个Log文件和Data文件好了。</p>
</div>
<div class="paragraph">
<p>如果你自己要做一个类似于Mysql或者Redis这种东西，Redis也有这个，Redis那个文件里面你不管他是分成了一个文件还是分成两个文件，他一定有这种角色的东西。ES绝对有，你想嘛？我打个比方Mysql他有时候，他会因为硬盘问题宕机?或者断电？那个时候正好在写某条数据，但是你发现不会因为断电就是那种确定保存好的数据，你从来不会掉，为什么？除非那个硬盘刚好坏在了Data文件这个位置，但是你只是宕机停电了你会发现没有丢数据，为什么？因为数据在写之前会保存到Log文件里头，因为这里面有个buffer，放到buffer里面的东西他是不会告诉你保存成功的，只有把buffer里面东西写到Data文件里面，操作系统返回说，我写完了，然后他写完了过后，这个Log里面添加一个ok的记录，然后这个Mysql就会返给你说保存成功，你会发现insert它就ok了，如果刚刚保存到Data这个文件，然后你会发现Log文件还没有来得及返给你断电了，没关系，你启动的时候Mysql提示说有章数据请运行repair自动修复，他就读这个里面章数据，什么叫章数据？就是出正在处理当中的但不是ok的，他把那个数据重新确认一遍，保没保存嘛，但是你把这Log文件一删，我跟你讲，你白搭，为什么？因为你只有Data文件，当然我说这个很绝对哈，我只是假设我把Mysql做了简化，实际上他保存索引的时候你会发现这个Log文件是可以删的，我只是在故意偷换概念，一定还有第三个这种文件，为什么？因为这个刚才的索引呢可以放在前面的位置？约定前第100m，从0-100m全是放索引的，全是放这种东西的，你就固定加在那100m，100m以后的都是Data，你是不是也可以算位置，我刚刚把这Data文件和Log文件故意分开，我现在把它合在一起，你也可以理解这个概念，所以现在的Mysql我告诉你那个Log文件是可以删的，当然你要确定你的数据一定是保存完了的哈，所以你要去造一个数据库，或者这种类似保证那个数据一定保存成功的是不是也要按这种逻辑去做？比如说你是kafka，哎呀，好巧，kafka也有这个东西，那真太巧了，那肯定RabbitMQ也有，但凡说他不丢消息了，能够持久化保存的，都有这个东西，就是这种东西，通常他们就会叫Log File，不会有很特殊的名字，这种Log File叫Data Log File，他就来做这种保证数据不丢，因为你kafka重启过后你发现你消息是没丢的，没有消费的消息是没丢的哦， 但是你没用过，你可能现在不清楚，以后你就明白了，所以你就以后就不要去学kafka为什么不丢消息？你就发现了网上至少用3000字来解释了这个问题，他那种丢是消息本身丢了，都还没进到kafka，就是发出去了没收到。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ORM_chapter">21. ORM原理</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_20">21.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/ORM1.jpg" alt="ORM1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ORM2.jpg" alt="ORM2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是orm框架">21.2. 什么是ORM框架？</h3>
<div class="listingblock">
<div class="content">
<pre>O:Obiect          对象 &lt;-----&gt;类(A)的一个实例
R:Relational      关系 ------&gt;关系型数据库
M:Mapping         映射 ------&gt;表结构的映射类(A)</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方我们讲肯定是讲的ORM框架，我肯定指的不是说一个ORM本身，我肯定是特殊到具体框架，这种框架有JPA、Hibernate、Mybatis，那当然我讲这个东西，我可能就开始讲Mysql driver了，我就拉通了讲，就是从一个数据库，他躺在硬盘上面，你怎么把读出来的，那天其实有讲但是我把这部分故意漏掉，为什么？那天我是忽略的Java语言的。</p>
</div>
<div class="paragraph">
<p>那如果是ORM框架的，肯定先解释什么是ORM，再解释框架，然后现在先忽略框，那这个地方我就比如问你什么是JPA，你把JPA解释明白了这个就解释明白了，那什么是JPA？什么是Hibernate？什么是Mybatis？我记得那个框架的英文是怎么写的？framework。首先，框架你肯定不知道，而框架这个词，在我们的古汉语文言文里头，他一定没有计算机框架这玩意儿？那证明这个是一个舶来词，是个新词汇，出现在60年代过后，2000年也是60年代过后，就是计算机诞生过后，编程语言诞生过后才会这个东西，那这地方会发现就算是外国人发明的计算机，美国人发明的，那框架这个东西看起来也和他们拖不了关系，他们用英文叫什么framework，其实我今天讲之前我也没想过这个框架什么意思，我们就来解释一遍吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>这个frame就有点像HTTP协议里面的请求帧和响应帧，片段，帧，片段或者一堆， 包括那个如果你们用的很老的那些网站后台，它有叫框架类镶，镶嵌。就一个网页里面会塞多个framework，就相当于是说你可以把知乎的那个网页用框架的那个标签，把它塞到你的一部分，成一格一格的就变成一个九宫格嘛就像塞进去。那这样的话，单个拎出来的地方就是一帧一帧一帧，一片段一片段一片段，所以这是片段的意思，片段工作，感觉怪怪的？work嘛？一般我们理解就是job然后拿个锄头在这而挖挖挖然后你这个动作就work，片段工作。</pre>
</div>
</div>
<div class="paragraph">
<p>再来看框架，什么是软件框架呀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>就是你用那个框架过后，你的工作很省事，所以看这个地方就变成了工作片段，代码片段，多个片代码片段堆在一起就变成了framework，你看这么翻译就通畅了，不要直接变成这个词，你要把它给搞明白，多种多样的代码片段合在一起就是框架。</pre>
</div>
</div>
<div class="paragraph">
<p>我们来举个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SpringBoot，他有Controller，然后他有各种RestfulApi的规范，甚至它里面包了JPA，它有各种各样的东西，你会发现JPA和那个Controller完全没有关系，是不是一段一段的片段代码组合在一起就能完成某件事情。</pre>
</div>
</div>
<div class="paragraph">
<p>现在框架知道了，数据库框架你听得懂，ROM框架你就听不懂？比如说有个东西叫HTTP框架，你听得懂不？就是SpringBoot，没毛病吧，然后这个时候他前面换一个，你就不懂了，就像协议一样，有网络协议，有存储协议比如说那个Mysql的innodb存储引擎，他就是存储协议，那在这个地方框架框架前面有XXX框架，你不认识了吗？所以说你看到没有一切都是有来源的，他不会凭空的出现。所以你看到没有那这样的话，ORM框架，我们先解释框架，那么框架是什么，是多种或者一种是代码片段组成的一个软件集合，代码集合，你会发现我们在解释名词的时候用集合特别顺手，仓库也是集合，那你现在看的就是说为了提升软件开发效率出现的一种代码集合，然后具体的解释什么样的代码集合，这个时候先把框架给解释了，解释完框架我们到头了在框架前面做约束，做填空题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>为提升软件开发效率而提炼的代码集合，它就是框架，那么称作框架。</pre>
</div>
</div>
<div class="paragraph">
<p>框架解释明白了，那这个时候我们在用数据库这个ORM框架再套一下，为了提升软件开发效率而提炼的什么样的代码结合？打个问号，什么样的代码集合呀，将数据库的表映射成Java代码或者映射成编程代码，但是你会发现你这样的话前言后语不好接起来，我们就先不管框架，我们先看下怎么提炼，那么关键词肯定是映射，而且还要限制是关系型，所以我们现在把关键词先列出来，对象、关系、映射肯定必须得有，我们就看怎么套哈，那么就是说ORM是一种就是说白了，框架我们先不解释它，我们就说是一种框架，ORM框架是指将关系型对象的表结构映射成编程语言的框架，大概有这意思，但是我感觉还是有一点问题，我们再精简，然后我们看一下ORM映射完了过后有哪些功能，增删改查都有，那么这些是动作，然后动作完了过后能拿出记录数据，所以说明不仅仅是映射的表的结构，他你还能把类容拿出来，甚至你还能做更高级的东西，甚至你还能直接执行SQL，所以那现在看起来ORM能够简化数据库查询相关的操作，看到没有，你看我从这个角度去讲是不是就通了？然后再结合映射看怎么讲？那么就是说ORM框架它的目的是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>就是简化数据库相关的操作，简化关系性数据库相关的操作，简化Java操作数据库相关的操作，就是简化就很重要了。</pre>
</div>
</div>
<div class="paragraph">
<p>你刚刚说映射，你会发现你如果从这个角度去讲的话，是不是讲不明白？因为你还要去解释映射，而这种映射，其实映射是基本原理，映射完了过后才有上层的一些操作，所以其实ORM里面那个映射他是最基础的东西，但是如果你解释只解释了基础，你就导致了他上层SQL操作的就不行了，我们就先从简化这角度来讲，那么ORM框架是一种简化数据库操作的软件框架，他怎么简化的呀？通过将关系型数据库的表结构映射程编程语言对象，基于对象的基础上面在完成后续一系列的什么对象填充等等，那就变得很长了，那不是我们的风格，因为会发现你讲的这这段话过后，任何人看了只要能看明白这句话的人，他都能学会，但是很多人看到前半句后面就不看了，看下怎么总结，我就先写个草稿，等会儿再改哈：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ORM框架是为简化编程语言操作关系型数据库而出现的软件框架。</pre>
</div>
</div>
<div class="paragraph">
<p>这个地方框架我们就没有展开了，因为如果你框架都不明白，你是没办法理解这个东西的，所以刚刚对框架进行那个解释嘛，所以你会发现这个地方前面都是在解释什么是软件框架，什么是我们的ORM软件框架，这句话只是说他的目的，这只是目的，他怎么达成的？而且这个地方还要设计一个就是我没有说是关系性所以你要加上，关系解决了，但是对象和这个映射没有出现在这个位置，现在你要解释，后面就说白了，你后面怎么去解释这个ORM是怎么把这个框架搭起来的，不然的话这个概念你是解释不完，来想一下，首先，连接词肯定是通过嘛，通过什么？就拿Java举例：</p>
</div>
<div class="paragraph">
<p>你Java里面这个地方涉及到数据库对象的只有一个东西，表的一行记录，你想是不是？对象嘛，类的实例化嘛，类的一个实例就是称为对象嘛，你会发现如果我们之前对编程语言没有认知的话，我讲你根本听不懂，所以这个地方有前置条件，这个地方对象指的是什么这个地方对象，因为数据库里面是没有对象的，所以这个地方走的对象有两层意思，关系性数据库，关系数据库表和表之间有联系，但是和对象牵扯起来就很牵强，所以我们就忽略掉第一层意思，只留下关系可以了。第二层意思，在Java里面出现对象的只有一个，就是你的Model，Class实例化过后就变成了十行记录就是十个对象，所以这个地方你可以理解为类的实例，类的一个实例就是对象，他们是相等的，那这个时候你就明白了那个对象是什么，对象的意思就是说我把数据库里面的东西结果查出来，查出来过后你的那个SQL不是返了很多行记录，Java把这这条记录或者很多行记录转成了很多个对象，那就变成那个对象列表，那个列表的元素数量有可能是0个，有可能是1个，有可能是多个，就是一个toList，这地方关系跟你指的是数据库本身，关系性数据库，那映射呢？刚刚不是讲了吗？为什么要映射表和Java之间的这个关系？为什么做这个绑定关系？你的创建表的时候你要创建很多什么，那个表里面除了列以外还有啥东西吗？我说列也肯定包含了他相关的所有东西，一张对象性关系表的那个表里面，他设计了几个方面，表包含了表名，包含了列，列就涉及到列名，列属性还有默认值，还有是否组建这些东西我都认为是一列的东西，表名一个列相关的所有东西，那除了这个以外还有什么？还有外件组件，你可以单独把它拎出来，你可以放到列里面去，但实际上那个组件还是外件其实对于我们来说不是很关键，不是所有的表都有这个东西，但是那个列是必须的，你没有表名你只有列名是没有用的，所以说这个地方的映射是指的首先是这个表，其次是那个你的Class里面的类属性映射就是那个列的名称还有类型，就是列名，所以这个地方映射肯定是指将关系性数据库的表映射成一个Java类，或者是一个编程语言的类。</p>
</div>
<div class="paragraph">
<p>那上面这个地方这个类是指的谁？就是这个两个类是一样的，等于说你映射完的映射类的一个实例，所以那这个地方映射是指的什么关系型，我因为我这个地方有约束嘛，我就不强调关系型的，表结构的映射类，这个地方我就不去解释什么叫映射，这个地方不是我的重点，映射那个东西大家都懂，这个语文都懂，现在你不清楚的是他映射的谁，把谁映射成谁？表结构映射类，而这个类我如果取名字叫a的话，那这个地方a呀，就是先把表结构写成映射类，然后查完数据库所有的记录，就转成了那个类的对象，就表示一行一行的，就像你的Excel，你类的每个实例是一个Excel的一行,类的话是不就是个列，堆在一起就是那个类的总称，所以这个地方如果你要用形象一点表示的话，比如说这是Excel:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/excel表格图.png" alt="excel表格图">
</div>
</div>
<div class="paragraph">
<p>那这个地方是那个你的行数0123456，那这地方比如说是列名，那你可能得个这个东西,你得到这个东西过后你肯定有这样，所以那这个地方谁是类谁是对象，这个地方不是有列名，这是一个Excel的表格，就是列的话我这个地方肯定是a、b、c、b、e、f、g、h，那这样的话用a1、a2、a3、可以表示单个列，所以那这样的话就是你怎么去理解他的关系哈。类是指的整张表，所以那这个地方的话就相当于是说：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类A&#8230;&#8203;..H(所有列)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你想一下就说白了A到H这个地方就是类属性，那类属性和所有列之间是相等的，我是指的这个区间就表示是类，但是你会发现我没有说这个下头，我说的是谁，所以这地方指的是定义，哪怕那个Excel名是空的，类似存在的，但是没有对象，所以如果是一个空的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>空Excel：有类定义，无实例化对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那如果是非空Excel就是有类定义又有实例化对象，那具体类我讲明白了，这个很重要哈,那这个里面谁是对象哈，所以这个地方的对象，总的来说按这个模式了就变成了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A0&#8230;&#8203;..H0(一行)</p>
</li>
<li>
<p>A1&#8230;&#8203;..H1(一行)</p>
</li>
<li>
<p>A5&#8230;&#8203;..H5(一行)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么有a0是不是有a1啊，a1是这个到h1嘛，我可以有很多，这地方是5嘛，这全是对象，所以那这是一行，这是一行，这是一行，那最后这个对象肯定指的是多个，所以有所以单独出现说对象的时候，比如说实例化一个对象，实例化一组对象，所以说我们是有前置约束条件的，所以刚刚说是空的Excel，那如果现在是非空的Excel，就又有这个，又有这个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>空Excel：有类定义，也有实例化对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个地方我们要谈数量，因为是根据你情况来的，所以刚才类的话是指这他的那个表头，所以这个地方定义也称为表头，这个都叫表头了，你那个对象关系数据库的表结构，是不是等于表结构嘛，那对象的话肯定指的是行，所以这个地方对象指的是行，那在数据库里面叫一条记录，英文叫row，一行嘛就是一个w嘛，两行就是rows，那这个地方是列嘛，col嘛，但是他是类全部就是在所有的列s，那这地方行有可能是一个，也有可能是多个。</p>
</div>
<div class="paragraph">
<p>那又回到这边来，我们把这三个词挨个解释了一遍，第二个词已经出现了这个的位置了，类的一个实例或者对象，这地方是没有解释的，说白了你讲完了前一句话，你只讲了他的目的，你没有讲他实现的手段，就是有些时候去解释什么是什么的时候哈，你只是讲出来它是由什么组成的？你并没想到目的，但这个东西太复杂了。这个东西太复杂了，你不能只讲半句话，你讲完半句话你还是懵的，为什么？因为你的目的是最终理解他，然后去用它，结果也没理解到也没用上，所以就是说这个过程当中你要去解释它是怎么实现的，所以那这个地方实现就是这两个手段，肯定有因才有果，通过将表结构映射成编程语言类，再将查询的结果行转换成这个类的实例，最终实现简化操作的目的，所以通了，但是你会发现这个概念，如果不去理解这个对你这个，懵的，但是你解释是很麻烦的，比如说王雪慧找波波问他什么是HTTP，波波讲的可贼溜了，然后王雪慧说只能两句话跟我讲一下，然后这个时候波波就懵了，为什么？我知道是个啥但是我讲不出来，通过将表结构映射成类，映射成编程语言的类，通过将这个中间刚我们讲是个简化版的，映射成类过后有什么好处？就是把表变成Java的类部有什么好处？读取的是方便，便于就是读取表信息，便于读取表信息，括号表明列名，列类型等等，便于在编程时使用表（包括表名，列类型，列名等），这只讲的前半句话，那他查询完了过后呢？因为这个地方是通过将表结构映射成编程语言的类，便于在编程时使用表，表包括什么？这个地方可以用逗号哈，把括号去掉也是可以的，包括表名，列名，列类型等等，最终可以将SQL的查询结果转换成类对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>通过将表结构映射成编程语言的类，便于在编程时使用表，包括表名，列类型，列名等。
最终可以将SQL的查询结果转换的类对象。</pre>
</div>
</div>
<div class="paragraph">
<p>你这光只有这句话，你是没有办法说清楚的，就这句也不行，他有前后因果，这是目的是先给你介绍个总的概念，再跟你说我手段是怎么实现的，是分两步，先有映射才有对象，所以现在可能这一句话羽翼不丰满，但是核心思想已有了，但是我个人觉得就还是太复杂了，但是我如果把它精简一下，我感觉就是讲不清楚，我把他放大又多，所以我们先保持这个样子，我觉得就不是超过了，就最终就这个样子了，所以这个地方解释的框架，这个地方解释的什么是ORM框架，如果你要套的话，你就把这个框架个定义套过去，但是我个人觉得你最好是先告诉别人什么是框架，再说什么是ORM框架，所以把当遇到复杂概念的时候，把它拆分，有前置条件有后置条件，比如说这个时候你连类都没有用过，我就不会跟你讲，因为这个属于高级工程师需要学的内容，但是我们这个地方我们认为都是应该掌握的，不分初级高级中级，就是用到什么，你就应该去了解他，不要刻意给自己画圈圈，说，哎呀，我还是个初级的新人，我不需要学这些，所以这个地方的话就是他的前置条件是你能够理解这些东西，而且其实说白了，我哪怕没有那个，我能基于这个也一样给你讲下去，但是我觉得那个表可能会更形象一些。</p>
</div>
</div>
<div class="sect2">
<h3 id="_orm工作原理">21.3. ORM工作原理</h3>
<div class="paragraph">
<p>在讲ORM这个工作原理之前得先明白是两个东西，那这个地方肯定是Database Driver，数据库驱动，那看起来这地方是两个词，数据库不用解释了吧了，那什么是驱动？比如说显卡驱动，说到关键词了，协议，那我先举个例子嘛显卡驱动，大家都装过，没有显卡驱动你的那个屏幕那个显卡就没用，那么说明这个驱动是承上启下的，那就是操作系统和显卡之间的一个桥梁，显卡驱动让操作系统知道显卡是怎么工作的，能够控制它，使用它，显卡去都明白了那把显卡去掉，换成数据库，那数据库确定是啥，能够让第三方编程语言或者第三方工具与数据库通信的一个软件集合或者一个软件框架，这个驱动肯定是个框架，所有软件都是框架，基本上除了用户能点的，只要是给程序员用的，这是给程序员用的嘛，就是框架，这个地方我打个比方：</p>
</div>
<div class="paragraph">
<p>举的是Mysql的数据库驱动，让Mysql以外的第三方工具或者语言能够与Mysql本身通信的这么一个软件框架，那这样的话就是Mysql驱动，我现在问你个问题，那驱动做了啥，他能够让第三方工具知道查出来的东西是什么，你说是ORM，这是两个层面的东西，ORM更高级，数据库驱动更低级，其实本质上这两个东西是一样的，但是驱动里面没有映射，他也没有对象，为什么？没有映射当然就没有对象了，因为关系这玩意儿讲的是关系数据库，讲的可不是里面查出来的东西，所以这个驱动里头只有什么查询出来的结果集，它只是一个列表，只是一个可能数组指针，他可能只是一个其他东西就是非常非常原始的，ORM在数据库驱动的基础上面去做翻译工作，他就遍历那个数组，他就遍历那个结果集，挨个挨个拿出来，所以你如果很介意ORM的性能的话，你自己也是可以基于数据库驱动做一个的，我们就不要去搞重复发明了，其实一句话，驱动是负责与数据库沟通沟通按照Mysql的通行协议与数据库沟通，说白了他是一个协议的解封包解包器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>驱动是数据库通信协议的编码和解码器。

* 网络层面

* 结果集转换</pre>
</div>
</div>
<div class="paragraph">
<p>我从这个角度跟你讲，一下就明白了，其实刚刚从用户角度讲的发现讲了半天狗屁不是，编码解码器，你都把它解码了，你是不是可以用它了？当然就能沟通了，他当然是个桥梁了，从桥梁的角度讲你听不懂这是什么，为什么？因为涉及到需要了解驱动的人一定是写代码的人，他不需要知道什么是桥梁，你直接告诉我你有啥用，所以我就不去啰嗦，以前我给波波帮他们讲的时候，网络协议那块应该是后讲，所以我没有办法很简单给他讲明白。但是如果先讲的网络协议，而且讲的比较深入，过后你会发现所有东西都是按说明书翻译，翻译来翻译去嘛，翻译过来叫编码，翻译回去叫结码，就很简单了所以他就这个翻译器，翻译两个方向嘛，英文翻译成中文，中文翻译成英文。</p>
</div>
<div class="paragraph">
<p>所以那这个地方驱动明白了吗？很简单，它就是个编码解码器，只是说编码的东西是什么？他肯定要把网络协议里面东西拿过来，因为你想嘛，你用Java去连Mysql你填的时候IP地址和端口，所以说这个东西是一定要连网络的，他连网络就要封包解包，这个是网络的封包解包，那么他网络封包解包做完了过后，他那个里面带的数据还要去识别转换一下呀，他也是在做编码解码，只是一个是网络包封包解包，然后一个是Mysql查询数据集的一个封包解包，所以这个涉及到两方面，一个是网络层面哈，那么还有一个就是结果集转换，一个是网络层面的那个封包解包，一个是结果集的转换，他都是用编码解码去做的，只要能把这个做了驱动就ok了，你再用那个显卡驱动来套一下，显卡驱动那么肯定有串口通信，因为你要接线，你要把那个显卡插在那个pc插槽上头，所以这个时候操作系统主要解决的问题是怎么和pc-1插槽通信，网络有了的，然后这个叉槽有了过后，那这个时候显卡一定要通过那个pc-1插槽传输东西，来来去去来来去去，因为他有带宽嘛比如说40gb每秒，他那个带宽里面携带有数据，你的操作系统你知道的是什么数据吧？有来有去吗？又有一个层面的封包解包，你又发现这东西都是万能公式相通的，所以你看到没有，把协议这玩意弄懂了过后基本是万用语言。</p>
</div>
<div class="paragraph">
<p>比如说你买了个车，你看那个说明书是为什么吗？那是使用协议，当我报滴滴滴的时候，是汽车内存出了问题，然后比如说你的亮什么灯？他们也是一种协议，只是这个协议的转化是通过你的人脑转换的，所以你的人脑里面有编码解码器，但是如果你的编码解码器虽然在，但是如果把说明书抹掉，你能转吗？你转不了，所以我们很多时候不是从哲学层面去解释很多东西，你会发现在是吹牛逼，但是你倒回去套的时候，你发现万用公式随便套，这叫强哥学习法就诞生了。</p>
</div>
<div class="paragraph">
<p>那驱动我们明白了，那这个地方我们就不再解释驱动了，那这个地方的工作原理是什么样的？简单画一个图哈：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/正着来.png" alt="正着来">
</div>
</div>
<div class="paragraph">
<p>图是这样的，我就假设是用Java的那个JPA，比如说你先写过来点，比如说你有一段Java代码，你通过JPA，那么JPA又用了hibernate，然后hibernate一定用的是driver，我们这个地方通常指的driver一定是Mysql driver，其实到这个地方的时候，我提醒你一下，你应该会有印象，你用那个河狸数据库管理器的时候，他要下驱动，他下的东西你会发现下东西的Jar包，然后那么驱动有了过后，那驱动它往下走，他就会连Mysql，当然往下走，你要是具体一点的话，应该是操作系统里面的网口，有了网口就有主板，有主板就有网口那就太细了，我们假设他应该通过网络，然后这个地方他通过网络找到了Mysql的端口，你会发现这里面谁是ORM哈，而这个东西他就是driver，你会发现你只要把driver搞懂了过后，这个图就很清晰了。</p>
</div>
<div class="paragraph">
<p>Java语言里面可能某个地方需要查某个表什么by id查了某一列嘛，那么调的是的语法，JPA他给你封装的很高级，就是基本上他内部是方法名你都是瞎猜的find by id，find by类，find by id and类，他有一定的规则，封装的太好了，封装的太简单了，其实这个JPA是用hibernate改的，你发现hibernate启动的时候是用JPA起的，但是用的是用JPA，所以你可以两个都分称为ORM是没问题的？或者说都称为hibernate都是ok的，那么ORM看起来是在driver上面封装了一层，为什么？其实你可以跳过他，完全没有问题，我之前用c或者c + + 我写代码，我个别时候要查数据库，我用的是Mysql和官方提供的c + + 驱动，你的Java下载下来是个Jar包，用c + + 下载下来是一个.so的文件，然后那个文件里面就有函数嘛，你就现在把它加载进来函数就可以用了，这个你不用担心，具体过程你假设就跟Java一样，那这样的话，我调完了过后我就要用While循环或for循环，或者用if判断去把那个driver的东西挨个读出来,所以为什么我对这些东西那么清楚，所以我写过各种各样的驱动,我写过内核驱动，我写过数据库驱动，甚至我自己还基于Redis包装了一层驱动,我有c语言版的Redis驱动，最开始Redis官方是没有这个东西的，或者很难用，我就基于我自己的方式包装的一层，所以那这样的话就相当于是说driver过了过后通过网络你的数据库，所以说明driver做进行了网络的一个转换，还进行了结果集的一个转换，做了两个层的东西嘛，最后Mysql再返回来就回去回去回去。</p>
</div>
<div class="sect3">
<h4 id="_java和jpa是什么关系">21.3.1. Java和JPA是什么关系？</h4>
<div class="paragraph">
<p>这个过程当中我们再拎过来，看一下有没有需要补充的，那这个地方看起来那么Java和JPA是什么关系？他怎么绑定在一起的？我们讲了工作原理嘛，你得举个例子吗？我们现在没举例子，在我们的举个例子，证明的工作原因是对的，所以那这个地方首先，你既然Java里面用了这个东西，那首先第一个你要连数据库，首先那例子哈2.1，例子，那这个地方的话首先你有一个配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>config——&gt;mysql://localhost:3306/testdb?passwprd=123&amp;user=root&amp;...</pre>
</div>
</div>
<div class="paragraph">
<p>那你一般会写这个，这才是重头戏？一般是ip地址，localhost：3306，我随便写哈，我就假设我写的是对的，那这个时候你肯定先有数据库，比如说我们这个地方叫textdb，那这样写完了过后肯定还要跟你的账号名字，编码，时区，我记得像是这么写的，我就假设先写password满意了嘛，password=123，user=root，那比如还有些其他的东西，这个东西就典型的URL，我可没有说URL必须是HTTP开头的，HTTP：//，哎，巧了，Mysql：//，所以这个地方他有个名字叫连接URL英文叫connection，叫连接字符串连接URL都可以，就讲的是这个，这种分就不用我讲怎么分了，典型的一看就会，一用就废，所以这个明白了，这个后面后面可能会跟时区，或者跟那个编码，utf8等等很多很多东西都都可以跟就是你只要掌握了Mysql，我问你Psql怎么连？所以他顶多是说有一些Mysql特殊的属性，可能身体后面要要取掉，但是大多数情况下面你这个字符串的直接动这个地方，剩下的工作是ORM帮你做的，因为Psql的driver和Mysql的driver不是一个厂家写的，你咋保证他这个位置是一样的呀，他有可能把那个密码放到localhost里头，所以这个字符称转换了一般是ORM给你转换的，那我先用连接字符串连接，然后这个时候ORM做了什么？把这个字符串转换成一个结构化的连接类，那就存在Java里头了比如有个类就叫connection info，他把这个字符串挨个弄出来存到connection info的对象里头去，为什么叫一个类里面一个对象呢？他万一有两个连接字符串，他就可以有两个对象，就组成一个集群的嘛，所以那这个地方这是连接字符串，连接字符串有了过后那么Java里面会去做转换，然后这个地方就转换嘛，就是把上面这个东西哈就是解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>parser——&gt;解析URL，保存连接信息到对象</pre>
</div>
</div>
<div class="paragraph">
<p>URL然后保存连接信息到对象，这个对象我们就不要去深究他是什么，反正随便个对象都可以，再Java里面万物皆对象，连接信息保存了，他要连接，他要把这个信息给driver，他就去调用driver了，所以他就这个地方开始连接conn嘛：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>conn——&gt;ORM调用driver连接</pre>
</div>
</div>
<div class="paragraph">
<p>那这样的话就相当于是说这一块是ORM的基础工作，然后这样的话就相当于说ORM调用driver连接，连接完了才是使用，才有你的find by id，所以这个地方就是Java code：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Java Cpde——&gt;repo.findById（1）</pre>
</div>
</div>
<div class="paragraph">
<p>就相当是说你有一个类嘛，我们叫repo嘛，repo.findById，然后这地方比如说是(1）,就现在直接调用了，然后这个调用的过程当中，他肯定还要去复制ORM把它转换完了，又是调driver，所以那这个地方的话又涉及到转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>parser——&gt;code——&gt;SQL</pre>
</div>
</div>
<div class="paragraph">
<p>这地方转换把上code转换成一个SQL，那这样的话，就把上面那个code的转化成SQL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>driver——&gt;SQL——&gt;Mysql</pre>
</div>
</div>
<div class="paragraph">
<p>然后最后是driver把SQL发送给Mysql，然后发送给Mysql过后他一定会返回一个查询结果集，最后再反着来嘛，我这地方只写关键的地方哈，你会发现就是可能讲这个地方很多具体可能没讲，但写代码的时候你可以忽略到很多细节，为什么？你根本就不关心，所以这个地方我跳了很多的步骤，但是你知道这个地方可大概对哪个位置，你每做一件数据库相关的事，你要知道这个过程是什么样的，你把这个东西套过来。</p>
</div>
<div class="paragraph">
<p>比如说Java他要先怎么样，先去读那个配置文件，读完配置文件过后，把这个配置连接信息交给JPA，JPA交给hibernate，hibernate把那个连接信息最后调用driver去连，这是连接，连接完了之后Java准备的一个代码，代码是通过JPA的方式findById做的，那么findById通过hibernate转成了SQL，所以这个地方是SQL吧，这个地方是网络包加SQL吧，他返回回去的时候也是一样，就是变成结果集了，那我就不写了我觉得没有必要，那么结果集到这步也是结果集，这是网络加结果集，这就变成了结果集，那结果集再往上结果集就是变成了对象，结果对象，结果对象，结果对象Java就能用了，所以你们到时做笔记的时候，这个反着来，你们要画出来。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/反这来.png" alt="反这来">
</div>
</div>
<div class="paragraph">
<p>&lt;&lt;</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYJIEM_chapter">22. 智眼系统API和界面设计（一）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_21">22.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统API和界面设计板书1.jpg" alt="智眼系统API和界面设计板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统API和界面设计板书2.jpg" alt="智眼系统API和界面设计板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_需要注意的">22.2. 需要注意的</h3>
<div class="paragraph">
<p>现阶段我们的智眼有几点要注意：</p>
</div>
<div class="paragraph">
<p>第一个：如果我们有官网或者演示视频，要求一眼就能看懂，表达简单，能够在一两分钟以内把功能介绍完，因为现在还处于这个雏形阶段，十分钟，五分钟都太长了，别人看不懂。</p>
</div>
<div class="paragraph">
<p>第二个：安装方便，所以我们没用ES这种大的，Java的东西，一定要用PostgresSQL，顶多加上我们的Spring Boot的程序，安装完了过后，登录要简单，登陆进去过后功能也要简单，什么意思？如果有导航栏的话，导航栏建议就不要有二级菜单，就直接一级菜单，点完右边就是界面，当你达到这个效果，这个界面才是简洁OK的，为什么？因为现在还处于一个雏形阶段，雏形阶段的意思就是说你现在所有的功能都是不成熟的，那么在这不成熟的情况下，肯定是一个逐渐丰富的过程，只有这个样子，才能让别人一眼看出，比如说我们和传统的Zabbix相比，我们的功能丰富在哪个地方？</p>
</div>
<div class="paragraph">
<p>打个比方：</p>
</div>
<div class="paragraph">
<p>可能我们最开始的界面很简单，但是我们提供了API的，包括封装过后的SDK，意思就是我们先提供API系统能够把JSON给第三方调用，然后在这个的基础上，我们以后可以提个SDK，但是我们先把API给出去，API给出去过后，那又回到我们系统内部，</p>
</div>
<div class="paragraph">
<p>那我们系统内部和Zabbix区别在哪？</p>
</div>
<div class="paragraph">
<p>比如说Zabbix的话，他采集精度很低或者绘图慢，而且Zabbix最关键的问题是太复杂了，你可以去装一下Zabbix，那是真的复杂，就是我一个当时至少工作5、6年的都觉得Zabbix复杂，都摸索了好久，光一个显示中文我得搞半天，就是因为Zabbix图片上有些地方会有中文，比如CPU带宽那种字眼，它中文会乱码，为了解决乱码问题，还要去下一个ttf的字体，下完了，再放到指定的PHP目录里，他才能显示中文,所以Zabbix有各种各样的问题，因为Zabbix的那个服务端那是PHP写的，而且他的群组还非常复杂，说白了，Zabbix适合重度用户，但其实服务器来说很多人可能只是轻度使用，可能他在公司里头就是个程序员，他就想装一个监控，看一下有什么问题，而这个时候他把Zabbix装上，打开肯定一脸懵逼。</p>
</div>
</div>
<div class="sect2">
<h3 id="_定位">22.3. 定位</h3>
<div class="paragraph">
<p>所以这个情况下，你会发现从一开始，你的立足点叫定位，就是有句话讲的好：你要清楚自己定位，如果没有定位或者不清楚的话，请你花钱买个GPS，产品也是一样的，这个地方我们要给自己定位的话，首先要考虑我们的产品有什么特点？那么就从界面上来说：</p>
</div>
<div class="paragraph">
<p>1.简单明了</p>
</div>
<div class="paragraph">
<p>那这个就是说一分钟以内介绍清楚，现在我们都可以一句话总结出来：</p>
</div>
<div class="paragraph">
<p>把整个系统状态通过网页的方式呈现到你眼前。</p>
</div>
<div class="paragraph">
<p>这句话就很明显，以前要登服务器、要配Zabbix，而你装上我们的产品就只需要两个命令，一切都在你的眼前，就这意思，默认情况下CPU、内存啥的都不用配，默认就有了，说白了这个时候装完了我们的产品，进去过后是本机的监控视图，那么这里的简单明了就是指的是整个系统。</p>
</div>
<div class="paragraph">
<p>2.安装方便</p>
</div>
<div class="paragraph">
<p>如果你的源没有问题，能下到我们的包，那我相信一分钟一定能装上，而且一定能启动完并且能登上去，当然这个地方我们用到了Spring Boot，为什么用Spring Boot，主要因为是不想起TomCat、Nginx、Apach，因为那玩意儿要配的话，用户瞬间就看不懂了，我们最主要是想让程序员看懂，90%以上程序员都知道Java，而搞Java的人一定知道Spring Boot，既然都知道Spring Boot那再配个Nginx反代应该是没有问题的，我觉得那个东西就是很简单的，但是要让用户先用的简单，要是用户想自己上面加功能，不要管他，他想反代，就让他反代，但是你不能一开始就要求他着重安全，HTTPS啥的全部都给上完，要是这样的话就完全就和我们的目标背道而驰了。</p>
</div>
<div class="paragraph">
<p>3.界面清爽</p>
</div>
<div class="paragraph">
<p>清爽的意思就是动的东西少，简单，这样的话就不能有二级菜单，无二级菜单，但是想去掉二级菜单很难，就有时候给自己订了一条边界过后，你要守住那条边界，要付出很多，比如说有的时候没有二级菜单，代码逻辑可能就没有关联性，你就想放在一起，但放一起又不对，然后这个时候你就会拼命去想，所以就是一个作品，它精雕细琢的过程，就在这个地方，如果不思索，不管是八级菜单甚至十八级都没问题，但是你想把一件事情做的简单真的非常难，当然你说我直接不想了，他就简单了，是这个样子的，如果你不想的话就没有解决用户问题，所以这里的简单有个前提：</p>
</div>
<div class="paragraph">
<p>在解决用户问题的基础上面尽量简单。</p>
</div>
<div class="paragraph">
<p>这样就非常难了，所以作品级的代码或者系统，他难就难在这个地方，他并不是难在代码有多么高深。</p>
</div>
<div class="paragraph">
<p>4.逻辑简洁</p>
</div>
<hr>
<div class="paragraph">
<p>基本上只要做到这几个点，这个系统才会有人用，这样你才能录视频或者官网，如果一个系统搞得复杂了，你连官网都做不出来，那你怎么去推广？那GeeShow举个例子，GeeShow现在如果要做官网的话，很简单，就把使用的过程，录成GIF或者短视频，一个一个动图贴在官网上的,就表明我们使用很简单，所以就要靠产品核心里的东西去吸引别人，至于那种文章还原、历史管理都属于边角料，属于是核心完整了，然后边边的上东西才吸引人，要是核心都得不到别人的认可，还做啥做呢？</p>
</div>
<div class="paragraph">
<p>再比如说我们的智眼，也可以贴个动图或者首页正中间放一个大概一分钟的视频，至于安装过程就不要写了，直接写在文档里面，那这一分钟干啥呢？我们就假设那个人停在首页，然后通过首页点，比如说把我们最重要的一个界面就是整个服务器的状态直接呈现在用户面前的那个地方，比如说现在CPU状态是怎么样的，然后可能上面有些导航栏可以切换切换服务器、时间啥的，然后有些东西你可以点点点点，说白了就是基于起始界面让别人看到能用啥，那才是吸引别人的东西，这个很重要，因为一个产品他能不能运营起来，一定是从最开始决定的，比如像NodeJS他为什么简单？那是因为所有人都会JS，他当然就简单，但是你不会JS，对不起，贼难，因为他是前提条件的。</p>
</div>
<div class="paragraph">
<p>那上面定位讲清楚了，现在再讲界面就好讲多了，首先我们整个系统里，先不要去管设置、登录，这两个东西任何系统都有，但是我想的是我们的系统尽量没有设置，设置可以在界面里面去设置，但是并不需要一个单独的设置界面，这样的话就把逻辑统一了，你看到什么东西，就在什么地方设置，看到那种高大上的地方都是这样做的，所以那这个地方的话就是说约定优先，就像Spring Boot一样
约定俗成，意思就是我们默认的参数，一定是最适合当前的，当你需要改的时候，就到界面上去改，当然就有个问题，用户会找不到地方改，就像当初用Kibana，就遇到了一个问题，我当时想改它的时候,发现找不到,但是为什么？我花了两个星期才把它搭好，你认为我会因为这个设置问题把它放弃吗？说白了已经掉套路里了，那至于找不找得到，总会找到的，但要是你都不能吸引用户，用户就直接不用了，那约定优先的话就是无单独的设置界面，无独立的配置。</p>
</div>
<div class="paragraph">
<p>对用户越简单，对程序员就越复杂，当然这地方无独立的配置页面，那用户登录怎么办？用户登录那种用户管理的东西，我觉得有一个没问题，但是你用页面来设置那些图形、监控参数这些东西，是这样的，假设调完设置了过后，还得跳回去看那个页面咋样啊？你咋知道你的配置参数对应的是哪个页面？这就会变得学习了，这个像那个37signals这家公司，这个公司应该没跟你们讲过，这家公司做的所有软件都没有配置，他们认为你不需要配置,所以可能以后我们那个CPU的采集间隔，我们认为五秒就够了，可能就不会让用户配，要是用户天天在我们那个频道里面说，我们要一个配置的来改CPU监控时间，就让他们自己登服务器改，像这东西我就不需要给接口，就直接说我支持改，只是我不想做在界面上，我要求我的界面简化，说白了界面是给新手用的，你要是你觉得你是高手，你自己到服务器上去改改频率就完了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_核心界面">22.4. 核心界面</h3>
<div class="paragraph">
<p>那现在涉及到了一个我们的核心界面，所以我们的核心界面一定是监控，并不是登录、设置、用户管理，主机列表，一定是某一个主机的监控试图，说白了首当其冲的监控视图应该是服务器的TOP，TOP上显示啥我们就显示啥，当然你可能会想要不要把那个TOP原封不动抄过来，是这样的突破命令，只是瞬间的，而你是想的留住青春，什么意思？是想把这个TOP的历史留下来，而不是说当前的，如果你只是想看当前的话，我可以直接给一个通道给你，单独看，当然这一定不是我的核心功能，所以这个地方最合理的方式一定是像TOP一样，为什么？因为Linux系统里头默认都带了TOP，为什么？因为TOP才是最基础最核心的。</p>
</div>
<div class="sect3">
<h4 id="_page_one">22.4.1. Page One</h4>
<div class="paragraph">
<p>我们的第一个版本就完全是把TOP命令抄过来，那这个页面解没解决问题？首先什么叫智眼？打个比方有的电影里面有那些天眼、水晶球那种很高级的东西，比如说魔戒三步曲里的水晶球能够看到过去未来？智眼就很和他很像，如果你只看当前发生的，但其实我们是想看过去的，那么TOP这个页面就没有解决问题，所以我们要的一定不是这个页面，我们要是把TOP里面的信息单独拎出来，就比如现在的时间，我们可以在任何地方打印出来，不管是在系统的右上角还是左上角都是可以的，甚至开机时间我们都完全可以，假设我们有一个大的导航栏，然后它包括了所有的基础信息，比如说我们看这个机器视图的时候，有个导航栏，然后就把这几个比较重要的放在那个导航栏上，下面不管怎么切，导航栏都不变，因为进程数这些东西其实都不怎么重要，如果你觉得CPU那个很重要的话，你放上去后就发现太挤了，因为CPU它有几个参数很重要，空闲的，总的，所以你会发现Windows的任务管理器和这个很像，只是呈现形式不一样，那看起来这个地方提供了一个思路，就是CPU的使用频率可以像那个Win10，核心排在一起，但是要知道其实在我们平时解决问题的时候，哈，16个核心我们不用单独去拎出来对我们看，总的是能看出问题的你说那种玩意了，他必须得上俗气的已经不是这种通用的了我们想解决是通用的问题，那特殊问题特殊解决方式好，你看，这个配计弯的第一个版本看是这样，没有解决问题那是我们看看怎么拎哈，我记我的这一排我更觉得哈就是固定在那就可以了，我觉得这个都无所谓。</p>
</div>
<div class="paragraph">
<p>这样的话，我们可能有个页面：</p>
</div>
<div class="paragraph">
<p>就用Page1来表示,那首先它一定是基于TOP，那基于top的话他应该就有这些东西：</p>
</div>
<div class="paragraph">
<p>image:top.jpg</p>
</div>
<div class="paragraph">
<p>所以我们的第一个版本就完全是把TOP命令抄过来，那这个页面解没解决问题？首先什么叫智眼？打个比方有的电影里面有那些天眼、水晶球那种很高级的东西，比如说魔戒三步曲里的水晶球能够看到过去未来？智眼就很和他很像，如果你只看当前发生的，但其实我们是想看过去的，那么TOP这个页面就没有解决问题，所以我们要的一定不是这个页面，我们要是把TOP里面的信息单独拎出来，就比如现在的时间，我们可以在任何地方打印出来，不管是在系统的右上角还是左上角都是可以的，甚至开机时间我们都完全可以，假设我们有一个大的导航栏，然后它包括了所有的基础信息，比如说我们看这个机器视图的时候，有个导航栏，然后就把这几个比较重要的放在那个导航栏上，下面不管怎么切，导航栏都不变，因为进程数这些东西其实都不怎么重要，如果你觉得CPU那个很重要的话，你放上去后就发现太挤了，因为CPU它有几个参数很重要，空闲的，总的，所以你会发现Windows的任务管理器和这个很像，只是呈现形式不一样，那看起来这个地方提供了一个思路，就是CPU的使用频率可以像那个Win10，核心排在一起，但其实在平时解决问题的时候，核心核心不用单独去拎出来，直接看总的是能看出问题的，你说那种玩意了，他必须得上服务器的，已经不是这种通用的，我们想解决是通用的问题，特殊问题有特殊的解决方式。</p>
</div>
<div class="paragraph">
<p>那么第一个版本看起来并没有解决问题，那是我们现在看看怎么拎，TOP第一排我觉得固定在那就可以了，当然这么一讲，那下面的东西也不是不可以，关键是如果你想得的越多，就损失的越多？什么意思，他会把页面占满？现在最头痛的一个问题就是：现在服务器剩了多少内存，百分之百有人看不懂，甚至我给你写了一个ProLinux的教程，里面那个free，我说实话，我自己都没法给你解释清楚，但是我可以明确告诉你总数减去使用的一定等于剩下的,但是剩下的那玩意里头啊还包括Java已经占用的，它不会放出来，这个时候基本上我会去看那个free，如果只剩下一点点，你会发现电脑就会卡，但是在服务器上，一共128G内存，结果Free就只有2G，但是这不是真正的内存不够了，他是被内核给提前分走了，预热一下，所以显示CPU、内存是不可取的，包括SWAP也是一样的，当然SWAP简单一些，但通常情况下用户看不懂，CPU也只显示使用率就可以了，所以说如果真的要做的话，可以在导航栏上加一个CPU的使用率是显示一个数就可以了，正常显示百分之百就可以了，所有的统计都按百分之百的维度来。</p>
</div>
<div class="paragraph">
<p>那看起来第二个版本可以留下第一排，然后加上个CPU，然后任务数其实不重要，为什么？说实话，平常使用谁遇到过这种问题？，你怕没遇到，这些都是大佬该处理的，和平常用户没关系。</p>
</div>
<div class="paragraph">
<p>那么内存要显示的话我建议只显示剩余的，为什么？其实并不关心那个机器总数多少，只要内存空闲有4G，我认为还活着，但是显示个总数或者显示已用了110G，肯定第一反应可能出问题了，所以我们只显示剩下的,还有多少可用.</p>
</div>
<div class="paragraph">
<p>SWAP要显示的话，应该显示已用的,因为一旦用上SWAP就会慢，所以SWAP应该显示已用的.</p>
</div>
<div class="paragraph">
<p>下面的进程就不要不需要了，那看起来导航栏是可以简化，基本的信息留着没问题，包括这个平均负债也没有问题，加个CPU、内存就解决了问题了，所以说有一个是叫做缩略的当前系统运行状态，当然进程的问题，平常很多时候你怕不是关心的进程，要先看一下上面，然后才会去关心进程，为什么，就算第一眼看的进程，你还得回头看上面有多少空闲的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_page102">22.4.2. Page1（02）</h4>
<div class="paragraph">
<p>这第二个页面就像刚刚讲的，一个是系统时间，所以通常来说，如果显示系统时间的话，我会把年份显示上去，比如说今天是2021/09/22 09:00:02，那这个以后就是一个开机时间，我就先不管那个版面，我就先把大概的形式写出来啊，就我认为这个地方有一个up，然后比如说是刚刚写的03:00 3分钟嘛，后面就是一个1user，还有个负载，那这个地方可能是2.00, 1.42, 1.44，当然还有cpu、内存、swap，那这样的话就是cpu，叫使用率嘛，内存，这地方是空闲，那么空闲比如说是4GB，还有swap那这个时候是使用的used，所以常用的方式就这几个。</p>
</div>
<div class="paragraph">
<p>主要这个地方是个概览，意思是不详细的，任何地方你都可以看到的，我只打个比方哈，可能以后这东西可能单独版面，我假设现在现在还在，主要是我基于top出发的嘛，然后这样的话，那这个地方除了这些东西以外，我肯定在下面显示一些最核心的东西就是一个服务器上面最重要的东西就是这个地方展示，这个地方我假设现在有四个版面嘛，最重要的是肯定有cpu，有内存，然后有了内存过后，swap就不重要了，因为内存都吃满了那swap当然跑起来了，所以我大概可以武断的判断哈那这个地方第一个应该是cpu，第二个是内存，swap是不重要的，那第三个是负载，是这样的，Windows当你知道你机器卡了，你只知道卡了，到底有多卡呢？你懂我的意思吗？你没有量化标准，但是空气的PM2.5可是有量化标准的， 比如说今天的PM2.5是142，他是个量化标准，你知道142一定比1000好，你看到没？他是个量化标准吧，他量化是用颗粒来表示的，你可能武断的以为一个颗粒就表示+1，那么142、143、144他一定是一种密度，你有一个量化标准，而Windows是现在最缺的是什么，对服务器没一个衡量标准，而这个负载就是内核根据你当前的一个工作状态综合判断出来的一个标准，比如说你的那个cpu的IO一直等待空转，你会发现服务器莫名其妙那个负载一直往上跑，特别是那种慢查询导致一直堵在那儿的时候，cpu严重不够用的时候cpu100%，但是IO又没有，但负载就一直往上升。</p>
</div>
<div class="paragraph">
<p>我最见过最夸张的服务器，阿里云出问题了，负载那里显示了3000，我截个图给客服看，他自己都不敢还嘴，为什么？你以前找客服，他还跟你犟，什么意思？他要解释一下啊，这可能是你们应用程序问题，但是我截了个3000图给他，他就很懂事的给我换了台机器，阿里云经常出问题，你用云服务器不是因为它稳定，是因为它便宜，出问题你可以重启，懂吗？用云服务不代表不需要运维，记住这句话，用云服务区不代表不需要运维，用云服务器你只是解决你不需要网管插网线，wifi谁不会接嘛，还需要啥网管啊，服务器都没有全是阿里云，当然就不需要网管了，但你敢不要运维你怎么死你都不知道，外面一些公司就是因为这个技术搞不定经常死，经常性的，因为这种技术问题而垮掉的公司多的很。</p>
</div>
<div class="paragraph">
<p>所以这个地方我们平时叫负载，我们不会叫他平均负载，为什么？在Linxu系统里面只有一个玩意儿叫负载，你就不需要去限定他范围做平均负债了，这个负载这个地方第一个表示是过去1分钟的负载，第二个表示5分钟之前的负载，第三个是15分钟之前的负载，所以这个地方你的那个高负载先会在第一个飙到20，然后你会发现飙到20可能持续段时间过后，第二个会变成20，第一个又会变成25，然后可能等一会第三个又飙上去了，所以一旦你自己有负载过后，如果你有记录的话，你是不需要记后面两个值的，如果你能全部绘图完是最好的，你就一个图用三种颜色把它标出来是非常非常ok的，因为有可能你这个系统启起来的时候后两个已经有值了，如果你只记第一个的话就空白，就是0,有可能是有失真的，所以通常我们显示这个会用这种曲线：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/负载.png" alt="负载">
</div>
</div>
<div class="paragraph">
<p>比如说负载从这地方走的话，最开始这样嘛，你可能会用另外一种笔啊，或者另外一种颜色，你会去标记另外一条线，比如说是绿色表示1分钟的，两根杠的表示5分钟的，三根杠的表示15分钟的，一般是颜色来区分的，所以那这个地方ok撒，你不要去管他意义，这是我随便乱画的，那肯定不真实，因为这玩意下滑太多了，通常来说他应该是差不多的，差不多是增长的，所以这个是个负载。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cpu.png" alt="cpu">
</div>
</div>
<div class="paragraph">
<p>然后cpu这地方其实也是的，cpu这个地方分了可能直线的话表示叫IDLE，这空闲啊，比如说这个波浪线的表示WA，当然还有很多其他的，所以你可能就这个样子的就实现的，那你可能是这样的，然后你如果WA表示那个IO嘛，IO可能是这个样子，懂吗？那这样的话cpu其实大概有六种状态，你在一个图上给他汇出来，当然，看不懂的人永远看不懂，你不要去解决他看不懂的问题，其实是这样的，我们这个绘图啊，它只是一个入口，我其实更核心的会给他运维提供建议，你知道吗？这才是我最核心的，所以我会根据他的那个服务器的整个配置这些东西我会给他算一个建议值，我会告诉他这个值是正常的还是不正常的，当然你会说强哥你怎么算呢？是这样的，大数据时代嘛，我们用的多了，或者我们用的用户多了，都采集上来，然后这样的话就能够算一个在相等配置的情况下面别人的值是多少，当然可能这个没有参考性，我只说这一种可能，但是我更觉得可能就是我们主观的评判和那种建议都放在这儿，就比如天梯图嘛，放个天梯图的建议值，再放一个我们自己主观的人工审核的一个值放在那做个参考，就有意义了，所以这个地方就一个人工值，当然还个天梯的，但天梯值那玩意儿就很敏感，通常别人不会把自己服务器上的东西拿去做天梯值，所以看他愿不愿意上传。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mem.png" alt="mem">
</div>
</div>
<div class="paragraph">
<p>那这样的话cpu解决了，内存其实也是一样的，内存这个地方肯定也有这种很复合的曲线，因为内存有总的，有已用的内核分了多少，所以我个人觉得这个地方可能就不是按这种来的，你可能是这种比如这个地方8个G，那么你可能就是这个区间里头，用那个颜色的区块来表示，比如说这个地方表示谁，拿你这地方标一下嘛，比如这个地方标到这个地方是free嘛，那这个地方可能标的是那个avail，这地方标的可能是used的，这个时候这个值它是无法解读的，因为他只能看趋势，其实对于他来说没有意义的，所以这个时候你可能要有个人工建议，或者叫解读嘛，那这个地方可能也会有人工值天梯值，但我个人觉得这个可能就没有参考意义，所以说这个地方可能是说你在这个情况下面就是这个地方应该是叫空闲内存可能更关注一些，比如现在空闲内存这个地方是四个G，是不是对他来说的话更有意义些，你光标个这个东西是没有意义的，所以如果可以的话，你把这个地方标成绿色是最好的，那比如说这个地方少于了多少变成黄色红色，用这种来警告他，所以这个地方可能有绿色、黄色或者红色，所以你发现如果这样的话，就不能套图表了，你图表一定没这玩意儿。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/进程排名.png" alt="进程排名">
</div>
</div>
<div class="paragraph">
<p>那在这些地方以外，好像这些都没有什么必要去展示它，然后为了凑数放个swap？那这样我们会把那个进程排个排个序，按内存按cpu可以排个序，那这样的话就相当于是说你有个排序，排序的时候你肯定要把那个号的内存给标上，那这个地方比如说号的是vm，那么用降序排列一定你关心的是他耗最多的，随着这个地方表示降序，除了这个以外好像还有个东西叫mem也是降序，还有叫cpu那么也是降序，正常来说你去看top的时候啊，你其实是能看到这个东西，但是你看是瞬间的，我的建议是这个地方看这个玩意，一定不是瞬间的，所以这个地方也不能放瞬间的，这里一定要放汇总过后历史降序的，一定是历史，所以这个地方是历史排名，历史排名的话，你这么一排下来，比如说这个地方你可以用这种柱状图，那柱状图就是这样比如说这地方是1个G500兆可不可以，那这个地方就延伸出，就是很多时候都会用那个进程名，不要用那个进程的那个参数路径，会很长，所以这个地方我们要标的话可能会标这种，Mysql，至于如果运行两个Mysql，这个就看不出来了，我也不知道你运行哪个Mysql，那这个时候你关心进程的Pid吗？我更觉得你不关心，我觉得你关心的不是Pid，因为我都显示这个名字了，你就算是Pid也能塞吧。</p>
</div>
<div class="paragraph">
<p>我打个比方，我统计的是这一个小时以内的，然后这一小时，比如说有60条数据，这60条数据你加起来总和嘛，然后我另外个进程60条数据的总和，我把那个总和加在一起按比例算了，比如这个地方，你可能刚刚可能理解这个，你认为是1G的问题,比如说10%嘛，5%嘛，按比例的算然后相加，内存也是一样的，所以这个地方我备注一下嘛，百分比，那比如说这个地方15%也是Mysql，这个地方cpu肯定也是百分比的，我觉得你去看进程，我更觉得你更关心的是这个排名，其实你并不咋关心当前这个服务器的状态，如果你想看颗粒都更小，你在上面那个导航栏选最近一个小时的嘛，或者最近十分钟的嘛，我更认为一个服务器最重要的信息都在这儿啊，像带宽那个东西啊，通常来说你带宽不会有问题，当然我这个地方这么一画带宽那个图也不是不可以加，比如像这个内存一定要不了，为什么？因为内存这个轴总是不需要的，内存这个时候你是可以抹掉的，那你可以加个带宽，或者你刚刚说的IO嘛，所以那这样的话我一个版面是不就可以展示很多东西了，但是你会发现如果合理排版的话是不影响观看的，我等于说他长期把那个板面投在那，就一个屏投在那个地方过后这个页面会自动刷新嘛，他就把就是永远只看最近十分钟了，那这样的话他就一直自己刷新就可以了，就相比以前那个top来说的话是更方便的。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYJIEM2-3_chapter">23. 智眼系统API和界面设计（二、三）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_22">23.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统API和界面设计（二、三）板书1.jpg" alt="智眼系统API和界面设计（二、三）板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统API和界面设计（二、三）板书2.jpg" alt="智眼系统API和界面设计（二、三）板书2">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_基础模块">23.2. 基础模块</h3>
<div class="sect3">
<h4 id="_iops模块">23.2.1. IOPS模块</h4>
<div class="imageblock">
<div class="content">
<img src="images/IOPS.png" alt="IOPS">
</div>
</div>
<div class="paragraph">
<p>现在SSD的IOPS能达到20万左右，几万都是算非常非常差的了,那IOPS有什么用？这个IOPS是在衡量硬盘的负负载，这个数字越大就意味着你的硬盘越忙碌，通常来说保持比较小的数字算是比较合理的，但在复制电影的时候IOPS并不高，不过只要你在复制那种一个一个的小文件的时候，你会发现简直慢的可怕，为什么？因为如果你是Windows,它就一直在计算需要多长时间，Linux它是挨个复制的，就像那开车一样，已经跑了100了，再跑个200是很容易的，但从0跑到200要花更长的时间，所以IOPS是能够用曲线画出来的，这里IOPS是个整数，命令的话用IOSTAT是可以看到IO相关的一些东西的,里面有很多列,还有很多很多详细的指标，但是通常情况下我们不需要关心那么多，我们先把最基础弄了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_文件io">23.2.2. 文件IO</h4>
<div class="imageblock">
<div class="content">
<img src="images/FileSystemIO.png" alt="FileSystemIO">
</div>
</div>
<div class="paragraph">
<p>另外一种IO叫文件IO，这种IO通常指的是速度，大概就是10mb/s，那这样的话肯定就有读和写，要看这个东西的话，有个命令叫IOTOP，这个命令把每个进程的速度给列出来了，那么一说，应该有个基于进程的排名，但是我现在觉得这种太高级了，至少对于我们来说话，当前可能用不上，属于是非常非常高级的范畴，这个就以后再说，我们先把这个基础的做出来，然后再做叠加,文件IO有时候是针对目录的，但是现在没有，因为太高级了，我就没写。</p>
</div>
</div>
<div class="sect3">
<h4 id="_硬盘">23.2.3. 硬盘</h4>
<div class="paragraph">
<p>硬盘的使用量，硬盘存在挂在分区，而且硬盘的信息量很少，最关键的是它还不变化，你根本就不关注硬盘是否有变化,你永远只关注当前的，甚至历史的都不关注，因为只要硬盘没有用完都OK，所以这里用饼图可能很浪费空间，另外一种做法就是Linux下面有个叫磁盘分析器的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fenxiqi.png" alt="fenxiqi">
</div>
</div>
<div class="paragraph">
<p>它是像列表一行一行的，所以我们这里可以效仿他，大概就是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/yinpan.png" alt="yinpan">
</div>
</div>
<div class="paragraph">
<p>当然除了这个以外,我们其实并不关心硬盘的数量，比如说sda，sdb放到这个地方就没有意义了，要是有一个硬盘挂在那儿，但你没用，那我挂个监控干嘛？你把他挂在分区上我们才在管，说白了就是哪怕你分了分区，但是只要你没有挂载，我都不认，我只认挂载的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_网络带宽">23.2.4. 网络带宽</h4>
<div class="paragraph">
<p><span class="image"><img src="images/daikuang.png" alt="daikuang"></span></p>
</div>
<div class="paragraph">
<p>带宽就很好办了，带宽注意一点就是带宽有In和Out两个，所以图表上可能就会有两根线，尽量不要分两个图，要是分两个图，那个图就会变的有很多，而且信息不够密集，就太松散了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_网络tcp">23.2.5. 网络TCP</h4>
<div class="paragraph">
<p>TCP主要看的就是三次握手的数量、总的连接数，然后是连接完了后空闲的数量，那大概应该是这样画：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/TCP.png" alt="TCP"></span></p>
</div>
<div class="paragraph">
<p>当然TCP里有很多状态就不一一画了，这个是用那个light sit命令或者ss命令能查到的，不过是最简单的，当然有IOTOP，那有没有NetTop这些东西，就不知道了，没有见过，所以这个地方主要是看总数，那么TCP这里应该是没有其他的了，带宽是带宽，连接是连接。</p>
</div>
</div>
<div class="sect3">
<h4 id="_进程">23.2.6. 进程</h4>
<div class="paragraph">
<p>进程要单独有一个,就比如进程数量，但是只有进程数量好像并没啥用，我们这里要的应该是一个进程列表，比如说那种木马的进程悄悄的来悄悄的走，估计要的是这种，所以基于进程的话可能要的是那种监控某一个瞬间的或者历史清单，打个比方，把机器上面所有的进程都列出来，但是进程很多时候都是一样的，如果有个进度条，从第1秒到第10秒,因为有些服务重启了他的进程会变，所以现在你拉这个进度条应该是能够看到不同的，而且重启过PID啥的都不一样，所以这个是用折线图是画不了的。</p>
</div>
<div class="paragraph">
<p>进程这东西要监控的，但是进程监控通常要的不是一个单独的进程，之前我们说的是内存排名，CPU排名也是处理的进程，还一种进程是属于异常进程，那么我们现在想的是进程总数需不需要管？我觉得需要管的是那个TOP中间有一行叫进程的running，Sleeping啥的，把这一行用图表展示一下，这样可能就会好一些，就是一个基础的，虽然可能没啥用，但还是先把它放在那，那这样进程数量就可以画折线图了：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/jincheng.png" alt="jincheng"></span></p>
</div>
<div class="paragraph">
<p>这里关于进程的话，还有一个基于进程的IO开销,之前说过有一个命令是IOTOP，IOTOP里面有两部分，一个是总的读写，还有一个是基于进程的读写，有没有必要去做？这里肯定只弄前十的，多了也没用，因为通常情况下肯定是看最多的，有些进程都没动，就没有意义，那么这里可能是一个简单的基于排名前十的图，但是前十的进程有可能会变，所以就不能用进程的名字来画东西，上次CPU是我们是用的百分比那种，这个也是一样的，我就单独画一下这个：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/jinchengpaiming.png" alt="jinchengpaiming"></span></p>
</div>
<div class="paragraph">
<p>进程好像就搞完了，那么基础部分我感觉差不多就这些了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_应用程序">23.3. 应用程序</h3>
<div class="paragraph">
<p>其实基础这一块儿和以前的Zabbix没啥区别，这个并不能体现出我们的特点，但是我们首先要实现人家的基础功能嘛，连基础功能没有，就谈不上特色，我们的特色是应用程序的监控。</p>
</div>
<div class="sect3">
<h4 id="_http">23.3.1. HTTP</h4>
<div class="paragraph">
<p>刚刚TCP那里，没有去管那种SYN那些东西，太细了，我们先管总数，HTTP也是一样的，因为HTTP有一个状态码，就比如200、404、500啥的可多了，挨个列出来就很多,所以我们就先管请求的和响应的总数，但这个地方估计不能叠在一个图上，因为他请求完了又响应，是有响应时间的,所以这个地方可能响应时间应该是最重要的，就像你那个浏览器上面按f12一样，f12右边不是有一个时间图，他那个图是这样的：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/f12.png" alt="f12"></span></p>
</div>
<div class="paragraph">
<p>整个网页他是从他顶部有一个时间导航,一条一条的,如果一直在下东西，那那个条一直在增加，他是为了方便你看，但对于我们来说，我们其实只关心响应时间的问题，但是我们并不知道你哪些URL是一个网页的，所以我们没有那种视角，只能说你来一个请求，然后我响应给你了，我们把那个响应时间计算一下，那响应时间怎么做？比如说某一个URL响应多少时间，这肯定不会全部统计在一起，比如说所有的URL算他们的平均响应时间，这没有意义，为什么？请求Java，他肯定慢，但是请求个图片，那肯定贼快，那把这两个放在一起算个平均数毫无意义，所以这个地方看起来不能用折线图。</p>
</div>
<div class="paragraph">
<p>那么这个东西估计只能用排名，因为这个东西和URL有关系，或者我们在URL里面区分静态和动态，那看起来是做一个简单的排名,但是这个响应时间和时间有关系，可能还要关注是什么时间出现问题了，说白了，我们把HTTP的报文拿过来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>qq.com 80 2021 GET /login 2000ms http://baidu.com</pre>
</div>
</div>
<div class="paragraph">
<p>上面这一段就是说是你的Nginx主机名、然后80端口,精确到秒的时间、请求方法、请求的URL，其实我们在统计的时候并不关心他的POST里有什么内容，因为我又不是做安全审查的，我关注他干嘛，那么就还有响应时间，然后是哪个网页调用的，可能还有些浏览器标识、UserAgent啥的，所以这个响应时间一定和时间密切相关，为什么？如果要查服务器具体什么时候出的问题，然后查到状态码变大了，那现在你咋知道啥时候变大的？</p>
</div>
<div class="paragraph">
<p>那我们现在讨论怎么解决这种应用层的问题，看起来应用层不能用比较常见的图形来解决，那我们倒回去说，为什么要监控HTTP？首先监控HTTP一定是想知道:</p>
</div>
<div class="paragraph">
<p>1.请求是否收到</p>
</div>
<div class="paragraph">
<p>这里肯定是关心请求是否已经发起，是不是到了服务器上。</p>
</div>
<div class="paragraph">
<p>2.响应时间</p>
</div>
<div class="paragraph">
<p>意识就是这个请求收到后这个响应时间是多久。</p>
</div>
<div class="paragraph">
<p>3.系统时间</p>
</div>
<div class="paragraph">
<p>第一点是开始，第二点是结束，把他们两相减就能得到一个响应时间，所以监控有时候是为了解决这种在调试过程当中不知道到底有没有收到请求的问题。</p>
</div>
<div class="paragraph">
<p>4.指定URL</p>
</div>
<div class="paragraph">
<p>如果把所有的请求包都抓下来过后，肯定要去筛选，不然我怎么能知道我想要哪一个呢？所以这里要指定URL，这里看起来就不是一个统计图表了，是筛选图表，说白了，这个最终列出来的效果就是刚刚上面举例的报文那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>qq.com 80 2021 GET /login 2000ms http://baidu.com</pre>
</div>
</div>
<div class="paragraph">
<p>所以这种需求看起来是按表格来做的，然后另外一种就是需要去监控App，想看这个App的统计数据，就比如说能不能筛出来响应时间大于30秒的URL，但是看起来也是个列表，这这是一种嘛，还有可能就是我想看某些URL被访问的多少次，这看起来也是一个列表，只是那个列表展示是排行的方式，有可能是这种：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/URL.png" alt="URL"></span></p>
</div>
<div class="paragraph">
<p>其实这个时候你并不关心访问的时间，为什么?这里可能是一天以内或者一个周以内，是用户指定的时间，还有一种可能关心的重点是基于IP地址的排名，哪些ip地址访问了多少次，这里就不画出来了直接写名字了。</p>
</div>
<div class="paragraph">
<p>1.ip地址访问次数</p>
</div>
<div class="paragraph">
<p>2.基于浏览器访问次数</p>
</div>
<div class="paragraph">
<p>3.响应时间排序</p>
</div>
<div class="paragraph">
<p>4.来源排名</p>
</div>
<div class="paragraph">
<p>那这个监控还有一种作用，就是对于纯粹的运维来说，有时候服务器被攻击了，那么有的URL会在短时间以内被大量访问，就是平时说的分布式攻击，叫dddos，那这种攻击能够通过上面比如说直接看最近五分钟哪个URL被访问的最多或者最近五分钟得那个IP地址访问的最多，看这些就能解决问题，那开发测试人员，就可以去仔细筛，限定某个ip地址去筛，而这个排名就是基于HTTP报文里的关键字去排。</p>
</div>
<div class="paragraph">
<p>那还有HTTP的状态码，有没有必要基于这个状态码去做一个比例或者柱状图，好像有必要，这个可以了解大致情况，所以就可能就有一个响应代码的图：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/code.png" alt="code"></span></p>
</div>
<div class="paragraph">
<p>其实这也是一个排名，只是他用柱状图来做的，因为这个东西更像统计图表，因为这个用表格也是可以做的，那到时候具体怎么做，我觉得看情况，比如说用户看到这个图有404，然后再跑到列表里去筛404查看具体的信息。</p>
</div>
<div class="paragraph">
<p>这些东西在以前的Zabbix里面是做不了的，它只能做CPU，内存，Zabbix要做这些东西非常非常麻烦，也不是说不能做，就是非常非常麻烦，TCP还好做，但HTTP里面的东西已经涉及到交互了，做不了，排行榜也做不了，这个是HTTP，还有没有缺少的？就比如有没有关心POST里面内容的？安全审计啥的有没有必要，但好像就和统计图表没有关系了，那个刚刚有地方就是比如说反的是HTML或者EMIG，这个要不要做的统计？就是他返回的那个MIME，我觉得可能要，这个MIME肯定也是算的比例，不应该去做排行榜，因为那个东西也不是问题，所以大概可能是这样画的：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/MIME.png" alt="MIME"></span></p>
</div>
<div class="paragraph">
<p>5.响应大小</p>
</div>
<div class="paragraph">
<p>GET、POST请求方法这种玩意儿就不需要关心了，没有意义，还有就是刚提到安全审计，可能会关心参数的问题，因为GET的参数是在问号后面，而POST的参数是在Body里头，响应大小排名列出来，你要细节在列表里看，好像就不需要做其他的了，看起来HTTP好像就只有这些，运维能够筛，软件测试能够筛，统计也能看，这个要灵感的话到时候去网上看一下百度站长或者是51.la，51.la这个网站，去注册个账号或者直接看他的在线演示，它里面有很多图表值得我们去借鉴，人家做了很多年了，做的非常非常好，很细。</p>
</div>
<div class="paragraph">
<p>6.Host字段</p>
</div>
<div class="paragraph">
<p>差不多我们这里能做的都做了，端口不关心，访问御民统计，说白了就是看流量集中在哪个域名，这个就不用算比例就算次数，因为一般数量很少。</p>
</div>
<hr>
<div class="paragraph">
<p>那么HTTP才是我们的特色之一，以前要这样做的话就要去51.La引入一些JS脚本在网站里面才能统计，那如果能够在高效的情况下，直接在服务上弄是最好的，当然这又带来了服务器的性能问题，因为你要去分析网络包，而51.La是在你的网页屁股后面加个JS的脚本挂在那，因为你要访问他的链接，链接里面就有Nginx的日志，他就能分析这些东西了，就比如谁访了这个网页？网页来源是哪？他都有,所以51.La就是把所有的压力压在自己的服务器上面，主要是分析Web日志，而我们这个是分析网络包，所以这个东西肯定不能用Java写，太慢了，而且耗内存，所以C++或者rust是最好的选择，Go语言就算了，不适合干这个，因为它有GC，我都不用Go的GC，那用Go干啥？就像你用Java不用JVM，你还能跑吗？用PHP也干不了，那应用协议层还有些什么通用呢？HTTP一个，FTP没有必要，那么就还有个MySQL。</p>
</div>
</div>
<div class="sect3">
<h4 id="_mysql">23.3.2. MySQL</h4>
<div class="paragraph">
<p>因为每一个数据库的协议是不一样的，所以你要单独分析,不能把PostgresSQL和MySQL混在一起,这里我们尽可能分析多一些，Redis好像是不需要监控的，因为MySQL有慢查询的问题，那MySQL肯定最主要的就是SQL查询次数还有慢查询，那首先慢查询肯定要有一个，可能是个排行：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/manchaxun.png" alt="manchaxun"></span></p>
</div>
<div class="paragraph">
<p>那么还需要的一个搜索列表，为什么需要？因为我们在调优诊断问题的时候，我们的这个东西主要是用来诊断问题，而Zabbix只是好看，好看不能当饭吃，因为这个东西我们开发出来我们自己也能用，所以我们要提供一个SQL的查询列表,当然查询列表可能会有很多，比如数据库里某个表有1万条记录，Select * FROM Table Where ID=1&#8212;&#8203;10000，这些都要记下来，但是我们可以设置它保存的时间，因为是那样的，你总不可能关心三个月前的慢查询吧？所以你一定只关心的最近几天的，那这样我们可能会限七天内或者一天内或者三天内,那就要提供一个查询列表：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/SQLList.png" alt="SQLList"></span></p>
</div>
<div class="paragraph">
<p>这种是可以交互的，那SQL要做哪些具体的统计？数据库里面有数据库，里面有多少表？甚至还要算容量和记录条数，但其实没有人关心记录条数，为什么？因为我们主要是用来诊断问题，不出问题的话不该看这个，出问题再来看，这个能够解决他的问题，所以如果你要把MySQL里面有多少个表，多少个库，那就变成了MySQL的管理工具了，所以有时候要放弃一些东西，我之所以给个列表是让用户可以搜索，比如说像刚才那个地方一样，他要确定那个SQL有没有被查，比如说:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Select * From table Where id =1 And name=123</pre>
</div>
</div>
<div class="paragraph">
<p>用户需要确定在测的时候这个SQL上来了，而以前要做这个事很麻烦，现在我们直接提供各种工具摆在他眼前让他去用。</p>
</div>
<div class="paragraph">
<p>那这个时候SQL需不需要做统计，除了刚才说的那些，比如说基于响应时间，这个时候响应时间并不关心具体哪一刻，为什么？因为数据库，你只要不乱改它，那么今天以内，它的查询时间应该是相差不多的，再一个响应时间，排名的时候是选择那个时间范围的，如果你想看前五分钟的，就把范围拉一下就可以了，那么除了响应时间还有什么需要排名的？就比如排名哪个SQL返回了多少，就是查一个SQL后屁股下面显示了个多少行，响应时间多少，好像就没有了，还以可能就直接做一个总的排名，但这个可以在SQL列表里实现，但是可能说这个列表能做排名，但是把它单独拎出来可能看的更直观一些，所以还是把分开吧，如果把他们放在一起的话，如果以后多加几个字段，你就不好排，变成操作列表了，打个比方，我都知道这个SQL慢查询了，那我是不 是要复制到服务器上试一下，那这个时候你关心行数吗？你肯定不关心，所以说这个地方显示行数没有任何意义，所以现在就有慢查询排行、返回列排行还有查询时间的排行，基于那张表就不关心了，因为SQL是整体的，那么还有一个就是查询结果大小排名。</p>
</div>
<div class="paragraph">
<p>那么MySQL这里好像就没有了，相对比较简单，我讲一下为什么会对查询结果的大小排名，因为这个大小有可能是100M，什么意思？就是你查出来结果有一百兆，要是你跨机器查100M东西，那你得下多久啊？最终Java拿到的时候可能都过去了几分钟，所以在这种情况下数据库其实已经查完了，查询时间可能只有一秒钟，结果传输时间花了一分钟，所以这个地方应该有整个操作的完成时间的排名，意思就可能是这样的：</p>
</div>
<div class="paragraph">
<p>SQL查询花了两秒钟，然后那个传输花了80秒钟，最终的时间就等于82秒，上面的大小是大小，时间是时间，虽然他两个有关系，这个也是个排行，就是TCP不是要挥手或者是SQL查完了后，TCP上一定有动作，这个是能知道的，所以基于这个最终算的时候，是有办法算的，所以这些东西拿出来后，我觉得不管是做性能调优、排错、开发测试都能做，包括运维也是可以的，像以前就要靠很有经验的人去做，各种命令，要死。</p>
</div>
<div class="paragraph">
<p>但是这里索引不关我们的事，建索引无非就是想加快速度，无非是想减少慢查询，然后想要好看的查询时间，但是我们都把有问题的查询列出来了，那不就好办了，以前在服务器上开启慢查询，有事没事盯一下，最关键的是慢查询那个日志贼难看，那既然时间都有了干脆就把行数也写上去，反正弄在那你就不用查了，就是那个文件里头有多少行，什么时间查的，那个数据库的，因为那个SQL里面是带了数据库的，然后这地方吃点苦，那为什么不把他们结合在那个列表里面？说白了你可以用一种东西展示，但是这个地方，这个列表自动带了三个搜索条件，然后把这个搜出来排一下序，但是我觉得不要这么干，为什么？工作量一定比这个多，所以直接弄个排名最简单，相反这个很复杂。</p>
</div>
<div class="paragraph">
<p>那么MySQL就这些，PostgresSQL就不讲了，用户太少了，我们先解决共性的问题。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYJIEM4-8_chapter">24. 智眼系统API和界面设计（4~8）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_23">24.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/板书1.jpg" alt="板书1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/板书2.jpg" alt="板书2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/板书3.jpg" alt="板书3">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/板书4.jpg" alt="板书4">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/板书5.jpg" alt="板书5">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_界面设计风格">24.2. 界面设计风格</h3>
<div class="sect3">
<h4 id="_统计图表">24.2.1. 统计图表</h4>
<div class="paragraph">
<p>那个工具导航栏这个地方除了放大缩小就是比如说highcharts提供的以外，我们还要增加什么东西，这个地方，我认为还有个东西叫设置，通常来说是一个圆圈，然后外面那个设置，就知道说是个工具，那这地方要设置设置什么？我打个比方你这个时候你在某一个服务器的那个统计页面里头你设置的时候，一定是设计设置那个服务器的，因为是这样的，大多数情况下头你可能关心的只是某一台服务器的那个指标，其他时间默认就可以了，所以我现在讨论几个问题啊，就是第一个就是在我们出版的时候，在我们第一个版本的时候，需不需要让用户去改我们的那个采集时间、间隔、上限这些东西需不需要？那就是说第一个暂时不需要考虑设置，为什么暂时不考虑啊，因为一个系统，他在不成熟的时候，你并不知道用户想怎么设置，所以你这个东西就要保住你的核心功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>暂时考虑设置功能（核心功能更重要）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以这个地方其实本意是核心功能，就是核心功能更重要，像其他这东西啊就是必须得，要绕不过去再说就是你把核心功能开发完了，然后这个是有多余的时间你可以做这种边缘工作，所以看下这个设置按钮应该是不需要的，除了这个以外，通常来说这些以外就是表格框架呀他会这个地方选时间是有的，时间范围，这个上面还有什么？像我们昨天说的就是统计图表啊，就是还有时间范围来看，最近五分钟，最近十分钟，最近多久，放大缩小，好像就没有了，还有没有。比如说他说那个就是需要用颜色做标注，这个是一根线表示什么意思？这个波浪线或者红色的线表示什么？比如说这个方格的这种什么，你的去说明每种线代表的是什么意思，这种就是统计图标的，还有一种是什么排名列表排名的，排名的那些东西好像都差不多，因为他也是统计表格，那么还有一类就是纯表格类，这是统计啊，统计图表，还有一类是表格。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_表格">24.3. 表格</h3>
<div class="sect3">
<h4 id="_按列排序单列">24.3.1. 按列排序（单列）</h4>
<div class="paragraph">
<p>表格上头就有东西，通常来说的话，这些上面一定是涉及到过滤，然后过滤的话他可能有几种，输入，我打个比方，输入一个文字筛选，属于搜索，给了个数字框去搜索用户名，就纯字符串这一类的，然后还有什么？这个地方会有上下的那个排序，那么这类的话就那么第一个，就是按照列的排序，那像你排序，有个问题，你排序可不可以用两列排、三列排、四列排、排了又排，有没有必要？有点复杂，就是跟Excel一样，但是你不能在这儿放Excel啊，有没有必要吗？我要实现的话，我肯定是所有的表格都支持这个功能，因为应用函数一写，所有东西套进去都是一样的，和数据类型没有关系，比如说一个Root用户，我先用Root用户名排序，用户名排序之后，用户名排序过后按时间排，我就筛出了每个用户，那么一个时间列表，有没有这种必要？那这种情况下面的话，我就说一个交互上的问题啊，因为我们在系统做系统设计嘛，我们是从界面开始的。我先点他，再点他，看一下是两次动作,随时如果支持多列排序的话，我就不能用这种单点的方式来用，因为这么点只是解决一列的问题,我要复杂的排序的话可能在上面选利用哪几列排，一个筛选条件嘛，我就给他一个筛选条件，先按谁排，再按谁排谁排谁排，当然我就不去做那种Excel那么高级的复杂的筛选功能和排序按在一起，我们这个排序功能只关心当前里边的内容，至于他前面条件和这个东西没有关系，不要把它偶合在一起，意思就是说不要在排序的时候增加强关联的，必须的填那些东西，把它分开排序是排序，搜索是搜索。</p>
</div>
</div>
<div class="sect3">
<h4 id="_多列排序">24.3.2. 多列排序</h4>
<div class="paragraph">
<p>我先说单列，你还有多列排序，多列排序怎么做？下拉菜单，然后呢？你大概是这样吗？比如说我就画个工具栏，那这有个排序，然后就出现一个列表，然后列表我们就用打勾来选，就他以此打勾嘛，最简单的方式是这样的，但是打勾你勾打多了你会迷路，你不知道先打的谁，所以通常那种排序有这个做法，比如说这个地方叫时间，这个地方叫用户名，比如这样他通常或者这个地方放个这个，你点这个上，他就往上排，我们就先假定这种嘛，这是最常见的嘛，等于说排序的话就通过这种方式来，单列的话就点这个，因为是这样的，你做了这个功能和这个功能你其实调的是一个接口，因为你这么一点，你点这一列就是把这一年放在前面，然后其他的默认呗，你就是相当于是把其中任何一个调到最前面去，他是有用的，但是暂时的可能用的不多，但是要用的时候又没有代替品，你想嘛，你说我提供个导出功能啊，这个地方有个导出哈，比如导出csv格式，就是Excel，就只是导出Excel，因为导成Excel过后他可以自己排，但是我们这个地方想的是说你不用Excel你直接点，这样的话对于用户来说他不需要去装office，因为有可能对方连Linux、WPS都没装，或者他不会用，你不要觉得那个Excel很简单，真的很多人都不会用的，支持单列，单列是这种方式，支持多列是这种方式，还有筛选。</p>
</div>
</div>
<div class="sect3">
<h4 id="_筛选">24.3.3. 筛选</h4>
<div class="paragraph">
<p>我打个比方吗？这种筛选有几种数据类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>是\否（Boolean）</p>
</li>
<li>
<p>数字范围</p>
</li>
<li>
<p>时间范围</p>
</li>
<li>
<p>值匹配（模糊匹配\精确匹配）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>按时间筛选、按字符串匹配、然后按数字范围、布尔值，也是匹配哈，但是我们写出来嘛，然后这个涉及到是或者否，就是布尔，然后可能还涉及到一个数字范围，时间范围。比如昨天我们说Mysql那个响应时间，他这个时间是个数字范围，比如三秒到五秒钟，字符串匹配，就是值匹配哈，值匹配就不一定是字符串有可是他填个1想搜1，是那样的啊，数字范围的话啊他比如0-1而值匹配的话他填个1,那有可能搜的是123，因为是模糊的，就只匹配这个地方，是用模糊的还是精确的？比如说那个HTTP，那个要查浏览器标识的时候你没有办法用精确的，只能用模糊的，比如说你要搜错误代码，你输入个2,他应该看全部的，所以这个是应该是模糊的，模糊匹配，还有没有啊？就拿那个Web日志来，搜索域名、搜索时间。域名是模糊匹配，搜索时间是时间范围，搜索URL是模糊匹配，响应代码是之匹配，所以这里我觉得这样嘛，让用户点嘛，是点模糊匹配还是点精确在后面放个选项上选，这样对我们来说其实都差不多，来源是值匹配，浏览器标识是值匹配，响应时间从零秒到十秒的是数字范围，Get\Post那是精确的，Mysql那个查询的话，响应时间是数字范围，然后时间范围是时间范围，SQL查询是值匹配，好像布尔值很少，但是他有，0或者1,2或者3这种,但是这个也可以归到精确值里面，精确的0精确的1,只是那个到处展示的时候，你可能是用一个是或者否的checkbox来做，好像就这几种啊，基本这个覆盖了所有的，所以我们要在让用户有个选项就是是模糊的还是精确的有没有必要？我打个比方吧默认全是模糊的，他说那个错误代码200，能搜是200，搜2能收出302,200都包含2嘛,他想精确他就把那个字符串加长嘛，好像精确放在这而是累赘，你想精确你就加长嘛，对于我们来说是一点性能损失，主要是因为你要用精确的话他每一次填任何搜索值的时候，都按照后面写个那个box，就checkbox，那个界面贼丑，用户一下就不想用了。</p>
</div>
<div class="paragraph">
<p>表格上还有没其他东西啊，还有没有其他统计图表的形式啊？柱状图需要改那个吗？所以看起来界面风格都这么定了，折线图你无非也是这种，你工具来是一样的，然后这个地方也有个导出，要加个导出啊。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>导出（CSV、PNG、JPG、SVG）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然我们默认所有导出的是表格数据，只是支持导出CSV，PDF要不要？没有必要吧，导成照片，照片就没有数据，照片就是个图像，就可以看趋势，我都看照片了，我就不怎么关心数据了，我关心数据我我就打表格，你都做成照片了，要不要考虑pdf啊？那要不要考虑分享？分享是为了啥？你导PDF也是为了分享，我们就讨论明白吗？就是他用什么情况下需要导出？给领导看PPT需要导出，他截图也是可以的，只是截图没有这么高清嘛，这就提出了要求，导照片是为了PPT，导CSV是为了自己去分析，然后导PDF这种有可能是为了领导，但是我导的时候可能就不是一张图表了，你应该要的是整个服务器的状态，所以我认为导PDF应该是在整个主题视图里面，而不是单个图表了，你应该是先进一台服务器的子页面，你应该是导的这台服务器的，你应该把服务器上所有的表格都导出来，而不是只导一个，所以PDF不应该是单个表，因为单个导你也不如导照片的都划算，那分享链接也没有必要啊，比如说他问别人这个服务器有什么问题，他截个图发个对方就可以了，他导PDF也没有意义，分享链接也是，你分享链接就意味着一个问题，你分享链接对方直接看链接和看图片啥区别？你导的文件你直接发给他也不是不可以，所以看起来就没有链接这回事了，所以这个地方是支持CSV啊，支持PNG、JPG、SVG，这是矢量高清，这个你无限放大都可以的，这个东西导出来它不是一个照片，导出来它是一个XML，它的照片是用数据画的，SVG是数字照片，其他的都是是纯图片，流媒体，多媒体的东西，我觉得要做一起做没啥问题，因为都差不多，所以这个地方也是一样的，SVG主要是为了高清，他可以用来做海报都可以。</p>
</div>
<div class="paragraph">
<p>然后现在来看主机试图，应该是完整试图，我打个比方这个地方是一个完整的Page，有可能从这儿到这儿可能是个菜单栏，然后上面这个地方可能是一些登录、我的，然后主页之类的，那这地方可能是Logo，还有其他东西，这地方菜单，那么菜单过后我们不考虑那个进来的主题，我觉得又没有意义，随便你怎么做，你们就考虑主机视图，然后这个地方就是cpu这些，然后有这个过后就是一个整个统计视图了，那这样的话就在下面地方应该有内存，负载这些，所以是这个样子的。我觉得界面就讲完了。</p>
</div>
<div class="paragraph">
<p>最下面有个Power By，一些技术支持之类的，就先写个主机，然后二级菜单就是所有主机列表吗，这个东西你避免不了啊，你主机那么多，我如果不要二级菜单怎么做哈，不要二级菜单的话，你点了主机过后，这个地方就会出现主机视图，然后他自己手选嘛，就不要在菜单里面选，在这个之前还要多个页面，就不要放到这儿，因为放到这儿他不好搜，而且如果你这个地方如果有主机菜单的话，你还可以做个主机概览，就是所有主机的一个大概的，比如说绿色的红色的，你可以展示在那个位置，红色表示有异常，点击去看嘛。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_绑定界面">24.4. 绑定界面</h3>
<div class="paragraph">
<p>首先他这个地方可能就有一个主机的注册，那么还有概览，然后我们再说注册，所以注册界面就不要真的花里胡哨了，直接一个表格，所以主机注册这地方就是个列表，然后这地方是操作嘛，然后这地方可能是IP啊，可能是一些其他的，192.168.0.0，然后这地方操作涉及到一个是注册，然后还有个是取消之类的，先这么定嘛，所以涉及到一个注册界面，然后这个地方有个主机注册，这应该是注册列表，然后点了这个注册按钮过后才是主机注册，然后这个是具有IP地址，时间，随便占个位置哈具体什么我不知道，然后可能还有些主机ID之类的是吧，然后可能还有凭证是否可信之类的，就先暂时不管，但是地方一定有地区，或者机房，机房这种东西就不要去再增加个机房添加管理了，打标签对吧，你愿意写啥机房就写啥，你弄完了之后一个框放在那就可以了，我才不管你填啥呢，那地区也是一样的，我也不会给你弄个省市区的那个下拉列表给你来拉，我又不是身份证管理系统那么严谨，你填个成都我就知道成都，你要填什么乡什么村，我也没有意见，但是你不要给我写什么街道117号，因为我们不是资产管理系统，我们这里面是监控，我用这东西只是辅助你，你这么一说的话网卡的MAC地址写不写上来啊，那这个时候填完那些信息过后那么注册，我觉得主要主要逻辑逻辑已经完了，当然刚刚不是说的那个事件回调那些东西，我们现在还没有做这些地方去，我们先把图形展示出来，那是第二版，下一个迭代要做的，这也是这个迭代要做的，你可能先有个主机注册这两个页面先画，当然你要先画Logo跟主机这个，画完这两个再画主机注册，画主机注册再画主机注册列表，然后你才能看到主机概览，画了主机概览才能看到刚才那个主机视图，是不是就连起来了，就非常非常ok。</p>
</div>
<div class="paragraph">
<p>界面讲完了就要开始讲API了，那这样的话就相当于是说界面我们现在基础流程已经拉出来了，而且这个是核心功能，我们刚刚就是讲，这些东西都是核心功能，因为为什么？我们和Zabbix最大的区别是什么？</p>
</div>
</div>
<div class="sect2">
<h3 id="_竞品区别产品优势">24.5. 竞品区别（产品优势）</h3>
<div class="paragraph">
<p>就是我们在到回去讲核心功能的问题，首先市场上已经有很多很多的监控系统了，就是我们的区别和重点啊，所以我们就讲区别，其实在讲我们自己的优势，先讲一下在在服务器管理和运营过程当中的一些问题，你可能说你不是服务器管理员，你可能说你也不需要，这正是这个时代向前走的个原因，所有人认为那些技术设施，它都应该是什么智能化，自动化的，但是实际上大家知道开发了那么久，就像昨天说那个GeeShow宕机了你都不知道一样，所以那这个时候当扯远一点哈，我打个比方，你不是有接口吗？我们也是监控，我们是不是以后也可以上一些功能做什么呀？</p>
</div>
<div class="paragraph">
<p>我们讲一下我们和竞品的区别或者产品优势，就是在这个年代，系统运维会越来越少，就特别是初级的，那当然所谓岗位里面中高级的岗位永远的缺，有就是被代替的永远永远都是初级，所以在这个情况下面大家不会把精力啊化在服务器的管理上，这是这因为这个导致了什么？我刚刚说那个用户嘛，天天被黑，比如说那个GeeShow宕机了这种情况你肯定要买360云监控去做，当然我也没有说我们这个玩意不能部署到云上，你注册成我们的用户，我帮你监控，你报到我这就可以了，Elasticsearch就这样的呀，他先开发个东西让你用，然后最后你说你自己不想搭你买我的，我都搭好了，至少轻度是可以的，那这个时候我可不可以把你的接口监控起来，我甚至把你网站监控一起给你做了，就是有无限的扩展性，他还可以支持回调，现在哪个监控支持回调啊，他只是发邮件发短信给你，但是发短信有个问题啊，你这种方式如果我内部有管理系统，你接不进来，就像美团那种公司那么大，你发短信肯定不合适啊。所以就在胜在我们年轻啊，那传统的监控能解决吗？就现在涉及到监控的两个词涉及到互联网行业的服务器领域的有几个？360云监控，阿里云监控，他是你给他的网站的URL他就一直去访问那个URL，访问打不开了，超时了500错误了就告诉你了，他就发个短信给你说网站打不开了，
那剩下的问题为什么打不开啊，你懂我意思吗？就说白了，他只解决了一个你知不知晓的问题。他并不能帮助你去解决这个问题，然后又回到那种需要在服务器上装东西然后监控的这种，Zabbix那种东西，他只是帮你绘图，剩下的你还是没解决，然后你说强哥，好像我们也没解决啊，我们不是正在解决吧，我通过这些信息我们刚刚说那种CPU属于基础技术信息，但是我们的应用监控我们那边只讲的HTTP、TCP和Mysql我可没有说没有其他东西啊，我有无限一种扩展性，因为我们的客户端程序支持Python、支持Shell、支持Java、支持Rust，你用你爱弄的方式弄就可以了，我都能怎么样，我给你搭了一个架子，你要什么用体系你自己搞嘛，只是现在自动生成图片那端，我们现在那种统计图表没有办法自动生成，我们到时候可以学Kibana，让你选图表嘛，我们把数据套进去嘛，但是你要告诉我们你那个插件是符合那一种图形的，所以说我们的SDK里头，到时候让他供数据的时候，他一定要调我们函数，调函数，比如说叫排序列表函数，它就调排序列表函数，所以它生成的格式就一定能用Highcharts直接能套，我只要发现是那个用户的自定义程序1,我就用自定程序对应的排序列表就套他，套不套的上我不关心，反正你肯定不是万能的噻，你不可能写了个插件任何图表都能套我才不信，他说我要改怎么办？你自己改插件和我没有关系我，我提供一个通道给你，我可能不能解决所有的问题，但是我提供了个通道，我认为通道才是有价值的，我认为我们不应该写死，要是写死我们直接用Rust，用C+ +把那个服务器监控采集的全部写死完了，用户咋办呢？凉拌，我们正是因为不相信我们自己能解决所有问题，我才让你解决的，我只解决共性问题，比如说你要监控啥接口的，我也可以提供这种方法给你啊，你可以做呀，所以随着我们的这个产品越来越成熟，我们里面东西越来越多，而且最关键是我们自己也在用，我们自己也有那么服务器需要管理，随着我们成熟我们壮大，我们插件是不是越来越多啊，我们最后会反哺我们的开源程序，那这样才是有益的互动，但一旦我们成熟了，我们的用户是不是就成熟了？用我们的就可以了，你不用去费心思了，美团你不要自己开发，你把我收购了就可以了，这就是明年为什么我们需要程序员的原因，因为GeeShow他也成熟了，然后我们的这个智眼它也会成熟，我们需要在开源领域里面去深根我们的技术设施，这属于基础设施。</p>
</div>
<div class="paragraph">
<p>最开始给大家讲监控的时候，大家可能觉得就是个监控嘛，画个图嘛，那现在问大家一个问题，监控简单吗？那我再问你个问题，你最开始认为监控是不是很简单？因为说到监控两个字，大家都会是吧？我们讲框架设计都讲了3、5天吧？讲界面都讲了几天，我还是讲了一个主要链路，我也没讲其他的呢，所以我们最大的区别是帮助用户搭建监控通道解决应用问题，而不是解决服务器管理问题，因为服务器这种情况下他是不会被黑的，只有你在上面放了网站才被黑，所以我们是解决应用问题，解决调优问题，解决产品问题，我们不是解决系统问题的，比如说你那个系统没打补丁被黑了我们我们监控我们也不知道啊，因为所有的监控指标都是用户提供的，我们只是说我们能够基于基础监控给出一个健康指数来，比如指数为零就证明是正常的，指数我1000就是不正常的，我只能告诉你服务器是否健康，我不知道他出了什么问题，但是我提供个手段，让你去解决，比如说我讲的服务器被分布式DDoS攻击了，你能通过HTTP监控，还有带宽，还有TCP，你能完整的看到这个服务器这个状态，因为数量越来越多嘛，一下暴增，你是傻子你都能看出来，在服务器死机之前还有机会把数据报出来，比如说服务器带宽只有十兆，对方把十兆占满了，你会发现前面那个带宽是平稳向上的，然后突然没数据了，空的就变成发生任何变化，断了嘛，很明显，你的那个客户机掉线了，但是掉线之前的一个趋势我已经采到了，这样才能解决问题。</p>
</div>
<div class="paragraph">
<p>我再给你扩大一些啊，比如说你是太行云梯，太行云梯是一家互联网公司，他是不是也有这种管理问题？他是不是也有连接问题？他能不能写个太行云梯自己的插件基于物联网的把自己的所有状态报到平台上来啊，是不是又变成了物联网监控了？因为你只要用到服务器我就都能干，我可能解决不了你设备的问题，但是我可以解决你设备服务器的问题，是不是跨行业了？这个才叫基础设施，什么叫基础设施？你家的宽带，你手上的智能手机、你的电脑、你用的Windows、你用的Linux、你用的Mysql，这些东西是不是任何行业都可以用啊？任何人都可以用所以这个时候叫基础设施，而我们这个监控是叫技术设施吧。</p>
</div>
<div class="paragraph">
<p>但是我就这么说实话，我在开源界混了十多年，真的基础设施非常缺，大的那种数据库啊操作系统有大公司在维护，我们不用去操心，但是涉及到用户端的时候，由于你的财力精力是有限的，解决的并不好，我就拿一个Mysql调优来说，以前那些大公司要请叫Database Administrator，叫DBA，叫数据库管理员，工资多高呢？起步2万，找工作就2万，找不到就是没工作，90%以上都找不到工作，最后变成网管和运维，退而求其次，但是呢，数据库问题不是大公司才有啊，比如说昨天那个赵玉玺说的他们公司数据库被删了，是不有这个问题？我们的I/O监控是不是检测到被删啊？我们现在I/O监控不是没有设定目录吗？我们之前讲过的我们可以监控目录是吧？我可以知道什么时候删的呀，我可能不知道谁调的删的，但是我可以告诉你是什么时间这个目录被动了是吧？解决了赵玉玺的线索问题，当然我们可能还可以提供比如客户端程序，我们还能镶嵌到应用程序里面去，比如说你写了个Java应用程序，然后这个时候你想把Java应用程序里面的状态收到几个用户提交的注册请求，然后登录几次，注销了几次，我问你我们这可以做吗？你只需要把那些数据按照那个SDK对吧，朝外面报，需要我在暗示你吗？所以你知道为什么我们要提供客户端的那个上报的SDK了吗？虽然我叫主机试图，但是我没有说你主机是谁呀，他主机完全可以是个应用程序啊，没说错吧，他能是万金油，那我问你个问题Windows是不是啥事可以干？他是不是也是万金油啊，所以万金油是贬义词吗？ 因为它是基础设施,我打个比方:整个互联网百分之九十的数据库都是Mysql，因为大家都能用啊，而且他没有限制自己，所以我们也不要限制自己啊，比如说你写Java的时候，比如用户注册了三次，你把它记到你的小本门上，用变量保存下来，你写个类里面有个变量等于三,然后用户注销了八次，注销那个变量等于八，最后你又写个toString，把那个东西了打印成字符串，再把这个字符串调我们的SDK，包装在Json丢到服务端来，我是不是可以画图了？</p>
</div>
<div class="paragraph">
<p>我从来没有说我是监控系统，我说监控系统只是想让你听明白，我从一开始就叫智眼，意思就是说人能干的我都能干，现在发现这个事好像就没有那么简单了，格局就变大了，我之前不敢跟大家讲是因为我讲你听不懂，但是你现在已经看到界面了，你大概清楚，比如说那个地方那个IP地址，我没有说我一定是IP地址，我主机是可以分类型的，比如说叫应用主机，或者叫应用节点，或者就叫节点，节点：IP地址，节点：Java，节点：Nginx,你可以把Nginx日志也报上来啊,只是没有必要，为什么？我们也有监控，但是我们的监控的是基于网络来的，所以我们的响应时间是通过网络来算的，可能稍微和Java真正处理时间还是有些误差，但是这个可以接受，因为网络传输永远是相等的，意思就是说你的那个变化的值加上个相等的值，你可以忽略这个相等的这部分。</p>
</div>
<div class="paragraph">
<p>现在要给智眼做定位，那么智眼的定位是什么？刚刚说了就是我们不仅仅是监控，我们要帮助用户解决他的应用层的问题，就先说解决的问题嘛，我们解决了监控问题，我们解决了报警问题，那我就说解决的问题或者重点嘛：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>监控、报警、消息推送(回调)</p>
</li>
<li>
<p>状态类数据通道</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>定位先放在那儿，这我写关键词，我们能监控，能报警，而且我们还能消息推送，就通过回调，监控，报警，消息推送还有什么？还有一个就是你可以把Java的用程序朝我们往上报，我们是一个状态数据通道，因为监控的是状态，所以我们是状态类，他打通了开发者到最终的管理者甚至再到开发者，以前你放到系统上是从开发者到到运维，以前是这个样子的：</p>
</div>
<div class="paragraph">
<p>old：      开发者——&gt;Linux&lt;——运维</p>
</div>
<div class="paragraph">
<p>那么这是开发者，那么开发者把东西部署在Linux上面，然后这个时候是由运维来管，以前是这个样子的，中间是隔了一个，而现在啊，这是old，现在新的模式是开发者他开发完了过后部署到Linux上面：</p>
</div>
<div class="paragraph">
<p>new：      开发者——&gt;Linux——&gt;智眼&lt;——开发者/用户平台</p>
</div>
<div class="paragraph">
<p>那部署到Linux上面过后现在因为有智眼，所以现在变成了开发者能自己解决，所以我们解决这个通道的问题，当然这个地方我为什么不说产品从外面报，因为开发者开发的就是产品，他不开发产品的开发啥呀？我就没有必要讲废话了，我们通过这种方式让这问题隔离在智眼这个环节，他是完全是不需要上服务器的，除非是我们不支持的，但是那种手动操作的事和我们没有关系，所以我们搭建的是个状态类数据的通道，这也非常非常重要的。</p>
</div>
<div class="paragraph">
<p>那么报警、消息推送，为什么我把报警单独提出来，因为以前老的报警是邮件，邮件其实没啥用，因为我消息推送才能解决接入用户内部系统，我接得到用户的平台，美团的平台我才有价值，我可以让他自己做数据分析，除了这个以外，我们还可以把我们的数据通过SDK主动朝外面报或者是它的调，就相当是数据报到我们这个地方，然后再推出去，大家我们推出去要看他想要什么东西，大多数情况下的一定不是我们主动推，是用我自己来拿，他想要拿多少，比如他想拿最近一个月的数据，他拿了过后自己去存着，所以我们还有我们自己的API系统，所以有我们的API系统，那么用户可以把数据推到用户平台上面，所以我们有API系统是不是就有我们的SDK（Software Development Kit），就是我们用Java把那个API包一层，包装成Java的语法用户可以用，我用Python包成Python的语法给用户用，那这样的话用户就不用去管关心Json格式了，他关系的是Python把那个库引进来就是个框架了，我们框架的Java框架，我们框架的Python版，我们框架的Rust版本，那这样的话可以把数据接到他那边，所以那这边是API系统：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>插件——&gt;智眼——&gt;API系统（SDK）——&gt;用户平台</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那这个地方是插件，那么插件把数据推到智眼，智眼再通过API系统等着别人来调，解决了数据最终是开发者到智眼，最关键是智眼还可以到用户平台，是不是全部打通了？然后这个地方不仅到开发，这个地方甚至还可以到它的产品内部，比如说这个Linux智眼，那么你可以直接把产品推给智眼，产品状态嘛，所以我们还有个特点就是我们可以嵌入：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>嵌入Java等应用程序内部</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>好像就是这几个是吧？这讲了一大堆特点啊，就是还是没有定位定出来，就只知道怎么用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_初衷">24.6. 初衷</h3>
<div class="paragraph">
<p>然后现在有两个问题是我做这个系统的初衷哈，我做这个系统的第一个初衷：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户不了解自己企业的数据状况（服务器、产品数据、运行数据）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>而这个数据状况包括了服务器，产品数据，还有运行数据，这地方是讲的是Java，不了解就是说看都看不见，所以总结个词就是&#8217;看不见'。</p>
</div>
<div class="paragraph">
<p>第二个初衷：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>企业发展过程中无力解决问题（没人、没钱、没技术手段）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>正是因为不了解，看不见导致了无法解决或者预判问题啊，这是真要命哈，就是企业发展中无力解决问题，体现几个方面，第一个没人，第二个没钱，第三个没技术手段。我告诉大家智眼的最终目：'是让用户都能免费用我们的系统，他发现问题他解决不了的，他可以一键呼叫我们'，所以他的商业模式其实我早就想好了。</p>
</div>
<div class="paragraph">
<p>所以那么第三个初衷：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过解决开发者的问题延伸到收费企业服务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这才是最终目的，我觉得我讲的很直白了，没人没钱没手段，那第一个初衷是看不见啊，第二个初衷是解决不了，第三个初衷是花钱解决。</p>
</div>
<div class="paragraph">
<p>所以那又回到特点这边来，你会发现这些手段无非是先服务于开发者，最后他们公司连开发者都没有，就是一个新人装了我们的系统就可以了，剩下的老板说，你能解决吧，我知道智眼他们能解决，买企业服务，所以这地方是花钱买服务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_定位_2">24.7. 定位</h3>
<div class="paragraph">
<p>所以最终它的定位是：解决企业问题。</p>
</div>
<div class="paragraph">
<p>那这个地方定位的话，应该是分两个阶段，那么第一个阶段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务开发者解决产品运营问题</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以这个地方定位：服务开发者解决产品问题，解决产品运营问题，是运营问题不是运行问题，因为运行问题只是运行那一刻，运营问题，你要了解你的状态数据统计，所以服务开发者解决产品运营问题。</p>
</div>
<div class="paragraph">
<p>所以现在问你，我们是监控系统吗？角度完全和Zabbix不一样，所以现在知道为什么强哥一开始就要让大家去设计整API通信了吧，因为你没有API通信的话你没有办法去做后面的延伸工作，不管是插件里面的API上报，还是这个前端的API输出，你完全可以用PHP在服务器上全部写完，用啥API啊？那是因为我们最终要朝外面输出API，反正都是一套的，就不要去重新搞了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_详细分析定位">24.8. 详细分析:定位</h3>
<div class="paragraph">
<p>刚才我们就提了我们的初衷和定位，那我们第一阶段的定位就是：</p>
</div>
<div class="paragraph">
<p>”服务开发者，解决产品运营问题。”</p>
</div>
<div class="paragraph">
<p>通常来说，一个企业里头开发者是起决定性因素的：</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>一个科技公司里面技术领导最高的职位是CTO，中文叫首席执行官或技术执行官，那他是走技术线的,而一个科技公司，他既然都叫科技公司了，那证明是技术才是最值钱的，当然公司不是因为程序才值钱，但公司连产品都没有，还谈什么融资，谈什么商业模式，所以开发人员是非常非常重要的基础，通常来说开发产品的人，他在公司里面话语权非常非常非常重的，再加上领导又不关心服务器，这个时候开发者说服务器有问题，那就是有问题，所以开发者为了公司解决运营当中的问题，自然而然就是为公司解决，那自然而然我们就把触手伸到了企业里头，比如说大家都用的码云，最开始他是为个人开发者提供仓库的，慢慢的就变成了企业项目管理平台，各种项目管理的东西了，就产生企业年费了，但是个人开发者还是免费的，如果他连开发者的土壤都没有，还谈什么企业服务，所以我们商业模式和码云一模一样，包括GitHub也是这样的，在GitHub上，如果你是企业的话，你要买私有仓库，私有仓库算钱，他不是针对企业，而码云纯粹是为企业服务的，所以这个定位就是：</p>
</div>
<div class="paragraph">
<p>你解决了企业开发者的问题，你就解决了他的企业问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_详细分析初衷">24.9. 详细分析:初衷</h3>
<div class="paragraph">
<p>首先详细解释一下，我待过的或者服务过的公司应该上百家，他们都有一个很致命的问题，你问他服务器或者产品运营，打个比方，我问饿了么的工作人员，问他的产品现在有多少注册用户？他很有可能答不上了，因为这个问题除了他们公司非常关心用户数据的人才知道，但如果你不是饿了么，只是一家名不见经传的小公司，你知道你注册用户多少吗？你大概知道一个数，因为注册用户数拉个列表一看就看到了，一点问题都没有，那问你用户一般使用高峰期是早上还是晚上？哪个时间点？他答不上的，为什么？因为他在做企业服务过程当中或者说在给用户提供服务的时候，他其实他并没有手段去了解他用户的状态，那个程序员一上手说，我要给你开发一个用户画像系统，意思就是说大数据、大平台、几百万起步，大哥，你小心点好吧？所以这个时候中小企业啊，大企业我们不管，他自己对公司内部的运营状况不清楚，他如果想清楚就得让程序员手动去查SQL，
但是查SQL，这样你也不知道用户在哪个时间段用，为什么？这是最后一个结果，但可能就很麻烦，你可能写了一堆SQL，每个星期给老板发个报表，这种公司我见多了，都是这个样子的，统计一下，然后那个报表懂技术的人还至少能看懂,要是不懂技术的，他说你那个界面不够好看,所以这种是做产品的企业,还有一种企业就是那种纯网站，他们可能开发了个网站，然后让用户的访问，比如说开发了个微博，他除了知道自己有多少用户以外，那么想知道今天的热点是什么，不清楚，那就要开发个热榜，热榜有了，那请问今天用了多少带宽，也不清楚，然后装了个Zabbix，好像清楚一点了，那访问的稳定性怎么样？就说等一下，得先看下日志，嗯，那个屏幕在动，访问是正常的，但是你知道，很多时候日志在动也可能有500错误，就夹在里头，所以公司对他自己的访问质量，其实是失控的，你只有用肉眼跑的浏览器上打开，你看速度是正常的，但有的用户，他打开就不是正常的，所以你会忽略掉很多很多的细节，所以我基本上经历的公司，百分之百的公司都对自己不了解，因为他们都是中小型公司不超过一两百个人，真的是小公司，所以他们在这一块做的非常差，然后一旦程序员说要开发一套东西的话，一来几个月，老板肯定不干，所以说在低成本或者快速的情况下面，他没有办法，我再说为什么不用ES和Kibana，这是人用的吗？那个门槛可不是一般的高，那基本上你对大数据有了解，你基本上才才敢说你的会用，门槛那么高，那有没有低门槛的？没有，一个都没有，一个能打的都没有，所以要看见数据，他们就说反正是开网站的，我就装个51.LA或者百度站长工具在屁股后面加一个JS的调用，通过这个至少能知道用户多少访问量，那你的访问质量怎么样啊？这不就又回到刚才的问题上去了，你只能知道你的数量，你从数量上看到，用户量少了，那为什么用户会少？你也不知道，我昨天讲过的，你在外面挂了个外挂，但是你不知道里面发生了什么？永远站在门外面说话，但是程序内部出了什么问题，具体什么故障，你是不清楚的，你只是说你访问量下降了，这是个很笼统的概念，所以真正能解决问题的，一定是从系统内部的基础监控开始着手的，把这种状态数据分门别类，采集下来才是万全之策，所以他们看不见啊，这里顺嘴提一句，我们不是说不想用ES，是因为如果部署到用户端，那玩意太大了，但是我可没有说我们以后做成云服务的时候，不用ES，我可没讲，那个时候我的产品模式已经定型了，我有钱请程序员在基础版上做个plus版本，就是你用的开源版本，很low，Vip版本就很高级，所以那这个时候慢慢慢慢的，我们就有层次、梯队了，免费版是免费版，但是我们先开发免费版是对的。</p>
</div>
<div class="sect3">
<h4 id="_看不见">24.9.1. 看不见</h4>
<div class="paragraph">
<p>所以要先了解自己，比如说，我问你现在血压多少，你也不清楚，你的脉搏次数多少？脉搏这还有用手摸一分钟才知道吧，然后你的视力多少？还得测一下，所以你不体检永远就不知道，所以监控就像体检一样，无时无刻的关注着自身。</p>
</div>
</div>
<div class="sect3">
<h4 id="_产品数据">24.9.2. 产品数据</h4>
<div class="paragraph">
<p>这里的产品数据指的就是你可以把那种SQL数据，通过插件往上报也是可以的，就是纯查SQL，查完了你数据丢出来，我才不管你是啥数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="_运行数据">24.9.3. 运行数据</h4>
<div class="paragraph">
<p>什么叫运行数据啊？就是在Java程序里面或者Python程序里头，甚至于PHP里，在整个运行过程当中的一些应用程序到底我们稳不稳定，处理速度刚才才明明是两毫秒，为什么现在变成十毫秒了，至少你关注这个，你可能知道哪个地方出了问题，当然颗粒度大小其实是根据用户来决定的，需要我们给他们打个样，甚至还可以定制，定制的意思就是说量身定制，意思就是得加钱，就比如说有很多常见服务的，这种在采集运行数据的，我给你打个样，用户不会写，我们给你写，定制服务是可以的，定制服务肯定是采完了过后，包括图表都给展示出来，这是一种，就是能够让你看到。</p>
</div>
<div class="paragraph">
<p>那看到过怎么解决呢？你都用我的系统了，证明你解决不了，我问大家个问题，一个资深的程序员需要用这个东西吗？不需要，那么多年没这玩意，不是也活过来了？但是如果是你，你管一台服务器，你能保证你不死吗？我能扛下来是因为我是专业的，但不是每个人都像我一样专业，那既然你没有我专业，肯定就没有我厉害，那肯定有些问题你是解决不了的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决不了">24.9.4. 解决不了</h4>
<div class="paragraph">
<p>问大家个问题，为什么解决不了？就是明明他都看到见问题，他为什么解决不了？就比如说可能没时间，打个比方，你们本来是家才创业起步的科技公司，一开始就遇到了老大难的问题，一天到晚老卡死，你到外面去请一个人，首先请的这个人靠谱吗？他可不可能会把你的数据全拿跑？但是我们这种公司是你主动用我的，天生有信任感，而且这个渠道又是可控的，说白了就是那种百度找医院的感觉，反正你搜癌症一定出来的不是你想要的,所以这个地方解决不了，可能是因为着急、可能是因为没有人脉、可能是因为那个很匆忙各种各样的原因，就是解决不了，那么有些公司他是怎么解决的？比如说波波的公司，他需要各种各样定制的东西，他在外面找不到人，当然他东西都没有就不存在有问题，网站都没有哪来问题，所以这个时候他产品有了，给用户吹牛逼吹出去了，那赶鸭子上架的事儿他得做啊，他不做怎么办？所以没钱没技术这个是个综合原因，最后他必须花钱解决，为什么？因为他如果知道花500块钱能解决的话，他肯定会弄的，比如说咨询我们客服解决他的问题要花多少钱，然后我们就给他报个价，客服就说这个大概要花一天时间，500块，老板绝对会花钱，老板的想法都是花钱解决问题，反正你做也是花钱，我给对方也是花钱，那程序员会不会暴露自己的问题？不会的，程序员会说：我本来就只是个开发代码的，这个是运维管的，公司运维能力不行，运维只是解决网管不发布的问题，他解决不了更深层次的问题，这已经属于性能调优或者安全问题了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_api">24.10. API</h3>
<div class="paragraph">
<p>首先我们按照大的方向来分API系统有几块：</p>
</div>
<div class="paragraph">
<p>1,插件</p>
</div>
<div class="paragraph">
<p>2.内部上报</p>
</div>
<div class="paragraph">
<p>3.Web API</p>
</div>
<div class="paragraph">
<p>4.开放API</p>
</div>
<div class="paragraph">
<p>5.Web服务</p>
</div>
<div class="paragraph">
<p>API是什么？他的英文叫Application Interface（应用程序接口），意思就是说都是一堆JSON，JSON是不友好的，他要去拼字符串，很容易出错所以这里哪些地方提供SDK：</p>
</div>
<div class="paragraph">
<p>1,插件(SDK)</p>
</div>
<div class="paragraph">
<p>2.内部上报(SDK)</p>
</div>
<div class="paragraph">
<p>上报调了SDK他就会把上报一起做了，其实插件和内部上报是一体的，把上报拎出来，只是说有插件那回事儿，因为内部上报和插件上报其实是一回事。</p>
</div>
<div class="paragraph">
<p>3.Web API
Web为什么不用，是因为这是我自己用的，自己用的话JSON绝对不会拼错的。</p>
</div>
<div class="paragraph">
<p>4.开放API(SDK)</p>
</div>
<div class="paragraph">
<p>5.Web服务</p>
</div>
<hr>
<div class="paragraph">
<p>Web服务，我们的不是Java的Spring Boot，我们的客户端、节点把数据报给Spring Boot需不需要用SDK封装一下？看起来是需要的，要做就一起做了，意思就是说你要朝上面报各种各样的东西，然后用Java SDK封装好全部往上报，当然这个地方也就会存在个问题：这个Web API是谁？是我们的Client，这个是Client下面的插件，插件把数据收集过后报给我们的client，然后Client调Web API SDK把它报给Spring Boot，所以如果要分块的话就这样去分：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/fenkuai.png" alt="fenkuai"></span></p>
</div>
<div class="paragraph">
<p>看起来是这样的。</p>
</div>
<div class="paragraph">
<p>再确认一下语言,Web API的SDK报给开放API，开放API是用Java，通过JSON通信，那么Web API是用的rust，那么Web那里是一个Rust的SDK，然后报给开放API，当然这个地方写SDK有点多余，为什么？反正都是你自己写，你怎么报是固定的，主要是因为我们本来就在写SDK，这个顺带就写了，就不维护两种逻辑，直接用一种逻辑，这样的话以后换人维护也方便，不用去告诉他那个字符串表是啥意思，你调那个Class就可以了。</p>
</div>
<div class="paragraph">
<p>那么总结一下：</p>
</div>
<div class="paragraph">
<p>1.Web API使用Rust语言</p>
</div>
<div class="paragraph">
<p>2.开放API使用Java</p>
</div>
<div class="paragraph">
<p>3.Web服务使用Spring Boot+Java</p>
</div>
<div class="paragraph">
<p>然后插件和内部上报就无所谓了，我们可能会提供Python、Java、PHP、C/C++这几个版本，Rust先不管，受众太小了，按优先级的话：</p>
</div>
<div class="paragraph">
<p>C/C++  ★★★★</p>
</div>
<div class="paragraph">
<p>Python ★★★</p>
</div>
<div class="paragraph">
<p>Java   ★★</p>
</div>
<div class="paragraph">
<p>PHP    ★</p>
</div>
<div class="paragraph">
<p>所以在做任何事情之前，你会发现，光搭架子三年过去了,为什么?因为你的这个基础通信逻辑有哪些接口到现在都没定下来,你要定,定又要过去好久，每定一个，你开发一个，那倒无所谓，然后这个时候权限验证还要做，开放API是给别人用的，总得权限认证，然后Web服务访问，虽然访问的你自己，但你的权限还是得验证，因为你要公开，上报也要权限验证，说白了你要把密钥发给Web服务。</p>
</div>
<div class="paragraph">
<p>所以Web API会发给Web服务，然后Web服务要做密钥检验，Web API要做密钥生成，你会发现只要涉及到API的地方都有密钥，虽然看起来好像是本地报的，我讲过的万一他是Java报给服务器，如果那个服务器不在这台机器上的呢？那就可以跨机器的，那这样的话意味着通信里面都要报，但是你现在要关心另外一个问题，可能以后涉及到一个性能问题，之所以这么做是因为要先让它转起来，我觉得对于现在来说性能是其次的，都没到了那个点就不要考虑性能问题，Web API之所以用rust，是因为我们不想管内存，而且那地方需要一个静态语言，省内存的东西，所以绝对不能用Java，因为一用Java就必须用框架，用框架的话那个内存蹭蹭蹭往上涨，哪怕一百兆都觉得多，如果一个只有256的机器，我们吃了100,那他还活不活？甚至我们这个东西可能会布在Docker里，Docker虽然不占内存，但是你一个机器跑十个Docker那就是就是1G,因为迷你精悍就意味着他的场景就不会被被局限在某些地方，比如说你用MySQL，就算装了不用，它内存占的也非常非常小，不用去关注他，但是一个SQL Server有事没事启起来，2G内存就没有了,所以说MySQL我不会关它，不管用不用都挂在,Redis也是，但是SQL Server或Orcole启起来，必须得关掉，不用就不开，包括Java的Tomcat莫名其妙在那开着，你会发现开机贼慢，为什么？就是因为他那一堆乱七八糟的东西，所以Web API用Rust主要是：</p>
</div>
<div class="paragraph">
<p>1.要静态语言</p>
</div>
<div class="paragraph">
<p>2.要省内存</p>
</div>
<div class="paragraph">
<p>3.速度要快</p>
</div>
<div class="paragraph">
<p>肯定不能Python，用Python就意味着是动态语言，有效率问题，一上来就遇到这种选型问题，要命。</p>
</div>
<div class="paragraph">
<p>Web服务为什么用Spring Boot，那是因为本来就是外部服务，Spring Boot+Java写Web是没问题的，PHP也可以，但是用PHP就意味着API系统要自己独立搞，校验这些我都自己搞，这个情况下头为什么选Java？因为整套系统里面本身只需要一套，这个吃的内存无所谓，256的机器你还想装一套，你要做梦呢，自己想办法，比如说在内网搭一个机器挂在这儿，然后用FRP穿透出去不就有内存了吗？也不是解决不了，256本来就穷，穷就是原罪，你就不要想开车了，所以说256只能跑客户端，服务端是跑不了的，当然Web服务其实也可以用Rust，但是我更觉得这个难度有点陡增，为什么？主要是因为Rust很多东西都没有，要去从头造。</p>
</div>
<div class="paragraph">
<p>所以我们先跑起来，大不了以后觉得这个地方需要精简的时候再改，再用Rust重写，那么看起来API大的块有这几个，所以我们一定有一套统一的验证机制，为什么？如果我要有验证机制的话，所有的地方都应该是一模一样的，我不会去重复造几套，这也是涉及到API系统系统设计。</p>
</div>
</div>
<div class="sect2">
<h3 id="_api系统系统设计">24.11. API系统系统设计</h3>
<div class="paragraph">
<p>我之前讲过的一旦涉及到API系统过后就会很复杂,讲API大家都会讲，但是一旦讲到系统设计，大家都是懵的。</p>
</div>
<div class="paragraph">
<p>1.HTTPS通信安全</p>
</div>
<div class="paragraph">
<p>当然加了密的东西速度肯定慢一些，但我觉得这是可以解决的。</p>
</div>
<div class="paragraph">
<p>2.数据安全</p>
</div>
<div class="paragraph">
<p>什么叫数据安全签名？就是数字签名，我现在说的可不是数字印章、公章，我说的是针对一个数字做一个Hash。</p>
</div>
<div class="paragraph">
<p>3.参数教研</p>
</div>
<div class="paragraph">
<p>4.API权限教研（AccessKeyId）</p>
</div>
<div class="paragraph">
<p>5.数据使用</p>
</div>
<hr>
<div class="sect3">
<h4 id="_怎么做">24.11.1. 怎么做</h4>
<div class="paragraph">
<p>1.HTTPS通信安全</p>
</div>
<div class="paragraph">
<p>不需要我们做什么，加个证书就可以了，</p>
</div>
<div class="paragraph">
<p>2.数据安全（数字签名）</p>
</div>
<div class="paragraph">
<p>大家都会做了</p>
</div>
<div class="paragraph">
<p>3.参数教研</p>
</div>
<div class="paragraph">
<p>大家都会做了</p>
</div>
<div class="paragraph">
<p>4.API权限教研（AccessKeyId）</p>
</div>
<div class="paragraph">
<p>大家都会做了</p>
</div>
<div class="paragraph">
<p>5.数据使用</p>
</div>
<div class="paragraph">
<p>等于说如果是有KeyId的话，你的插件一定用的是用的Web API里有一个类似于KeyId的东西：</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>一台主机1和一台主机2，然后还有个Java，Java要向主机1报数据，主机1上一定写死了一个Kid，因为他不需要一直变，你对的插件永远是有限的，而且那插件都是你自己写的、你自己用的，所以这个KeyId完全可以手动填或者我们自动生成,他把了KeyId复制到插件的配置文件里面去或者那个插件在本机的话完全可以读配置文件,但是通信的时候一定会把他带上，为什么？万一跨机器咋办？</p>
</div>
<div class="paragraph">
<p>打个比方</p>
</div>
<div class="paragraph">
<p>现在有节点一和节点二,那这样的话，他们通信节点一上头一定写了一个KeyId放在那写死的，然后这个时候长度啥的都不管，反正只要有那么你的采集程序，你每次启用一个，采集程序里的配置文件一定也写了个KeyId，而且还写了他的节点IP，不然的话采集程序不知道往哪发数据，那这样的话就变成了采集程序要发的时候，是基于节点的IP地址+节点的KeyId，然后通过Signatrue签名往上面发，只是这个时候签名可以选择SHA1最简单的那种，只是说跨公网的时候，你可以选择SHA512、2048都可以，因为算法越长，加密的时间越长，但是基础逻辑可以有，只是说你KeyId不一样，长度不一样，但是并不影响你的算法签名。</p>
</div>
<div class="paragraph">
<p>那么这个时候，我就可以通过签名把数据传给我的节点服务器，节点收到过后，把数据打包整理再往我的服务端上报，为什么不让那个采集程序直接往上报？因为采集程序有很多，主要是为了减少频率的问题，而且采集程序不应该关心怎么往上报的问题，当然我们写个SDK就可以解决，但是为了考虑网络的问题，假设1个服务器有20个采集程序，那10台服务器有多少采集程序？那就要命了，当然节点和服务器之间是可以通过长连接的，只要连接不断就行了，永远可以用一个连接，100台服务器，100个节点就100个连接，100个连接服务器应该是可以承受的，那这样就讲明白了采集程序怎么通信的问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_采集程序通信">24.12. 采集程序通信</h3>
<div class="sect3">
<h4 id="_节点端通信流程">24.12.1. 节点端通信流程</h4>
<div class="listingblock">
<div class="content">
<pre>1.节点配置文件有AccessKeyId和AccessKeySecret

2.采集程序一：

2.1.手动配置节点IP和端口

2.2.节点AccessKeyId和AccekssKeySecret

3.采集程序一签名后，发起API请求</pre>
</div>
</div>
<div class="paragraph">
<p>那这样剩下的逻辑就是，上面是节点端通信流程，那节点和服务器之间的通信呢？节点上肯定也是基于这个KeyId，因为这个KeyId一定是服务器颁发给他的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_节点和服务端通信流程">24.12.2. 节点和服务端通信流程</h4>
<div class="listingblock">
<div class="content">
<pre>1.节点端手动增加AccessKeyId和AccessKeySecret

2.节点请求注册携带Id和Secret

3.管理员人工完成注册和确认

4.KeyId和KeySecret用于签名</pre>
</div>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYJIEM9_chapter">25. 智眼系统API和界面设计（九）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_24">25.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/1.jpg" alt="1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_功能分区">25.2. 功能分区</h3>
<div class="paragraph">
<p>现在不是存的问题，现在留于表面，就是在浏览器上面,你要绘图，我们系统里面大部分东西都在绘图，你现在考虑一个问题，第一个你绘图不是需要API返数据给你吗？所以你的这个数据对应的这个Java的Springboot是不是应该有独立的模块去处理绘图的问题啊，把数据拿出来，你不可能说我这个API叫是另外名字，然后Controller是一个，下次我分散的各个地方你也没法管了，所以你现在要先对URL进行分区，什么意思？斜杠+路径，路径后面才是你的API名字，所以要先分区，功能分区嘛，有的功能是/user，有的功能分区是/图片，那有的功能分区还可能是setting，所以你现在先要做功能区分，在用API层面，因为我们不需要每个界面都去讨论，比如说那个用户改密码，你要不要设置一下改密码的界面啊，我更觉得那个东西都不用我讲。</p>
</div>
</div>
<div class="sect2">
<h3 id="_访问方式">25.3. 访问方式</h3>
<div class="paragraph">
<p>然后现在面临第一个问题，我们就挨个讨论嘛，我们之前讨论完界面，那现在有个问题:用户怎么访问我们的系统？它怎么进来？是用二维码扫码吗？还是用账号密码登录？还是什么？就是我要讨论，你可能最终会拿出个常见的方案，就是为什么要去选这个方式？比如说用密码、用短信、用二维码？</p>
</div>
<div class="paragraph">
<p>我们不需要用户的信息，我们只需要验证身份，所以那这样的话看起来直接输入密码是比较好的，这是一种，就是用户可以进入系统，我们还有种系统就开放平台，我们的数据是可以对外提供的，要允许他来查询这些东西，这个地方要引入一个新技术，这个技术在国内基本上没人用，就是facebook的GraphQL，所以那首当其冲的就是说我们要先确定几个大块，第一个就是，我们自己的就是Web API，第二个大块就是我们要对外提供服务哈。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Web API</p>
</li>
<li>
<p>Open API</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以我们在讲这个Web API和Open API之前，我们先讨论我们的API有什么特点，然后等一会我们再讲GraphQL，这个东西大概出现时间不到五年，而且国内很少人用。</p>
</div>
<div class="paragraph">
<p>我们现在有两种API系统一直是内部用的，Web API就是我们的网页调的，那么还有一种是Open API，就是对外提供服务的，那现在就是看一下他们的特点Web API，意味着就是我们网页上有图形，就是要让他汇表，那这种情况下面我们的API数量是不固定的，就是我打个比方我们一共有20个表格。那基本上就应该有20个API，这样才是一一对应的，免得我改一个API把另外个给错了，因为你合着一起的，需求一变，你就懵了，所以这样的话，就是在Web API或者在业务系统里面涉及到API的时候，通常来说一个功能。一个逻辑功能一个API，但是你在对外提供Open API的时候就可不是这样的，因为你就基本上属于用户可以传参数进来，他查自己想要的，所以你这个可能就是一个大的逻辑一个API,小逻辑就通过后面的参数来区分，有什么好处？你之所以界面上分的那么细是因为你的界面是固定的，您限死了，那这样的话做前后端适配的时候就比较轻松，但如果你把Open API套在你的前端那边就意味着前端要去拼那个API的参数。拼的时候还要考虑怎么去调，而且最关键是如果你把两个合在一起，比如说设置密码这个API你都放到Open API里面来了,有用吗？就出现冗余了，就是明明不应该在开放平台出现的东西，结果你开放平台里面也有，那么Web API不应该有开发平台东西也有，比如说你的Web API这地方是不需要getToken的，你会出现这种交叉，这种交叉是有问题的，因为会导致后期维护会有很大的问题。不管是维护层面还是你写文档的时候，你发现交叉在一起里文档你都不好写，所以API第一个就是他场景不同，所以这样的话，就第一个就API使用场景。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API使用场景</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就这两个API使用场景是不同的，所以不能混为一起，所以把它区分开，还有没有其他原因要分开?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>避免逻辑交叉</p>
</li>
<li>
<p>安全性不同</p>
</li>
<li>
<p>域名不同</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>*数据行为不同（颗粒度）</p>
</div>
<div class="paragraph">
<p>还有就是颗粒度，数据的颗粒度是不一样的，我打个比方像Web API，你要拿数据的话可能默认情况下只有最近两个小时，但是你要通过API拿的话，可能只有最近五分钟，就是叫数据行为不同，就颗粒度，有时候颗粒都不同，当然还有很多，其他的就基本就这几个。</p>
</div>
</div>
<div class="sect2">
<h3 id="_特点">25.4. 特点</h3>
<div class="sect3">
<h4 id="_web_api">25.4.1. Web API</h4>
<div class="paragraph">
<p>我们现在来看各自的特点啊，Web API有什么特点？首先Web API他意味着他的需求会经常变，你的页面一修改，他就要跟着变，他为什么要调整呢？那是因为就是API逻辑颗粒小，所以需求如果一变的话，API逻辑就要变，是因为这个原因，颗粒度大的话，你只要需求大方向没变是不需要变的，所以他们两个是相互影响的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>需求可能调整</p>
</li>
<li>
<p>API逻辑颗粒度小</p>
</li>
<li>
<p>界面适配需要更新API</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_open_api">25.4.2. Open API</h4>
<div class="paragraph">
<p>但是Open API就没有这个问题，因为他颗粒度通常比较大，比如说阿里面有个东西要获取ECS列表，你ECS哪怕内存再怎么变，你不用改你的接口啊，但是你是获取ECS详情他如果增加了一个CPU，以前没有CPU现在增加了CPU，你变成了V2了,那就存在变化的问题，这那么开放平台通常来说他的颗粒度大，所以就只要需求无大变化就不需要调整。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API逻辑颗粒度大</p>
</li>
<li>
<p>需求无大变化，不需要调整</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有什么特点？这个属于强行总结的哈，因为这是根据经验道推的，你是自己总结不出来的，界面上我打个比方绘图的时候需要某个字段，但是表里面不一定需要，你是不是要加字段呢？我打个比方，表里面没有，但你界面上有，你可能就要查个系统时间返回去就多了一个，但是表里面是没有的，就是由于数据要填充到界面上去，所以界面一动，你的数据就得动，比如画折线图和画曲线都不一样，我这个后端接口是不要改啊？但这意思就是需求调整，我认为需求调整可能加字段这种，而我把另外一种需求叫界面需求，界面适配需要更新接口。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_graphql">25.5. GraphQL</h3>
<div class="paragraph">
<p>其实更多API的那些特点不是我想讲的，就是说白了API谁不会讲，传数据有个标准格式啥的嘛。那不是我想讲重点，我之所以讲出来这个是因为我想讲GraphQL，那么你们都看了官网瞄一眼也然后大家告诉我GraphQL是什么？</p>
</div>
<div class="paragraph">
<p>就是我来大家看不懂，我跟你讲句话，你绝对听懂了，GraphQL可以把你的表字段映射成一个Json，然后前端就可以指定需要哪些Json，不需要哪些Json，那前端是不是就可以根据他需要过滤值了，只要表里面有的他就能拿出来，而且还能做增删改查，就相当于不需要后端了，这个是什么意思呢？就是说后端的业务逻辑向前端移动，因为我们最这个主要是通过页面，而我们的后端逻辑其实相对比较偏少，我们后端只需要做逻辑上的API教验，以前你在后端验证参数，你现在只需要验证一些公共参数就可以了，因为制定一些参数然后剩下的全都由前段获取，但是前端获取的时候，GraphQL可能说是没有安全的这些东西，所有你要套一层皮，你要把我的API系统套在外头，中间是GraphQL。</p>
</div>
<div class="paragraph">
<p>所以这个地方我们要做个调研，就是在这种需求频繁变化的情况下，用GraphQL是不是比较好？这种措施将重心往前移了过后减少你的后端维护的这种成本，而且最关键是GraphQL，你改了表过后他是兼容的，就是他可以把那种字段给你留着置空之类的，当然他之所以能兼容，是因为你的数据库表和他之间有个对象映射，就像我们的之间的Model，你要用他的语法也写个Model，就等于说你改了表没有改Model是没关系的，GraphQL不会报错的，因为是空的，那这样的话就是说其实这个还不是我们想要的，主要是因为我们不想太多逻辑在后端，因为他毕竟是个界面程序，所以我们要把业务逻辑往前移，因为我们如果要用GraphQL来查的话，就意味着我们的表的逻辑啊要清晰，所以现在我们先做个前期调研，就是GraphQL到底和我们怎么结合？先不定方案，先去做调研，用GraphQL和传统的Controller，两种方式在前期我们都使用，然后当我们用了一段时间过后，我们再考虑取舍的问题，当然引入GraphQL还有个问题就是因为他是新技术，就是为他新才用的，我讲过的极客营选型是很极端的，所以我们要走在这个时代的前沿。我们讲过嘛，我们所向美国人看齐嘛。</p>
</div>
</div>
<div class="sect2">
<h3 id="_题外中国程序员和国外程序员写代码有什么区别">25.6. 题外：中国程序员和国外程序员写代码有什么区别？</h3>
<div class="paragraph">
<p>所以在国内这种情况下，今天又看到我以前点赞的一个回答：中国程序员和国外程序员写代码有什么区别？</p>
</div>
<div class="sect3">
<h4 id="_美国程序员">25.6.1. 美国程序员</h4>
<div class="paragraph">
<p>先讲的美国人，工期贼牛皮，随便改个Bug要七天，找Bug一天，分析问题一天，设计方法一天,修改代码一天,CodeView一天,一个星期过后，那下个星期写Commit一天，写完了过后来提给他的leader，Leader还要审核一天，基本上七天才会修一个Bug，但这过程当中明明可以用一个全局变量的，他们会用单例模式再套个行为模式，适配器模式，各种设计模式满天飞，就怕你一眼看懂，套上去过后整个代码看起来非常优雅。</p>
</div>
</div>
<div class="sect3">
<h4 id="_印度程序员">25.6.2. 印度程序员</h4>
<div class="paragraph">
<p>印度程序员就是一板一眼的，就是老师怎么教他的，他上司就怎么要求的，就这么写，当然还有另外一种情况，就是不写，只要不写就没有Bug，所以相对来说比较符合规范的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_中国程序员">25.6.3. 中国程序员</h4>
<div class="paragraph">
<p>在同样的情况下面,中国程序员写代码，他会用Select * 查一个ID出来，然后用For循环把ID取出来，那为什么不直接是Select ID呢？意思就是中国程序员解决问题就行了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_传统与新型">25.7. 传统与新型</h3>
<div class="paragraph">
<p>所以这个也是我们现在去做设计要考虑的问题，总的来说就是向好的学习，但是美国的那种就不要去学了，学美国的技术就行了，那么这个过程当中把GraphQL引入进来，主要是想隔离，把数据逻辑和后端做隔离，后端只是数据的提供方，而不负责数据的组装，那这样的话就是说：</p>
</div>
<div class="paragraph">
<p>传统:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/chuantong.png" alt="chuantong"></span></p>
</div>
<div class="paragraph">
<p>传统是这样的，但这样意味着一个问题:逻辑在后端,而用数据的人在前端，所以前端就要拼命和后端做沟通，你两个要约定用SWAP API、Document去约定，意思就是我们两个先写个一篇文档，然后前后端按照文档开发，前后端有沟通。</p>
</div>
<div class="paragraph">
<p>而我个人认为现在的模式应该是所有的业务往Web端引进，而后端只解决安全问题，那为什么Web不直接去查这个数据库呢？密码都被别人看完了，还查啥呀，你用JS能加密吗？右键原代码，不管写的再乱，真的存心想看，也不是不行，那么我认为新型，虽然一个新型技术不一定好，但就是你要有试错的期望，如果你永远不试错的话，你就是个保守的人，而保守的人迟早会被淘汰的，所以在极客营我教给大家的就是：哪怕我说的也有可能是错的，我们讨论问题该不该解决，而不应该讨论你应该听我的，为什么？你听我的，你不带脑子做错了，怪谁啊？只能怪我，但是我不想这样，为什么?因为压力都是我头上？既然你自己造出的问题，你自己解决
，每个人担起自己的责，就非常Pro Fessional，非常专业，专业才是极客营追求的。</p>
</div>
<div class="paragraph">
<p>所以那这个地方新型的一种模式就是：</p>
</div>
<div class="paragraph">
<p>新型：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/xinxing.png" alt="xinxing"></span></p>
</div>
<div class="paragraph">
<p>那现在谁告诉我组装的位置改变过后有什么好处，有什么坏处？有人可能会说性能，但我觉得性能，因为你多引入了一个组件，性能持平就算不错了，我觉得没有明显的变化，你想嘛，以前要查SQL，用GraphQL就不查SQL了吗？都是一样的，因为数据使用的在数据库里，还是得写，这里应该像NodeJS+Vue，NodeJS负责把几个API调在一起，拼了过后再返给前端，但是和Vue没有关系，之所以你现在在组装，是因为你有几个API要调，但是你调了几个API数据和它是不一样的，你调的数据是从Java来的的，传统的逻辑的在Java，而新型的逻辑在前端，新型就不在Java查表了,GraphQL框架就直接帮你查了,比如说你告诉他连查两张表并且返回前十条，GraphQL直接用语法就做了，就相当于以前叫SQL，没有那个S，就相当于这个地方你是前端，你来查，后端只把那个GraphQL框架搭，都不用写代码了，这样的好处就是所有的控制权全在前端，只是后端你要控制好。</p>
</div>
<div class="paragraph">
<p>所以我现在现在比较困惑或者不确定的就是说这样一工作的话，全都暴露在前端，那后端怎么去控制安全的问题，GraphQL有个单独的端口，我上次调那个GraphQL去做的话，我是把GraphQL放到Java里的，输出的时候，是已做了过滤的，说白了，graphic解决的是DB和Java之间的关系，但是我想是把他放在前端，所以这是我们要去考虑的问题，因为GraphQL出现主要是为了解决数据查询的问题，我们现在要待定GraphQL到底能做的哪种程度。</p>
</div>
<div class="paragraph">
<p>所以那现在这个地方我们考虑的是GraphQL到底用在哪一段？用在DB和Java还是Java和前端，DB和Java之间我已经用过了，原代码都有，但是这只是省掉了查SQL，但是我想把他放在前端，但又有安全问题，如果GraphQL单独的验证，但这样的话，就把所有的表都漏给别人的，那如果我们要这样做的话，可能GraphQL我们要单独写个模块，可能Java还是有部分的逻辑，主要是为了安全。</p>
</div>
<div class="paragraph">
<p>再看Open API，这个就很典型的，就照着亚马逊写个SDK就可以了，没啥技术含量。</p>
</div>
<div class="paragraph">
<p>那么这两个app系统啊，主要有这两个问题，第一个问题就是要不要引入新技术，但是我现在直觉告诉我这个地方能够用，然后SDK没什么难度了，就是API设计到底友不友好的问题了，所以这节课就是板书就到这，我们来研究一下GraphQL。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYJIEM10_chapter">26. 智眼系统API和界面设计（十）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_25">26.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统API和界面设计（十）板书1.jpg" alt="智眼系统API和界面设计（十）板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_web服务和api">26.2. Web服务和API</h3>
<div class="sect3">
<h4 id="_api和url的分区">26.2.1. API和URL的分区</h4>
<div class="paragraph">
<p>现在假设我们的域名是www.ZhiYan.com，那分区的话，首先第一个和用户相关的：</p>
</div>
<div class="paragraph">
<p>www.ZhiYan.com/user/&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>然后第二个是和绘图相关的：</p>
</div>
<div class="paragraph">
<p>www.ZhiYan.com/data/&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>就先随便举这两个例子，那这里指的分区就是上面的/user和/data，所以我们今天要做的事情就是把这个定下来。</p>
</div>
</div>
<div class="sect3">
<h4 id="_用户层具体分区">26.2.2. 用户层具体分区</h4>
<div class="paragraph">
<p>1./user/login&#8212;&#8203;登陆</p>
</div>
<div class="paragraph">
<p>2./user/logout&#8212;&#8203;登出</p>
</div>
<div class="paragraph">
<p>3./user/add&#8212;&#8203;添加用户</p>
</div>
<div class="paragraph">
<p>4./user/delete&#8212;&#8203;删除用户</p>
</div>
<div class="paragraph">
<p>5./user/update&#8212;&#8203;更性用户</p>
</div>
<div class="paragraph">
<p>6./user/query&#8212;&#8203;查询用户</p>
</div>
<div class="paragraph">
<p>7./user/profile/query&#8212;&#8203;查询用户配置</p>
</div>
<div class="paragraph">
<p>8./user/profile/update&#8212;&#8203;更新用户配置</p>
</div>
<div class="paragraph">
<p>9./user/password/change&#8212;&#8203;修改密码</p>
</div>
<div class="paragraph">
<p>Update里面不一定包括修改密码，修改密码一般是单独的，因为这个改的是配置，而配置里面是不包修改密码，记住密码不叫用户配置，什么叫用户配置？比如说你叫XXX，性别男，年龄22岁，爱好女，这才叫配置，这个里面是不能包括密码，不然你密码怎么写？XXX.配置.<strong>*</strong>，那这样你的密码属性要展示出来吗？所以配置是可以展示的，而密码是不能展示的。</p>
</div>
<div class="paragraph">
<p>10./user/photo/query&#8212;&#8203;头像</p>
</div>
<div class="paragraph">
<p>头像是在配置里面改，但是查头像的时候一定是单独查的，不然右上角那个头像怎么展示啊？，所以不可能查100个字段，只展示个头像吧。</p>
</div>
<div class="paragraph">
<p>11./nav/query&#8212;&#8203;导航栏</p>
</div>
</div>
<div class="sect3">
<h4 id="_绘图层具体分区">26.2.3. 绘图层具体分区</h4>
<div class="paragraph">
<p>首先我们有很多数据，而且这些数据拿出来应该是绘图用的，那现在就暂定为graph，所以这个地方就不叫date，因为是这样的：我们的开放平台肯定不叫graph，为什么？因为数据颗粒度不一样，但这个地方是只要界面上调那个数据API，那一定是用来绘图的，所以这里叫绘图是没有毛病的。</p>
</div>
<div class="paragraph">
<p>那我们有哪些需要绘图的？cpu、内存、硬盘，那绘图的时候，前面还要跟一个host，用来标注是哪个host的图形，所以你的模板应该是这样的：</p>
</div>
<div class="paragraph">
<p>/graph/{host}/{modole}</p>
</div>
<div class="paragraph">
<p>其中用花括号表示变量，主机后面应该跟监控模块(modole),比如说是：</p>
</div>
<div class="paragraph">
<p>/graph/127.0.0.1/cpu</p>
</div>
<div class="paragraph">
<p>然后后面跟着数据，因为通常这个数据本身是不需要更新的，所以大致应该模板就这样，比如说如果有日期的话，就带上问号跟参数。</p>
</div>
<div class="paragraph">
<p>那这样的话还有一种情况孩子球是用户要改监控模块的更新时间，因为我们没有独立的配置页面，等于说这个地方要改他的设置，然后ct后面跟具体设置，我这不用了因为这地方就是cpu，然后问号参数了？或者是poster嘛？</p>
</div>
<div class="paragraph">
<p>那这样的话，就举几个例子:</p>
</div>
<div class="paragraph">
<p>/graph/127.0.0.1/cpu</p>
</div>
<div class="paragraph">
<p>这个就相当于是一个基础的模板，可以把所有的模块代替了，但是现在有个问题：比如说Web日志，它的监控模块是http，http会有很多很多的统计，那看起来module后面应该还有个东西，首先seting应该是不用改的，为什么？因为采集数据这个行为，不管图表怎么展示，他就只会采集模块自己的数据，所以这个seting是不用改的，但是这地方少东西，少什么？比如说你要获取这个module里头哪一部分数据，是要说的，因为module里面的数据很大，比如说那个Nginx日志有那么长一串，那肯定要指定获取哪一类，所以这里可能叫type，意思就是这个module里面具体要哪些数据，所以这个地方给你应该还有一个：</p>
</div>
<div class="paragraph">
<p>/graph/{host}/{modole}/{type}</p>
</div>
<div class="paragraph">
<p>这个分类肯定是我们自己分的，但是我现在没有想好要怎么去做数据库设计，那就先泛泛的讨论一下，那这个地方的话，type的默认值可以叫default，那么除了默认的还有些特殊的：</p>
</div>
<div class="paragraph">
<p>/graph/127.0.0.1/http/ip_arae</p>
</div>
<div class="paragraph">
<p>比如说想获取ip地址的区域，那肯定要把那种数据单独分门别类，一定不是IP地址一个字段，所以这里就假设叫ip arae，到时我们再具体设计在哪个地方设置。</p>
</div>
<div class="paragraph">
<p>当然你这个地方就会有很多分区了，比如说还有一个useragent：</p>
</div>
<div class="paragraph">
<p>/graph/127.0.0.1/http/user_agent</p>
</div>
<div class="paragraph">
<p>这里你肯定要告诉别人是哪个域名，因为你都不告诉别人域名光说一个浏览器版本号这样没有意义，那看起来http前面还要加个host，不然没意义，那看起来host可不可以作为参数传进来？还是说加在http前面？假设这地方可以这么写：</p>
</div>
<div class="paragraph">
<p>/graph/127.0.0.1/http/ip_arae ? host=qq.com</p>
</div>
<div class="paragraph">
<p>我们先假设成这样，至于以后是放到这个URL里还是怎么样，再说，主要是因为我们监控的时候，监控的是整个http，而我并不是一个Web服务器，Web服务器才关心这个维度，但对于我们来说我们是关心的是很大的一个范围，那这样看起来，后面我们不用去具体分区，可以直接在http后面跟参数，这样的话操作会方便一些，就比如说我想查所有的Chrom浏览器，当然可以多个参数，就比如指定的类型，这样看起来就像：</p>
</div>
<div class="paragraph">
<p>/graph/127.0.0.1/http ? host=qq.com &amp; content_type=&#8230;&#8203; &amp; user_agent = chrome</p>
</div>
<div class="paragraph">
<p>那看起来tcp也是可以这样做的，mysql也是一样的，那这样看起来很简单，主要是跟数据挂钩的，所以说后端写的是要接收的万能API,等于说HTTP有很多很多字段，你都不能去做参数教验,因为参数是用户自定义的，什么叫用户自定义？比如说你写的那个接口有个头叫Token,但是这个Token又不在我们预定义的头里头，那么这个地方就不能把参数写死，所以应该是先接受这个参数，然后去查，没有就没有，不要报错，直接假装不存在，那现在问题来了，Http有body，如果要接收body呢？首先我们讨论一下我们要不要存Body？我觉得可以不存的，因为Body存下来没有意义，想象一下，日常处理问题的时候，就只有在f12才看body，我们这里就可以直接看状态是200还是404,所以我们暂时不考虑Body，直接扔掉。</p>
</div>
<div class="paragraph">
<p>那MySQL你也不关心返回的内容，只关心成功没有，TCP你也不关心tcp的PayLoad，只关心TCP的头。</p>
</div>
<div class="paragraph">
<p>那SQL的就是：/graph/127.0.0.1/mysql&#8212;&#8203;SQL结果</p>
</div>
<div class="paragraph">
<p>其实和上面一样的，以此类推，很多不用关心的，所以总的来说我们对他的body、复载、查询结果都不关心，我们只关心查询的条数、时间，不然数据库要被撑爆，明明一个网页要保存100次1000万次，疯了。</p>
</div>
<div class="paragraph">
<p>那这一块就相对比较OK了，都是有套路的，那这样的话Seting就没毛病了，当然这个Seting是放在这个前头还是放到后头？比如说把Seting放到graph那里，叫图形设置，这样显得怪怪的，那我们就不用graph了，我觉得该换一下,这个地方应该是采集数据的,因为绘图是查询，而这个地方不是查询，这是在更改插件，那这个地方应该换成Plugin(插件)比较合适:</p>
</div>
<div class="paragraph">
<p>/plugin/conf/{host}/{modole}/change</p>
</div>
<div class="paragraph">
<p>我们这么讨论出来后，就知道我们的数据库里大概有些什么东西了。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYANDatabase_chapter">27. 智眼系统设计之数据库设计</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_26">27.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统设计之数据库1.jpg" alt="智眼系统设计之数据库1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统设计之数据库2.jpg" alt="智眼系统设计之数据库2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/智眼系统设计之数据库3.jpg" alt="智眼系统设计之数据库3">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_axure回顾">27.2. axure回顾</h3>
<div class="paragraph">
<p>国外就是叫UX，或者是说叫UI，那么就是用户经验或者用户接口，然后在国内你必须要搜产品原型，其实我认为这个是不对的，因为不一定要产品我才需要这个东西啊，任何涉及到两个人写代码之间要沟通的，因为这个地方叫user experience，叫user interface，等于说我画个数据库的一个设计图,他也算啊,是不是意思？所以说他会把他范围限定的很死，我认为国外这个称呼是对的，因为他们环境特别好，我刚讲了如果你不清楚就去问作者，那个action你就问他作者，为什么你要去创建这个产品啊，对方会很乐意的告诉你，所以在国外的话就是你可以轻松的问作者，而在国内你吸收的知识可能这个中间经过了五手，才会传递到你的这个视线里面，或者你的视野里头，所以你的事就变窄了，这个按装逼一点的说法叫信息茧房，什么叫信息茧房？因为这个地方有语言隔离，你得明白为什么这个东西哈，有个词叫信息茧房，意思就是说你这个cocoon，茧的这个英文叫cocoon嘛，就是你在一个茧里头然后你看不到外面的世界，那这样的话你是从这个渠道传过来的，比如说你在某个视频上看到了，你就只知道他，因为是这样的，一个全新的事物如果你接受的时候是五手的，那很有可能你不是原汁原味的，我的跑偏是有可能啊，也不说百分之百是对的，然后这里面为什么会出现这个问题哈，因为第一个有语言隔离。</p>
</div>
<div class="paragraph">
<p>生物进化最重要的是什么？达尔文的，生物进化最重要的是生殖隔离，什么叫生殖隔离，比如说四川盆地崇山峻岭，古代你要翻过去，比如说你要到西安去翻秦岭，你怕这一辈子能够翻两趟就不错了，中途还不知道多少危险呢，所以这个时候大概率西安的人和这边的人说话不一样，长相不一样，之所以能做到说话一样，是因为秦始皇太牛逼了，比如说像在某个孤岛上，比如说同样是狗，同样是蜥蜴，你会发现体型啊，它的饮食习惯，甚至它可能有的那个身，身体特征都不一样了，有的地方那个蜥蜴它是靠舌头去卷，然后有的可能还有牙齿，所以说生物进化最重要的就是生殖隔离，因为如果不会出现生殖隔离的话，你生物是不会出现那么大差异的，那这样的话就变成了你同一种生物同源的朝两个方向独立的发展，就像现在的猩猩和猴子其实和人是非常非常相似的，甚至连大脑可能人类就比他多5%。但那是完全不一样的，这是在进化的道路上，就是越走越远啊，所以你要明白哈，就是提一下这个啊。</p>
</div>
<div class="paragraph">
<p>就是axure或者这类东西啊究竟有什么作用？现在那直接说作用，作用是传递信息交流，所以那UX/UI他的产物主要是为了交流，那你要交流的话肯定是同事之间，团队之间，肯定不是和随机一个人吧，你不能拿这个产品原型跑到随机一个人，请问你对这个人什么看法，那叫社会调查，所以我刚问那个问题，为什么像那种圆形的东西，或者草图类的东西不让前端来做，是因为这个时候你是需要一种交流的媒介，所以这个地方它的产物哈。这地方你可以是图，这个时候它是一种媒介，它让你和别人可以沟通，无障碍的沟通，你想要什么，我想要什么，所以那既然媒介，就无所谓是在电脑上画还是在白板上画，还是在草稿纸上画，你只要能画出来，不管用哪种方式，它都是一种沟通的媒介，那这个时候你就能达到我们两个认知是一样的，所以起这个目的。所以这团队或者在那个项目团队里头，在特别在那做产品的公司啊。这种原型图或者草稿特别特别重要，因为它会在不同的人之间去流转，比如说产品经理画好了过后会拿给他的leader看，大概是这样，然后leader再给他的那个用户看，你是不是想象这个东西内部用户哈，比如说一些市场经验，业务经验很丰富的人拿给他们看，你们是不是觉得这个可不可以，觉得可以就经过讨大范围讨论过后定下来了过后，当然这个过程程序员也要参与，资深程序员参与过后，那么才是一般程序员，最后就是这个东西会出现在所有程序员的视野里面，前端要看，后端要看，甚至设计UI的，我们的美工他也要看，他们都是看了同一张图，那这样就不会出现偏差，有一种矫正的作用，所以你知道为什么你要画了吗？因为你们现在对编程没有概念，如果直接上手写代码有个很大的问题，写的该有啥用啊？说白了，最终那个界面上确实能展示出来，但感觉好像别人没有通过那种很正规的渠道，他野生的也可以做成那样，那区别在哪呢？区别在于你这种经验的你是可以指挥团队，你可以参与团队你甚至能独立研发产品，但是别人是不行的，因为这个当中这种媒介啊，信息沟通的手段，我打个比方我不告诉你，你可能五年过后才发现，哇，还是有点用，你可能现在在公司看到别人在画，但是你不是很在意嘛，只是觉得他就是一个东西而已，所以这种产品原型图它会在整个团队里面起的非常非常重要的作用，以前是不需要的，以前是我们先画出来，因为人少嘛，然后需求也少，但是现在需求越来越多，你画嘛，等你前端画完了那个三个月过去了，懂意思了吗？再加上我讲过的前段又不喜欢写自己的代码库，经常是没有现成的就自己从头开始造，而后端在几十年前就已经开始就这风格了，不然哪里来的那么多jar包嘛，这是昨天讲axure的问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数据库整体设计">27.3. 数据库整体设计</h3>
<div class="paragraph">
<p>今天应该是数据库设计，终于往后端走了哈，我估计我们这个应该讲了20节课了，可能还不止，所以为什么那么复杂？是因为我们这过程当中，你会发现我们在动手之前，我们应该是想到非常非常完善的，只有一些可能不能用言语表达或者过于复杂的地方，我们可能会直接上手写代码，就比如说那种技术很难的地方，我们就不需要去沟通了，因为技术很难的点一般在公司里面都是主层，程序员嘛，看起来有次层和主层是这个意思嘛，就是一般这个团队里头一定有那么几个人写代码很厉害的，如果没有，请你赶快换公司啊，一般情况下那种难点问题都是由另一两个人他直接搞出来的，他不会和你沟通的，因为他没有必要教你，他要教你一定是你要协作，但是那个很难的问题那种点通常来说需要攻克他，那这个时候不是教你就能攻克的，所以那种问题还是不会去沟通的，所以说我经常写代码的时候，如果别人要求我工期，我会说你等我先做完，他说你必须今天给，我会说你等我先做完，然后他说你必须跟我开会，我说不行，我不想教你，这种事情也发生过很多很多次，对方意识不到那个地方到底有多难，但是我心里很清楚，我跟你开会沟通，告诉你这地方为什么那么难，我觉得我很多时候我愿意去做，但是我做那么两次过后发现你理解不了，我就不愿意做了，因为人是教不会的，你得记住啊，你不要认为你学会，我不是在教你，你是在自己去理解这个东西，然后你自己理解的基础上面你才能去真正完善的一套的这种体系去理解，而不是从我的嘴巴讲你已经听明白的，所以在弄技术设计难点或者实现难点的时候，通常来说有专门人去做，我希望在座的各位你有机会去尝试那种事情，从我的经验来说的话，在这种场合的时候我不会和任何人沟通，我就基本上处于闭关状态，就基本上就那一两个星期，就是也不咋聊天，然后也不咋跟你开玩笑，就噼里啪啦在那儿敲，然后等你看到我在那里嘻嘻哈哈了，证明我做的差不多了，所以那种问题是不需要沟通的，所以实际上写一个完整的系统，所以我们这个地方叫系统设计，比你想象的事情还要多，所以不仅仅是说我们二三十节就能讲完的，他只能覆盖一些基础的部分，或者是说需要你理解的部分，很多地方不需要你理解的，我们变成日后再说，至于日后是哪个时候，我也不知道，一定是实际成熟的时候。</p>
</div>
<div class="paragraph">
<p>所以那今天做数据库设计，我们之前是先做的界面,我们先做了一些界面调研，那个界面调研像不像UX/UI？只是我当时没提，我的意思就是说当你经验不够，你的写代码经验不够丰富的时候要多观察，而观察源代码是一种非常低效的事情，所以不要去关注源代码，你要关注别人怎么做的，从你看得见的地方下手，这样效率才是最高的，因为你点了那个按钮发生了什么事？f12看API嘛，API看了看Controller,Controller看了看Service,Service看到了什么其他地方，你这样链路才是通的嘛，你从源代码，请问是从Maven开始看吗？是不是道理嘛？都不用我说，我现在给你布这个作业，让你去看Springboot的源代码，人都疯了，看了啥用啊，还不是看HTTP实在，因为HTTP看了过后，不管是Springboot还是PHP还是Python，都懂了，本源不在源代码层面，所以我们从界面去了解他，知道给你一个方向做个参考嘛，一些借鉴，然后借鉴完了过后再考虑我们要做哪些功能，所以画了一些简要的界面出来，有用户的，有一些就是绘图的，其实大部分是绘图的，绘图有哪些东西挨个挨个列出来了，绘图做完了，现在API就能定下来了，那么用户的，然后一些改密码的登录啊注销，还有一些绘图，现在就这些，因为核心功能是绘图，核心功能不是用户那套，所以用户那套一定是绘图做的差不多了，就是附带上的东西。</p>
</div>
<div class="paragraph">
<p>所以那么界面API做完了，那么API要涉及到你要怎么去查数据库的问题？那就涉及到数据库表设计了，所以这个地方先明确一点哈我们说用的是Postgresql，我们用的是Postgresql，Postgresql的好处是什么？他相对来说默认情况下性能会好很多，而且它的就是这种性能啊，配置啊，就到现在为止我用过算非常满意的一个数据库了，又轻练又不像Oracle一来就装一大堆东西，来不来就各种异常错误，你装都装不上，就像极了SQL server，越复杂的东西越装不上，所以他是比较适合我们这个系统，因为用Mysql存那么多数据的话，查询上肯定会有各种问题的。我不想花时间去优化它，当然我们用的是ORM，你要换也不是不行，所以因为ORM把那个SQL给你隔开了，其实你哪怕换Mylsq和SQL server，对代码都一点影响都没有，只是你建表的时候，你要在SQL server上面建一遍嘛，因为ORM他也可以帮你建，我们以前不是练习题嘛？ORM时候他会自动帮你outoquit，还会自动给你建表，所以我们选了个Postgresql。</p>
</div>
<div class="sect3">
<h4 id="_时序数据">27.3.1. 时序数据</h4>
<div class="paragraph">
<p>我们在数据库设计之前，我们先理清楚大方向，那么数据类型是Postgresql，那么数据的特征是什么？数据特征就是说我们存的大部分数据都是时序数据，这个词已经出现过很多次了。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>时序数据：时序数据是指时间序列数据。是按时间顺序记录的数据列，在同一数据列中的各个数据必须是同口径的，要求具有可比性。时序数据可以是时期数，也可以时点数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大概意思是我有a，b，c三列啊，这地方永远是比如说2021年,2022年，然后这个地方可能就是1,2,这个是0,1,就属于这种有规律的变化,持续数据嘛,比如说b是名称，c是年龄，a是时间，那么随着时间的变化它也在变化嘛，这就叫时序数据。</p>
</div>
<div class="paragraph">
<p>举个例子：监控Web日志就是持续数据哈，那么它就是一种持续数据，就是Nginx的访问日志，就最典型的了，因为他的字段一样的，只是它里面的值不一样，有默认值或者是有值，那是不一样的，那这样的话他就一直排下去就可以做分析了，所以时序类数据，那么我们可以这么做啊。</p>
</div>
<div class="paragraph">
<p>然后现在有个问题，时序数据库其实有很多，为什么要用Postgresql，主要是我们的智眼系统不想要太多的依赖，现在我们开发的是社区版嘛，社区版我们不想有那么多依赖，用户先用上，至于它量大了，买我们的vip版本，或者他自己改造嘛，也不是不行，但是我要改造好的肯定就更好噻。所以我们现在数据类型大多数都是持续数据，比如说我们的CPU。</p>
</div>
<div class="paragraph">
<p>我们现在举个例子哈，那么时序数据这个地方，我拿CPU的监控数据举例，那么CPU这个地方有一个东西叫us%（使用率），有一叫id%（空闲率），还有个叫wa%(等待I/O的CPU时间百分比)，我就拿了三个举例，wa%表示I/O吗？I/O等待，在TOP里面有，那这样的话比如说我假设他们加起来是百分之百，然后肯定还差个时间，所以这里还有一个time，当然我是用整数还是用日期，我为了方便表示，我用日期来写啊，2021/01/01 00:01:00，那这个地方23,53,24，那这是100，那接下来也是一样的，比如说刚刚使用率是23现在变成25那这个地方可能还是53，后面是22,那这个地方肯定还是时间，2021/01/01 00:02:00,就相当于第二分钟嘛，你看到没有？这就是典型的实际数据。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/CPU.jpg" alt="CPU">
</div>
</div>
<div class="paragraph">
<p>所以通过这种时序数据啊，所以这个时序数据我是可以用excel存，我也可以用那个前端绘图来做，我甚至也可以用数据库，因为这种带结构的又是这种规律的，那个怎么表示都无所谓，然后用这样的表示的好处是什么？这样好处的意思就是我在绘图的时候那柱状图直接出来了，我就不需要去关心那么多后续的问题，最关键是因为它是时序数据，我们把它当时序数据存完了过后有非常非常多的时序数据库或者时序数据库的绘图插件可以给你做调研，甚至有可能以后我们的用户会拿到这些数据自己套那种图形，因为现在用户最缺的就是采集端，他缺的不是呈现端，他是不知道怎么把数据采上来。</p>
</div>
<div class="paragraph">
<p>昨天我在知呼上逛，我又看到有一些自媒体的推荐的Gethub上面的开源项目有个叫前端监控系统，就是前端那个屁后面套一个JS文件嘛，就那种方式噻，然后他就是那个叫前端埋点，但前端埋点他永远关注的他就绘完了图像极了51拉，就那天给你们看的那个，基本上一模一样，用户的地区分布访问时段，但是我问你个问题：你该出问题的时候你通那个能看出来吗？目的不一样，那个东西只是为了统计你的访问量，而我们是想通过智眼系统能够为你整个产品或者生产系统做分析，我当时是讲过的，我们的出发的就是让用户了解自己的产品，而你只是做前端埋点，你服务器宕没宕机，你也不知道，所以说我们整个系统是包含的前段监控的，因为你是HTTP协议，只是说我们把以前那种压力分散到了浏览器上面，那这样的话就是很多人访问那个51拉的服务器，就压力来说相对来说比较小，因为是纯HTTP服务嘛，但是我们在生产上面去监控我们的系统，他肯定对系统是有干扰的，因为如果代码写的很差的话，那么我们监控CPU可不就上去了，所以我们自己的肯定要保证性能，至于用户的我不保证，你有你用户自己保证和我没有关系。</p>
</div>
<div class="paragraph">
<p>所以我们的数据大部分是持续数据，那除了时序数据以外，就是除了那个图形绘图的数据以外还有什么？</p>
</div>
</div>
<div class="sect3">
<h4 id="_用户数据">27.3.2. 用户数据</h4>
<div class="paragraph">
<p>第二类是用户数据，大多数是和他的配置和密码，当时可能有些其他的，我们就比如说头像那种都包含在里面的，那就大体是这两类，至于刚刚说的通信密钥这些东西，那个是和主机挂钩的，和用户资料没关系。</p>
</div>
</div>
<div class="sect3">
<h4 id="_主机">27.3.3. 主机</h4>
<div class="paragraph">
<p>第三类就是主机相关的，我们为什么说主机而不说server？那是因为server他的范围很小，比如doker，他不叫server，他叫host，因为host更大？比如说你的手机也是个host，他有可能采集手机上的数据，你不要去限制他啊，如果相机手表能采也是可以采的嘛，比如说那广告屏也是可以采集的，所以通常来说任何和监控类似的地方我都叫host。</p>
</div>
<div class="paragraph">
<p>那么主机里面肯定涉及到通信的，就是要主机配置嘛，用户叫用户配置嘛，主机叫主机配置，那主机配置是一些主机名、ip地址、还有些其他东西的，当然那个密钥也算，因为它不像密码，密钥是可以眼睛看到的，密码是不能给你显示出来的，所以里面包含的密钥，当然还有很多其他的东西，就不挨个列出来的，因为现在聊的是大方向，当然你你就都叫主机了，是不是有用户列表和主机列表啊？那玩意里都是能讲了一个了那一堆是不是就很好讲了？</p>
</div>
<div class="paragraph">
<p>然后现在有个问题，像其他的监控系统，当然我们不叫监控系统哈，但是用户会把那个理解为监控系统，那监控系统通常来说，他们主机还有分组，我们要不要分组？我没有跟大家聊字段，我聊的是要不要分组，比如说你这两个主机在一个机房，这两个主机然后负责某一个产品线，需不需要？为什么？那我问你个问题吗？我没有那个分组，你就不知道怎么查了吗？我就这么跟你讲我可能职业生涯里面总共负责2万台，但是我不可能那1000台都有问题，意思就是说，在了2万台里头，我通常来说我只会把它当成个体，我就为什么问这个问题啊，因为我们现在讨论是大的点，不是某一个字段的问题，你现在就更应该有取舍，所以在这个阶段你要注意取舍的问题啊，这个取舍非常重要，因为用户需求啊，通常来说产品经历或者是说刚刚画的原型，其实在讨论原型的时候，在程序员脑子里面就基本上就这些大框框了，因为没有在大框框的话，那个程序的主要负责人他是讨论不出那个原型的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>记住：产品设计出来的原型很可能会被程序员推翻的，因为他可能就涉及了很多看起来有用的东西，但实际上根本就没用，因为程序员的逻辑是很严谨的，比如说：你跟我讲你说今天我早上吃了个早饭，下午放了个屁，然后程序员就会心想，这两个有什么关系啊，不是之前讲了个那个段子嘛，那个女生的笔记本没有电了，就打电话给老公说：老公我的笔记本怎么开不了机了？然后老公说，你看一下，电源插了没有，我昨天晚上都还有电呢，你看一下那个电源开关打开没有，我昨天晚上是有电的为什么今天早上就没点了。那个男生他讲话的时候就是非常逻辑性层次，但是另外一个人讲话就没有什么逻辑性，非常非常感性，一来就是昨天晚上都有电今天就没有，然后最后见人就说我家里面那个电脑贼垃圾，然后因为一问谁买的，我男朋友买的，男朋友背锅，结果男朋友回去按了一下电源键开机了，其实之前我都不用按呢，为什么现在要按呢？可能就是涉及了这种。</pre>
</div>
</div>
<div class="paragraph">
<p>所以产品经理设计的东西有可能会被程序员推翻，因为不是每个产品都有逻辑性，记住：产品经理不一定是合格的，在国外有产品经理这个岗位，但是国外的产品经理和软件测试，我之前讲过的通常来说都是由退役的程序员，就是年龄非常大的那种程序员，他不想写代码了，或者公司需要他就去搞产品，所以这个时候人家是非常非常严谨的，人家搞需求分析能给你搞两年，他们爱放假那是一回事，但是人家两年搞出来东西绝对能用，但是在国内就不一定了，两个月搞出来东西大多数时候都不能直接用，所以这个时候为什么程序我们要取舍，那是由于这个客观世界里面不是每个事物都是完美的，所以说你取舍要根据产品原型，在这个加上现实。</p>
</div>
<div class="paragraph">
<p>现在又回到我刚问的那个问题就是需不需要分组，要问这个问题的话，那首先要回到问我们自己的那个产品啊，我们原本是想解决什么问题的？我们原本是想让他了解自己产品的，了解自己的生产服务器的状态，那这个时候这个和我们了解他的产品的现状有关系吗？你只是说这两台服务器都是那提供qq服务的，那提供qq服务和服务的状态有什么关系啊？逻辑上就推翻了，但是你刚才说的有道理，就说你可以更快的把那个分组找出来，根据分组怎么怎么样，但是我告诉你一个很残酷的现实问题，很可能那个公司很穷，他就一共买了两台服务器，公司有五个产品，然后两台服务器交叉为五个产品提供服务，请问现在你怎么分组？你说那个公司太穷好，我就跟你这么说嘛，太行一共加起来三台服务器，加了五台ECS，然后为整个系统提供服务，而这产品可能有两条产品线，请问现在你怎么分组？你分不了组的。</p>
</div>
<div class="paragraph">
<p>就像微信联系人那个，发朋友圈不是有一个分组嘛，我觉得那个分组他用词不当，不是叫分组，应该是范围的意思，为什么叫范围而不叫分组，因为分组的话通常来说我们的意识里面就是这个人属于某一个组，然后你就不会有另外一个组包含他，但是你叫分组吗？但是你叫范围我就知道了啊，要发给那些人不想发给那些人，所以我自第一次发朋友圈看到分组啥玩意啊，结果发现可以包含，就开始吐槽微信了，确实说实话不考究，当然，他说他为了满足中老年的会发朋友圈，人家才不管他分组，他只想说我想发给谁，我想让谁看，所以他前面那个title就是有问题的，所以这个地方如果你的硬要去说方便的话，你可以说加个主机标签，我之前好像设计界面的时候我说过标签这回事，所以你需要的是标签，什么叫标签？强哥身上有100个标签，你身上有200个，当有相同标签的人，我想把它找出来是可以的啊，但是你分组是啥意思啊，我主机分给了这个组，那我主机是不是还可以分给另一个组，你这么分完了过后，请问你分组的意义在哪了？我说一个概念哈，你就知道了，有一个区别啊，标签和分组它在这个表达上是不一样的，所以很多时候讲过就是大家语文，虽然我作文经常二三十分我感觉大家都不如我，因为就是那个对词的含义不理解，什么叫分组，我打个比方，我们小学不是上课做图形分组是吧？然后比如这是组1这是组2，然后现在老师说，我这个地方有圆形，有三角形，有椭圆形，有正方形，有菱形，有六边形，然后小朋友们，请你把它分组，小学是这么教的噻，比如说这个地方有三个点的分到组1,有五个点的分到组2，你看这个就是严格意义上的分组，非常非常严格，你但凡在一个图形出现的两边老师会打叉叉的，所以到时候你记笔记，你要用言语的表示这个分组的概念，最好是画两个草图，画就画明白了，随便随便那个小学试卷那个那个分组你拍个照一看就明白了，都不用我解释，因为小朋友都懂，我们在说标签，我打个比方，比如说有标签啊，你的属性是人，有钱人、帅、程序员、代码、工作狂，比如说，我有这些标签，这标签我用编号来表示哈，我一共有很多个标签，那现在我有个标签云，打个比方，我们要确定范围，那这个时候标签a和标签b在标签云里是可以的，b和c也是可以在一起的，那么从数据结构上说，分组和标签有什么区别？</p>
</div>
</div>
<div class="sect3">
<h4 id="_分组">27.3.4. 分组</h4>
<div class="imageblock">
<div class="content">
<img src="images/fenzustat.jpg" alt="fenzustat">
</div>
</div>
<div class="paragraph">
<p>各个点之间都有不同的关系，那么这就会变成了一个网，最终你会得到个：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/zuizhongfenzu.png" alt="zuizhongfenzu">
</div>
</div>
<div class="paragraph">
<p>这就看主机和主机之间是不是属于同一个产品线，一台主机可能和几个人都有关系，那就很凌乱了，这个举例还算好的了，为什么？因为上面的一根线，可不止一条关系，有可能和其他的点有关系，我之所以这么画是为了简便，其实他可能都乱成麻了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_标签">27.3.5. 标签</h4>
<div class="paragraph">
<p>当用标签来表示的时候，他就这样的：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/biaoqian.jpg" alt="biaoqian"></span></p>
</div>
<div class="paragraph">
<p>这些点相当于我们刚刚列出来的标签,说白了，我没有用分组，我想用标签来表示，就可能出现这种情况：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/biaoqian2.jpg" alt="biaoqian2"></span></p>
</div>
<div class="paragraph">
<p>那这样就相当于标签和标签之间是没有关系的，不需要强行给他做任何统计分析和关联,这样的话会让以后写代码减少很多负担，可能我现在这么讲，你理解不了，但在数据库设计的时候，最忌讳的就是说遵从第一、第二、第三？？2：51，你学了数据库导论、数据库设计、数据库原理过后你就明白了，就是我们以前学第三？？就讲的关系，我们老师那会就讲的，数据库一定用外键，如果不用外键的话，会导致数据库、表之间关系不严谨，然后当我第一次自己设计数据库系统的时候，整个系统全部都是外键，有一天一个用户把数据误删了，他让我恢复，然后我发现我为了恢复一条数据，我把整个数据库的所有表都操作一遍，就连日志表都不例外，用户只是想的那一条数据，但牵出了一整个逻辑链，这就导致了系统维护性贼低，你可以说老师之所以把你限的那么死是为了让逻辑严谨，对的,逻辑严谨是严谨的是OK的，但严谨到你都不想去改它，那就不存在维护性的问题了。</p>
</div>
<div class="paragraph">
<p>但是这个地方如果你用标签的话，改完了过后我能去验证，肯定要去验证的，等于说把那个主动权交给人,而不是把主动权交给代码，因为我们又不是银行系统，银行系统就是一板一眼，没有什么技巧可言，但是互联网产品没有那么多的条条框框的东西，所以这个时候人是最重要的，你要让人更灵活、效率更高，而不是通过各种条条框框去限制住，所以说为什么大家不用Oracle去开发，比如说阿里巴巴或者电商，那是因为只要你想改任意一个东西都要登陆一下服务器图形还去操作一遍，那很多时候我想自动化，因为我改的很频繁，SQLserver上面有个功能呢个叫批处理作业，他可以做计划任务，可以定时等等，但是我不想去弄它，我要我的代码去控制，为什么？因为你这个批处理作业是消耗的服务器CPU，但是我想把它读到内存里，用Java去弄，所以不要去限制用户。</p>
</div>
<div class="paragraph">
<p>那么只要记住分组和标签他们图形的区别，就知道从互联网这种更少的边界来说，标签更好，我们设计数据库就要追求这种关系，越少越好，这就意味着灵活，意味着代码是可控的，一旦出现分组的那种情况的，假设你处于一个团队中，如果在分组的情况下，一个人发了个补丁，那么另一个人也得跟着发补丁，但是团队里每个人的工期是不一样的呀，这就变成每半年发一次版本，但是我们的互联网产品是允许出Bug的，我先让用户用，然后用户给我们提供反馈，而不是让用户等我们半年，半年过后公司都死掉了,所以在设计数据库的时候，取舍是非常非常重要的，你通常为了去说服你的同事，你要花很多的时间，那么这种图形表达就是一种媒介、一种用户经验，你的同事可能理解不了，但是你画个图给他，所以我们的产品就不需要分组的功能，我们只需要标签，最关键是标签随便怎么填，到时候把一样的标签筛出来就可以了。</p>
</div>
<div class="paragraph">
<p>支付宝里面有默认分组，账单也默认分类，但是你会发现他里面有个东西叫备注或者叫标签，但他也没有给你分组,因为分组是非常重的东西，比如说账单，我分完了A组，那还要不要分到B组去？比如说我买了一件可以吃的衣服，那他是属于衣服还是零食？说白了，事事无常，那这样的话你会发现支付宝也是通过标签让你来做代替分组的，非常轻度的，这样的话用户搜索的时候，只要搜索特定的标签就搜出来，特别方便，我经常用他的标签功能，所以我们要多去观察自己的生活。</p>
</div>
<div class="paragraph">
<p>说实话微信我点都不想点进去，如果要我用微信支付的话，一定是迫不得已，比如说优惠个五块钱，可以考虑一下，优惠三块就算了，经常出去吃饭，别人说用微信扫码可以优惠九折，我才不要呢，为什么？</p>
</div>
<div class="paragraph">
<p>1.不想绑卡</p>
</div>
<div class="paragraph">
<p>2.微信的体验贼糟糕</p>
</div>
<div class="paragraph">
<p>之前有相当长一段时间微信都还要让我输密码，明明有指纹，最近更新了，微信终于可以选指纹付款了，他妥协了，之前华为让微信弄指纹支付，微信说不干，但现在华为可以用指纹支付了，说白了，微信之所以去做支付是为了对抗支付宝，说白了支付宝是事实上的支付的No.1,没有人可以撼动，而微信只是个陪衬，如果有一天支付宝垮了，微信可能还是一样的难用，所以支付宝毕竟电商摆在那，再加上支付本来更擅长去做那种金钱类的交易，而微信更多是社交，最可怕的是微信的账号所有权归腾讯管，QQ号也是，反而用户并没有所有权。</p>
</div>
<div class="paragraph">
<p>所以得了解这两种结构的区别。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数据表设计">27.4. 数据表设计</h3>
<hr>
<div class="sect3">
<h4 id="_时序数据数据表设计">27.4.1. 时序数据数据表设计</h4>
<div class="paragraph">
<p>我们现在主要是要定一下，我们要怎么保存时序数据，是应该每一个模块一张表还是每个主机一张表？意思就是要把整个数据表结构设计出来，为什么？因为只要一个模块设计出来，那么N个模块，无非就是N张表。</p>
</div>
<div class="paragraph">
<p>那么时序数据最重要的是时间，首先现在讲的时序数据应该是某一张表， 看起来我们应该是一个插件，一张表，因为CPU和内存的值是不一样的,有可能CPU有五个字段，内存只有三个字段，那肯定不能弄到一张表里面，所以看起来是要分表的。</p>
</div>
<div class="sect4">
<h5 id="_cpu">CPU</h5>
<div class="paragraph">
<p>我们就先拿CPU举例，那么CPU表里就可能有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.日期

2.host

3.use

4.idle

5.wa</pre>
</div>
</div>
<div class="paragraph">
<p>如果把这里换成内存，好像差不多也是这几个字段，表也差不多一样的，如果是HTTP呢？可能HTTP就中间不一样，然后报文里面一个头一个字段，但HTTP的头有可能是自定义的，所以我们数据库创表的时候，肯定不知道用户要自定义什么头，像CPU、内存啥的基础类还挺好办的。</p>
</div>
</div>
<div class="sect4">
<h5 id="_tcp">TCP</h5>
<div class="listingblock">
<div class="content">
<pre>比如TCP，它就很好办，因为他没有自定义的，那TCP表里的字段可能就有这些：

1.日期

2.host

3.src

4.dst

5.src_port

5.dst_port

6.length</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_http_2">27.4.2. HTTP</h4>
<div class="paragraph">
<p>由于HTTP报文里存在头，那我们在处理这些头的时候就把常见的头一个头一个字段，因为我们不需要body，而Nginx它是个日志，他是把响应和请求加到一行里头，他一行就表示了请求和响应，就比如请求了哪个网址，然后响应500，他只记了这个，你看响应你想英语要有其他的吗？投这些组对我们来说也是要要的我们不但是我们不能像Nginx一样，我们需要更详细的东西，所以这里HTTP我们就考虑分成两个，请求和响应，因为把他们两放在一起的话就很怪。</p>
</div>
<div class="sect4">
<h5 id="_http_request">HTTP_Request</h5>
<div class="listingblock">
<div class="content">
<pre>1.日期

2.host

3.method

4.URI

5.query-string//查询参数

6.version//版本号

7.tcp_number

8.stream_id

9.header_host

10.header_user_agent

11.header_referer//引用地址

12.headers//代理地址

13.client_ip

14.client_port

15.server_ip

16.server_port

17.length</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_http_response">HTTP_Response</h5>
<div class="listingblock">
<div class="content">
<pre>1.日期

2.host

3.version

4.code

5.message

6.tcp_number

7.stream_id

8.header_content_length

9.header_content_type

10.headers

11.clinet_ip

12.client_port

13.server_ip

14.server_port</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_请求和响应如何建立关系">请求和响应如何建立关系？</h5>
<div class="paragraph">
<p>这里我们并不会去标记他，我们就直接标记是同一个TCP就可以了，只要是同一个TCP的，那肯定就是了.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/TCP_stat.png" alt="TCP stat"></span></p>
</div>
<div class="paragraph">
<p>请求和响应之间是没有绝对关系的，他们两个是靠顺序来的，你想如果我把顺序打乱了，浏览器都疯了，浏览器也是靠顺序的，所以说这个顺序是由时间保证的，先返回的响应就肯定和第一条请求有关系，所以我们只需要保证他们发生在一个连接里，然后按时间排序，不就可以得到关系了，所以只需要有一个TCP_Number，这样的花有编号然后用时间排序就好了，就能拿到刚才那个时间图了，拿到时间图肯定是先有请求后有响应，如果两次连续两次发了请求那就证明出问题了，不过可能在HTTP2.0有问题HTTP1.1没有问题，所以这个地方TCP_Number是解决的是1.1的问题，那么我们现在还要加上HTTP2.0的东西，2.0里有个东西叫Stream_id，意思就是流ID，因为1.1是一个请求的连接嘛，但2.0是可以同时发起几个请求，然后又同时回几个请求，浏览器分不清楚谁是谁了，所以在2.0里有这个Stream_id，这是我们可以分析出来的，到时候再告诉大家怎么做，所以我们通过日期、TCP_Number、Stream_id这三个就绝对能筛选出所有HTTP的信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="_http报文头">HTTP报文头</h5>
<div class="paragraph">
<p>头的问题怎么解决？如果直接加字段的话，那用户自定义的头怎么办？所以这个地方我们加一个headers的字段，在这里保存个JSON，把全部都放进去，那查的时候怎么办？因为我们现在只有PostgresSQL，没有ES很难查的，PostgresSQL支持JSON查询,但是我们尽量不要用那种堆在一起的方式去查,看能不能展，就是展示着平铺的结构，而你Headers里面又放了个JSON这样就成了套娃的套娃，套了两层，那个JPA很难写的，写不了，所以得用裸的SQL去查，那这个头应该怎么办？首先我们就先把常见的头列一下，就是我们先确定一下我们自己知道的头，区分常用和不常用的，把一些常用的列出来，哪些是常用的嘛？我们就按照Nginx日志上的，比如：header_host,header_user_agent,header_referer,header_proxy，这些是Request常见的头，Response常见的就有：header_content_length,header_content_type。</p>
</div>
<div class="paragraph">
<p>header_content_type不是每次返回的时候都有，如果用了Gzip压缩，那这个地方永远只会看到是Gzip压缩，但是浏览器解压过后就是个JSON，看情况，先这么列，如果返回东西很多的时候，就没有这东西，到时候再说的是，这是属于属于特殊情况。</p>
</div>
<div class="paragraph">
<p>那么剩下的头怎么办？剩下的头放进Headers，用什么格式？首先绝对不会用JSON，那玩意儿贼不好分析，如果一定要放的话,我也会用逗号分割，就像这样：</p>
</div>
<div class="paragraph">
<p>头名：值</p>
</div>
<div class="paragraph">
<p>如果值里面有特殊的东西，就用Base64给它编码一下或者用urlcode，防止出现逗号，如果要这样保存的话，我们就应该想一想有什么不好的地方？如果是基于header做统计，不过我们好像没有这种需求，绘图应该不会绘这种东西，因为我们想破脑袋好像都没有使用场景，就比如说你要查Token，你只是想看，这样我把这个值展示出来就可以了，就像PoseMan有一个Header列表，展示出来就可以了，但是并不会机遇那个去做统计，绘图也不会按它来的，但是你可以在数据列表，其实应该有很多原始数据，我们这里没讨论，但是我们界面上是有的，原始数据就是一个列表，用户可以去搜，但是绘图是不需要的搜的，就先这么定下来，以后有疑问再讨论。</p>
</div>
<div class="paragraph">
<p>所以还要有字段叫headers，当然这个外面是常用的，headers应该是所有的，不要去区分外面已经有了，里面就踢掉，代码写的贼复杂，所以这个地方的话啊就属于键值对：Key:Value，就保存一个CSV，不要用JSON，太难分析了，CSV是最方便的。</p>
</div>
<div class="paragraph">
<p>所以这个地方的话应该是把它扩充一下，应该还有这些东西对吧？这个长度是不要的，因为只需要ip地址相关的，所以应该有一个client_ip，有一个应该是还有server_ip，那肯定还有端口，client_port，server_ip，那这边也是一样的，还有没其他的表，基础模块儿嘛，TCP。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mysql_2">27.4.3. Mysql</h4>
<div class="paragraph">
<p>还有Mysql，那Mysql一样的应该有日期，有host，那应该是这样的为什么这个地方会有TCP的信息，因为有可能这个地方是刚好Nginx个是个反代，通过这个机器有可能他最终的那个目标地址可能是不一样的，有可能我本机比如说ip地址127，但有可能他想到的地方不是127本身，我只打个比方，不一定正确啊，那这个Mysql也是一样的，有可能也是一个Mysql代理，所以那这样的话肯定也有一个TCP的基础信息。为什么要把TCP的基础信息写到HTTP Response？因为我们的抓那些数据的时候TCP的数据本身就在那包含在里面，只是在应用层是这个HTTP，但是在网络层的时候本来就是TCP的，所以其实我们最终抓包的时候应该是这个地方有TCP的信息，还有HTTP的，就等于说他会很多都重复的，所以默认情况下这个时候我们可能是不打开的，如果他真的要打开再说，那这边那个Mysql也是一样的，Mysql也是基于TCP的一个应用层协议，所以那这个时候他应该也有一些就是TCP的基础信息，为什么要把这个信息独立分出来，而不直接用这个地方呢？是因为我们不想去查表，我们拿数据的时候，本来一个包里面就有这些信息，所以这边也是一样的，那么TCP的信息都是有的，当然就像TCP最高地方一样，你看这个地方我有长度，我们等会讨论长度要不要放进来，我觉得等会可能有必要讨论哈，我觉得先加进去吧，因为他如果是个Post的传上来，东西如果很大，你可以通过TCP能看到问题，先加进去，这个应该就是TCP的一个总大小了，我想一下如果它Body里面有长度的话，头里面有没有？比如说他Post传上来，那头里面有一个大小，等会去确认一下，那就用TCP的，等会我们再取名字嘛，我先写上去，那这个地方看起来也是一样的，因为因为header_content_length长度不一定有，因为如果是压缩包的话就没有这个长度多，这gzip压缩是没有这个东西的，是空的，所以这是hoste，那么有tcp的number，那么有tcp的 client_ip、client_port、server_ip、server_port、length，那除了这意外就应该现在应该有数据库，查的是哪个数据库的,查的是那张表的,表好像有个问题就是他可能很多表，所以所以我更觉得那个表就不用像这个样子写出来，数据库是带编码的，所以你要把编码写上来，这是编码的意思啊，charater，然后编码完了就是SQL本身：SQL_statment，那有还有个响应时间：query_time，查询时间，那除了查询时间还有一个行数：rows，应该还有开始时间和结束时间，这个地方也有个问题哈，他来查，他还有个返回，我们是像这个样子登记吗？还是说合并成一个？这是有讲究的，这个东西，因为你这个地方有个查询时间吗？我来查的时候肯定不会同时只查一个，我打个比方嘛把它分开写像这些没有意义啊，这样写是有意义的，因为从应用程上的时候，他关心这Http Requst和Http Response，包括你按f12的时候他都分开显示的，但这个数据库子可没有必要，你没有场景说需要像这个样子，所以这个地方我就把开始时间，结束时间也写上去，应该就是查询时间：query_datatime，这是查询时间，还有一个是返回时间，先随便写一个，等一会再去考究吧，查询响应：response_datatime，好像就没了而这个query_time和query_datatime、response_datatime是不一样的，到时候看那个Mysql协议里面他会不会返query_time，他如果返我就填进去他如果不返的话，我就用他那个连接的时间来算。</p>
</div>
<div class="paragraph">
<p>Mysql：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日期</p>
</li>
<li>
<p>host</p>
</li>
<li>
<p>tcp_no</p>
</li>
<li>
<p>client_ip</p>
</li>
<li>
<p>client_port</p>
</li>
<li>
<p>server_ip</p>
</li>
<li>
<p>server_port</p>
</li>
<li>
<p>length</p>
</li>
<li>
<p>database</p>
</li>
<li>
<p>charater</p>
</li>
<li>
<p>sql_statment</p>
</li>
<li>
<p>query_time</p>
</li>
<li>
<p>rows_number</p>
</li>
<li>
<p>query_datatime</p>
</li>
<li>
<p>response_datatime</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_用户表">27.4.4. 用户表</h4>
<div class="paragraph">
<p>那现在要做的是第二个是用户，就是用户相关的表哈，然后用户相关的表就正常的登录，注销，密码，字段，首先你可能有个user表，当然那刚刚那个时序数据我没有加id，到时候看需不需要id，需要id就加，我觉得加个id就是int嘛，至增，有什么可讲的，然后比如说那个用int还是bigint？肯定bigint，用的数据可能很多，那这样的话这地方就一肯定有个id，这个id你在代码里面写的时候就要user_id，我在表里面我就不用user下滑线id了吧，没有必要吧，那首先id那么肯定有名字，用户名通常这是一个单词，它不是两个，然后有用户名称，性别啥的我们就不关心，我们肯定还关心头像，但是先说放在这合不合适啊？我认为 用户用两类信息，一个是用户的基本信息，一个是用户配置，最后配置里面才有头像，还有一个是用户的密码,所以密码通常是放到user表里面的，不会单独建张表，所以这地方用户id，用户名还有密码psaaword，还有什么？上次登录时间，上次ip地址，主要是因为我们没有必要再单独增加一个叫user_log表专门去记这玩意儿，我们又不是多安全，比如说我们是个安全审计系统，所有用户行为到审计的，所以你应该啥都得加，除了这两个性别不关心，密码有了，用户的基础信息，好像没有了。</p>
</div>
<div class="paragraph">
<p>User：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>id</p>
</li>
<li>
<p>username</p>
</li>
<li>
<p>password</p>
</li>
<li>
<p>last_login_datatime</p>
</li>
<li>
<p>last_login_ip</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面是用户配置表，user_profile，然后这个地方同样有id，然后这个id应该是user_id了，你要和他做关连嘛，这个id是他自己的，关联上了过后就是开始加头像，头像肯定是一个url，至于url到时再说，比如说是个相对路径是我们服务器上的，那么用户那有头像，然后还有什么？地区是没有必要吧，就是一般你现在用户那个用户中心改资料的地方有啥吗？密码、头像、安全问题，密码忘了，好像暂时不管他吧，他自己到数据库上去改，假设不忘密码，就是相当于就没有安全问题嘛，手机号主要是我们不想自己发短信，email需要，主要是用email留着以后忘记密码的时候，是可以通过邮箱找回，手机号不需要，这个系统没有几个人用，就是用这个系统的人毕竟不是全公司，一定是资深的人，要么是运维，要么是那种团队里面的架构师。</p>
</div>
<div class="paragraph">
<p>user_profile：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>id</p>
</li>
<li>
<p>user_id</p>
</li>
<li>
<p>photo</p>
</li>
<li>
<p>email</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用户表就这两张，然后还有没有用户权限，我们认为所有用户都应该看到所有的东西，我还给你分个权限，你直接不让他看就完事了，首先你不可能说我运为装了，你不让我运为看嘛，比如说运维装完了过后给他的架构试看，运维还不让的架构是看某些东西？是不是个意思？所以现在我们在用户那一套只保证正常登录，这主要是为了安全，没有为其他的。</p>
</div>
<div class="paragraph">
<p>说到用户安全哈，这地方讲一下未来，就是正常来说像这种系统纯靠这种密码就是总的来说还是有点欠妥，还是不是足够安全哈，所以通常我们会用这个HTTPS，然后再加个，然后再加上个HTTP Basic Auth，这个叫HTTP的基础身份认证，就是在Nginx上面配置访问这个URL必须要输入一个账号和密码，在Nginx上配的是个静态的，写死就是写死的，然后通信加密再加上用户身份验证，验证完了，进去才是系统的验证，还有更高级的，我就以前就这么干的，我们的系统更安全，除了这个玩意以外还要加一个东西叫客户端证书，因为HTTPS是有证书的，所以我们想加客户端证书，这样才绝对觉得安全，没有这个客户端证书就是你前面两部通过了，但是这个HTTPS是不会让你访问的，HTTP握手这个S握手都不会让你握，网络层、会话层，会话层是负责加密的，在会话层那个地方握手，那个加密握手都不会让着握的，因为你通不过那个校验，因为所有的解密啊都要用客户端认证来解密，他是一把钥匙，你解不开，所以都还没到这个系统里头，所以你这么一搞，简直难受，所以总的来说我们系统应该不会用这种，用户可以考虑HTTP+HTTP Basic Auth，你如果觉得安全的话，就是还要更安全的话，所以正常来说这个就可以了，再说这个地址不应该所有人都能访问，所以你端口可能不是默认443或者默认的80,URL不可能/admin就猜到了嘛，然后被暴力破解，但是就算他破解完了，进去所有东西都只读的，顶多是把那个采集频率降低，然后让那个带宽、CPU变高，也没有直接危害，所以总的来说的话只要你是只读的就好办，因为我们的所有的客户机都是Post向上报，服务器下发只是下发一些参数指令这些东西，所以这个安全问题当前不考虑，以后主要是证书这些东西，你这样你如果要加客户端证书的话这个HTTPS那把绿色的锁他就没了，因为你是自己签的证书，以后再讲啊。</p>
</div>
</div>
<div class="sect3">
<h4 id="_主机_2">27.4.5. 主机</h4>
<div class="paragraph">
<p>那现在增加的是主机表，主机的维度就比较多了，他就不是那么单纯了，所以你现在是有表叫host，他有个id，有id、有ip地址、还有主机名字，hostname，还有标签，还有tags，有标签，还有备注，就是描述，描述主机是干啥的？desc嘛，description，还有没有？地区上次提过是吧？有地区还地区分哪些？就是一个地区就可以了是吧，不需要省市区，area，所以这个area其实也是个tag或者就是个字符串，成都就可以了，还有没有，这个界面上还有啥？翻出来看一下啊，界面上还有啥，机房是需要的，machine_room，地区、机房、描述、id，这个id我们就用主机名来表示吧，这是基础表啊，这个地方刚刚涉及到这个tags，这个tags的话，为了减少数据表的这个量，这个地方就直接保存成字符串，就是用逗号分割，比如说他填的是为了让他以后方便，他就可以把这种已经有的tag我们把这个读出来，然后去重排序，然后展示成列表，但是不单独创建一个tag表，太多余了，所以这个地方是保存一个逗号分割的，然后这个地区机房这就无所谓，就纯字符串了。</p>
</div>
<div class="paragraph">
<p>那我们之前讲过的我们的主机有通信密钥，这个通信密钥相对是说他朝外面发数据出来的时候，有一个主机就是server有个密钥，我们当时说的是这样的，就是这下面是采集插件，报到这个host的上面，然后由多个这种再向上报嘛，这地方就server嘛，那这样这地方是host，首先他去报的时候有可能不在一台机器，所以他其实是有密钥的，然后那么Agent在上面报的话其实通信也要有密钥，现在我们就要开始审视我们的设计了，就是我们在做这种通信的时候，有HTTPS就可以了，有没有必要用HTTPS过后还要去做校验，当然Server出去我认为是有的，Agent这地方我想想有没有,还是用密钥吧，就相当是那个主机在创建的时候我们手动会生成一个40位的密钥，然后他在注册之前，他自己先把那个主机密钥把填到这边来，他添加过来，他请求注册的时候，他请求注册这个过程当中没有密钥，也不去做签名，然后就是个基础信息，哪个ip地址，然后他上来了过后管理员自己把密钥手动从Agent复制到server去，然后点添加保存，保存的时候，他们两个会就相互验证一下的密钥是不是一样的，那个密钥必须手动从Agent自己复制过去，手动复制，复制到添加主机那个地方，那个密钥是管理员手动填，他只有填的那个密钥和这边一样，他才能保证是可信的，而不要自动注册，自动注册你密钥哪而来的？你不可能服务器上同一个密钥所有人用一样的密钥吧，那你在那里泄露就全完蛋，所以说这地方的密钥就是在主机信息里头的，所以这地方有个密钥，access_key_secret，像这个地方有密钥，密钥等于说就包含进来了，等于说他来注册的时候只会有个ip地址。</p>
</div>
<div class="paragraph">
<p>我们需不需要给这个主机增加个别名，这主机名应该是那个机器名字，比如他想给ip地址，注册的时候这个主机名是从机器上查出来的，所以这个地方应该还有个别命之类的，或者就叫那个host的id，那个id是一个字付串，这个id是表id嘛，这是用户给他取的小名就这个意思。</p>
</div>
<div class="paragraph">
<p>host：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>id</p>
</li>
<li>
<p>ip</p>
</li>
<li>
<p>hotsname</p>
</li>
<li>
<p>tag（？，？&#8230;&#8203;csv）</p>
</li>
<li>
<p>desc</p>
</li>
<li>
<p>area</p>
</li>
<li>
<p>machine_room</p>
</li>
<li>
<p>access_key_secretinclude::sections/</p>
</li>
<li>
<p>host_id</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ZHIYANAgent_chapter">28. 智眼系统设计之Agent</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_27">28.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/智眼采集模块设计之Agent板书1.jpg" alt="智眼采集模块设计之Agent板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_agent">28.2. Agent</h3>
<div class="sect3">
<h4 id="_模型图">28.2.1. 模型图</h4>
<div class="paragraph">
<p>每一个Agent对应的一个Server，这个server专门负责接收主机上报的数据，所以在这个模型里面用Agent来形容会会更贴切一些，而不是Persis，然后之前我们讲了一个大的流程，就是从Agent到Server,应该是采集模块采集模块上次我们把他叫做插件，但是插件并没有办法对应到这个模型里，现在模型是这样的：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/moxing.jpg" alt="moxing"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_采集节点命名">28.2.2. 采集节点命名</h4>
<div class="paragraph">
<p>是这样的，如果只讲插件的话，比如在这个地方讲插件，那到底是Server的插件或者Agent的插件还是采集节点插件呢？就看起来我们没有办法定位清楚，插件的范围太大了，比如说我们叫采集插件，名字又太长了，沟通不方便，我们以前好像Agent叫节点，而不是下面的采集节点，而我们现在考录的是下面这些CPU、Mem、IO的采集子程序应该叫什么？首先我们这个程序有可能是跨主机上报的，比如跨Dokcer，所以他不一定是某一种模块，他可能比模块的范围更大，因为采集模块是个完整的程序，他是可以独立运行的，如果叫模块的话，就只讲到了其中一小部分，而实际的范围其实很大，那么模块这个命名就排除了，如果名字可以长一点，就应该叫采集客户端，上面的Agent不叫客户端，叫采集节点，为什么？因为Agent只是个通信节点,那么这个地方的如果要分层的话:</p>
</div>
<div class="paragraph">
<p><code>Agent为通信节点,CU为采集单元.</code></p>
</div>
<div class="paragraph">
<p>因为Agent只是负责通信，真正采集的是下面的采集节点，甚至你可以把不同机器的数据报给Agent，然后再报给Server都是可以的，只是说通信的过程当中和主机有一些关系，所以说跨机器通信现在不管他，我们也不去限制，那采集节点这个是基于通信结构里面来的，但是我们要给他单独取个名字，我们就先用Unit叫节点，采集的英文是collection,然后把他们合起来就是Collection Unit,名字有点长,我们就简称CU，这个名字没想好的话，可能写代码连变量名都不知道怎么取。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_智眼系统的作用">28.3. 智眼系统的作用</h3>
<div class="paragraph">
<p>现在我们做的是Agent和CU之间的东西，这个我们当时有个大致的目标，但是现在没写到那去，我们现在写的是CU，那么CU可以是CPU、内存，我们的智眼系统有点像以前用的Zabbix，但不仅只是说看起来像，因为现在用监控系统并不能解决生产的一个问题，我们的智眼系统主要是想让产品的所有者或者服务器的管理者知道自己服务器发生的情况，用来诊断、维护、管理自己的产品或者你的生产环境，让用户了解产品当前的一个状态。</p>
</div>
<div class="paragraph">
<p>所以最终他能具体做什么？打个比方，公司的程序员写的代码有问题，但运行又是正常的,跑一段时间就出问题了,始终找不到问题在哪，然后我们的智眼系统提供了HTTP、MySQL、CPU、内存、带宽、IO监控，用图形绘出来，在这个过程当中，通过在界面上拖拖拽拽或者搜索就能查出问题所在，比如说有五个SQL慢查询，然后就能够挨个挨个把问题解决完，而以前的监控系统，他只能看不能摸，因为我用Zabbix那么多年，从来没有用他解决过问题，说白了智眼系统就是把我的运维能力、系统管理能力变成一个系统，让系统成为一个媒介，然后就可以在这个系统上工作，踩在我的肩膀上去管理系统，这样就能提供一种手段，而不是依靠我，依靠这个系统就能让你的运维水平上个新台阶，当然我们的野心不止于此，现在不方便透露。</p>
</div>
<div class="paragraph">
<p>我们现在几点在这儿，那现在我们写的有CPU、内存、带宽，挂载的文件、开机时间、用户数，当然如果觉得那个用户数一个字段写一个程序有点浪费，你可以多写几个嘛，又没让你只能写一个，把那个用户数和开机的时间、运行时间那种不重要的，可以合在一起写或者说写一个程序，可以分别输出cpu，内存，不要建了一个项目，最后只输出一个字段，应该是通过用户输入的参数不同或者是说写程序的时候，直接把所有的东西都打印完，就像写了个top程序一样，然后最后再根据参数的不同只打某一个。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cu">28.4. CU</h3>
<div class="paragraph">
<p>那现在我们首先要讲的是这个我们的CU程序发生了什么？在内部发生了些什么？以前讲的非常非常粗，我们现在要把它细化，包括我们马上要做什么事情，为什么？现在有个问题：现在把数据采集到了然后呢？因为现在的程序只是把数据在屏幕上打印出来，这是不行的，所以现在我们要把这种细节全部定下来，我们就只需要先搞完一个，然后把数据向上报，先把链路打通，然后再去写第二个，这样的话程序就跑起来了，这样做三个星期，别人看三个月都看不懂，为什么？因为别人不知道你程序是怎么架起来的，所以那这个地方就先说CU程序的作用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cu程序的作用">28.5. CU程序的作用</h3>
<div class="paragraph">
<p>CU程序的作用就是：</p>
</div>
<div class="paragraph">
<p><code>采集特定类型的主机数据，通过HTTP POST上报到Agent。</code></p>
</div>
<div class="paragraph">
<p>所以他应该有两步，首先这个是作用，然后他是什么就不去讲了，因为这个东西太熟了，那么他要上报，那第二个就是CU语言支持。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cu语言支持">28.6. CU语言支持</h3>
<div class="paragraph">
<p>我们之前讲过按正常来说只要能采集数据并且把数据POST报上去都认，所以这个地方可以支持Shell脚本、python、PHP、Java、C、C++、C#只要能够请求POST就可以，比如说CURL -X POST -D {Date}，-D后面就是程序的数据，Shell里面写个变量也可以的，Shell里面是可以写变量的，而且又没有让你一行做完，你写三行也可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.采集TOP里面CPU的值，把它赋给变量。

2.CURL......</pre>
</div>
</div>
<div class="paragraph">
<p>只需要两行就把数据推上去了，所以：</p>
</div>
<div class="paragraph">
<p><code>智眼系统语言支持不限定，仅需要HTTP POST。</code></p>
</div>
<div class="paragraph">
<p>但凡你会用Linux，就应该能会用CURL，所以理论上全部都行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cu是否提供sdk">28.7. CU是否提供SDK？</h3>
<div class="paragraph">
<p>向上报这地方，我们当时还考虑了是否提供sdk，因为HTTP的不是每个人都会写，最关键是有可能涉及到一些重启的问题，因为Agent可能有指定下面的CU要重启，当时说的是每次重启Agent，那CU就没有控制了，因为Agent重启的时候会把下面的CU全部杀掉，就没有控制了，那还有没有必要提供SDK？如果只是个POST的向上提，好像还有Hash，因为有校验，所以还是要提供SDK，因为CU可能是跨主机通信的。</p>
</div>
<div class="paragraph">
<p>现在有个问题了，CURL POST的是Hash，Shell去计算它的话，估计得写疯，那想一下能不能更简单一些，可以把模型简化，我们可以不做完整的API校验，可以用纯Token，CU只需要知道Token，在URL里面带上Token就可以了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cu和agent的通信方式">28.8. CU和Agent的通信方式</h3>
<div class="paragraph">
<p>通讯方式首先是HTTP POST，如果要用脱坑的话，我们要加个头，那个头是Auth：{Token}，通过这个来校验身份，因为他是POST，就不用查询参数，就不要在问号后面加参数，合规范应该是在头里面去加，CURL是可以支持-H加头的：</p>
</div>
<div class="paragraph">
<p>不带校验的Curl语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>curl -X POST http://.... -d "XXX"</pre>
</div>
</div>
<div class="paragraph">
<p>带校验的Curl语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>curl -X POST -H "Auth:123" http://.... -d "XXX"</pre>
</div>
</div>
<div class="paragraph">
<p>这样就可以去校验了，所以到时候把这个Token写完整，然后通过校验就可以了，那么Token主要是为了确认安全，当然这个地方要不要求HTTPS，我们说过的第一个版本，先不管HTTPS，所以Agent和CU之间是基于HTTP通信，先不去考虑HTTPS的问题，所以现在就在报文里加头。</p>
</div>
</div>
<div class="sect2">
<h3 id="_token来源">28.9. Token来源</h3>
<div class="paragraph">
<p>如果要用Token的话，看起来主机这边应该有一个通信Token，Token肯定是写在配置文件里的，到时候CU去读配置文件就可以了，你之所以不安全，是因为数据是通过网络传输的，打个比方，有一个CU部署在Docker里，然后Agent在Docker外，然后你说读不到文件，你都装CU了，你要么通过环境变量写死脱坑，要不就手动写个配置文件，为什么？跨主机我们是支持的，但是我们并没有这么智能，请你手动自己写，你在外面Agent瞄一眼Token，然后复制到Docker里面不就好了，那本机的怎么办呢？本机就可以通过文件读写直接去读的，所以Token就写在一个固定的配置文件里面去就可以了。</p>
</div>
<div class="sect3">
<h4 id="_agent配置文件">28.9.1. Agent配置文件</h4>
<div class="paragraph">
<p>在Agent机器上头，要去写一个配置文件，当然我们的主程序肯定有自己的配置文件，因为这个上面跑的是Rust，所以说主程序有自己的配置文件，那么针对CU就应该有个单独的一个配置，不要把主程序和子程序的配置写在一起，这样会特别乱，就像把你的钱和你妈妈的钱存在一起，你妈说帮你存的，结果莫名其妙钱就没有了，那这样的话就有两个配置文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>~/ZhiYan/CU/common.conf</pre>
</div>
</div>
<div class="paragraph">
<p>在这个配置文件里面写一个Token的键值对，那么每一个只要是本机的CU，在运行的时候，只需要去找这个配置文件就可以了，如果是跨机器运行的，就把这个目录复制到Dokcer里，就可以了，主要是这种场景很少，我们就不需要自动去帮他配，等于说这个Agent在运行之前，要进行初始化操作，比如Agent发现文件夹都没有，就可以自动创建一个，并且把Token写进去，所以这个Token很简单，那么配置文件里的内容就变成了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>cat ~/ZhiYan/CU/common.conf

Token=123</pre>
</div>
</div>
<div class="paragraph">
<p>先不管具体采用JSON还是XML还是其他的，先假定是用最简单的方式，那这样Token在Agent就有了，那接下来只需要程序读它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_cu_2">28.9.2. CU</h4>
<div class="paragraph">
<p>CU在启动时从/cu/common.conf读取Token</p>
</div>
</div>
<div class="sect3">
<h4 id="_curl">28.9.3. Curl</h4>
<div class="listingblock">
<div class="content">
<pre>curl -x POST http://..... -H "Auth:{Token}" -d "a=1"</pre>
</div>
</div>
<div class="paragraph">
<p>那么我只需要在Shell里面调这个命令就可以了，那剩下的就好办了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_采集方式">28.10. 采集方式</h3>
<div class="paragraph">
<p>采集方式可能不止一种，比如：CPU这种连续不断的采集，一直采的，然后读取用户数量的，是一次一次的采集的，也就是重复性的，还有就是读主机名的，只需要读一次就可以了，比如有人手贱把那个主机名改了，你一天读一次也是可以的，这种不重要，还有就是IP地址，这种一个小时一次，那么不管是主机名、IP地址、CPU都是重复性的，那等于说CU程序一旦运行起来就不应该退出去了，除非用户自己把程序杀了，那么结论就是CU程序一直后台运行不退出。</p>
</div>
<div class="sect3">
<h4 id="_cu配置文件">28.10.1. CU配置文件</h4>
<div class="paragraph">
<p>有采集间隔就依靠配置文件，用户可以在配置文件里自定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>cat ~/ZhiYan/cu/cpu.conf

interval = 1//间隔

name = cpu//CU名称

agent_url = http://...... //上报地址</pre>
</div>
</div>
<div class="paragraph">
<p>因为Docker总要改,那既然Docker可能有，那外面的本地的应该也有,如果不写的话，就用个默认的localhost:8080也是可以。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>token = .... //可选

cmd = /data/mod/cpu -d 1</pre>
</div>
</div>
<div class="paragraph">
<p>那如果Token是公共的，要是以后要从其他地方报不同的数据，本地的话肯定是没问题的，比如说我要把某一个应用程序的采集，因为这个地方我们是可以采集Java的数据的，采Java的数据，然后报给另外一个Agent，然后再报上Server，就比如说现在我有一个生产线，生产线上有五个模块，这五个模块分散在各处，然后我想通过一个生产主服务器统一报上去，然后就能通过一个主机看到各个模块的数据，那要不这样，如果CU配置文件里没配Tokne，那就用公共的，如果配了就用CU自己的。</p>
</div>
<div class="paragraph">
<p>那么现在唯一问题是：CU程序是谁的启动的？之前说的是Agent启动的，那么配置文件里应该还有个启动参数，因为CU在启动的时候Agent要读CU的配置文件，然后CU自己也要读，那配置文件里应该还有一个CMD的，暂时就叫CMD，可能这里要带参数，我的建议是不把命令和参数分开写，就直接在后面加，参数和命令行写在一起，那在启动的时候，就会调这个CMD，然后这个程序就会自动在后台运行。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_OS_chapter">29. 操作系统（OS）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_28">29.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/操作系统板书1.jpg" alt="操作系统板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_操作系统os">29.2. 操作系统（OS）</h3>
<div class="paragraph">
<p>我们现在常见的操作系统可以分为：</p>
</div>
<div class="paragraph">
<p>Linux</p>
</div>
<div class="paragraph">
<p>Unix</p>
</div>
<div class="paragraph">
<p>Windows</p>
</div>
<div class="paragraph">
<p>Minx：</p>
</div>
<div class="paragraph">
<p>这个是一个教授写的一个用来教学的操作系统，Linux大神当初也是参考了他的，然后重新实现的，因为他没有完整的Unix的源代码。</p>
</div>
<div class="paragraph">
<p>VX：</p>
</div>
<div class="paragraph">
<p>实时操作系统，用于飞机。</p>
</div>
<div class="paragraph">
<p>RThread：</p>
</div>
<div class="paragraph">
<p>嵌入式操作系统</p>
</div>
<hr>
<div class="paragraph">
<p>常见的操作系统就是上面这些了，其实在生活中最常见就是Linux和Windos，我们这一门课肯定不是个普及课程，谁知道Windos用的什么内核？用的是NT，Linux的内核是叫Core，翻译过来就是内核，Unix就不去了解他了，差不多的。</p>
</div>
<div class="paragraph">
<p>当然每个操作系统里有着不同的发行版，比如：</p>
</div>
<div class="paragraph">
<p>Linux：CentOS,Ubuntu,Android，RedHat&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>Unix:Freebsd,Natbad,Openbsd,Soliars,AIX,MacOS,IOS&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>Windows：Server系列，Phone，CE&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>其他Minx，VX，RTread我们就做了解就行了。</p>
</div>
<div class="paragraph">
<p>如果你要画张图的话，按时间轴来画的话了就是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/caozuoxitong.png" alt="caozuoxitong">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/wincaozuoxitong.jpg" alt="wincaozuoxitong">
</div>
</div>
<div class="paragraph">
<p>这里面也包括他的家族谱系，什么叫家族谱系？就是你的表哥、堂弟都在里面，包括他们的关系，比如说那个苹果的操作系统，他是买的Unix的版权，Unix的版权是在贝尔实验室，后面贝尔实验室里面的大佬出走了，自己开了一些商业公司来运作各种Bsd</p>
</div>
<div class="listingblock">
<div class="content">
<pre>BSD：伯克利软件包（英语：Berkeley Software Distribution，缩写：BSD；也被称为伯克利Unix或Berkeley Unix）是一个派生自Unix（类Unix）的操作系统，1970年代由伯克利加州大学的学生比尔·乔伊开创，也被用来代表其派生出的各种包。</pre>
</div>
</div>
<div class="paragraph">
<p>还有没有听过的，比如IBM的小型机，哎呀，就是台式机嘛，然后他里面的CPU是用的一种叫Power系列的CPU，但现在IBM自己宣布不搞了,他要基于X86搞了，这个Power不是X86的，它是一种独立的体系，在它上面可以装一个操作系统发行版叫AIX，意思就是这个AIX Unix系统只能跑在它自家Power CPU上，美其名曰高性能，包括Inter还出过一个叫安腾系列的CPU，反正太高级了，我也没见到过，只是听说过，X86他不香吗？那些系统上面只能运行特定的软件，说白了编个木马,跑上去都运行不了，包括发明Java的那家公司，台湾人翻译成Sun，这家公司他们还有个操作系统叫Soners，，这个系统呢自从Sun公司被Orcle收购之前，他开发了一个开放版本叫Open Soners，是一个免费开源的Unix系统,是这个Sun公司开发的，但开发了没几年，Orcle把Sun收购了，这玩意就被抹掉了，但他有一个项目一直延续下来，叫ZFS，就是在Unix上面有ZFS文件系统吗？然后在Linux下有BFS,在装系统的时候是有这个选项的。</p>
</div>
<div class="paragraph">
<p>ZFS是Unix的版本，然后Linux社区因为版权，说白了就是许可证，Unix和Linux是不一样，所以Linux的大神们就仿照ZFS的特性，自己重新写了一套，就叫BFS，因为Unix的版权是闭源的，所以用了他过后，就会导致整个许可证协议传染，说白了就是给钱，而BFS是完全免费的，可能今年年终的时候说是可以用于生产服务器了，但是还是有些不成熟，再等几年就可以生产上用了，那么ZSF有什么好处？ZFS意思是说最后一个操作系统，他自带快照、还原、恢复、日志，可以说把虚拟机那一套全部代替了，以后比如你买了个8T硬盘，现在要备份，那只要硬盘本身没有坏，做一个快照就可以了，这样的话，只要硬盘的基础文件还在，你可以基于快照还原到任何一个地方，像极了Git，因为Git也是个小型的文件系统，所以它里面有很多包括镜像这些很高级的功能，我都没有听说过的。</p>
</div>
<div class="paragraph">
<p>NTFS我们就不说了，本来就差，微软的文件系统从来提不上日程，Wind XP发布的时候，同时也发布了NTFS，当年连权限都没有，木马满天飞，U盘双击经常中毒，真的是解决不了吗？估计微软觉得这种病毒那么小儿科的，应该不会有人中毒。</p>
</div>
<div class="paragraph">
<p>还有AIX小型机的，这个我用过，说实话也就那样，当年我给红帽做全球支援专家的时候，有一次硬盘坏了，他们在上面跑DB2，IBM为了挣钱，他还是允许在他的服务器上面装DB2,装的是RedHat企业版，软件是DB2,</p>
</div>
<div class="listingblock">
<div class="content">
<pre>DB2:IBM DB2企业服务器版本，是美国IBM公司发展的一套关系型数据库管理系统。</pre>
</div>
</div>
<div class="paragraph">
<p>订阅了我们的服务，出了问题，我们去解决，然后上面装的是DB2,DB2是个关系性数据库，跟SQL Server差不多，只是性能肯定比SQL Server好，当时第一次见到IBM的人，也就那样，我还以为多高大上，一个小年轻比我还嫩，当时我都觉得我很菜了。</p>
</div>
<div class="paragraph">
<p>那么上面讲的就是属于操作系统，操作系统就不去给他下定义了，我觉得解释不了，知道是个啥玩意就可以了，反正知道操作系统上面的可以干啥。</p>
</div>
</div>
<div class="sect2">
<h3 id="_os能做什么">29.3. OS能做什么？</h3>
<div class="paragraph">
<p>讲完操作系统，慢慢我们就开始往后深入了，操作系统能做什么？比如说刚刚讲的单片机，单片机的话，如果写完了程序烧进去，那就只能干这个，比如说单片机的程序里只能写个加减运算，1+1=2，那么他永远只能做这个运算，但操作系统是可以自动更新的，单片机要想更新还要Blog，BootLoader,</p>
</div>
<div class="listingblock">
<div class="content">
<pre>BootLoader:在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</pre>
</div>
</div>
<div class="paragraph">
<p>就相对来说操作系统里面可以做很多事情比如：</p>
</div>
<div class="paragraph">
<p>1.自制定安装应用程序APP</p>
</div>
<div class="paragraph">
<p>2.用户交互</p>
</div>
<div class="paragraph">
<p>就是各种鼠标点击，还有各种界面交互，交互和界面可不一样，怎么叫交互？DOS黑蛐蛐的窗口，那个地方有光标，也能打字吧？那也属于交互，只是这种交互很低级，所以这个用户交互相对来是更高级的交互。</p>
</div>
<div class="paragraph">
<p>3.图形UI</p>
</div>
<div class="paragraph">
<p>所以通常来说都自带界面的，只是看你选择装还是不装，Windows不装界面的话，估计死的很难看。</p>
</div>
<div class="paragraph">
<p>4.网络</p>
</div>
<div class="paragraph">
<p>因为是通常单片机，如果要想进行网络收发，还必须得有网络芯片，所以光靠一个程序是解决不了的，这样就变成了如果你的单片机程序里头自己写网络驱动，自己写文件驱动，自己写升级，那么恭喜你，mix适合你，就是你如果把这些都弄完，你都写了一个微操作系统了，如果还想自定义程序的话，内存管理欢迎你，就开始涉及到内存分配这些东西了,所以也不是不可以跑，只是要裁剪，Linux裁剪过后是可以跑在几k的芯片上面的，只不过很麻烦，说白了现在整个嵌入式还处于一种非常非常初级的阶段，原因是太穷。</p>
</div>
<div class="paragraph">
<p>5.驱动程序</p>
</div>
<div class="paragraph">
<p>6.读写数据</p>
</div>
<div class="paragraph">
<p>保存文件是最基础的功能，包括DOS都是可以保存的。</p>
</div>
<div class="paragraph">
<p>这些就是主要的特点，有了这些特点过后就能做很多事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_os的使用场景">29.4. OS的使用场景</h3>
<div class="paragraph">
<p>谁知道微软的发家史？因特尔、微软都是靠这个起家的，就是小心机，在MS Dos流行之前，60年代发明计算机，在80年代末期，90年代早期，那个时候美国有一个电脑公司，叫王安电脑，王安电脑当时卖的是什么？就是现在大家都用的台式机或者苹果的一体机，在那个时候，小心机就是那种的桌面PC叫Personal，意思就是个人电脑，在个人电脑流行之前，都是那种服务器很大一坨，特别贵，就是服务器已经足够贵了，结果还要买个Unix操作系统，还要花每年几万的服务费，所以当时太贵没什么人用，然后IBM蓝色巨人，巨人是看不起蚂蚁的，当时比尔盖茨的妈是IBM的工程师，然后他妈带着比尔盖茨去参观IBM，那么比尔盖茨就在IBM里面跟别人聊，就说他开发了个MS DOS操作系统，可不可以用在你们的机器上跑？然后当时别人并没有搭理他，然后比尔盖茨其实啥都没干，等了几年，因为比尔盖茨告诉IBM:个人电脑就是已经被更多人接受，而且也足够便宜了，家庭已经负担得起了,所以比尔盖茨蹭着个人PC狂卖，然后用户买完电脑总的配一个操作系统，当时能够选择的操作系统就只有MSDOS，没什么对手，当然有些其他的不认识的操作系统，你能用的也就MSDOS，那下面能干啥？我当时初二的时候上微机课，那个时候进微机室还要带脚套，反正我到死都想不明白当时上微机课还要带脚套，估计是我的头皮屑会让那个软盘中毒死机，当时我们的任务是学会office简单操作，但我学完了我感觉我啥都没学会，就是那个金山的表格，然后我们除了上课还干啥？就是某一天，老师故意在那屏幕上敲，我们就记住模糊的那个命令，然后敲完了超级玛丽奥就跳出了，然后开始玩儿，结果老师一来，当时我们也不知道咋退出，反正老师发现就给我们关了，所以那个时候MSDOS下面都有采蘑菇，那肯定还可能有其他的。</p>
</div>
<div class="paragraph">
<p>所以在当时MSDOS是桌面领域比较火的一个操作系统，当时王安电脑，苹果电脑就应运而生，苹果最一开始就是为个人PC服务，我从来没听说哪家公司买苹果的服务器，怕是人傻钱多，傻的不得了，那这样的话操作系统的使用场景就分为：</p>
</div>
<div class="paragraph">
<p>1.通用操作系统</p>
</div>
<div class="paragraph">
<p>Windows,Linux/Unix</p>
</div>
<div class="paragraph">
<p>2.专用操作系统</p>
</div>
<div class="paragraph">
<p>专用操作系统和我们常见的操作系统不一样，他内存分配过后基本上就不会释放，各种就是性能好，基本上用毫米为单位来衡量自己程序跑的时间，他们一般写程序，一毫秒或者十毫秒跑完，是通过这种方式来跑的，所以这种叫实时操作系统，比如说像RThread操作系统也是一样的，他这种是一种专用嵌入式的，还有一个是移动端，就是在手机上跑的，比如说已经挂掉的塞班，包括那个黑莓手机的黑莓操作系统，这种都算非常独特的,从广泛意义上来讲苹果的IOS也是算的，安卓也算，我们这里严格一点，因为移动端也是属于嵌入式。</p>
</div>
<hr>
<div class="paragraph">
<p>所以说大家知道为什么写的程序性能差了吧，因为用的是通用操作系统，如果换成专用的操作系统就快了，比如说有一个函数，Linux下面有个函数叫生成随机数，如果你用你的CE去调的话，它每秒钟可能生成200个，你的CPU就可能100%了，比如说要去破解密码，然后你用Python或者C调了个库去破解密码,你发现破解的时候CPU一直非常高，我告诉你，淘宝上几块钱或几十块钱有一种东西叫破解芯片或者破解器，把那个字符串输给他，他会有特定的算法破，那速度贼快，可能几分钟就破出来了，为什么?因为那些东西是专用的,就比如说那个指纹解锁，你如果用你的程序去判断的话会很慢，那是硬件层面用单片机写的，刚刚我说那种专用或者密码的肯定也是里面有单片机的程序，但你们啥都没有，就一个单片机是要跑，所以那这样的话就分通用和专用，那这个使用场景。</p>
</div>
</div>
<div class="sect2">
<h3 id="_特点_2">29.5. 特点</h3>
<div class="paragraph">
<p>这时候特点就是Linux/Windows的特点：</p>
</div>
<div class="paragraph">
<p>OS的特点：</p>
</div>
<div class="paragraph">
<p>windows：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>界面</p>
</li>
<li>
<p>鼠标</p>
</li>
<li>
<p>用户友好</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个东西就不用强行总结了，就是我不会叫他强行总结，因为但凡是个人，是个大学生都用过电脑，所以我随便想那个特点你都知道，OS的特点，然后先说Windows，windows的特点就是鼠标，就只说关键词：界面，鼠标，还有一个就是没权限嘛，用户友好，确实是权限开放，我打个比方每一次用户双击的那个C盘提示你输入密码，我估计用户要疯，他说我们电脑被黑了，为什么被人控制了？不输密码都进不去。</p>
</div>
<div class="paragraph">
<p>然后我以前我那个亲戚，他悄悄告诉我一个软件可以看到特殊的东西，肯定是那种带颜色的东西，然后他就说软件每次运行的时候要输入一串东西，我把这个软件和那串东西发给你，你就可以看到了，然后我拿过来看是那个软件每次运行要输入注册码，他是让在Windows上运行软件，然后在运行的时候要输入注册码就可以进去用了，但是我就心想在帮助里面一定有一个注册按钮，我点了过后把那个注册码输的地方点完成，再也没输入过了，我这操作了十分钟我才明白他说的是啥意思，所以说Windows的用户和通常都是关注这几个，比如说Windows让你不用鼠标我以前这样，我上大二的时候，我当时为了极客嘛，极客风有点叫简朴风，连鼠标我都不想买，小红点根本就没有，就是触摸板，所以现在你任何一台电脑，你哪怕没有小红点，触摸板我用玩的比你6，我当时还用触摸板打魔兽三，星际，就是挺费手的，就是摩擦非常非常痛，用了几天过后，那个手完全瘫痪了，但是可以证明他可以完成这些事情，只是那个上限有点低。</p>
</div>
<div class="paragraph">
<p>所以Windows普通人一旦脱离了键盘，他连那个桌面的都进不去，因为登录界面他不知道敲回车，就是万一敲回车刚好在头像上，一敲头像放大了，你要点Tab键Tab键切下去，所以很长的时间我是在背那个Windows的cmd那个的帮助手册，我天天背那个玩意儿，各种背快捷键组合怎么切，所以大家发现一个问题，我装完Linux过后从来不会调教桌面，他是啥就是啥，因为折腾了几十年我觉得够了，KDE第一我折腾过。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>KDE是一个国际性的自由软件社区，开发运行在Linux、BSD、Solaris、Microsoft Windows 与 macOS 等平台上的一系列跨平台应用程序。它最著名的产品是 Plasma 桌面，是许多 Linux 发行版的默认桌面环境，例如openSUSE、Mageia、Linux Mint（19版开始不再支持）、Kubuntu、PCLinuxOS 与 Chakra GNU/Linux。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>德国那个发行版我折腾过，Windows下面所有的东西我全都折腾过，包括当时想批量装100的机器这种自动装安装Linux/Windows全部都折腾过的，折腾完才发现人生再无意义，我是已经试过了，所以Windows脱离这个三个点（界面、鼠标、用户友好）里面的任何一个点，就没人用，比说让他变得更安全，服务器上面比如那管理员上去让他随时随地输入密码，我跟你讲已经够难用了，你经常用一个命令，比如说改防火墙规则，他一个叫nat命令的，里面有很多子命令，可以改防火墙啊这些东西端口这些，命令我超会玩，但是你到了界面上我在哪儿来着？就是我连搜关键字我都不知道怎么搜，当时我还配DHCP：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>动态主机设置协议（英语：Dynamic Host Configuration Protocol，缩写：DHCP），又称动态主机组态协定，是一个用于IP网络的网络协议，位于OSI模型的应用层，使用UDP协议工作，主要有两个用途：(1）用于内部网或网络服务供应商自动分配IP地址给用户，（2）用于内部网管理员对所有电脑作中央管理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>配那个服务，他说有个选项可以开，我硬是把那个软件里面所有的菜单点了一遍，我就是没找到，结果在那有个地方有个小的那个符号，你点一下旁边那个小加号，它就出来了，就真的要命啊，就是界面对于有些人来说可能是很好，但对于我来说我脑子太笨，我跟不上那个界面啊，所以对于我来说我更喜欢是简单的界面或者无界面的，所以那这个是Windows的特点。</p>
</div>
<div class="paragraph">
<p>Linux或者Unix特点我们简称是*inx，就表示Linux或者Unix，他特点很简单，人家从一创建的时候，当时贝尔实验室的老大说我要一个多任务系统，我告诉大家Windows最开始是没有多任务的，什么意思？我用XP的时候你在放歌。你把它切到背后去，他就不会放了，早期的Windows，比如说你在给放一个视频做个工作，你放到背后，你发现它就不运行了，就会有问题，当时的cpu都是单任务cpu，因为cpu响应不过来，不是windows的问题，因为他的桌面把整个资源全给你占了，说白了就是你的操作主窗口在那个地方谈不上多任务，他从始至终就没有多任务，这Win10是可以多桌面的，四个手指触摸板向左右滑，你会发现他会新建个桌面，因为没事按手指，双手指三手指四个呢？五个爪一起，然后发现五个就没用了。</p>
</div>
<div class="paragraph">
<p>所以Linux的话从诞生之初他就是多任务，这奠定了他最开始受大家欢迎的原因，因为我把他当成服务器的时候，任何人同时用都没有问题，但Windows Server可不是这样的，你一旦登上去Win7/Win10登上去提示你已有用户登录，你要把它踢下去吗？这是一个，然后你买了个Server版，Server版也是有限制的，也就是十个。也就是说同时十个人登上那个服务器，对不起，任何人都再也登不上去了，除非有人下来，所以他那个多任务完全就是应该是可以实现的，所以Windows不要去强调他多任务，他其实做的不好，其实做的不好，你想嘛，比如说一个Admin用户他同时登录他登录上去你会有个很严重的问题，amidstreet在home目录下面有个文件夹，在你多人同时登同一个账号，对不起，锁死，你第二个人是登不进去的，同一个账号同时只能有一个桌面，然后如果同时两个人用远程桌面登上去的话，他有个设置叫克隆，克隆你的用户空间，但是操作很多东西都会出错啊，所以Windows的远程桌面啊，有管理员有些事情是做不了的，所以他会各种地方都有很怪的那种限制，所以Windows的多任务做的不好，但cpu又有支持多任务的这个概念，以前酷睿才出来说他支持多任务，其实不是的，是人家md先搞的，md先搞了X86 64位,然后提出了多核的概念，当年两核大一核打得满地找牙，后面酷睿出来过后才解决的差不多，所以酷睿老是说自己多任务多核，你以为他是个第一，不是的，他是抄的md，因为两家都是差不多的，反正一个生一个死，反正你不能垮喽，垮了我拿钱给你让你养着，所以那个cpu也有多任务的问题，以前cpu就单核或者单任务的时候，好像超纲了哈，随便顺提一句啊，现在的cpu比如说你的服务器有128个核心，但是你会发现你的128个核心里面的第一个cpu永远是占用率和使用率最高的，因为他要负责所有线程，所有上下文切换的调度，然后那这个指挥过程当中要要耗他的资源，而那个第一个cpu就是以前的那个单任务的cpu，他做了个逻辑核心，你还是会进入第一个零号cpu那个核心上去，进去过后他把你只会放到山上面去哈，鉴定完连接，然后再用上，像不像三只握手？所以以前的cpu都是单核的，人都是单核的，然后这是多任务。</p>
</div>
<div class="paragraph">
<p>然后第二就性能，反正我从来没有看到Windows宣传自己性能好的，又要方便友好，又要性能好，我跟你讲那是绝对是冲突的，有个叫三角理论嘛，就是有三个点，如果你想你的那个安全性提高一些，比如说就变成这样提高一些，你安全起高了，你总有地方降低了噻，比如说中间是那个原点嘛，这个地方的距离表示他的能力值嘛，那这样的话你看到没有，安全性是提高了，但是他那三个点不管你怎么倒腾也要为了保证他们是个三角形，你必须要把另外的移动，安全性高了，那么应用性就降低了，应用性提高了，安全性就降低了，所以宣传Linux同时还宣传个安全，那怎么安全哈？</p>
</div>
<div class="paragraph">
<p>我不是经常讲笑话吗？我黑我自己都不行，我自己的系统，我就想按照那些教程去把我自己的那个另外个是内核给去给他拿下root权限，我搞了半天我连踢门那一步部我都进不去，或者我在本机虚拟机里面装了个系统，然后照着教程做，教程说要2.6的内核，我也用了，他说的版本我也用了，我就发现我死活进不去，然后严重怀疑那个教程是个假教程，所以你看到没有，我自己玩，我也不是个纯新人，我也有经验，我经常这么干，比如说我装了一个空白的Linux我想黑他，我发现不行，我装个Nginx我黑他好像也不行，我就装个Apache好像还不行，然后装个Apache后面加个PHP，结果漏洞是PHP，脚本的问题，就已经和系统已经没有关系了，然后我把PHH权限拿到了，我想我可以建个用户噻，我搞了半天不行，因为默认情况下PHP是在3W用户上运行的，我想跨那个权限的话比登天还难，多用户运行是Linux看家本领，你轻易就把人家破了？但是在Windows下面你新建个权限大家都知道要提权，Windows提权好容易哦，Linux提权试一试？搞死你，所以多任务、性能、安全是正儿八经的，当年我有了性能，我还抛弃用了FreeBsd在我的那个服务器上面，然后测试一段时间发现，没两样，安装我装了三个星期我就装上，因为那个驱动问题，很多老的新的，太老的没有太新的也没有，他只有中间这一段，然后跑到那个gethub上面去下驱动程序，然后各种编译，我发现编译完了又不行了，而且老断，我发现个驱动兼容问题各种换，所以他对硬件的支持简直无语，所以Linu有时候觉得很牛逼了，因为厂商愿意给Linux贡献那个网卡内核，那个驱动，他就能跑噻，比如说卢宇的那个wifi不是老出问题吗？那出问题是完全是因为要驱动不对，但是他的那个内核里面官方是自带了的，官方已经发出了这个东西，而且很多人愿意给你那个这些网卡驱动，最后他用的驱动就是网上别人写的，听起来很高大上吧，写驱动，其实很简单的，比你写的XXX管理系统还简单，只是说领域不一样。</p>
</div>
<div class="paragraph">
<p>所以那这个地方宣传Linux这些东西的少i后通常在这几个关键词：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>多任务</p>
</li>
<li>
<p>性能</p>
</li>
<li>
<p>安全</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>安全跟友好一定是互排斥的，然后这个地方就不要去强调性能了，多任务就不要强调了，就是个很拉跨的一个东西，所以那除了这些以外，比如那种实时操作系统就没有必要讲。</p>
</div>
<div class="paragraph">
<p>然后这个地方讲了几个大点，那Linux还一个非常非常重要特点是什么？小巧算一个，还有没有？无图性界面，所以那这样的话就可以根据无界面倒推它是支持命令行运行的，Windows因为他有界面，有鼠标，所以他就没有这种需求，但是用Linux的人通常来说都是习惯无界面，小巧就是意味着用内存少，用硬盘少，这地方可能强调的是内存，硬盘，那无界面的话意味着可以脱离界面去做的全自动化，所以它的地方就意味着可以自动化，我可以自动化去配置防火墙，我任何管理任务我可以自动化去加计划，当然windows也是可以自动化加计划任务的，但是我相信你这辈子你都没有机会用，我都用windows了我还用计划任务？我绝对会到网上找个XXX计划任务工具，因为你不会用那个windows自带的，难用是真难用，比如说windows自带的记事本，你没几个时候用吧？你多用问题就更多，至少Linux下面的gedit至少人家能用，没有编码问题，有行号，有颜色，有主题，还有次数统计，还有一些简单的插件，虽然还是集成在里面的，但是我觉得已经足够用了，至少不用去装个notepad++，那玩意儿装个第三方总归没有集成的好用，所以那这样的话就相对于说我优化性能，我也是配置参数是基于脚本，不需要界面，那这样就开始意味着Linux根据这上面特点你可以推出一个，根据这上面的特点就可以推出这个：适合自动化，大量部署——&gt;分布式集群，那我们看Windows可不可以啊？Windows可以做分布式的软件吗？到现在为止我没有发现任何分布式软件可以在Windows下跑，可能是有些商用软件要给钱才能用的，至少开源里面都没有这个，Git,不对啊，你只有Git的客户端啊，你把我带偏了，你Git在windows下面用是官方把Git塞到了个迷你的Linux模拟器里头，然后才在Windows上面跑的，先跑个Windows，跑个Linux模拟器，模拟器面装了个Git，叫mingw，现在改名字了叫msys2，这玩意是个Linux模拟器，所以唯一的一个就推翻了，Linux我给你举些例子哈，原生Git，因为大佬就是Linux ，然后Elasticsearch是java写的，百分之百的人都部署在Linux下面。</p>
</div>
<div class="paragraph">
<p>我就给大家讲个笑话吧，当时我们属于阿里云早期，当时我们选择的方案是基于Linux加kvm虚拟机，然后搭建了一套整套就是基础环境云服务器嘛，然后我们隔壁公司选择了使用windows加那个virtualbox和vm搭建的一个就是商用的虚拟机服务器，我们叫云服务器，正儿八经的叫虚拟机服务器，然后当时你使用下来特点这样的，我们一台同样配置的服务器我们可以开512内存的那个虚拟机，我们可以开300台，但是我们对手的服务器只能开100台，然后当时我们私底下打听了采访了我们对手的用户，他就告诉我们他在他们公司在那个我对手公司，他便宜吗？我们比如卖50一台，他可能卖20，他买了挂yy挂qq的那个等级，他们的服务器每隔三天就要重启一遍，因为Windows那个内存用完了必须要重启，不然那个内存放不出来，意思就把虚拟机全部都关了，重新再开一遍就可以了，不用重启Windows重启的是虚拟机，那时候我们用kvm就没有重启问题，然后以前不是一个叫OpenVZ的虚拟机软件，然后Linux用户在里面更新的那个Linux版本内核，居然还要导致数组机死机，就是虚拟机的版本还和物理机的版本还要勾搭上，不然他用不了，一脸蒙逼，因为kvm是集成在那个内核里头一个模块，天生就没有兼容性的问题，所以当时的订方案的时候就只看了Linux官方有没有，基于这个方式下去做下去，所以我们3000块钱可以卖100台虚拟机，但是对手3000块钱只能卖十台或者是50台20台，而且最关键是还不稳定，这个当时候分布式没关系啊，只是证明他下面的技术先进，然后那这个地方的话就是说，Windows下面想了半天，除了这种Java跨平台的程序以外找不出几个能打的，但是Linux下面打能打的可多了，Nginx、Apache、Redis、Mysql、Psql、Oracle也是主张在Linux上面运行的，因为Oracle官方开发了个版本，发行版叫Oracle Linux，专门去集成他的Oracle数据库，他为什么不用个Windows呢？当然因为钱 ，Docker天生就只能在Linux下面跑，微软当时当年收购Docker想在Windows下面开发个Docker，结果发现是微软先开发了个WSL，先开发个虚拟机，模拟Linux然后再跑Docker，你会发现微软想一旦想去借助于社区那些东西啊，他必须要先有个翻译器，一个虚拟机，比如现在用wsl2他要先开一个hyper v的虚拟机，虚拟机开完了才会用他这个，开机默认就给你挂个虚拟机挂在那而，我的暂且不论内存多大哈，现在用户内存大是这么用的吗？以前没有flash的时候我日子挺好，有了flash内存严重不足，然后现在flash他死掉了，我的内存还是不够，你猜问题在哪？ 所以说现在是你软件是有多少内存用多少，微软首当其冲，所以你再举例子，你举不出更多的例子，你比如说，你说的是个SQL server，对不起现在是个SQL server可以在Linux下运行的，因为SQL server那个新的ceo想拥抱Linux，他们自己的卖的云服务器都是占多数，靠Linux挣钱，在四年前，五年前还骂Linux是毒瘤，所以你看微软的开始吸Linux的血了，所以你再举例子我看一下，有没有什么东西是Linux建在windows下面的？qq，除了这些玩意以外好像都没有了，所以你会发现，只要涉及到服务器领域，Windows完全面处于弱势，除非你是万科，是金牛这些大房地产企业开发了一套Windows特用，特定用的服务器版本软件，然后必须要跑到Windows .net开发的嘛，就是因为外包公司用.net的开发的，所以用Windwos啊，但凡是用PHP或Java开发的就不至于这样了，其实他们打赌可能是为了多收一笔Windows的钱，所以那这样的话就是你只要提到性能分布式集群，还有服务器领域，Linux/Unix占绝对的统治地位，当然你要统计全世界的这个windows服务器的占有量一定是第一的，因为小白很多嘛，要是大家都用Linux了，就显得我不够高级， ，所以那这样的话在服务器领域，特别在互联网领域，基本上百分之百都是Linux，Unix的都非常少，银行的那种老系统里面有很多Unix，比如说那个AIX，银行里面特别多，因为服务器没有报销嘛，IBM的那些服务器报销过后绝对是换成Linux的,就是比如说了新网银行是最近几年才成立的，就是在前面那个二街三街之间有个叫新网银行的办公楼嘛，他们是一家纯面向互联网的银行，这个银行绝对大部分90%以上都是Linux，我都不用去去问为什么，因为他是个全新的银行业务，全新的体系，他的招的人都只会Linux，没人会Unix，你懂吗？肯定找不到啊，所以那这个情况他采购的时候肯定要想维护成本 ？但是绝对不会用windows的，ATM机用Windows，Windows 2013，Windows XP，Windows7，我看到的，然后电梯里面我看到用那个Linux的多一些啊。</p>
</div>
</div>
<div class="sect2">
<h3 id="_linux历史">29.6. Linux历史</h3>
<div class="sect3">
<h4 id="_unix渊源">29.6.1. UNIX渊源</h4>
<div class="paragraph">
<p>UNIX操作系统（英语：UNIX），是美国AT&amp;T公司贝尔实验室于1969年完成的操作系统。最早由肯·汤普逊（Ken Thompson），丹尼斯·里奇（Dennis Ritchie），道格拉斯·麦克罗伊（Douglas McIlroy），和乔伊·欧桑纳于1969年在AT&amp;T贝尔实验室开发。于1971年首次发布，最初是完全用汇编语言编写。后来，在1973年用一个重要的开拓性的方法，Unix被丹尼斯·里奇用编程语言C（内核和I/O例外）重新编写。高级语言编写的操作系统具有更佳的兼容性，能更容易地移植到不同的计算机平台。</p>
</div>
<div class="paragraph">
<p>1983年，理查德·马修·斯托曼创立GNU计划。这个计划有一个目标，是为了发展一个完全自由的类Unix操作系统。自1984年发起这个计划以来，在1985年，理查德·马修·斯托曼发起自由软件基金会并且在1989年撰写GPL。1990年代早期，GNU开始大量地产生或收集各种系统所必备的组件，像是——库、编译器、调试工具、文本编辑器，以及一个Unix的用户界面（Unix shell）——但是像一些底层环境，如硬件驱动、守护进程、系统内核（kernel）仍然不完整和陷于停顿，GNU计划中是在Mach微内核的架构之上开发系统内核，也就是所谓的GNU Hurd，但是这个基于Mach的设计异常复杂，发展进度则相对缓慢。林纳斯·托瓦兹曾说过如果GNU内核在1991年时可以用，他不会自己去写一个。</p>
</div>
<div class="paragraph">
<p>386BSD涉及的法律问题直到1992年还没有解决，NetBSD和FreeBSD是386BSD的后裔，早于Linux。林纳斯·托瓦兹曾说，当时如果有可用的386BSD，他就可能不会编写Linux。</p>
</div>
<div class="paragraph">
<p>MINIX是一个轻量小型并采用微内核(Micro-Kernel)架构的类Unix操作系统，是安德鲁·斯图尔特·塔能鲍姆为在计算机科学用作教学而设计的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_linux的创立">29.6.2. Linux的创立</h4>
<div class="paragraph">
<p>1991年，林纳斯·托瓦兹在赫尔辛基大学上学时，对操作系统很好奇。他对MINIX只允许在教育上使用很不满（在当时MINIX不允许被用作任何商业使用），于是他便开始写他自己的操作系统，这就是后来的Linux内核。</p>
</div>
<div class="paragraph">
<p>林纳斯·托瓦兹开始在MINIX上开发Linux内核，为MINIX写的软件也可以在Linux内核上使用。后来使用GNU软件代替MINIX的软件，因为使用从GNU系统来的源代码可以自由使用，这对Linux的发展有益。使用GNU GPL协议的源代码可以被其他项目所使用，只要这些项目使用同样的协议发布。为了让Linux可以在商业上使用，林纳斯·托瓦兹决定更改他原来的协议（这个协议会限制商业使用），以GNU GPL协议来代替。之后许多开发者致力融合GNU元素到Linux中，做出一个有完整功能的、自由的操作系统。</p>
</div>
</div>
<div class="sect3">
<h4 id="_linux命名">29.6.3. Linux命名</h4>
<div class="paragraph">
<p>Linux的第一个版本在1991年9月被大学FTP server管理员Ari Lemmke发布在互联网上，最初Torvalds称这个内核的名称为"Freax"，意思是自由（"free"）和奇异（"freak"）的结合字，并且附上"X"这个常用的字母，以配合所谓的类Unix的系统。但是FTP服务器管理员嫌原来的命名“Freax”的名称不好听，把内核的称呼改成“Linux”，当时仅有10000行代码，仍必须运行于Minix操作系统之上，并且必须使用硬盘引导；随后在10月份第二个版本（0.02版）发布，同时这位芬兰赫尔辛基的大学生在comp.os.minix上发布一则消息：</p>
</div>
<div class="paragraph">
<p>Hello everybody out there using minix- I&#8217;m doing a (free) operation system (just a hobby, won&#8217;t be big and professional like gnu) for 386(486) AT clones.</p>
</div>
<div class="paragraph">
<p>Linux的标志和吉祥物是一只名字叫做Tux的企鹅，标志的由来有一说是因为Linus在澳洲时曾被一只动物园里的企鹅咬了一口，便选择企鹅作为Linux的标志，但更容易被接受的说法是：企鹅代表南极，而南极又是全世界所共有的一块陆地。这也就代表Linux是所有人的Linux。</p>
</div>
</div>
<div class="sect3">
<h4 id="_发展现状">29.6.4. 发展现状</h4>
<div class="paragraph">
<p>1994年3月，Linux1.0版正式发布，Marc Ewing成立Red Hat软件公司，成为最著名的Linux经销商之一。早期Linux的引导管理程序（boot loader）使用LILO（Linux Loader），早期的LILO存在着一些难以容忍的缺陷，例如无法识别1024柱面以后的硬盘空间，后来的GRUB（GRand Unified Bootloader）克服这些缺点，具有‘动态搜索内核文件’的功能，可以让用户在引导的时候，自行编辑引导设置系统文件，透过ext2或ext3文件系统中加载Linux Kernel（GRUB通过不同的文件系统驱动可以识别几乎所有Linux支持的文件系统，因此可以使用很多文件系统来格式化内核文件所在的扇区，并不局限于ext文件系统）。</p>
</div>
<div class="paragraph">
<p>今天由Linus Torvalds带领下，众多开发人员共同参与开发和维护Linux内核。理查德·斯托曼领导的自由软件基金会，继续提供大量支持Linux内核的GNU组件。一些个人和企业开发的第三方的非GNU组件也提供对Linux内核的支持，这些第三方组件包括大量的作品，有内核模块和用户应用程序和库等内容。Linux社区或企业都推出一些重要的Linux发行版，包括Linux内核、GNU组件、非GNU组件，以及其他形式的软件包管理系统软件。</p>
</div>
</div>
<div class="sect3">
<h4 id="_linux系统架构">29.6.5. Linux系统架构</h4>
<div class="paragraph">
<p>基于Linux的系统是一个模块化的类Unix操作系统。Linux操作系统的大部分设计思想来源于20世纪70年代到80年代的Unix操作系统所创建的基本设计思想。Linux系统使用宏内核，由Linux内核负责处理进程控制、网络，以及外围设备和文件系统的访问。在系统运行的时候，设备驱动程序要么与内核直接集成，要么以加载模块形式添加。</p>
</div>
<div class="paragraph">
<p>Linux具有设备独立性，它内核具有高度适应能力，从而给系统提供了更高级的功能。GNU用户界面组件是大多数Linux操作系统的重要组成部分，提供常用的C函数库，Shell，还有许多常见的Unix实用工具，可以完成许多基本的操作系统任务。大多数Linux系统使用的图形用户界面创建在X窗口系统之上，由X窗口(XWindow)系统通过软件工具及架构协议来创建操作系统所用的图形用户界面。</p>
</div>
<div class="paragraph">
<p>已安装Linux操作系统包含的一些组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>启动程序：例如GRUB或LILO。该程序在计算机开机启动的时候运行，并将Linux内核加载到内存中。</p>
</li>
<li>
<p>init程序：init是由Linux内核创建的第一个进程，称为根进程，所有的系统进程都是它的子进程，即所有的进程都是通过init启动。init启动的进程如系统服务和登录提示（图形或终端模式的选择）。</p>
</li>
<li>
<p>软件库包含代码：可以通过运行的进程在Linux系统上使用ELF格式来执行文件，负责管理库使用的动态链接器是“ld-linux.so”。Linux系统上最常用的软件库是GNU C库。</p>
</li>
<li>
<p>用户界面程序：如命令行Shell或窗口环境。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_linux发行版">29.6.6. Linux发行版</h4>
<div class="paragraph">
<p>Linux发行版指的就是通常所说的“Linux操作系统”，它一般是由一些组织、团体、公司或者个人制作并发行的。Linux内核主要作为Linux发行版的一部分而使用。通常来讲，一个Linux发行版包括Linux内核，以及将整个软件安装到电脑上的一套安装工具，还有各种GNU软件，和其他的一些自由软件，在一些Linux发行版中可能会包含一些专有软件。发行版为许多不同的目的而制作，包括对不同电脑硬件结构的支持，对普通用户或开发者使用方式的调整，针对实时应用或嵌入式系统的开发等等。目前，超过三百个发行版被积极的开发，最普遍被使用的发行版有大约十多个。较为知名的有Debian、Ubuntu、Fedora、CentOS、Arch Linux和openSUSE等。</p>
</div>
<div class="paragraph">
<p>一个典型的发行版包括：Linux内核，GNU库和各种系统工具，命令行Shell，图形界面底层的X窗口系统和上层的桌面环境等。桌面环境有如KDE或GNOME等，并包含数千种从办公包，编译器，文本编辑器，小游戏，儿童教育软件，到科学工具的应用软件。</p>
</div>
<div class="paragraph">
<p>很多发行版含有LiveCD的方式，就是不需要安装，放入系统光盘或其它介质进行启动，就能够在不改变现有系统的情况下使用。比较著名的有MX Linux、PCLinuxOS等。LiveCD的相关技术进步至此，很多的发行版本身的安装光盘也有LiveCD的功能。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_windows">29.7. Windows</h3>
<div class="sect3">
<h4 id="_windows由来">29.7.1. Windows由来</h4>
<div class="paragraph">
<p>Microsoft Windows，有时译为微软视窗或视窗操作系统，是微软公司以图形用户界面为主推出的一系列专有商业软件操作系统。其问世时间为1985年，起初为运行于MS-DOS之下的桌面环境，其后续版本逐渐发展成为主要为个人电脑和服务器用户设计的操作系统，并最终获得了世界个人电脑操作系统的垄断地位。此操作系统可以在几种不同类型的平台上运行，如个人电脑（PC）、移动设备、服务器（Server）和嵌入式系统等等，其中在个人电脑的领域应用内最为普遍。在2004年国际数据信息公司一次有关未来发展趋势的会议上，副董事长Avneesh Saxena宣布Windows拥有终端操作系统大约70%的市场份额。</p>
</div>
<div class="paragraph">
<p>微软于1985年11月20日推出了名为Windows的操作系统，作为MS-DOS的图形操作系统外壳，以响应对图形用户界面（GUI）的日益增长的兴趣。Microsoft Windows以超过90%的市场份额占领了全球个人计算机市场，超过了1984年推出的MacOS。苹果公司开始将Windows视作对产品进行GUI开发的创新的不公平侵犯。例如丽莎（Lisa）和麦金塔（Macintosh）（最终于1993年在法院和解下获得微软的支持）。在PC上，Windows仍然是最受欢迎的操作系统。然而，由于Android智能手机的销量大幅增长，微软在2014年承认其将整个操作系统市场的绝大部分输给了Android。2014年，出售的Windows设备数量不到出售的Android设备的25%。但是，这种比较可能并不完全相关，因为这两个操作系统通常针对不同的平台。尽管如此，用于Windows的服务器使用数量（与竞争对手相当）仍显示出三分之一的市场份额，与最终用户使用的相似。</p>
</div>
<div class="paragraph">
<p>截至2021年5月，用于个人电脑、平板电脑、智能手机和嵌入式设备的最新版本是Windows 11，版本21H2。用于服务器计算机的最新版本是Windows Server 2022，版本21H2。Windows的特殊版本也可以在Xbox One视频游戏机上运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows全球使用比例">29.7.2. Windows全球使用比例</h4>
<div class="paragraph">
<p>Windows在全球操作系统市场之中有统治性的地位，占了约90%，遥遥领先其他竞争对手(如Mac OS或Linux等)；但其移动操作系统如Windows Phone及Windows Mobile等则大幅落后于其他移动操作系统(如Android及iOS等)并失去了该领域大量的市场。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Windows使用比例.jpg" alt="Windows使用比例">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_windows历史">29.7.3. Windows历史</h4>
<div class="paragraph">
<p>Windows之起源，可追溯到多年前施乐公司所进行的研发工作。1970年，美国施乐公司成立了著名的研究机构帕罗奥多研究中心，主要从事局域网、激光打印机、图形用户界面和面向对象技术的研究。施乐于1981年宣布推出世界上第一个商用的图形用户界面系统“Star 8010”工作站。但技术并未得到大众的重视，也没有协助商业化的应用。</p>
</div>
<div class="paragraph">
<p>这时苹果电脑的创始人之一的史蒂夫·乔布斯在参观施乐公司的帕罗奥多研究中心后认识到图形用户界面的重要性以及广阔的市场前景，便开始着手进行自己的图形用户界面系统研发工作。之后在1983年研发出第一个图形用户界面系统Lisa OS。不久，苹果电脑又推出第二个图形用户界面系统System Software（现称macOS），成为世界上第一个成功的商用图形用户界面系统。苹果电脑在开发Macintosh时基于市场战略上的考虑，故意开发了只能在苹果电脑上作运作的图形用户界面系统，但当时因为Intel x86微处理器芯片的IBM兼容电脑已渐露头角，因此就给了微软公司所开发的Windows生存空间和市场。</p>
</div>
<div class="paragraph">
<p>微软公司亦已经意识到创建业界标准的重要性，所以在1983年春季就宣布开始研究开发Windows，希望它能够成为基于Intel x86微处理芯片计算机上的标准图形用户界面操作系统。它在1985年和1987年分别推出Windows 1.01和Windows 2.03。但是当时硬件和DOS操作系统的限制，这两个版本并没有获取很大的成功。此后，Microsoft对Windows的只读存储器管理、图形用户界面做了重大改进，使图形用户界面更加美观并支持虚拟内存功能。此一突破性的由来是亚历桑那大学物理教授Murray Sargent 1989年去微软做暑期研究，发现当时Microsoft Windows不能处理大量记忆和同时处理多项程序，这问题可由他发明的一种程序来解决。他帮微软解决这重大问题后仍回学校教书，后来才加入微软成为微软员工。微软于1990年9月推出Windows 3.0并一炮而红。这个“千呼万唤始出来”的操作系统一面世便在商业上获取惊人的成功；不到推出后的六个星期，微软已经卖出50万份Windows 3.0，打破了任何软件产品的六周内销售记录，从而开始了微软在操作系统上的垄断地位。但在1994年时被苹果公司控告侵权，展开了著名的“Look and Feel”诉讼官司。盖茨还讥讽乔布斯说：“我们有一个富邻居——施乐，他家有一张电视。当我们想偷的时候，发现乔布斯早就偷走了，可他却说我们是小偷。”乔布斯也反唇相讥：“毕加索不是说过吗，‘好的艺术家只是照抄，伟大的艺术家则是窃取灵感’。而我们在窃取伟大的灵感的方面上一直都厚颜无耻。”</p>
</div>
<div class="paragraph">
<p>自Windows 95和Windows NT 4.0以来，这个系统最明显的特征是桌面环境。微软设计的桌面大大增进了人机交流的界面，使得更多简单的操作只需要少许的书、知识就可以胜任了。但是Windows界面也使得用户和电脑的内部运作产生隔阂，令用户控制或设置电脑内部的选项感到更大的困难（这也是由于现代操作系统功能和复杂性不断增长、以及有大量低水平的计算机人员的增长所带来的困难）。</p>
</div>
<div class="paragraph">
<p>Windows获得了巨大的市场成功。估计现在有90%的个人电脑使用这个系统。但从另一方面看，用户很难选择其它的操作系统，因为许多电脑已经预装Windows系统，而他们必须移除Windows之后才可以安装其他系统，况且市面上的很多流行软件及硬件厂商的驱动程序都是为Windows而编写的，如果用户安装其他操作系统便必须面临辛苦的适应新操作系统，并为新系统寻找驱动及第三方软件的尴尬，为此将抛弃他们可能获得的技术支持和常年累积的使用习惯。毕竟一款没有多数驱动软件和应用软件支持的操作系统很难普及。因此，它的市场占有率或保持市场主导位置的活动都是极富争议性的。不过目前一部分Linux系统选择试图兼容Windows的软件并因此开发了相仿的技术，更甚至有组织试图用C语言编写与Windows XP完全兼容的非Windows系统，但是这些技术对于普通用户还是有太高的难度。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_OS2_chapter">30. 操作系统（二）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_29">30.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/操作系统二板书1.jpg" alt="操作系统二板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_操作系统通识二">30.2. 操作系统通识（二）</h3>
<div class="paragraph">
<p>上节课我们讲了操作系统的分类、发型版，还提了一点内核的东西，然后讲的操作系统能做什么，因为这个东西天天大家都在用，单凡买个笔记本或者手机，里面都有操作系统，操作系统听起来高大上，实际上我们每天在生活中都能接触到的，所以并没有那么神秘，那我们接下来讲的东西可能脱离一些日常生活，但是在极客营一定是听说过的，比如说进程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_提出问题什么是进程">30.3. 提出问题：什么是进程？</h3>
<div class="paragraph">
<p>我们最开始上过编程通识，就是算法加数据结构等于程序，然后今天讲的是操作系统通识，网上去搜的话，搜出来的东西不是我现在讲的，搜出来的是cpu是一个什么组成的、内存是怎么样的，甚至有可能提到DOS，说白了就是那种考软件工程认证啥的，那种考了找不到工作的，因为考的是30年前的知识，一点用都没有，上面唯一有用的就是让你知道什么是键盘什么是鼠标，仅此而已。</p>
</div>
<div class="paragraph">
<p>今天我们的目标是讲什么是进程，但是在讲进程之前我们先得明白操作系统里面有什么，讲明白这个过后我们回过头讲进程的时候，就非常清楚进程里面到底在做什么？所以这个是我们等一会要回答的问题.</p>
</div>
</div>
<div class="sect2">
<h3 id="_操作系统是什么">30.4. 操作系统是什么？</h3>
<div class="paragraph">
<p>现在我们从另外个角度去看待操作系统，上节课讲的操作系统，是属于老少皆宜的，今天讲的就不属于了，我们今天是从编程或者我们作为这个行业的新人的角度来看操作系统。</p>
</div>
<div class="paragraph">
<p>上节课我们并没有对操作系统下定义，上次我们在讲操作形成用能用来做什么？操作系统的特点，还讲到实时操作系统，那今天我们讲操作系统是什么？首先我讲的所有东西都是很主观的，那么从我的角度来说的话，操作系统他应该囊括硬件，计算机的设计范围里面应该包括鼠标、键盘、cpu内存、硬盘等等，因为一旦脱离这些东西过后，操作系统啥都不是，所以我说的是囊括，我可没有说那些东西是操作系统，所以我们回答这个问题z之前你还得先明白另外一个概念，什么是计算机？</p>
</div>
<div class="sect3">
<h4 id="_什么是计算机">30.4.1. 什么是计算机？</h4>
<div class="paragraph">
<p>很明显计算机就好定义了，我们就先简单的下一下定义：</p>
</div>
<div class="paragraph">
<p><code>计算机是指由CPU、内存、硬盘、主板、鼠标、键盘等组成的用于运行计算软件的电子设备。</code></p>
</div>
<div class="paragraph">
<p>看起来这句话就是是一种套话，先看关键词:</p>
</div>
<div class="paragraph">
<p><code>由&#8230;&#8203;.组成的&#8230;&#8203;.用于&#8230;&#8203;.的&#8230;&#8203;.</code></p>
</div>
<div class="paragraph">
<p>其实这个中间这些把它列出来就可以了，看起来完全就是个填空题，因为我是假定所有人都知道什么叫电子设备，所以我就不用再去解释它，因为如果是光讲设备，英文叫Device，那机械设备，它也是设备，而计算机并不是一个用于机械的设备，那这样的话计算机是电子设备没毛病吧？但反过来电子设备是计算机吗？不是，所以这个地方精简一下就是：</p>
</div>
<div class="paragraph">
<p><code>计算机是&#8230;&#8203;的电子设备</code></p>
</div>
<div class="paragraph">
<p>那现在来用排除法，来举例子，就是和计算机有相同的硬件，但是又不是计算机，能不能举例子？比如飞机上的自动导航系统，难道不是计算机吗？导航计算机，如果你看过星际迷航的话，它里面有导航计算机、攻击计算机，那这样的话基本上只要带了CPU的，基本上就是计算机，只是你对具体组成的部分了，可以再分类而已，计算机明白了。</p>
</div>
<div class="paragraph">
<p>刚刚是从硬件的角度去解释了，首先计算机加上软件不等于操作系统，我们刚刚只讲了计算机硬件的部分，你想吗？如果有个导航计算机，里面没有导航软件，那还是导航计算机吗？首先他是个计算机，你用他做导航，他就是导航计算机，你用它点赞，那就是点赞计算，其实就是从硬件角度来解释的，你去买任何一本计算机普及的书，都是这么讲的，但是他不完整，为什么？因为我们通常讲计算机的时候，可不只是指他的硬件，在广义层面上，计算机其实包括了硬件和软件，为什么？打个比方，你买了个笔记本，上面装不了任何软件，那他还算笔记本吗？他就是个砖头，从你的概念上，你并不会把它当作一台计算机，只有他能真正用起来的时候，他才是计算机，在你的概念里面，没有坏掉的计算机，但是有坏掉的机器，怪不怪，你从来不会这么去想吗？还有坏掉的计算机吗？很怪，所以在广义层面：</p>
</div>
<div class="paragraph">
<p><code>计算机=硬件+软件</code></p>
</div>
<div class="paragraph">
<p>所以通常来说，你买了台笔记本，一定有Windows，我们就套嘛：</p>
</div>
<div class="paragraph">
<p><code>笔记本=硬件+Windos/Linux</code></p>
</div>
<div class="paragraph">
<p>我买了台笔记本电脑，就相当于我买的硬件加上里面的系统，如果他里面不带系统的话，你会骂商家是奸商，所以在大家的认知里头，计算机是等于硬件加软件的，而这个软件除了windows或者Linux以外可能还包括了其他的，比如说最常见的office，qq等等，那如果买了过后不能运行office、qq你也会骂商家，那现在问题来了，你为了运行Office、QQ这些软件，你需要有操作系统，所以现在我们就开始套概念了，那上面讲的软件就等于一个操作系统，操作系统里面必须要包含一些软件，硬件就还是硬件。</p>
</div>
<div class="paragraph">
<p>所以我们通过偷换概念的方式，得出了：</p>
</div>
<div class="paragraph">
<p><code>计算机=硬件+操作系统</code></p>
</div>
<div class="paragraph">
<p>因为这Windows/Linux是操作系统，Office和QQ要运行的话必须要依赖于操作系统，那现在就可以给操作系统下定论了，我就先把熟一点的概念先写下来，然后我们再用书面语重新再去翻译一下，简单来说：</p>
</div>
<div class="paragraph">
<p><code>操作系统的作用是让计算机硬件协同工作。</code></p>
</div>
<div class="paragraph">
<p>那反过来什么是操作系统啊？我们按照刚刚定义计算机一样，首先操作系统是一种软件，那是一种什么样的软件？操作系统是一种管理调度硬件资源的软件，因为一些软件无非就是说把指令发给CPU，让CPU去执行，我们就先用套话去套，就是操作系统是管理调度硬件资源的软件，然后在接上上面我们定义它的作用，那我们就可以直接下定论了，那这地方我们就把刚才那句话再丰富一点：</p>
</div>
<div class="paragraph">
<p><code>操作系统是一种软件，是一种管理调度计算机硬件资源的核心软件。</code></p>
</div>
<div class="paragraph">
<p>我们要不要再补充一下，就比如说：</p>
</div>
<div class="paragraph">
<p><code>这种软件是所有其他软件运行的平台。</code></p>
</div>
<div class="paragraph">
<p>还可以把运行过程当中的动作给写出来：</p>
</div>
<div class="paragraph">
<p><code>OS将硬件视作资源，在此基础上可以进行读取文件、分配内存、管理进程、安装应用等操作。</code></p>
</div>
<div class="paragraph">
<p>然后再把作用套进来，应该就差不多了，然后最后一句话应该是讲的最大的作用，那我们先跳出这个地方，看一下操作系统最大的作用，刚刚说是应用的平台，我觉得应该换一个词，桥梁应该更合适，那这地方应该是说：</p>
</div>
<div class="paragraph">
<p><code>操作系统作为硬件和软件的一个桥梁，使之能够协同工作完成用户指派的任务。</code></p>
</div>
<div class="paragraph">
<p>用户怎么指派的？双击鼠标就好了。</p>
</div>
<div class="paragraph">
<p>那接下来就开始总结：</p>
</div>
<div class="paragraph">
<p><code>OS是一种管理调度计算机资源的核心软件，OS将计算机硬件能力当作资源，读写文件、分配内存、安装软件等操作都是对资源的某种控制，OS作为软件和硬件之间的桥梁，使计算机能够完成用户指派的工作。</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_什么是进程">30.5. 什么是进程</h3>
<div class="paragraph">
<p>现在操作系统我解释了，那进程是为什么？就是通常来说操作系统的课程，他们会重点是管理调度，教你怎么分配内存的，教你什么是堆什么是栈，听得我都是懵的，然后还告诉你什么是硬件中断，反正各种高级的概念套进来了，但是我们现在是在通识，我们聚焦的点不在于那个地方，所以我们现在来看这个里头，这个进程是在这个地方，我刚刚把它删掉了，管理进程我把它删掉了，那什么是进程，我再把它换一个概念，进程是怎么产生的？</p>
</div>
<div class="sect3">
<h4 id="_进程是怎么产生的">30.5.1. 进程是怎么产生的</h4>
<div class="imageblock">
<div class="content">
<img src="images/进程图.png" alt="进程图">
</div>
</div>
<div class="paragraph">
<p>讲明白这个，我们在说什么是进程，先回答这个进程是怎么产生的，进程是什么我讲得明白就是打开任务管理器，那就是进程，但是你要听到不是那玩意儿，你只是告诉我进程在哪儿，你是怎么产生的？对于windows用户来说，双击一下，打开一个应用程序，但是我把打开换个词叫运行，运行一个软件，然后运行软件就省掉了，那么它是由运行软件产生的，所以那这个地方的话他是通过运行软件产生的，比如说你打开了Photoshop，我觉得QQ不够形象，打开Photoshop你的电脑会卡半天，谁知道为什么卡？不管再好的电脑都会卡，只是卡的气表现不一样，如果以前像李喜的电脑他没有换SSD的话，他双击Photoshop首先是卡在读取文件上面，Photoshop会加载很大一个他自己，他自己可能就几个g，然后加载完了过后你会发现他就开始进度条了，读进度条在做什么？他把所有东西加载到了内存里头，边加载内存里面边把自己解压出来，只是说白了在运行，就是一旦把整个应用程序读到了内存里头过后，他就开始自己在内存里面run，最开始只是加载，从磁盘加载文件，我不知道大家有没有编辑过10个g或者1个g以上的文件，比如说你用vim或者你用vscode的，你打开任何文件，如果你打开的文件大于你机器的内存的话，你会死机，尤其在那种小内存的机器上面更明显的，所以我最怕在服务器上打开那种几个g的文件，因为vim会分配几个g的内存占在那儿，服务器就卡死了，所以说这个时候你运行软件，它首当其冲的是将硬盘上的内容加载到内存，首先他会产生个进程，创建进程，平时大家不叫进程，大家叫创建软件进程，我只是把省掉了，所以首先会创建一个进程，创建一个进程呢，然后这个时候他会加载文件到内存里面，从硬盘读取文件，然后将其加载到内存中，所以这个地方直接体现就是你打开的文件有多大内存，进程内存就基本上相差无几，后面为了解决这种问题，vscode他就可能只记载前面一百兆，然后这一百兆用完了，再把前面一百兆是放掉，然后再加后面一百兆，但是始终要耗内存，我也没说全部加载，至于你是加在一半还是加在全部，我又不管，反正你用内存了，所以我们只管这两步，剩下我们就不管他了，还是管吧，那么他读取完了过后，那么加载到内存里面，加载完了过后就运行软件逻辑，为什么要加逻辑两个字？因为你这个地方就已经在运行软件了，记载文件其实也是在运行，所以那个范围太大了，你说Photoshop到从硬盘上读取文件就应该是先卡，卡了过后你看的进度条，进度条看到了过后，最后就展示这个Photoshop的界面，然后那这个创建进程就是相当于是说是在双击， 那从硬盘读取文件就是相当于进度条，然后运行软件逻辑就相当于是主界面，然后这个地方我就用了Photoshop举例，这就对上了嘛。</p>
</div>
<div class="paragraph">
<p>回个头来啥是进程，首先你得明白个概念，创建完进程过后这个箭头不是这个样子的，创建完进程过后，是由创建进程到从硬盘读取文件并将其加载到内存中，所以这个地方是进程，下面两个操作在进程里面跑的，他有可能就是进程里面自己干的工作，所以这个里面是工作1，工作2，我们并不管这个工作怎么做的吗？他始终都是进程自己管自己的。</p>
</div>
<div class="paragraph">
<p>现在回过头来，进程是啥？</p>
</div>
<div class="paragraph">
<p>这个要和OS结合起来，创建进程干了啥嘛？分了内存，分了CPU，首先提关键字吗？手下进程在运行东西，进程在分配内存，读取文件，这些操作的是某种控制，那肯定不是操作控制嘛，我也没有翻书，我们就一起来推断嘛，看起来是和运行有关系，进程是操作系统运行的最小单位，这个是书上对他的定义，但是那句话是一句屁话，有又没有讲人话，但是那是那句话我可以做一个借鉴，最小运行单位，所以运行有了，最小运行单位，这个单位怎么解释，那个单位指的是什么？是指进程产生的这一整块，然后这个单位里头做了读取文件，分配内存，然后包括一些什么其他的东西，所以看起来在这个里面做了很多操作，进程是操作系统的最小运行单位，现在就是要解决那个运行单位的概念，就是进程，你倒过来看嘛，就是进程其实他不属于这个里头，进程根本就没在这里面提及，证明进程是操作系统里面的一部分，就是说白了操作系统将命令的传给了进程，让进程去做这些事情，刚刚那句话太精简了，精简的可怕，没有办法一眼看懂，我们把它扩充成一句话，那这个地方是管理调度计算机资源的核心软件，那进程的是什么？进程是他当中的一部分，而且非常重要，可不可说进程是一种管理调度计算机资源的方式？可能不一定准确嘛，但是刚刚我们这个过程当中他是不是在管理控制那个资源嘛，那我可以这么讲，操作系统是一种管理调度计算机资源的核心软件，而进程是负责执行这一操作的具体表现.</p>
</div>
<div class="paragraph">
<p><code>进程是OS的最小资源分配单位。</code></p>
</div>
<div class="paragraph">
<p>所以我可以推出后面进程是操作系统什么什么，咱们是不是可以这么套吗？那第一句话肯定没错嘛，操作系统是一种管理调度计算机资源的核心软件，这句话没毛病，进程肯定和OS有关系嘛，而进程是什么？负责执行这些操作的最小单位，我没说最小运行单位啊，那么这地方解释OS，那么进程是什么？就是你现在要做创建个连接，把进程和操作系统连接起来，进程是操作系统里面的一部分，可以这么讲嘛，用来做什么？进程是操作系统的那一部分？我先这么写嘛，进程作为操作系统中的一部分，就是刚刚从这地方看嘛，进程在吃内存，他在读写文件，他的运行，等于说不管你做什么样的操作，最后都落在进程头上，是这意思嘛，这么讲就是这些不管你做什么操作，最后有可能内存是落在进程头上，但是分配内存也是他头上分配的，那么在进程当中可以读写文件，分配内存，可以做这些操作，那他就是属于操作系统的执行者，他应该属于操作系统策略的控制和执行者，就是我这句话讲他的意思就说OS和计算机有关系，然后我再去解释进程嘛，解释进程做了什么吗？最后再对进程下定义，进程作为操作系统中的一部分，进程作为操作系统的核心组件，可以完成读写文件，分配内存，我直接对他下定义，作为执行者可以完成操作系统指派的读写文件分配内存的工作，可以吧，进程这个地方再解释一下，讲清楚进程，这地方多了少了半句话，难怪这么难做，那么操作系统对资源的控制，对资源的控制这句话怎么讲？完整定义是进程是操作系统资源分配的最小单位，不是执行，但是线程也是属于进程的，所以都是在进程中处理完成，那么进程是操作系统的一个执行单位，这个地方讲的执行单元 ，意思就是说在它里面去完成这些东西嘛？所以操作系统是OS的执行单元，我们对他下了定义，然后再对他进行个扩充，那么这个执行单元是可以做这些操作，是可以对资源进行控制和分配，所以进程是操作系统的执行单元，对资源的管理分配都是在进程当中进行，大概这个意思，我刚是为了推理嘛，我现在就倒过来，进程是操作系统的执行单元，可在其中进行资源分配和管理，然后至于那个最小，我们现在不知道是最小，我就把这个话倒过来，进程是OS的一种执行单元，在进程中可完成对资源的管理调度，这句话没毛病吧，在进程中可完成对资源的管理调度，所以最后才总结一句话，那么就是相当于说进程是操作系统的最小资源分配单位。这样才是完整的，光有一句话肯定是看不懂的。</p>
</div>
<div class="paragraph">
<p><code>OS是一种管理调度计算机资源的核心软件，进程是OS的一种执行单元，在进程中可完成对资源的管理调度，进程是OS的最小资源分配单位。</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_linux进程图">30.5.2. Linux进程图</h4>
<div class="imageblock">
<div class="content">
<img src="images/Linux进程图.png" alt="Linux进程图">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_windows进程图">30.5.3. Windows进程图</h4>
<div class="imageblock">
<div class="content">
<img src="images/Windows进程图.png" alt="Windows进程图">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_OS3_chapter">31. 操作系统（三）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_板书_30">31.1. 板书</h3>
<div class="imageblock">
<div class="content">
<img src="images/操作系统三板书1.jpg" alt="操作系统三板书1">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_操作系统通识之进程和线程">31.2. 操作系统通识之进程和线程</h3>
<div class="paragraph">
<p>通常讲进程的时候，我不会去故意的讲What，Why，Where，How，因为会显得文皱皱的，所以进程相关的应用这个标题是为了取标题而取了一个标题，这里面的应用是个动词不是个名词，他表示是某种场景啊，这个地方其实应该打引号的,就比如说什么时候你要用的进程，什么时候你要做和进程相关的事情，就是把我们涉及到的所有使用场景捋一遍，这样你可以理解为进程的使用场景，但通常我们是从第三方切过来的，所以这里是应用而不是使用场景，比如你写Java，你用IDE调试，这就启动了一个Java进程，甚至IDE本身就是一个进程，再比如说我们用的网页钉钉，他在Linux里，关了他的后台，其实还是在运行，如果你想强杀他，你直接把它浏览器进程给干掉，你就发现一旦把父进程干掉过后，子进程就自动垮了，但是有些软件就不是这样的，这个就涉及到进程，然后在你编程的时候，你的IDE有进程，Java也有进程，除了Java以外还有Python、MySQL、Nginx这些都有，但是我觉得讲了半天这些进程你都听不懂，因为他的范围太广泛了，那我们就只讲和我们编程有关的进程，就是：</p>
</div>
<div class="paragraph">
<p>什么时候会用到进程？</p>
</div>
<div class="paragraph">
<p>什么时候会做和进程相关的东西？</p>
</div>
<div class="paragraph">
<p>进程应用过程中有没有闪光点？</p>
</div>
<div class="paragraph">
<p>就是平时非常在意的，比如说PhotoShop，你会发现运行的时候，你的机器变卡了，然后跑去看，看是谁占的内存，这个时候就涉及到和进程相关的了，但是有些时候那个进程杀不掉这种特殊情况，我估计你是不会遇到，为什么？大不了重启电脑就可以了，没有必要去处理太多，所以这地方我们就举一些例子来证明我们其实是用过了进程，只是不自知，后面大家都听说过线程，线程又是个啥东西，这个等一会我们最后再讲。</p>
</div>
</div>
<div class="sect2">
<h3 id="_和进程相关的应用">31.3. 和进程相关的"应用"</h3>
<div class="sect3">
<h4 id="_top">31.3.1. TOP</h4>
<div class="paragraph">
<p>这个地方最显而易见的是Linux下的TOP，因为TOP大部分都是进程相关的东西，甚至它本身就是个进程。</p>
</div>
<div class="paragraph">
<p>那还有什么地方会让你注意进程的？</p>
</div>
</div>
<div class="sect3">
<h4 id="_java程序">31.3.2. Java程序</h4>
<div class="paragraph">
<p>但凡你用Java编程，你会特别在意那个内存，比如说我之前写了一个SQL解析器，用于解析SQL语法，我看了一下最慢最慢的情况0.009秒，基本上就是毫秒级别了，但是如果用Java，那时候你Java都还没启动起来，所以你看这个时候Java和C或Rust那种静态语言写的，虽然Java也是静态语言，但是他需要JVM虚拟机的，所以我们说的是二进制语言，那么Java和这种二进制语言比起来，Java在整个行为上差异很大，Java是先分了一堆内存，先给你分了你也不用管，我自动帮你释放，可贴心了，至于他帮你释放遇到的Bug，我觉得你不会遇到这种事情，所以对于普通人来说够用了，但至少从我的角度来说，在我自己的生产环境里，我运行的二进制语言到现在为止，有可能在写的过程上会内存泄露，但一旦我发到生产上面，到现在为止我从来没有因为内存泄露而导致我的程序宕机，我还没有遇到过这种情况，为什么？因为我写的时候特别小心，我的习惯已经养成了，我一旦申请，就会释放，就算在我开发的时候没注意，我在发布出去的时候，我还会做一个野指针的判断，用工具去扫描，它还能帮我查漏补缺，解决一些问题，所以这地方你写Java程序，你会特别在意内存。</p>
</div>
</div>
<div class="sect3">
<h4 id="_chrome多进程">31.3.3. Chrome（多进程）</h4>
<div class="paragraph">
<p>用Chrome的时候，你会在意那个Chrome那个进程到底用了多少内存的问题，就是今天我们只讲焦点的问题，因为操作系统里面任何一个东西都是进程，但是你并不会关心，因为我讲一个你不会关心的事情，你记不住的。</p>
</div>
<div class="paragraph">
<p>如果你去看Chrome相关研究的博客，就比如说Chrome开发团队是有他们的blog的，他们那个上面会说我又优化了多少Bug，又优化了什么内存使用效率之类的，那个时候你就应该关心Chrome之所以一个网页卡死了，但不会影响其他网页，这是因为在Chrome里面每一个标签都表示一个进程，Chrome是典型的多进程。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ide">31.3.4. IDE</h4>
<div class="paragraph">
<p>除了这些以外，可能用IDE的时候也很在意进程使用的内存。</p>
</div>
<hr>
<div class="paragraph">
<p>说白了，你是因为内存，你才关心进程的，比如说你从来不会因为硬盘，跑去看IDE，所以你的整个焦点都是在内存上，而进程不仅仅只管内存，他也在调度CPU，当然从严谨来说，那是操作系统内核做的事情，但是进城也是被操作系统管理的，那么至少和进程还是有关系。</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_视频">31.3.5. 视频</h4>
<div class="paragraph">
<p>比如说在笔记本上打开个20G的MKV视频文件，通常发现除了读取硬盘慢以外他还一卡一卡的，这就证明有可能是内存不够或者CPU不够，因为他要做应接嘛，比如你用集显的时候就特别明显，用独立显卡还稍微好一些，但是笔记本因为有散热问题，你的显卡能不能全功率运转是不一定的。</p>
</div>
<hr>
<div class="paragraph">
<p>说白了，我们这里讨论的就是：在操作系统的使用过程中，你什么时候会打开任务管理器？</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_媒体软件">31.3.6. 媒体软件</h4>
<div class="paragraph">
<p>视频编辑或者渲染3D模型的时候。</p>
</div>
<div class="paragraph">
<p>基本就上面这几个典型的应用，这个时候你会发现Chrome、视频、媒体软件是属于多媒体的，IDE和Java是属于编程的，TOP就太特殊了，不是普通人干的，相当于Windows上的任务管理器。</p>
</div>
<div class="paragraph">
<p>这个时候你就会发现大家注意进程相关的应用场景通常只会关心内存，为什么？那是因为太穷了，可能你的硬盘有1T，但是你内存可能就只有8G，但十多年前我的第一台笔记本就只有512Mb的内存，我觉得挺香的，而且4399小游戏也很顺畅，也不卡，为什么到现在这么大内存反而还不行了呢？那是因为Winter联盟在搞你，Winter联盟是Inter和Windows两个联合，Win7一起就占了1.5G的内存，Win10一来基本上八个g勉勉强强，Windows后面改变的策略了，为了用户体验，操作系统会把大部分内存都占到内核里面，给自己用，这个时候他想分给你就分给你，关键是他咋知道什么时候应该分呢？总有有缺陷的时候吧，这就导致了该分不分或者占用了很多内存释放不出来，包括后面的Flash也是，狂占CPU和内存，现在好多了,就是自从哔哩哔哩用上了H5相关的播放器过后,优酷、爱奇艺、腾讯视频都不要求Flash了，在那个之前，但凡是个视频网站，都要Flsah，现在解决了Flash，结果大家发现APP内存吃更多了，Chrmo也吃内存了,为什么，因为Chrome心想你有内存，反正都是给我用的，我为啥不占呢？然后 那些写网页的人心想，反正有那么多内存了，那我把20个20M的JSON架在内存里面也没有什么问题，但是回头想一下，任天堂在开发采蘑菇的时候，人家总的内存可能才几Kb，相当于是说人家用二十张贴图就做出来一个游戏，当时作者为了处理声音的问题，但是又不想增加大小，就在图片里面填充了音频，从音频里面读取特殊的编码数据，然后把它转成声音，各种奇异技巧，所以游戏虽然贼小，但是又很好玩，转过头来看现在的游戏，哪怕几百个G装上去，可能一会就卸了。</p>
</div>
<div class="paragraph">
<p>那看起来这个世界好像在开倒车，为什么？因为工业能力上去了，大家觉得要求可以没那么高了，主要是因为程序员的能力下降，第一个程序员是一个女生，是一个数学家，现在的程序是数学家吗？一个都不是，连半边天都不能顶。</p>
</div>
<div class="paragraph">
<p>回过头来，注意的进程相关的或者打开日志管理器的时候，通常是因为你的电脑卡，然后作为一种专业人士，你想去观察到底怎么回事，你才会注意到进程这玩意。</p>
</div>
<div class="paragraph">
<p>上面讲的都是和我们生活是有关系的，你会发现每个都是再讲内存，看起来我说了那么多，就表明进程一定在处理内存相关的事，说白了之所以你会去关注进程，是因为你是专业人士，如果你是个电脑小白，你根本就不会注意注意到这个，你就只会怪那个人给你配的电脑垃圾，装的系统带毒。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_进程的工作职责">31.4. 进程的“工作职责”</h3>
<div class="paragraph">
<p>那根据上面讲的，我们开始推进程他管了些啥？通过刚才这个我们得知，他至少管了内存的，这个时候内存只有两种情况，对外行来说叫占用和消失，但专业来说叫分配和释放，说白了就假设有一个仓库，你从里面拿了两件货就是2Mb，用完了再把2Mb丢回去，但如果你一直拿，每次运行都要拿一次，没几天你的仓库就满了，就要重新补货，但内存又不是说你想加就能加，等于说仓库里东西没有了就是没有了,你就等着死机吧。</p>
</div>
<div class="paragraph">
<p>说到死机你哪可是说我卡了我卡了我的10万不快满了然后十万万分满了过后还能撑一阵，然后你那个windows是直接难品，怕其实windows也有虚拟内存，虚拟内存但是温度是处理那些东西的效率啊和性能完全不是一个级别的，所以你那个是通常卡呀他不会马上死，他是卡到最后那一刻，已经自己不能运行了才死的啊，所以你要见到你，那是那个内核死啊，就是不太见面的服务器，要想见到踏实很难为什么基本上你不怎么能见到，不怎么见到。</p>
</div>
<div class="paragraph">
<p>所以看得出来进程管了：</p>
</div>
<div class="paragraph">
<p>1.内存的分配和释放</p>
</div>
<div class="paragraph">
<p>2.文件读写</p>
</div>
<div class="paragraph">
<p>刚刚说了多媒体文件和视频，所以和文件I/O有关系。</p>
</div>
<div class="paragraph">
<p>3.运行指令（CPU/GPU）</p>
</div>
<div class="paragraph">
<p>刚刚说放视频的时候，CPU可能也会100%，甚至Chrome也可能会100%，其实Chrome在放播放视频也是一样的，所以效果都是一样，那就说明进程还在处理和CPU相关的事情，但是进程真的是在直接调用CPU吗？进程怎么知道CPU是Inter还是AMD？怎么处理啊？你写Java进程的时候关心是什么CPU了吗？那谁关心？</p>
</div>
<div class="paragraph">
<p>答案是操作系统内核，内核里面包含了很多驱动，如果你的内核里面没有wifi驱动，你能用Wifi吗？比如说Linux内核里，显卡驱动没带，就单独装驱动，那你见没见过是CPU单独装驱动的？你能装上Windows吗？这么说我就是因为没有系统才装系统的，结果你让我先装CPU的驱动，死循环一模一样的，所以在操作系统内核里面通常把基础硬件的驱动都已经集成进去了，这是操作系统该干的事情，它带的是一些必要的，如果他把所有驱动都包含进去了，就变成了臃肿的操作系统，现在Windows不用做显卡驱动了，不就是这个原因吗？他里面自带了，但是Linux里面他是默认是不带驱动的，因为太大了，会影响它，所以现在的Linux内核打包过后是很大的，它里面的包含很多很多驱动，所以Linux内核的代码函数一直在增加，就是因为驱动越来越多,所以每隔10年或者7、8年，你会看到那个ChangeLog里面会出现Remove（移除）什么支持的时候，就知道驱动被干了，</p>
</div>
<div class="paragraph">
<p>我那个戴尔工作站，我拿这个机器去CentOS8的时候，人家现在已经把我上面的阵列卡的驱动给移除了，死活装不上，但是装CentOS6又装得上去，但是我就不服气,就手动把驱动加载进去了，所以这个时候是内核在做这个事情，但是只是提一嘴啊，这个现象你得知道。</p>
</div>
<div class="paragraph">
<p>但进程要用CPU怎么办？那么进程只负责一件事情：</p>
</div>
<div class="paragraph">
<p>和CPU打交道，运算指令。</p>
</div>
<div class="paragraph">
<p>比如说你要看视频，其实你是发了一个指令，通过进程发了一个渲染视频的指令，那这个时候操作系统就会告诉CPU怎么做，双击一个文件夹、音频、视频，虽然对于你来说是双击，但是操作系统已经告诉那个CPU和GPU要怎么做了，所以你的代码里面，把东西放到某个HashMap里面的时候，HashMap会帮你分配的内存，当你在你的编程语言里面去调了一个视频截图函数的时候，那个函数里头首先一定要分配内存，一定要读写，写完了过后，他不知道读写的是啥吗？为什么？因为截取的是画面，比如说截取第几帧第几帧当然这个时候肉眼看的画面，是不需要掉GPU的，你可能要去按视频协议加载一下，然后去数第几帧再截出来，如果你想听声音或者眼睛看到，比如说写的是一个Photoshop软件或者视频编辑软件，要把图像加在的屏幕上面，这就涉及到渲染了，所以你调那个视频编辑函数的时候，进程除了分配读写以外，他还要去告诉GPU或者CPU把那个二进制数据流，就是你打开的任何一个视频文件，它也是二进制吗？0101,所以他把这个0101通过特定的驱动交给显卡或CPU，然后就会变成一个图片或者一个视频。</p>
</div>
<div class="paragraph">
<p>所以这个时候进程完成了个复杂的操作，这个复杂操作就是运算指令，只是说是你调的还是驱动帮你调的，你要是足够牛逼的话，你甚至自己都可以写驱动，所以你在操作系统上面的操作或者在系统里面运行的任何命令都会触发运算指令，如果你写了一个函数啥都没干，那你的意义在哪呢？最常见的这种运算指令相关的，就比如说网上写的：</p>
</div>
<div class="paragraph">
<p>怎么一句话把CPU跑满？</p>
</div>
<div class="paragraph">
<p>就是写个批处理在里面死循环运行一些东西。</p>
</div>
<div class="paragraph">
<p>4.输入/输出</p>
</div>
<div class="paragraph">
<p>就比如在浏览器里面敲东西，不就是有输入输出，具体点的话就是键盘鼠标这些东西，当然还有很多其他东西，你可以认为显示器也是一种输出设备，输入输出有很多。</p>
</div>
<hr>
<div class="paragraph">
<p>其他的好像就没有了，我能讲很多，但是都和你没关系，只有你接触到的时候，你才会注意,那看起来进程在做这些事情，说白了就是进程的工作，，讲了这个和我们有什么关系？这里在座的都是软件开发工程师，我讲这个的目的是告诉你，首先我讲了什么是进程，然后他和你的生活有什么关系，现在我都讲到工作职责了，那剩下也是工作描述，软件工程师的工作描述。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进程和软件工程师">31.5. 进程和软件工程师</h3>
<div class="sect3">
<h4 id="_内存分配">31.5.1. 内存分配</h4>
<div class="paragraph">
<p>这个地方我就随便写语言的，比如说有一段Python代码：</p>
</div>
<div class="paragraph">
<p>a=[1,2,3]</p>
</div>
<div class="paragraph">
<p>那这个代码一旦运行它，它会做个什么事情？</p>
</div>
<div class="paragraph">
<p>1.他会调用list（）初始化</p>
</div>
<div class="paragraph">
<p>2.在初始化的时候刚好你带了几个参数？就相当于是这个样子：</p>
</div>
<div class="paragraph">
<p>list（1,2,3）</p>
</div>
<div class="paragraph">
<p>其实他干了很多事情,这个就是有语法糖,什么是语法糖？就是编程里面的快捷方式，这个语法堂，他其实做了很多事情，那大家都知道，在初始化的时候其实是要分配内存的，不管是哪个语言，你只要是调的操作系统，而操作系统是C写的,微软的操作系统内核是C和C+ 写的，那么最核心一定是C，外部的一些基础设施是C+写的，但是Linux的内核一定是C，纯C，当然那个Linux大神说他们正在考虑一些内核模块，可以用rust来写，我觉得那个是一个很好主意，所以说现在所有的编程语言，它是依托于操作系统在运行，而操作系统是C，所以一定会触发内存分配，我到现在还没有见过，你以为一句A = 1他就不触发内存分配了吗？只是这个东西触发，是你手动触发还是编程语言帮你实现，然后编程语言在调内核里面的触发，都是一样的，比如说new class，那只是编程语法里面的要求，但是A=1的时候内核一定会帮你做，你如果一直可以看下去的话，一定会看到有内存分配的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_文件读写">31.5.2. 文件读写</h4>
<div class="paragraph">
<p>这玩意儿随便一句话，大家都看懂：</p>
</div>
<div class="paragraph">
<p>f = file.open(&#8230;&#8203;,"r")</p>
</div>
<div class="paragraph">
<p>读：</p>
</div>
<div class="paragraph">
<p>f.readline()</p>
</div>
<div class="paragraph">
<p>写：</p>
</div>
<div class="paragraph">
<p>f.write()</p>
</div>
<div class="paragraph">
<p>然后运算指令，刚刚写的这些东西都在运算，如果不触发运预算指令的话，等于说他们都不需要CPU，那你跑给我看一下，所以他们所有的基础都基于运算指令。</p>
</div>
</div>
<div class="sect3">
<h4 id="_输入输出">31.5.3. 输入输出</h4>
<div class="paragraph">
<p>更简单了</p>
</div>
<div class="paragraph">
<p>输入：</p>
</div>
<div class="paragraph">
<p>in = input()</p>
</div>
<div class="paragraph">
<p>这样的话他就会卡在那，你必须要输入东西，敲回车，然后执行下面的东西，这就是一个典型的输入。</p>
</div>
<div class="paragraph">
<p>输出：</p>
</div>
<div class="paragraph">
<p>print（）</p>
</div>
<div class="paragraph">
<p>对于你来说叫输出，对于Linux来说，你写文件的甚至都是一种输出，叫标准输出，标准输出输入，只是说的输出方式，输出到的是文件还是屏幕，无所谓了，这个东西他只是说一个快捷方式直接打到屏幕上了。</p>
</div>
<div class="paragraph">
<p>以前有个面试题就说print这个函数调用的过程当中发生了什么？像极了问你那个浏览器里面输入过网址发生什么？你要是能讲清楚print打到屏幕上的具体发生哪些事情的话，绝对大神,基本上操作系统都能写一小半了，反正我是讲不出来，为什么？我要管那么多我早就老死了，我还在这给你站着，我是新生一代程序员，我要站在别人的肩膀往上爬，结果让我去搞几百年前就该懂的事情,你不看元代码，哎，你看过几行？我没有，我就也就写个几百万行代码而已，我为什么读你的呀？相比来说我觉得做更有意义的事情，那你还说是坐啥飞机坐啥汽车呀？你自己不发明一辆，有得放肆就是应该在发力的地方你去发，你不发那就用现成的，用笔记本一样，你咋不自己造个CPU，从沙子开始造自己弄笔记本呢，是不是这么个道理吗？</p>
</div>
<div class="paragraph">
<p>所以就是这个输入输出我们通常指的是屏幕上，一个标准的输入输出，没有把那个文件当成一种输出设备，其实进程就是干这些事情，我通过这种偷换概念，偷换第一次，偷换第二次后面就再去约等于他，所以那这样的话你会发现，其实任何进程里面他做的事情你都会，只是你想不想去做而已，比如说这地方渲染视频，我也不会渲染我搞它干啥，但是我会写Web服务，我会输出HTML标签，我会输出什么什么协议的内容，我会用controller输出一段内容一段Json，你其实就是我在我调这个完成进程里面应该负责的事情，因为这边是作为用户，用户来用这些东西，而这些东西就是软件工程师写的，软件工程师使用代码，实现这些功能，而这些功能到了用户层，所以我这地方像极了画了个框架图，然后这个地方是用户，那这样的话，应用这个地方是用户，然后最右边这个地方是工程师，或者是代码，我们叫软件嘛，软件层次更高一些，代码太底层了，软件到用户这个地方操作系统，因为这些功能你只是调用了，并不是你写的，所以我们定义操作系统说他是桥梁，有毛病吗？然后这个时候就相当是软件依托于操作系统，实现了用户想要的东西，而他们通过这个过程当中产生的联系是什么？就是谁把他们联系起来的，因为操作系统联系的是软硬件，把用户联系起来了，因为用户先装个windows才能用chrome，用户先装一个windows才能访问你的网站，所以在用户和软硬件之间，操作系统也是桥梁，所以这个操作系统其实就是整个核心，就相当于操作系统在这个位置，那么所有的人都是依托于他：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/OS小太阳.png" alt="OS小太阳">
</div>
</div>
<div class="paragraph">
<p>那这个地方有了，具体到编程专业领域里头又是谁把他们联系起来？就是这个操作系统概念很大，所以这个地方就设计到一个概念就是其实严格意义上讲，谁把你们连接在一起的，因如果没有进程的话就没这些事了，就是操作系统可以当做一个平台，这个平台里面有个功能叫进程，进程负责的把这些事串起来，所以所有的事情都是在这个进程里面去做的，操作系统的作为一个平台，而进程作为一个依托的一个媒介，比如说我是在这个盘子上面做的事情，而这个盘子放到桌子上的，盘子桌子的一部分，桌子是平台，盘子是盘子，所以那这样的话就相当于是说软件依托于进程为用户服务，所以进程其实就是严格意义上他才是桥梁，因为一旦没有进程，那啥都没有，你想象一下如果操作系统里面没有进程，啥都没有，而你而进程有调了什么呀？进程里面调了内存分配，你调了内核通信的东西，你调了驱动，你看到没有进程其实是一个囊括了所有东西的一个产物，所以那这样的话在进程之前其实还发生了很多，所以进程这个地方又衍生出来，这个地方比如说现在有进程嘛，肯定有进程管理噻，你不管你自己？你不把自己创建出来？但是严格意义上说是不对的，因为进程管理是内核干的，而这个分配内存也是内核干的，但是你看到我画了个起点是在进程之外，你懂我意思吗？内核其实也有进程，不然的话他做不了事情，所以这就意味着就是你说的内核的范围了，你刚刚说内核的进程，它只是一个关键进程，不一定代表内核，他只是为了实现内核的功能或者目的单独起起来的进程，保证这个操作系统的工作是正常的，比如说Linux内核里面，他有个东西叫什么？你说你装了个正列卡，你用阿里云你会发现多了叫jdb的一个进程，j开头的你去看，那个东西就是内存里面负责去和正列卡通信那个进程，当然这个很特殊就不用去讲了，所以在内核里面其实发生了很多事情，那些事情体现就情进程里面，所以进程做的那些所有事情其实就是操作系统，连起来了嘛，所以知道为什么要讲进程了吧，你进程学不好，你编程白学了。</p>
</div>
<div class="paragraph">
<p>我打个比方，顺便提一下线程，线程我就不单独讲了，因为太简单了，别人可能讲几万字跟你讲，但是在我的这个地方就一句话，进程干了那么多事情，还要占那么多资源，因为进程本身也要占用资源，我打个比方我一个chrome，所以我不单独在这上面写进程的问题了，因为那个完全没有必要，我就给你举个例子，到时你们记笔记的时候去记一下，比如说有个chrome，那么你开了200个标签，200个标签你就200个进程，那200个进程，那每个进程他本身他都要分配内存的，你启动起来你肯定要分配，你启Java，他也要分配，因为就算你的这个里面啥都没调，你启动它还是要分那么一点点的，因为你主要是有main函数，他里面又干了啥事？就是那个分内存的是那个编译器编译的时候他给你悄悄加了一部分代码进去，进程没有内存是启不起来的，刚刚说200个标签，那意味着你的那个电脑很卡，然后你就说我是个天才，你chrome用进程那么耗内存，那这样我把你那个进程都改成线程，因为书上的定义是说线程会继承他爸爸的财产，进程就是他的爸爸，所以这个进程下头有可能还有线程，我们通常说的线程是用户自己启的一些线程哈，我们操作系统内部发生啥我不管他，比如说你为了实现那个网页加载的时候不重新刷新网页，你要起个现成背后悄悄的干事就这个意思，直观的感受就是网页不会每隔几秒钟重新全部加上一次，所以你这个时候你说我为了减少chrome的那个占内存的问题，我就把那200的标签了都换成了线程，因为线程，我每起个标签，在chrome启动的时候他分了两兆，然后我每打开一个标签进，如果是用进程的话他可能又要分两兆，但是如果用两兆加一个线程的话，那个线程是不会分配内存的，他不会自己启动之前，就是除非你手动分配内存，不然线程启动的时候他是不会手动再分配内存，你要起一个进程是不是操作系统给你点东西，你不然怎么启动起来的，那线程启动也是一样的，线程他启动的时候只要爸爸有，我就有，爸爸没有我就没有，爸爸死了我就死了，他的爸爸就是进程，所以这个时候把200个chrome标签换成线程，你会发现，我就假设chrome启动的时候分了200个内存，你开了200个标签，都能打开了，突然其中有个标签是b站，然后他的视频突然自动播放了，对不起你的chrome直接挂了，因为那个视频三百兆，
小学生的这道超了，因为我刚刚讲过的，假设线程里面我没有手动分配内存，当然如果你发现那是b站，你在线程里面手动去分配的内存，当我没讲，所以大家平时在讲线程和进程的时候，大家只会讲一个概念，就是操作系统为了创建这个东西花了多少钱花了多少内存？那个东西和你没有关系，他只和内核有关系，所以凡事做事情都是代价的。</p>
</div>
<div class="paragraph">
<p>比如说你为了吃饭你嘴巴要动，请问你最后剩下多少能量，是不是这个道理吗？这下人要饿死了，你的嘴都张不开了，那铁定饿死了，所以操作系统他为了创建一个进程创建一个线程他付出的代价，他付出那个钱就是内存，至少这是其中一部分，那钱可能有很多种，可能有美元和人民币，那这里可能就有内存，可能还有端口资源，还有文件资源那种不管他，我们就一般只强调内存，因为就是因为穷，所以大家关注点都在内存上，从始至终都是这样，从古至今都是这个样子的，为什么永远是内存最贵？但是自从中国人开发到ddr4过后，差不多了，快了，合肥长兴还有紫光，白菜价看起来快了，到时候人均256内存起步，到时候操作系统课里面就可以把进程线程的这个知识给删了，因为已经无所谓了，因为你现在讨论过硬盘要花多少钱了吗？你从来不讨论，为什么？因为他永远是最多的，一旦我装上了256或者你刚刚他刚说128以上内存的时候也可以考虑，我们要看是时候开发个ddr6了，所以你操作系统里面应该教ddr6了，不应该教这个线程和进程的。</p>
</div>
<div class="paragraph">
<p>所以你就知道最关键的地方来源哪个地方，你只要掌握了他的过去，你基本上能预判他的未来，最怕的是跑去赶潮流，最关键是这些东西就是如果你想去追赶他，其实是很难的，所以你一定要了解他的过去，然后你就预判到他的未来，所以这个内存问题你得知道为什么大家那么关注进程和线程，就是因为内存少，所以太行云梯从一开始所以服务器标配64g以上，那就没这个问题了，果然我们的所有的东西都放到内存里面的，内存不值钱，日志随便写，所以线程是什么？线程是儿子，进程是爸爸，只要爸爸有钱儿子就有饭吃，就记住这句话就可以了，因为儿子是不可能凭空出现的，不可能爷爷只生个儿子，不可能吧，你想嘛？儿子不可能凭空出现，那么爸爸有财产，儿子有财产，爸爸有内存，儿子有内存，所以爸爸那个银行里面有20万，爸爸有20万儿子就能买20万的零食，然后如果爸爸死掉了，儿子也死掉了，就这么回事，所以你只需要记住这个。</p>
</div>
<div class="paragraph">
<p>所以线程没有什么神秘，他只有这个区别，只是你在写代码的时候，你写代码的这个地方，你写代码的这个窗口，通常来说我假设的地方是main函数，main函数那个地方就是主进程，比如说是这个函数：void main（），这些都发生在这个里头，这玩意儿就是主进程，就是你这么写的话他就会跑一个进程，然后你这个是如要跑一个子进程，没说儿子一定是线程，子进程也可以是儿子，那既然是爸爸生了一个子进程，那这个时候他都叫进程，他肯定也要占内存，说白了只要生了这个儿子就要单独把钱拨给他，但是线程这种儿子，你不用把钱拨给他，他要多少从爸爸那拿，但是子进程是爸爸死掉了，因为儿子银行里面有钱，他不会死的，他饿不死，知道区别了吗？所以你编程的时候，你的整个窗口你啥事不做的时候，他默认就是在主进程里面跑的，由于编程语言现在都非常难用，导致你写子进程的代码或者线程的代码的时候都会出现在语法上面很难受，只是因为语法的问题，并不是因为线程很复杂，是因为线程这玩意出现的时候，它出现了逻辑分差，就是你原来你的主进程走路是这么走的，像不像那Git的分支嘛，原来你是这么走的嘛，结果你现在有个子进程或者子线程在干事情的时候就变成这样了：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/线程进程关系.png" alt="线程进程关系">
</div>
</div>
<div class="paragraph">
<p>这叫逻辑分叉嘛，至于这个逻辑是子线程，子进程是无所谓，因为他已经产生分叉了，一旦成这个分叉你代码里面就开始继续这个分叉在里面就是写代码，写代码的时候你就不知道这个代码，比如说用花阔号把这个代码包起来，明明出现在一个界面里面，但是出现花括号里面的时候，那个代码已经跑在外面了，他已经不是主进程上面跑了，变量作用域，比如说刚才打开了个文件，在开始这个地方打开了文件，请问在最后这个地方还能用吗？是不打问号了，但是你确定是在开始位置可以用的，但是在结束位置还能用吗？这个时候你要开始了解了进程和线程的区别了，我刚刚讲过的，子线程会继承爸爸的东西，所以如果你用线程的话，你这个地方打开的文件都是可以用的，因为它继承了，但是你启个子进程的话，创建一个子进程，就相当于操作系统又跑去自己创建那个进程，把那个进程和你之间命名为父子关系，先创建个进程再命名父子关系，请问那个你打开的文件，它还能有吗？他没有了，就涉及到各种作用域的问题，资源还能不能用？什么叫资源，读写文件，这个f就叫资源，这个东西他已经不能这个逻辑分叉这用了，所以那么在这个地方这是主，这边是主，然后这个是子，比如说我是子进程嘛，我再写个子线程的，有子线程我比如跑到这，跑到这，跑到这，比如说这是子线程，就是叫线程，那如果在主进程这个地方我open f=open（），得到一个句柄，这个f是个资源，因为文件是一种资源，那个f打开是文件嘛，他是资源嘛，然后这个是f打开了，然后如果他是线程的话，因为他会继承爸爸的东西，比如说这个线程在这打开的时候，这个f是有效的，因为它继承了爸爸的东西，但是你跑到这儿的时候这个f是无效的，因为他是操作系统创建的一个进程，再把你们两个连起来，两步，一共两步，但主进程这个地方一步，操作系统只要干一件事情创建一个线程吧，创建线程的时候所有那些东西都是默认就是打勾的这个状态，所以一旦你在这个地方如果把f删掉了，请问这还会有f吗？会报错的，所以知道随着这个地方如果你把这个地方f处理掉了，用完了，删掉了，变量没有了，你到这个地方但是语法还不知道f不在了呀，你想嘛，你刚刚这不是个f吗？请问现在f的状态是什么样的？如果你在这干掉了，这个f已经无效了，就出现了空指针，因为你把f删了嘛，但是这个时候他被隔离了，你的主进程并不知道f没有了呀，这个删不是删f的个变量哈，你在硬盘上已经把它给删了，因为你在线程这个里面把硬盘给删了呀，不是删f，是删那个文件，因为他打开的是个文件，主进程这个时候并不知道文件被删了呀，是那样的如果代码只有3、5行，你本来这个地方也是你删的，你就会记得住，万一主进程开始到主进程结束一共有1万行，这个是其中200行，请问删是哪个地方删的呀，这个还是只有一个线程，我可没有说不会出现多线程这种情况，请问你现在删了过后，这个地方的f是什么状态？这是什么状态？这玩意叫线程同步，为了线程同步又有互斥锁，什么叫互斥锁？我在这儿删的时候，只要我锁我没有释放，其他人都不能用，这个地方f就请问可以用了吗？可以用了吗？可以了吗？就一直卡在那儿，你明明为了写多线程是为了性能，结果这玩意又在那儿等，你告诉你的意义在哪？</p>
</div>
<div class="paragraph">
<p>但是你这个互斥锁又会影响性的，你不会觉得这个事很怪吗？但是在我写代码我从来不会用到这玩意，？因为在我的逻辑里面操作系统为我所用，我可以利用操作系统的优势来解决这个问题，而不应该让我来写这个代码去解决这种问题，因为解决问题的方式千千种，我一定为什么要用这个线程，我什么时候我教你写代码的时候用过这玩意儿，用不上，因为你这东西说白了，这个地方就讲讲深入一点哈，就是为什么那么多程序员或者工程师他能力那么差，基本上99%以上的人我认为都是不合格的工程师，因为叫工程师的话他应该是基于解决问题出发，但是现在比如说我给不定性，我招聘你进来的时候你就是会Java开发工程师，所以你为了解决你遇到的问题，你所有的东西都用Java来解决，那能不复杂嘛？人家操作系统已经给你解决了，已经提供了方便了，有的个Nginx，有个Redis了，你还自己造个数据库，简称kafka，你就是想用这些东西1套解决嘛，因为我只会Java，我肯定在Java领域去解决，那对于我来说，这首先我会给他定性，这个东西有没有人已解决过了，如果已经解决过了，我就不会再去解决他了，如果他解决只是个半成品，我可以把他们胶水粘起来解决我的问题，通常都是可以的。</p>
</div>
<div class="paragraph">
<p>通过上面那个图就能讲明白进程、线程、子进程，讲了一清二楚，因为特别是那个open那玩意儿，你这个这个地方写个f.delete，f.remove，删除移除，移除完了之后，请问这是什么状态，主进程这个地方你记住你写代码的时候，这个地方你永远不会错，程序员写这个一点问题都没有，但是一旦程序修的路多了之后你自己都会忘了，所以这个时候一旦这个地方remove，你这个地方.read的时候就会报错，所以在这个地方最后你调.read，一定会报错，比如说我在这个地方f.clear，然后比如说我在这个地方f.delete，反正我就捣乱嘛，最后你会死的很难看，但是你说我在这个地方主分是调f.delete会不会死？你怕是个傻子，你自己搞你自己干嘛呀，因为在主分支上面通常你能看到错误，因为按住Ctrl你点那个函数点击进去，你就能看到到底在做什么，但是线程的时候，他虽然都是包含了一个函数里头，但是你进去的时候，那个地方执行的时候根本就不是理想的那种先后顺序来的，因为线程执行的时候他是在后台运行的，他不会影响你这个逻辑，这个地方启动线程过后，他就会继续往下走，那请问是主进程先执行完还是线程先执行完？你猜，万一线程这个地方查出去给我花了两秒，比如说你就打个print嘛，print线程2嘛，print主进程嘛，请问你看到的时候一定是先看到主进程还是先看到线程？对不起，随机的，因为大家都知道只要运行久了，误差会累积，就算第一次有可能是主进程先出来，但是你不敢保证运行到第100次的时候还是主进程先出来，主进程有可能是你看了两次print线程2,线程2,主进城，主进程，主进程，线程2,线程2,那个顺序就完全不受你控制了。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/luojishixutu.png" alt="luojishixutu">
</div>
</div>
<div class="paragraph">
<p>所以不管是从时间轴上来说，一个是逻辑，叫逻辑分支，然后一个叫逻辑时序，有时候时序图画不出来这玩意，因为他的顺序是乱的，所以说理解线程和进程的有这两个东西，一个是时序，一个是逻辑分支的问题，逻辑分支解决的是路的问题，逻辑持续解决是执行顺序，所以这个地方你可以理解为执行顺序，所以现在回不头来看是不是超简单吗？我只要跟你讲明白什么是进程，剩下的事情都是基于进程衍生出来的，就是个调用关系的问题，操作系统通识里面最重要的部分就是这个进程和线程。</p>
</div>
<div class="paragraph">
<p>在那个这个地方提醒一下，当你了解线程的时候，你去看man，man里面有关于fork的解释，但是在看这个之前你要先去写个demo。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-10-22 18:35:43 +0800
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>